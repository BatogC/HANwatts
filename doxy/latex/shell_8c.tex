\section{node-\/red-\/1881/node\+\_\+modules/sqlite3/build/\+Release/obj/gen/sqlite-\/autoconf-\/3310100/shell.c File Reference}
\label{shell_8c}\index{node-\/red-\/1881/node\+\_\+modules/sqlite3/build/\+Release/obj/gen/sqlite-\/autoconf-\/3310100/shell.\+c@{node-\/red-\/1881/node\+\_\+modules/sqlite3/build/\+Release/obj/gen/sqlite-\/autoconf-\/3310100/shell.\+c}}
{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
{\ttfamily \#include $<$stdio.\+h$>$}\newline
{\ttfamily \#include $<$assert.\+h$>$}\newline
{\ttfamily \#include \char`\"{}sqlite3.\+h\char`\"{}}\newline
{\ttfamily \#include $<$ctype.\+h$>$}\newline
{\ttfamily \#include $<$stdarg.\+h$>$}\newline
{\ttfamily \#include $<$signal.\+h$>$}\newline
{\ttfamily \#include $<$pwd.\+h$>$}\newline
{\ttfamily \#include $<$unistd.\+h$>$}\newline
{\ttfamily \#include $<$dirent.\+h$>$}\newline
{\ttfamily \#include $<$sys/types.\+h$>$}\newline
{\ttfamily \#include $<$sys/stat.\+h$>$}\newline
{\ttfamily \#include $<$sys/time.\+h$>$}\newline
{\ttfamily \#include $<$sys/resource.\+h$>$}\newline
{\ttfamily \#include $<$fcntl.\+h$>$}\newline
{\ttfamily \#include $<$utime.\+h$>$}\newline
{\ttfamily \#include $<$time.\+h$>$}\newline
{\ttfamily \#include $<$errno.\+h$>$}\newline
Include dependency graph for shell.\+c\+:
% FIG 0
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ Shell\+Text}
\item 
struct \textbf{ S\+H\+A3\+Context}
\item 
struct \textbf{ Fsdir\+Level}
\item 
struct \textbf{ fsdir\+\_\+cursor}
\item 
struct \textbf{ fsdir\+\_\+tab}
\item 
struct \textbf{ completion\+\_\+vtab}
\item 
struct \textbf{ completion\+\_\+cursor}
\item 
struct \textbf{ Apnd\+File}
\item 
struct \textbf{ Idx\+Constraint}
\item 
struct \textbf{ Idx\+Scan}
\item 
struct \textbf{ Idx\+Column}
\item 
struct \textbf{ Idx\+Table}
\item 
struct \textbf{ Idx\+Write}
\item 
struct \textbf{ Idx\+Statement}
\item 
struct \textbf{ Idx\+Hash\+Entry}
\item 
struct \textbf{ Idx\+Hash}
\item 
struct \textbf{ sqlite3expert}
\item 
struct \textbf{ Expert\+Vtab}
\item 
struct \textbf{ Expert\+Csr}
\item 
struct \textbf{ Idx\+Sample\+Ctx}
\item 
struct \textbf{ Idx\+Rem\+Ctx}
\item 
struct \textbf{ Idx\+Rem\+Ctx\+::\+Idx\+Rem\+Slot}
\item 
struct \textbf{ Saved\+Mode\+Info}
\item 
struct \textbf{ Expert\+Info}
\item 
struct \textbf{ E\+Q\+P\+Graph\+Row}
\item 
struct \textbf{ E\+Q\+P\+Graph}
\item 
struct \textbf{ Shell\+State}
\item 
struct \textbf{ Import\+Ctx}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ \+\_\+\+L\+A\+R\+G\+E\+\_\+\+F\+I\+LE}~1
\item 
\#define \textbf{ \+\_\+\+F\+I\+L\+E\+\_\+\+O\+F\+F\+S\+E\+T\+\_\+\+B\+I\+TS}~64
\item 
\#define \textbf{ \+\_\+\+L\+A\+R\+G\+E\+F\+I\+L\+E\+\_\+\+S\+O\+U\+R\+CE}~1
\item 
\#define \textbf{ G\+E\+T\+P\+ID}~getpid
\item 
\#define \textbf{ shell\+\_\+read\+\_\+history}(\textbf{ X})
\item 
\#define \textbf{ shell\+\_\+write\+\_\+history}(\textbf{ X})
\item 
\#define \textbf{ shell\+\_\+stifle\+\_\+history}(\textbf{ X})
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+U\+S\+E\+\_\+\+L\+O\+C\+A\+L\+\_\+\+G\+E\+T\+L\+I\+NE}~1
\item 
\#define \textbf{ Is\+Space}(\textbf{ X})~isspace((unsigned char)\textbf{ X})
\item 
\#define \textbf{ Is\+Digit}(\textbf{ X})~isdigit((unsigned char)\textbf{ X})
\item 
\#define \textbf{ To\+Lower}(\textbf{ X})~(char)tolower((unsigned char)\textbf{ X})
\item 
\#define \textbf{ set\+Binary\+Mode}(\textbf{ X},  Y)
\item 
\#define \textbf{ set\+Text\+Mode}(\textbf{ X},  Y)
\item 
\#define \textbf{ B\+E\+G\+I\+N\+\_\+\+T\+I\+M\+ER}~\textbf{ begin\+Timer}()
\item 
\#define \textbf{ E\+N\+D\+\_\+\+T\+I\+M\+ER}~\textbf{ end\+Timer}()
\item 
\#define \textbf{ H\+A\+S\+\_\+\+T\+I\+M\+ER}~1
\item 
\#define \textbf{ U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER}(x)~(void)(x)
\item 
\#define \textbf{ Array\+Size}(\textbf{ X})~(int)(sizeof(\textbf{ X})/sizeof(\textbf{ X}[0]))
\item 
\#define \textbf{ utf8\+\_\+printf}~fprintf
\item 
\#define \textbf{ raw\+\_\+printf}~fprintf
\item 
\#define \textbf{ S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1}
\item 
\#define \textbf{ S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2}(\textbf{ X})~(void)(\textbf{ X})
\item 
\#define \textbf{ S\+H\+A3\+\_\+\+B\+Y\+T\+E\+O\+R\+D\+ER}~0
\item 
\#define \textbf{ a00}~(p-\/$>$u.\+s[0])
\item 
\#define \textbf{ a01}~(p-\/$>$u.\+s[1])
\item 
\#define \textbf{ a02}~(p-\/$>$u.\+s[2])
\item 
\#define \textbf{ a03}~(p-\/$>$u.\+s[3])
\item 
\#define \textbf{ a04}~(p-\/$>$u.\+s[4])
\item 
\#define \textbf{ a10}~(p-\/$>$u.\+s[5])
\item 
\#define \textbf{ a11}~(p-\/$>$u.\+s[6])
\item 
\#define \textbf{ a12}~(p-\/$>$u.\+s[7])
\item 
\#define \textbf{ a13}~(p-\/$>$u.\+s[8])
\item 
\#define \textbf{ a14}~(p-\/$>$u.\+s[9])
\item 
\#define \textbf{ a20}~(p-\/$>$u.\+s[10])
\item 
\#define \textbf{ a21}~(p-\/$>$u.\+s[11])
\item 
\#define \textbf{ a22}~(p-\/$>$u.\+s[12])
\item 
\#define \textbf{ a23}~(p-\/$>$u.\+s[13])
\item 
\#define \textbf{ a24}~(p-\/$>$u.\+s[14])
\item 
\#define \textbf{ a30}~(p-\/$>$u.\+s[15])
\item 
\#define \textbf{ a31}~(p-\/$>$u.\+s[16])
\item 
\#define \textbf{ a32}~(p-\/$>$u.\+s[17])
\item 
\#define \textbf{ a33}~(p-\/$>$u.\+s[18])
\item 
\#define \textbf{ a34}~(p-\/$>$u.\+s[19])
\item 
\#define \textbf{ a40}~(p-\/$>$u.\+s[20])
\item 
\#define \textbf{ a41}~(p-\/$>$u.\+s[21])
\item 
\#define \textbf{ a42}~(p-\/$>$u.\+s[22])
\item 
\#define \textbf{ a43}~(p-\/$>$u.\+s[23])
\item 
\#define \textbf{ a44}~(p-\/$>$u.\+s[24])
\item 
\#define \textbf{ R\+O\+L64}(a,  x)~((a$<$$<$x)$\vert$(a$>$$>$(64-\/x)))
\item 
\#define \textbf{ F\+S\+D\+I\+R\+\_\+\+S\+C\+H\+E\+MA}~\char`\"{}(name,mode,mtime,data,path H\+I\+D\+D\+EN,dir H\+I\+D\+D\+EN)\char`\"{}
\item 
\#define \textbf{ F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+N\+A\+ME}~0     /$\ast$ Name of the file $\ast$/
\item 
\#define \textbf{ F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+O\+DE}~1     /$\ast$ Access mode $\ast$/
\item 
\#define \textbf{ F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+T\+I\+ME}~2     /$\ast$ Last modification time $\ast$/
\item 
\#define \textbf{ F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+A\+TA}~3     /$\ast$ File content $\ast$/
\item 
\#define \textbf{ F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+A\+TH}~4     /$\ast$ Path to top of search $\ast$/
\item 
\#define \textbf{ F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+IR}~5     /$\ast$ Path is relative to this directory $\ast$/
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+I\+R\+S\+T\+\_\+\+P\+H\+A\+SE}~1
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+K\+E\+Y\+W\+O\+R\+DS}~1
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+P\+R\+A\+G\+M\+AS}~2
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS}~3
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+L\+A\+T\+I\+O\+NS}~4
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+I\+N\+D\+E\+X\+ES}~5
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+R\+I\+G\+G\+E\+RS}~6
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+D\+A\+T\+A\+B\+A\+S\+ES}~7
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+ES}~8    /$\ast$ Also V\+I\+E\+Ws and T\+R\+I\+G\+G\+E\+Rs $\ast$/
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+NS}~9
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+M\+O\+D\+U\+L\+ES}~10
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+E\+OF}~11
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+C\+A\+N\+D\+I\+D\+A\+TE}~0  /$\ast$ Suggested completion of the input $\ast$/
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+R\+E\+F\+IX}~1  /$\ast$ Prefix of the word to be completed $\ast$/
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+W\+H\+O\+L\+E\+L\+I\+NE}~2  /$\ast$ Entire line seen so far $\ast$/
\item 
\#define \textbf{ C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+H\+A\+SE}~3  /$\ast$ e\+Phase -\/ used for debugging only $\ast$/
\item 
\#define \textbf{ A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+IX}~\char`\"{}Start-\/Of-\/S\+Q\+Lite3-\/\char`\"{}
\item 
\#define \textbf{ A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+SZ}~17
\item 
\#define \textbf{ A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE}~25
\item 
\#define \textbf{ A\+P\+N\+D\+\_\+\+M\+A\+X\+\_\+\+S\+I\+ZE}~(65536$\ast$15259)
\item 
\#define \textbf{ O\+R\+I\+G\+V\+FS}(p)~((\textbf{ sqlite3\+\_\+vfs}$\ast$)((p)-\/$>$p\+App\+Data))
\item 
\#define \textbf{ O\+R\+I\+G\+F\+I\+LE}(p)~((\textbf{ sqlite3\+\_\+file}$\ast$)(((\textbf{ Apnd\+File}$\ast$)(p))+1))
\item 
\#define \textbf{ S\+Q\+L\+I\+T\+E\+E\+X\+P\+E\+R\+T\+\_\+H}~1
\item 
\#define \textbf{ E\+X\+P\+E\+R\+T\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+S\+A\+M\+P\+LE}~1    /$\ast$ int $\ast$/
\item 
\#define \textbf{ E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+S\+QL}~1
\item 
\#define \textbf{ E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+I\+N\+D\+E\+X\+ES}~2
\item 
\#define \textbf{ E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+P\+L\+AN}~3
\item 
\#define \textbf{ E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+C\+A\+N\+D\+I\+D\+A\+T\+ES}~4
\item 
\#define \textbf{ S\+T\+R\+L\+EN}~(int)strlen
\item 
\#define \textbf{ U\+N\+I\+Q\+U\+E\+\_\+\+T\+A\+B\+L\+E\+\_\+\+N\+A\+ME}~\char`\"{}t592690916721053953805701627921227776\char`\"{}
\item 
\#define \textbf{ I\+D\+X\+\_\+\+H\+A\+S\+H\+\_\+\+S\+I\+ZE}~1023
\item 
\#define \textbf{ A\+U\+T\+O\+E\+Q\+P\+\_\+off}~0           /$\ast$ Automatic E\+X\+P\+L\+A\+IN Q\+U\+E\+RY P\+L\+AN is off $\ast$/
\item 
\#define \textbf{ A\+U\+T\+O\+E\+Q\+P\+\_\+on}~1           /$\ast$ Automatic E\+QP is on $\ast$/
\item 
\#define \textbf{ A\+U\+T\+O\+E\+Q\+P\+\_\+trigger}~2           /$\ast$ On and also show plans for triggers $\ast$/
\item 
\#define \textbf{ A\+U\+T\+O\+E\+Q\+P\+\_\+full}~3           /$\ast$ Show full E\+X\+P\+L\+A\+IN $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+U\+N\+S\+P\+EC}~0      /$\ast$ No open-\/mode specified $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+N\+O\+R\+M\+AL}~1      /$\ast$ Normal database file $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS}~2      /$\ast$ Use appendvfs $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE}~3      /$\ast$ Use the zipfile virtual table $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY}~4      /$\ast$ Open a normal database read-\/only $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+ZE}~5      /$\ast$ Open using \textbf{ sqlite3\+\_\+deserialize}() $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+H\+E\+X\+DB}~6      /$\ast$ Use \char`\"{}dbtotxt\char`\"{} output as data source $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+P\+L\+A\+IN}~0      /$\ast$ Show input S\+QL text $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+E\+X\+P\+A\+N\+D\+ED}~1      /$\ast$ Show expanded S\+QL text $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+ED}~2      /$\ast$ Show normalized S\+QL text $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+Q\+U\+I\+ET}~0x01  /$\ast$ Omit announcing every progress callback $\ast$/
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+R\+E\+S\+ET}
\item 
\#define \textbf{ S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+O\+N\+CE}~0x04  /$\ast$ Cancel the -\/-\/limit after firing once $\ast$/
\item 
\#define \textbf{ S\+H\+F\+L\+G\+\_\+\+Pagecache}~0x00000001 /$\ast$ The -\/-\/pagecache option is used $\ast$/
\item 
\#define \textbf{ S\+H\+F\+L\+G\+\_\+\+Lookaside}~0x00000002 /$\ast$ Lookaside memory is used $\ast$/
\item 
\#define \textbf{ S\+H\+F\+L\+G\+\_\+\+Backslash}~0x00000004 /$\ast$ The -\/-\/backslash option is used $\ast$/
\item 
\#define \textbf{ S\+H\+F\+L\+G\+\_\+\+Preserve\+Rowid}~0x00000008 /$\ast$ .\+dump preserves rowid values $\ast$/
\item 
\#define \textbf{ S\+H\+F\+L\+G\+\_\+\+Newlines}~0x00000010 /$\ast$ .\+dump -\/-\/newline flag $\ast$/
\item 
\#define \textbf{ S\+H\+F\+L\+G\+\_\+\+Count\+Changes}~0x00000020 /$\ast$ .\+changes setting $\ast$/
\item 
\#define \textbf{ S\+H\+F\+L\+G\+\_\+\+Echo}~0x00000040 /$\ast$ .\+echo or -\/-\/echo setting $\ast$/
\item 
\#define \textbf{ Shell\+Has\+Flag}(P,  \textbf{ X})~(((P)-\/$>$shell\+Flgs \& (\textbf{ X}))!=0)
\item 
\#define \textbf{ Shell\+Set\+Flag}(P,  \textbf{ X})~((P)-\/$>$shell\+Flgs$\vert$=(\textbf{ X}))
\item 
\#define \textbf{ Shell\+Clear\+Flag}(P,  \textbf{ X})~((P)-\/$>$shell\+Flgs\&=($\sim$(\textbf{ X})))
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+Line}~0  /$\ast$ One column per line.  Blank line between records $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+Column}~1  /$\ast$ One record per line in neat columns $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+List}~2  /$\ast$ One record per line with a separator $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+Semi}~3  /$\ast$ Same as \textbf{ M\+O\+D\+E\+\_\+\+List} but append \char`\"{};\char`\"{} to each line $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+Html}~4  /$\ast$ Generate an X\+H\+T\+ML table $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+Insert}~5  /$\ast$ Generate S\+QL \char`\"{}insert\char`\"{} statements $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+Quote}~6  /$\ast$ Quote values as for S\+QL $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+Tcl}~7  /$\ast$ Generate A\+N\+SI-\/C or T\+CL quoted elements $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+Csv}~8  /$\ast$ Quote strings, numbers are plain $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+Explain}~9  /$\ast$ Like \textbf{ M\+O\+D\+E\+\_\+\+Column}, but do not truncate data $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+Ascii}~10  /$\ast$ Use A\+S\+C\+II unit and record separators (0x1\+F/0x1\+E) $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+Pretty}~11  /$\ast$ Pretty-\/print schemas $\ast$/
\item 
\#define \textbf{ M\+O\+D\+E\+\_\+\+E\+QP}~12  /$\ast$ Converts E\+X\+P\+L\+A\+IN Q\+U\+E\+RY P\+L\+AN output into a graph $\ast$/
\item 
\#define \textbf{ S\+E\+P\+\_\+\+Column}~\char`\"{}$\vert$\char`\"{}
\item 
\#define \textbf{ S\+E\+P\+\_\+\+Row}~\char`\"{}\textbackslash{}n\char`\"{}
\item 
\#define \textbf{ S\+E\+P\+\_\+\+Tab}~\char`\"{}\textbackslash{}t\char`\"{}
\item 
\#define \textbf{ S\+E\+P\+\_\+\+Space}~\char`\"{} \char`\"{}
\item 
\#define \textbf{ S\+E\+P\+\_\+\+Comma}~\char`\"{},\char`\"{}
\item 
\#define \textbf{ S\+E\+P\+\_\+\+Cr\+Lf}~\char`\"{}\textbackslash{}r\textbackslash{}n\char`\"{}
\item 
\#define \textbf{ S\+E\+P\+\_\+\+Unit}~\char`\"{}\textbackslash{}x1F\char`\"{}
\item 
\#define \textbf{ S\+E\+P\+\_\+\+Record}~\char`\"{}\textbackslash{}x1E\char`\"{}
\item 
\#define \textbf{ session\+\_\+close\+\_\+all}(\textbf{ X})
\item 
\#define \textbf{ O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+K\+E\+E\+P\+A\+L\+I\+VE}~0x001   /$\ast$ Return after error if true $\ast$/
\item 
\#define \textbf{ O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+Z\+I\+P\+F\+I\+LE}~0x002   /$\ast$ Open as Z\+I\+P if name matches $\ast$.\+zip $\ast$/
\item 
\#define \textbf{ C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+A\+L\+\_\+}(opt)~\#opt
\item 
\#define \textbf{ C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+AL}(opt)~\textbf{ C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+A\+L\+\_\+}(opt)
\item 
\#define \textbf{ S\+Q\+L\+I\+T\+E\+\_\+\+S\+H\+E\+L\+L\+\_\+\+I\+S\+\_\+\+U\+T\+F8}~(1)
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef \textbf{ sqlite3\+\_\+int64} \textbf{ i64}
\item 
typedef \textbf{ sqlite3\+\_\+uint64} \textbf{ u64}
\item 
typedef unsigned char \textbf{ u8}
\item 
typedef struct \textbf{ Shell\+Text} \textbf{ Shell\+Text}
\item 
typedef struct \textbf{ S\+H\+A3\+Context} \textbf{ S\+H\+A3\+Context}
\item 
typedef struct \textbf{ fsdir\+\_\+cursor} \textbf{ fsdir\+\_\+cursor}
\item 
typedef struct \textbf{ Fsdir\+Level} \textbf{ Fsdir\+Level}
\item 
typedef struct \textbf{ fsdir\+\_\+tab} \textbf{ fsdir\+\_\+tab}
\item 
typedef typedef\+S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1 struct \textbf{ completion\+\_\+vtab} \textbf{ completion\+\_\+vtab}
\item 
typedef struct \textbf{ completion\+\_\+cursor} \textbf{ completion\+\_\+cursor}
\item 
typedef struct \textbf{ sqlite3\+\_\+vfs} \textbf{ Apnd\+Vfs}
\item 
typedef struct \textbf{ Apnd\+File} \textbf{ Apnd\+File}
\item 
typedef struct \textbf{ sqlite3expert} \textbf{ sqlite3expert}
\item 
typedef struct \textbf{ Idx\+Column} \textbf{ Idx\+Column}
\item 
typedef struct \textbf{ Idx\+Constraint} \textbf{ Idx\+Constraint}
\item 
typedef struct \textbf{ Idx\+Scan} \textbf{ Idx\+Scan}
\item 
typedef struct \textbf{ Idx\+Statement} \textbf{ Idx\+Statement}
\item 
typedef struct \textbf{ Idx\+Table} \textbf{ Idx\+Table}
\item 
typedef struct \textbf{ Idx\+Write} \textbf{ Idx\+Write}
\item 
typedef struct \textbf{ Idx\+Hash\+Entry} \textbf{ Idx\+Hash\+Entry}
\item 
typedef struct \textbf{ Idx\+Hash} \textbf{ Idx\+Hash}
\item 
typedef struct \textbf{ Expert\+Vtab} \textbf{ Expert\+Vtab}
\item 
typedef struct \textbf{ Expert\+Csr} \textbf{ Expert\+Csr}
\item 
typedef struct \textbf{ Saved\+Mode\+Info} \textbf{ Saved\+Mode\+Info}
\item 
typedef struct \textbf{ Expert\+Info} \textbf{ Expert\+Info}
\item 
typedef struct \textbf{ E\+Q\+P\+Graph\+Row} \textbf{ E\+Q\+P\+Graph\+Row}
\item 
typedef struct \textbf{ E\+Q\+P\+Graph} \textbf{ E\+Q\+P\+Graph}
\item 
typedef struct \textbf{ Shell\+State} \textbf{ Shell\+State}
\item 
typedef struct \textbf{ Import\+Ctx} \textbf{ Import\+Ctx}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \textbf{ isatty} (int)
\item 
F\+I\+LE $\ast$ \textbf{ popen} (const char $\ast$, const char $\ast$)
\item 
int \textbf{ pclose} (F\+I\+LE $\ast$)
\item 
static \textbf{ sqlite3\+\_\+int64} \textbf{ time\+Of\+Day} (void)
\item 
static void \textbf{ begin\+Timer} (void)
\item 
static double \textbf{ time\+Diff} (struct timeval $\ast$p\+Start, struct timeval $\ast$p\+End)
\item 
static void \textbf{ end\+Timer} (void)
\item 
static void \textbf{ shell\+\_\+out\+\_\+of\+\_\+memory} (void)
\item 
static void \textbf{ utf8\+\_\+width\+\_\+print} (F\+I\+LE $\ast$p\+Out, int w, const char $\ast$z\+Utf)
\item 
static int \textbf{ is\+Number} (const char $\ast$z, int $\ast$realnum)
\item 
static int \textbf{ strlen30} (const char $\ast$z)
\item 
static int \textbf{ strlen\+Char} (const char $\ast$z)
\item 
static char $\ast$ \textbf{ local\+\_\+getline} (char $\ast$z\+Line, F\+I\+LE $\ast$in)
\item 
static char $\ast$ \textbf{ one\+\_\+input\+\_\+line} (F\+I\+LE $\ast$in, char $\ast$z\+Prior, int is\+Continuation)
\item 
static int \textbf{ hex\+Digit\+Value} (char c)
\item 
static \textbf{ sqlite3\+\_\+int64} \textbf{ integer\+Value} (const char $\ast$z\+Arg)
\item 
static void \textbf{ init\+Text} (\textbf{ Shell\+Text} $\ast$p)
\item 
static void \textbf{ free\+Text} (\textbf{ Shell\+Text} $\ast$p)
\item 
static void \textbf{ append\+Text} (\textbf{ Shell\+Text} $\ast$p, char const $\ast$z\+Append, char quote)
\item 
static char \textbf{ quote\+Char} (const char $\ast$\textbf{ z\+Name})
\item 
static char $\ast$ \textbf{ shell\+Fake\+Schema} (\textbf{ sqlite3} $\ast$db, const char $\ast$z\+Schema, const char $\ast$\textbf{ z\+Name})
\item 
static void \textbf{ shell\+Module\+Schema} (\textbf{ sqlite3\+\_\+context} $\ast$p\+Ctx, int n\+Val, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$ap\+Val)
\item 
static void \textbf{ shell\+Add\+Schema\+Name} (\textbf{ sqlite3\+\_\+context} $\ast$p\+Ctx, int n\+Val, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$ap\+Val)
\item 
static void \textbf{ Keccak\+F1600\+Step} (\textbf{ S\+H\+A3\+Context} $\ast$p)
\item 
static void \textbf{ S\+H\+A3\+Init} (\textbf{ S\+H\+A3\+Context} $\ast$p, int i\+Size)
\item 
static void \textbf{ S\+H\+A3\+Update} (\textbf{ S\+H\+A3\+Context} $\ast$p, const unsigned char $\ast$a\+Data, unsigned int n\+Data)
\item 
static unsigned char $\ast$ \textbf{ S\+H\+A3\+Final} (\textbf{ S\+H\+A3\+Context} $\ast$p)
\item 
static void \textbf{ sha3\+Func} (\textbf{ sqlite3\+\_\+context} $\ast$context, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static void \textbf{ hash\+\_\+step\+\_\+vformat} (\textbf{ S\+H\+A3\+Context} $\ast$p, const char $\ast$z\+Format,...)
\item 
static void \textbf{ sha3\+Query\+Func} (\textbf{ sqlite3\+\_\+context} $\ast$context, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
int \textbf{ sqlite3\+\_\+shathree\+\_\+init} (\textbf{ sqlite3} $\ast$db, char $\ast$$\ast$pz\+Err\+Msg, const \textbf{ sqlite3\+\_\+api\+\_\+routines} $\ast$p\+Api)
\item 
static void \textbf{ read\+File\+Contents} (\textbf{ sqlite3\+\_\+context} $\ast$ctx, const char $\ast$\textbf{ z\+Name})
\item 
static void \textbf{ readfile\+Func} (\textbf{ sqlite3\+\_\+context} $\ast$context, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static void \textbf{ ctx\+Error\+Msg} (\textbf{ sqlite3\+\_\+context} $\ast$ctx, const char $\ast$z\+Fmt,...)
\item 
static int \textbf{ file\+Stat} (const char $\ast$z\+Path, struct stat $\ast$p\+Stat\+Buf)
\item 
static int \textbf{ file\+Link\+Stat} (const char $\ast$z\+Path, struct stat $\ast$p\+Stat\+Buf)
\item 
static int \textbf{ make\+Directory} (const char $\ast$z\+File)
\item 
static int \textbf{ write\+File} (\textbf{ sqlite3\+\_\+context} $\ast$p\+Ctx, const char $\ast$z\+File, \textbf{ sqlite3\+\_\+value} $\ast$p\+Data, mode\+\_\+t mode, \textbf{ sqlite3\+\_\+int64} mtime)
\item 
static void \textbf{ writefile\+Func} (\textbf{ sqlite3\+\_\+context} $\ast$context, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static void \textbf{ ls\+Mode\+Func} (\textbf{ sqlite3\+\_\+context} $\ast$context, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static int \textbf{ fsdir\+Connect} (\textbf{ sqlite3} $\ast$db, void $\ast$p\+Aux, int argc, const char $\ast$const $\ast$argv, \textbf{ sqlite3\+\_\+vtab} $\ast$$\ast$pp\+Vtab, char $\ast$$\ast$pz\+Err)
\item 
static int \textbf{ fsdir\+Disconnect} (\textbf{ sqlite3\+\_\+vtab} $\ast$p\+Vtab)
\item 
static int \textbf{ fsdir\+Open} (\textbf{ sqlite3\+\_\+vtab} $\ast$p, \textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$$\ast$pp\+Cursor)
\item 
static void \textbf{ fsdir\+Reset\+Cursor} (\textbf{ fsdir\+\_\+cursor} $\ast$p\+Cur)
\item 
static int \textbf{ fsdir\+Close} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur)
\item 
static void \textbf{ fsdir\+Set\+Errmsg} (\textbf{ fsdir\+\_\+cursor} $\ast$p\+Cur, const char $\ast$z\+Fmt,...)
\item 
static int \textbf{ fsdir\+Next} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur)
\item 
static int \textbf{ fsdir\+Column} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur, \textbf{ sqlite3\+\_\+context} $\ast$ctx, int i)
\item 
static int \textbf{ fsdir\+Rowid} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur, \textbf{ sqlite\+\_\+int64} $\ast$p\+Rowid)
\item 
static int \textbf{ fsdir\+Eof} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur)
\item 
static int \textbf{ fsdir\+Filter} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur, int idx\+Num, const char $\ast$idx\+Str, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static int \textbf{ fsdir\+Best\+Index} (\textbf{ sqlite3\+\_\+vtab} $\ast$tab, \textbf{ sqlite3\+\_\+index\+\_\+info} $\ast$p\+Idx\+Info)
\item 
static int \textbf{ fsdir\+Register} (\textbf{ sqlite3} $\ast$db)
\item 
int \textbf{ sqlite3\+\_\+fileio\+\_\+init} (\textbf{ sqlite3} $\ast$db, char $\ast$$\ast$pz\+Err\+Msg, const \textbf{ sqlite3\+\_\+api\+\_\+routines} $\ast$p\+Api)
\item 
static int \textbf{ completion\+Connect} (\textbf{ sqlite3} $\ast$db, void $\ast$p\+Aux, int argc, const char $\ast$const $\ast$argv, \textbf{ sqlite3\+\_\+vtab} $\ast$$\ast$pp\+Vtab, char $\ast$$\ast$pz\+Err)
\item 
static int \textbf{ completion\+Disconnect} (\textbf{ sqlite3\+\_\+vtab} $\ast$p\+Vtab)
\item 
static int \textbf{ completion\+Open} (\textbf{ sqlite3\+\_\+vtab} $\ast$p, \textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$$\ast$pp\+Cursor)
\item 
static void \textbf{ completion\+Cursor\+Reset} (\textbf{ completion\+\_\+cursor} $\ast$p\+Cur)
\item 
static int \textbf{ completion\+Close} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur)
\item 
static int \textbf{ completion\+Next} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur)
\item 
static int \textbf{ completion\+Column} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur, \textbf{ sqlite3\+\_\+context} $\ast$ctx, int i)
\item 
static int \textbf{ completion\+Rowid} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur, \textbf{ sqlite\+\_\+int64} $\ast$p\+Rowid)
\item 
static int \textbf{ completion\+Eof} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur)
\item 
static int \textbf{ completion\+Filter} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$p\+Vtab\+Cursor, int idx\+Num, const char $\ast$idx\+Str, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static int \textbf{ completion\+Best\+Index} (\textbf{ sqlite3\+\_\+vtab} $\ast$tab, \textbf{ sqlite3\+\_\+index\+\_\+info} $\ast$p\+Idx\+Info)
\item 
int \textbf{ sqlite3\+Completion\+Vtab\+Init} (\textbf{ sqlite3} $\ast$db)
\item 
int \textbf{ sqlite3\+\_\+completion\+\_\+init} (\textbf{ sqlite3} $\ast$db, char $\ast$$\ast$pz\+Err\+Msg, const \textbf{ sqlite3\+\_\+api\+\_\+routines} $\ast$p\+Api)
\item 
static int \textbf{ apnd\+Close} (\textbf{ sqlite3\+\_\+file} $\ast$)
\item 
static int \textbf{ apnd\+Read} (\textbf{ sqlite3\+\_\+file} $\ast$, void $\ast$, int i\+Amt, \textbf{ sqlite3\+\_\+int64} i\+Ofst)
\item 
static int \textbf{ apnd\+Write} (\textbf{ sqlite3\+\_\+file} $\ast$, const void $\ast$, int i\+Amt, \textbf{ sqlite3\+\_\+int64} i\+Ofst)
\item 
static int \textbf{ apnd\+Truncate} (\textbf{ sqlite3\+\_\+file} $\ast$, \textbf{ sqlite3\+\_\+int64} size)
\item 
static int \textbf{ apnd\+Sync} (\textbf{ sqlite3\+\_\+file} $\ast$, int flags)
\item 
static int \textbf{ apnd\+File\+Size} (\textbf{ sqlite3\+\_\+file} $\ast$, \textbf{ sqlite3\+\_\+int64} $\ast$p\+Size)
\item 
static int \textbf{ apnd\+Lock} (\textbf{ sqlite3\+\_\+file} $\ast$, int)
\item 
static int \textbf{ apnd\+Unlock} (\textbf{ sqlite3\+\_\+file} $\ast$, int)
\item 
static int \textbf{ apnd\+Check\+Reserved\+Lock} (\textbf{ sqlite3\+\_\+file} $\ast$, int $\ast$p\+Res\+Out)
\item 
static int \textbf{ apnd\+File\+Control} (\textbf{ sqlite3\+\_\+file} $\ast$, int op, void $\ast$p\+Arg)
\item 
static int \textbf{ apnd\+Sector\+Size} (\textbf{ sqlite3\+\_\+file} $\ast$)
\item 
static int \textbf{ apnd\+Device\+Characteristics} (\textbf{ sqlite3\+\_\+file} $\ast$)
\item 
static int \textbf{ apnd\+Shm\+Map} (\textbf{ sqlite3\+\_\+file} $\ast$, int i\+Pg, int pgsz, int, void volatile $\ast$$\ast$)
\item 
static int \textbf{ apnd\+Shm\+Lock} (\textbf{ sqlite3\+\_\+file} $\ast$, int offset, int n, int flags)
\item 
static void \textbf{ apnd\+Shm\+Barrier} (\textbf{ sqlite3\+\_\+file} $\ast$)
\item 
static int \textbf{ apnd\+Shm\+Unmap} (\textbf{ sqlite3\+\_\+file} $\ast$, int delete\+Flag)
\item 
static int \textbf{ apnd\+Fetch} (\textbf{ sqlite3\+\_\+file} $\ast$, \textbf{ sqlite3\+\_\+int64} i\+Ofst, int i\+Amt, void $\ast$$\ast$pp)
\item 
static int \textbf{ apnd\+Unfetch} (\textbf{ sqlite3\+\_\+file} $\ast$, \textbf{ sqlite3\+\_\+int64} i\+Ofst, void $\ast$p)
\item 
static int \textbf{ apnd\+Open} (\textbf{ sqlite3\+\_\+vfs} $\ast$, const char $\ast$, \textbf{ sqlite3\+\_\+file} $\ast$, int, int $\ast$)
\item 
static int \textbf{ apnd\+Delete} (\textbf{ sqlite3\+\_\+vfs} $\ast$, const char $\ast$\textbf{ z\+Name}, int sync\+Dir)
\item 
static int \textbf{ apnd\+Access} (\textbf{ sqlite3\+\_\+vfs} $\ast$, const char $\ast$\textbf{ z\+Name}, int flags, int $\ast$)
\item 
static int \textbf{ apnd\+Full\+Pathname} (\textbf{ sqlite3\+\_\+vfs} $\ast$, const char $\ast$\textbf{ z\+Name}, int, char $\ast$z\+Out)
\item 
static void $\ast$ \textbf{ apnd\+Dl\+Open} (\textbf{ sqlite3\+\_\+vfs} $\ast$, const char $\ast$z\+Filename)
\item 
static void \textbf{ apnd\+Dl\+Error} (\textbf{ sqlite3\+\_\+vfs} $\ast$, int n\+Byte, char $\ast$z\+Err\+Msg)
\item 
static void \textbf{ apnd\+Dl\+Close} (\textbf{ sqlite3\+\_\+vfs} $\ast$, void $\ast$)
\item 
static int \textbf{ apnd\+Randomness} (\textbf{ sqlite3\+\_\+vfs} $\ast$, int n\+Byte, char $\ast$z\+Out)
\item 
static int \textbf{ apnd\+Sleep} (\textbf{ sqlite3\+\_\+vfs} $\ast$, int microseconds)
\item 
static int \textbf{ apnd\+Current\+Time} (\textbf{ sqlite3\+\_\+vfs} $\ast$, double $\ast$)
\item 
static int \textbf{ apnd\+Get\+Last\+Error} (\textbf{ sqlite3\+\_\+vfs} $\ast$, int, char $\ast$)
\item 
static int \textbf{ apnd\+Current\+Time\+Int64} (\textbf{ sqlite3\+\_\+vfs} $\ast$, \textbf{ sqlite3\+\_\+int64} $\ast$)
\item 
static int \textbf{ apnd\+Set\+System\+Call} (\textbf{ sqlite3\+\_\+vfs} $\ast$, const char $\ast$, \textbf{ sqlite3\+\_\+syscall\+\_\+ptr})
\item 
static \textbf{ sqlite3\+\_\+syscall\+\_\+ptr} \textbf{ apnd\+Get\+System\+Call} (\textbf{ sqlite3\+\_\+vfs} $\ast$, const char $\ast$z)
\item 
static const char $\ast$ \textbf{ apnd\+Next\+System\+Call} (\textbf{ sqlite3\+\_\+vfs} $\ast$, const char $\ast$\textbf{ z\+Name})
\item 
static int \textbf{ apnd\+Write\+Mark} (\textbf{ Apnd\+File} $\ast$p, \textbf{ sqlite3\+\_\+file} $\ast$p\+File)
\item 
static int \textbf{ apnd\+Is\+Ordinary\+Database\+File} (\textbf{ sqlite3\+\_\+int64} sz, \textbf{ sqlite3\+\_\+file} $\ast$p\+File)
\item 
static \textbf{ sqlite3\+\_\+int64} \textbf{ apnd\+Read\+Mark} (\textbf{ sqlite3\+\_\+int64} sz, \textbf{ sqlite3\+\_\+file} $\ast$p\+File)
\item 
int \textbf{ sqlite3\+\_\+appendvfs\+\_\+init} (\textbf{ sqlite3} $\ast$db, char $\ast$$\ast$pz\+Err\+Msg, const \textbf{ sqlite3\+\_\+api\+\_\+routines} $\ast$p\+Api)
\item 
static void $\ast$ \textbf{ memtrace\+Malloc} (int n)
\item 
static void \textbf{ memtrace\+Free} (void $\ast$p)
\item 
static void $\ast$ \textbf{ memtrace\+Realloc} (void $\ast$p, int n)
\item 
static int \textbf{ memtrace\+Size} (void $\ast$p)
\item 
static int \textbf{ memtrace\+Roundup} (int n)
\item 
static int \textbf{ memtrace\+Init} (void $\ast$p)
\item 
static void \textbf{ memtrace\+Shutdown} (void $\ast$p)
\item 
int \textbf{ sqlite3\+Mem\+Trace\+Activate} (F\+I\+LE $\ast$out)
\item 
int \textbf{ sqlite3\+Mem\+Trace\+Deactivate} (void)
\item 
\textbf{ sqlite3expert} $\ast$ \textbf{ sqlite3\+\_\+expert\+\_\+new} (\textbf{ sqlite3} $\ast$db, char $\ast$$\ast$pz\+Err)
\item 
int \textbf{ sqlite3\+\_\+expert\+\_\+config} (\textbf{ sqlite3expert} $\ast$p, int op,...)
\item 
int \textbf{ sqlite3\+\_\+expert\+\_\+sql} (\textbf{ sqlite3expert} $\ast$p, const char $\ast$z\+Sql, char $\ast$$\ast$pz\+Err)
\item 
int \textbf{ sqlite3\+\_\+expert\+\_\+analyze} (\textbf{ sqlite3expert} $\ast$p, char $\ast$$\ast$pz\+Err)
\item 
int \textbf{ sqlite3\+\_\+expert\+\_\+count} (\textbf{ sqlite3expert} $\ast$)
\item 
const char $\ast$ \textbf{ sqlite3\+\_\+expert\+\_\+report} (\textbf{ sqlite3expert} $\ast$, int i\+Stmt, int e\+Report)
\item 
void \textbf{ sqlite3\+\_\+expert\+\_\+destroy} (\textbf{ sqlite3expert} $\ast$)
\item 
static void $\ast$ \textbf{ idx\+Malloc} (int $\ast$p\+Rc, int n\+Byte)
\item 
static void \textbf{ idx\+Hash\+Init} (\textbf{ Idx\+Hash} $\ast$p\+Hash)
\item 
static void \textbf{ idx\+Hash\+Clear} (\textbf{ Idx\+Hash} $\ast$p\+Hash)
\item 
static int \textbf{ idx\+Hash\+String} (const char $\ast$z, int n)
\item 
static int \textbf{ idx\+Hash\+Add} (int $\ast$p\+Rc, \textbf{ Idx\+Hash} $\ast$p\+Hash, const char $\ast$z\+Key, const char $\ast$z\+Val)
\item 
static \textbf{ Idx\+Hash\+Entry} $\ast$ \textbf{ idx\+Hash\+Find} (\textbf{ Idx\+Hash} $\ast$p\+Hash, const char $\ast$z\+Key, int n\+Key)
\item 
static const char $\ast$ \textbf{ idx\+Hash\+Search} (\textbf{ Idx\+Hash} $\ast$p\+Hash, const char $\ast$z\+Key, int n\+Key)
\item 
static \textbf{ Idx\+Constraint} $\ast$ \textbf{ idx\+New\+Constraint} (int $\ast$p\+Rc, const char $\ast$z\+Coll)
\item 
static void \textbf{ idx\+Database\+Error} (\textbf{ sqlite3} $\ast$db, char $\ast$$\ast$pz\+Errmsg)
\item 
static int \textbf{ idx\+Prepare\+Stmt} (\textbf{ sqlite3} $\ast$db, \textbf{ sqlite3\+\_\+stmt} $\ast$$\ast$pp\+Stmt, char $\ast$$\ast$pz\+Errmsg, const char $\ast$z\+Sql)
\item 
static int \textbf{ idx\+Printf\+Prepare\+Stmt} (\textbf{ sqlite3} $\ast$db, \textbf{ sqlite3\+\_\+stmt} $\ast$$\ast$pp\+Stmt, char $\ast$$\ast$pz\+Errmsg, const char $\ast$z\+Fmt,...)
\item 
static char $\ast$ \textbf{ expert\+Dequote} (const char $\ast$z\+In)
\item 
static int \textbf{ expert\+Connect} (\textbf{ sqlite3} $\ast$db, void $\ast$p\+Aux, int argc, const char $\ast$const $\ast$argv, \textbf{ sqlite3\+\_\+vtab} $\ast$$\ast$pp\+Vtab, char $\ast$$\ast$pz\+Err)
\item 
static int \textbf{ expert\+Disconnect} (\textbf{ sqlite3\+\_\+vtab} $\ast$p\+Vtab)
\item 
static int \textbf{ expert\+Best\+Index} (\textbf{ sqlite3\+\_\+vtab} $\ast$p\+Vtab, \textbf{ sqlite3\+\_\+index\+\_\+info} $\ast$p\+Idx\+Info)
\item 
static int \textbf{ expert\+Update} (\textbf{ sqlite3\+\_\+vtab} $\ast$p\+Vtab, int n\+Data, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$az\+Data, \textbf{ sqlite\+\_\+int64} $\ast$p\+Rowid)
\item 
static int \textbf{ expert\+Open} (\textbf{ sqlite3\+\_\+vtab} $\ast$p\+V\+Tab, \textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$$\ast$pp\+Cursor)
\item 
static int \textbf{ expert\+Close} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur)
\item 
static int \textbf{ expert\+Eof} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur)
\item 
static int \textbf{ expert\+Next} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur)
\item 
static int \textbf{ expert\+Rowid} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur, \textbf{ sqlite\+\_\+int64} $\ast$p\+Rowid)
\item 
static int \textbf{ expert\+Column} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur, \textbf{ sqlite3\+\_\+context} $\ast$ctx, int i)
\item 
static int \textbf{ expert\+Filter} (\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$cur, int idx\+Num, const char $\ast$idx\+Str, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static int \textbf{ idx\+Register\+Vtab} (\textbf{ sqlite3expert} $\ast$p)
\item 
static void \textbf{ idx\+Finalize} (int $\ast$p\+Rc, \textbf{ sqlite3\+\_\+stmt} $\ast$p\+Stmt)
\item 
static int \textbf{ idx\+Get\+Table\+Info} (\textbf{ sqlite3} $\ast$db, const char $\ast$z\+Tab, \textbf{ Idx\+Table} $\ast$$\ast$pp\+Out, char $\ast$$\ast$pz\+Errmsg)
\item 
static char $\ast$ \textbf{ idx\+Append\+Text} (int $\ast$p\+Rc, char $\ast$z\+In, const char $\ast$z\+Fmt,...)
\item 
static int \textbf{ idx\+Identifier\+Requires\+Quotes} (const char $\ast$z\+Id)
\item 
static char $\ast$ \textbf{ idx\+Append\+Col\+Defn} (int $\ast$p\+Rc, char $\ast$z\+In, \textbf{ Idx\+Table} $\ast$p\+Tab, \textbf{ Idx\+Constraint} $\ast$p\+Cons)
\item 
static int \textbf{ idx\+Find\+Compatible} (int $\ast$p\+Rc, \textbf{ sqlite3} $\ast$dbm, \textbf{ Idx\+Scan} $\ast$p\+Scan, \textbf{ Idx\+Constraint} $\ast$p\+Eq, \textbf{ Idx\+Constraint} $\ast$p\+Tail)
\item 
static int \textbf{ idx\+Create\+From\+Cons} (\textbf{ sqlite3expert} $\ast$p, \textbf{ Idx\+Scan} $\ast$p\+Scan, \textbf{ Idx\+Constraint} $\ast$p\+Eq, \textbf{ Idx\+Constraint} $\ast$p\+Tail)
\item 
static int \textbf{ idx\+Find\+Constraint} (\textbf{ Idx\+Constraint} $\ast$p\+List, \textbf{ Idx\+Constraint} $\ast$p)
\item 
static int \textbf{ idx\+Create\+From\+Where} (\textbf{ sqlite3expert} $\ast$p, \textbf{ Idx\+Scan} $\ast$p\+Scan, \textbf{ Idx\+Constraint} $\ast$p\+Tail)
\item 
static int \textbf{ idx\+Create\+Candidates} (\textbf{ sqlite3expert} $\ast$p)
\item 
static void \textbf{ idx\+Constraint\+Free} (\textbf{ Idx\+Constraint} $\ast$p\+Constraint)
\item 
static void \textbf{ idx\+Scan\+Free} (\textbf{ Idx\+Scan} $\ast$p\+Scan, \textbf{ Idx\+Scan} $\ast$p\+Last)
\item 
static void \textbf{ idx\+Statement\+Free} (\textbf{ Idx\+Statement} $\ast$p\+Statement, \textbf{ Idx\+Statement} $\ast$p\+Last)
\item 
static void \textbf{ idx\+Table\+Free} (\textbf{ Idx\+Table} $\ast$p\+Tab)
\item 
static void \textbf{ idx\+Write\+Free} (\textbf{ Idx\+Write} $\ast$p\+Tab)
\item 
int \textbf{ idx\+Find\+Indexes} (\textbf{ sqlite3expert} $\ast$p, char $\ast$$\ast$pz\+Err)
\item 
static int \textbf{ idx\+Auth\+Callback} (void $\ast$p\+Ctx, int e\+Op, const char $\ast$z3, const char $\ast$z4, const char $\ast$z\+Db, const char $\ast$z\+Trigger)
\item 
static int \textbf{ idx\+Process\+One\+Trigger} (\textbf{ sqlite3expert} $\ast$p, \textbf{ Idx\+Write} $\ast$p\+Write, char $\ast$$\ast$pz\+Err)
\item 
static int \textbf{ idx\+Process\+Triggers} (\textbf{ sqlite3expert} $\ast$p, char $\ast$$\ast$pz\+Err)
\item 
static int \textbf{ idx\+Create\+Vtab\+Schema} (\textbf{ sqlite3expert} $\ast$p, char $\ast$$\ast$pz\+Errmsg)
\item 
static void \textbf{ idx\+Sample\+Func} (\textbf{ sqlite3\+\_\+context} $\ast$p\+Ctx, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static void \textbf{ idx\+Rem\+Func} (\textbf{ sqlite3\+\_\+context} $\ast$p\+Ctx, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static int \textbf{ idx\+Largest\+Index} (\textbf{ sqlite3} $\ast$db, int $\ast$pn\+Max, char $\ast$$\ast$pz\+Err)
\item 
static int \textbf{ idx\+Populate\+One\+Stat1} (\textbf{ sqlite3expert} $\ast$p, \textbf{ sqlite3\+\_\+stmt} $\ast$p\+Index\+X\+Info, \textbf{ sqlite3\+\_\+stmt} $\ast$p\+Write\+Stat, const char $\ast$z\+Tab, const char $\ast$z\+Idx, char $\ast$$\ast$pz\+Err)
\item 
static int \textbf{ idx\+Build\+Sample\+Table} (\textbf{ sqlite3expert} $\ast$p, const char $\ast$z\+Tab)
\item 
static int \textbf{ idx\+Populate\+Stat1} (\textbf{ sqlite3expert} $\ast$p, char $\ast$$\ast$pz\+Err)
\item 
static void \textbf{ shell\+Log} (void $\ast$p\+Arg, int i\+Err\+Code, const char $\ast$z\+Msg)
\item 
static void \textbf{ shell\+Puts\+Func} (\textbf{ sqlite3\+\_\+context} $\ast$p\+Ctx, int n\+Val, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$ap\+Val)
\item 
static void \textbf{ edit\+Func} (\textbf{ sqlite3\+\_\+context} $\ast$context, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static void \textbf{ output\+Mode\+Push} (\textbf{ Shell\+State} $\ast$p)
\item 
static void \textbf{ output\+Mode\+Pop} (\textbf{ Shell\+State} $\ast$p)
\item 
static void \textbf{ output\+\_\+hex\+\_\+blob} (F\+I\+LE $\ast$out, const void $\ast$p\+Blob, int n\+Blob)
\item 
static const char $\ast$ \textbf{ unused\+\_\+string} (const char $\ast$z, const char $\ast$zA, const char $\ast$zB, char $\ast$z\+Buf)
\item 
static void \textbf{ output\+\_\+quoted\+\_\+string} (F\+I\+LE $\ast$out, const char $\ast$z)
\item 
static void \textbf{ output\+\_\+quoted\+\_\+escaped\+\_\+string} (F\+I\+LE $\ast$out, const char $\ast$z)
\item 
static void \textbf{ output\+\_\+c\+\_\+string} (F\+I\+LE $\ast$out, const char $\ast$z)
\item 
static void \textbf{ output\+\_\+html\+\_\+string} (F\+I\+LE $\ast$out, const char $\ast$z)
\item 
static void \textbf{ output\+\_\+csv} (\textbf{ Shell\+State} $\ast$p, const char $\ast$z, int b\+Sep)
\item 
static void \textbf{ interrupt\+\_\+handler} (int Not\+Used)
\item 
static int \textbf{ shell\+Auth} (void $\ast$p\+Client\+Data, int op, const char $\ast$z\+A1, const char $\ast$z\+A2, const char $\ast$z\+A3, const char $\ast$z\+A4)
\item 
static void \textbf{ print\+Schema\+Line} (F\+I\+LE $\ast$out, const char $\ast$z, const char $\ast$z\+Tail)
\item 
static void \textbf{ print\+Schema\+LineN} (F\+I\+LE $\ast$out, char $\ast$z, int n, const char $\ast$z\+Tail)
\item 
static int \textbf{ ws\+To\+Eol} (const char $\ast$z)
\item 
static void \textbf{ eqp\+\_\+append} (\textbf{ Shell\+State} $\ast$p, int i\+Eqp\+Id, int p2, const char $\ast$z\+Text)
\item 
static void \textbf{ eqp\+\_\+reset} (\textbf{ Shell\+State} $\ast$p)
\item 
static \textbf{ E\+Q\+P\+Graph\+Row} $\ast$ \textbf{ eqp\+\_\+next\+\_\+row} (\textbf{ Shell\+State} $\ast$p, int i\+Eqp\+Id, \textbf{ E\+Q\+P\+Graph\+Row} $\ast$p\+Old)
\item 
static void \textbf{ eqp\+\_\+render\+\_\+level} (\textbf{ Shell\+State} $\ast$p, int i\+Eqp\+Id)
\item 
static void \textbf{ eqp\+\_\+render} (\textbf{ Shell\+State} $\ast$p)
\item 
static int \textbf{ progress\+\_\+handler} (void $\ast$p\+Client\+Data)
\item 
static int \textbf{ shell\+\_\+callback} (void $\ast$p\+Arg, int n\+Arg, char $\ast$$\ast$az\+Arg, char $\ast$$\ast$az\+Col, int $\ast$ai\+Type)
\item 
static int \textbf{ callback} (void $\ast$p\+Arg, int n\+Arg, char $\ast$$\ast$az\+Arg, char $\ast$$\ast$az\+Col)
\item 
static int \textbf{ capture\+Output\+Callback} (void $\ast$p\+Arg, int n\+Arg, char $\ast$$\ast$az\+Arg, char $\ast$$\ast$az)
\item 
static void \textbf{ create\+Selftest\+Table} (\textbf{ Shell\+State} $\ast$p)
\item 
static void \textbf{ set\+\_\+table\+\_\+name} (\textbf{ Shell\+State} $\ast$p, const char $\ast$\textbf{ z\+Name})
\item 
static int \textbf{ run\+\_\+table\+\_\+dump\+\_\+query} (\textbf{ Shell\+State} $\ast$p, const char $\ast$z\+Select, const char $\ast$z\+First\+Row)
\item 
static char $\ast$ \textbf{ save\+\_\+err\+\_\+msg} (\textbf{ sqlite3} $\ast$db)
\item 
static void \textbf{ display\+Stat\+Line} (\textbf{ Shell\+State} $\ast$p, char $\ast$z\+Label, char $\ast$z\+Format, int i\+Status\+Ctrl, int b\+Reset)
\item 
static int \textbf{ display\+\_\+stats} (\textbf{ sqlite3} $\ast$db, \textbf{ Shell\+State} $\ast$p\+Arg, int b\+Reset)
\item 
static void \textbf{ display\+\_\+scanstats} (\textbf{ sqlite3} $\ast$db, \textbf{ Shell\+State} $\ast$p\+Arg)
\item 
static int \textbf{ str\+\_\+in\+\_\+array} (const char $\ast$z\+Str, const char $\ast$$\ast$az\+Array)
\item 
static void \textbf{ explain\+\_\+data\+\_\+prepare} (\textbf{ Shell\+State} $\ast$p, \textbf{ sqlite3\+\_\+stmt} $\ast$p\+Sql)
\item 
static void \textbf{ explain\+\_\+data\+\_\+delete} (\textbf{ Shell\+State} $\ast$p)
\item 
static void \textbf{ disable\+\_\+debug\+\_\+trace\+\_\+modes} (void)
\item 
static void \textbf{ restore\+\_\+debug\+\_\+trace\+\_\+modes} (void)
\item 
static void \textbf{ bind\+\_\+table\+\_\+init} (\textbf{ Shell\+State} $\ast$p)
\item 
static void \textbf{ bind\+\_\+prepared\+\_\+stmt} (\textbf{ Shell\+State} $\ast$p\+Arg, \textbf{ sqlite3\+\_\+stmt} $\ast$p\+Stmt)
\item 
static void \textbf{ exec\+\_\+prepared\+\_\+stmt} (\textbf{ Shell\+State} $\ast$p\+Arg, \textbf{ sqlite3\+\_\+stmt} $\ast$p\+Stmt)
\item 
static int \textbf{ expert\+Handle\+S\+QL} (\textbf{ Shell\+State} $\ast$p\+State, const char $\ast$z\+Sql, char $\ast$$\ast$pz\+Err)
\item 
static int \textbf{ expert\+Finish} (\textbf{ Shell\+State} $\ast$p\+State, int b\+Cancel, char $\ast$$\ast$pz\+Err)
\item 
static int \textbf{ expert\+Dot\+Command} (\textbf{ Shell\+State} $\ast$p\+State, char $\ast$$\ast$az\+Arg, int n\+Arg)
\item 
static int \textbf{ shell\+\_\+exec} (\textbf{ Shell\+State} $\ast$p\+Arg, const char $\ast$z\+Sql, char $\ast$$\ast$pz\+Err\+Msg)
\item 
static void \textbf{ free\+Column\+List} (char $\ast$$\ast$az\+Col)
\item 
static char $\ast$$\ast$ \textbf{ table\+Column\+List} (\textbf{ Shell\+State} $\ast$p, const char $\ast$z\+Tab)
\item 
static void \textbf{ toggle\+Select\+Order} (\textbf{ sqlite3} $\ast$db)
\item 
static int \textbf{ dump\+\_\+callback} (void $\ast$p\+Arg, int n\+Arg, char $\ast$$\ast$az\+Arg, char $\ast$$\ast$az\+Not\+Used)
\item 
static int \textbf{ run\+\_\+schema\+\_\+dump\+\_\+query} (\textbf{ Shell\+State} $\ast$p, const char $\ast$z\+Query)
\item 
static int \textbf{ show\+Help} (F\+I\+LE $\ast$out, const char $\ast$z\+Pattern)
\item 
static int \textbf{ process\+\_\+input} (\textbf{ Shell\+State} $\ast$p)
\item 
static char $\ast$ \textbf{ read\+File} (const char $\ast$\textbf{ z\+Name}, int $\ast$pn\+Byte)
\item 
int \textbf{ deduce\+Database\+Type} (const char $\ast$\textbf{ z\+Name}, int dflt\+Zip)
\item 
static void \textbf{ shell\+Int32} (\textbf{ sqlite3\+\_\+context} $\ast$context, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static void \textbf{ shell\+Id\+Quote} (\textbf{ sqlite3\+\_\+context} $\ast$context, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static void \textbf{ shell\+Escape\+Crnl} (\textbf{ sqlite3\+\_\+context} $\ast$context, int argc, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$argv)
\item 
static void \textbf{ open\+\_\+db} (\textbf{ Shell\+State} $\ast$p, int open\+Flags)
\item 
void \textbf{ close\+\_\+db} (\textbf{ sqlite3} $\ast$db)
\item 
static void \textbf{ resolve\+\_\+backslashes} (char $\ast$z)
\item 
static int \textbf{ boolean\+Value} (const char $\ast$z\+Arg)
\item 
static void \textbf{ set\+Or\+Clear\+Flag} (\textbf{ Shell\+State} $\ast$p, unsigned m\+Flag, const char $\ast$z\+Arg)
\item 
static void \textbf{ output\+\_\+file\+\_\+close} (F\+I\+LE $\ast$f)
\item 
static F\+I\+LE $\ast$ \textbf{ output\+\_\+file\+\_\+open} (const char $\ast$z\+File, int b\+Text\+Mode)
\item 
static int \textbf{ sql\+\_\+trace\+\_\+callback} (unsigned m\+Type, void $\ast$p\+Arg, void $\ast$pP, void $\ast$pX)
\item 
static void \textbf{ test\+\_\+breakpoint} (void)
\item 
static void \textbf{ import\+\_\+append\+\_\+char} (\textbf{ Import\+Ctx} $\ast$p, int c)
\item 
static char $\ast$\textbf{ S\+Q\+L\+I\+T\+E\+\_\+\+C\+D\+E\+CL} \textbf{ csv\+\_\+read\+\_\+one\+\_\+field} (\textbf{ Import\+Ctx} $\ast$p)
\item 
static char $\ast$\textbf{ S\+Q\+L\+I\+T\+E\+\_\+\+C\+D\+E\+CL} \textbf{ ascii\+\_\+read\+\_\+one\+\_\+field} (\textbf{ Import\+Ctx} $\ast$p)
\item 
static void \textbf{ try\+To\+Clone\+Data} (\textbf{ Shell\+State} $\ast$p, \textbf{ sqlite3} $\ast$new\+Db, const char $\ast$z\+Table)
\item 
static void \textbf{ try\+To\+Clone\+Schema} (\textbf{ Shell\+State} $\ast$p, \textbf{ sqlite3} $\ast$new\+Db, const char $\ast$z\+Where, void($\ast$x\+For\+Each)(\textbf{ Shell\+State} $\ast$, \textbf{ sqlite3} $\ast$, const char $\ast$))
\item 
static void \textbf{ try\+To\+Clone} (\textbf{ Shell\+State} $\ast$p, const char $\ast$z\+New\+Db)
\item 
static void \textbf{ output\+\_\+reset} (\textbf{ Shell\+State} $\ast$p)
\item 
static int \textbf{ db\+\_\+int} (\textbf{ Shell\+State} $\ast$p, const char $\ast$z\+Sql)
\item 
static unsigned int \textbf{ get2byte\+Int} (unsigned char $\ast$a)
\item 
static unsigned int \textbf{ get4byte\+Int} (unsigned char $\ast$a)
\item 
static int \textbf{ shell\+\_\+dbinfo\+\_\+command} (\textbf{ Shell\+State} $\ast$p, int n\+Arg, char $\ast$$\ast$az\+Arg)
\item 
static int \textbf{ shell\+Database\+Error} (\textbf{ sqlite3} $\ast$db)
\item 
static int \textbf{ testcase\+\_\+glob} (const char $\ast$z\+Glob, const char $\ast$z)
\item 
static int \textbf{ option\+Match} (const char $\ast$z\+Str, const char $\ast$z\+Opt)
\item 
int \textbf{ shell\+Delete\+File} (const char $\ast$z\+Filename)
\item 
static void \textbf{ clear\+Temp\+File} (\textbf{ Shell\+State} $\ast$p)
\item 
static void \textbf{ new\+Temp\+File} (\textbf{ Shell\+State} $\ast$p, const char $\ast$z\+Suffix)
\item 
static void \textbf{ shell\+Fkey\+Collate\+Clause} (\textbf{ sqlite3\+\_\+context} $\ast$p\+Ctx, int n\+Val, \textbf{ sqlite3\+\_\+value} $\ast$$\ast$ap\+Val)
\item 
static int \textbf{ lint\+Fkey\+Indexes} (\textbf{ Shell\+State} $\ast$p\+State, char $\ast$$\ast$az\+Arg, int n\+Arg)
\item 
static int \textbf{ lint\+Dot\+Command} (\textbf{ Shell\+State} $\ast$p\+State, char $\ast$$\ast$az\+Arg, int n\+Arg)
\item 
static void \textbf{ shell\+Prepare} (\textbf{ sqlite3} $\ast$db, int $\ast$p\+Rc, const char $\ast$z\+Sql, \textbf{ sqlite3\+\_\+stmt} $\ast$$\ast$pp\+Stmt)
\item 
void \textbf{ shell\+Prepare\+Printf} (\textbf{ sqlite3} $\ast$db, int $\ast$p\+Rc, \textbf{ sqlite3\+\_\+stmt} $\ast$$\ast$pp\+Stmt, const char $\ast$z\+Fmt,...)
\item 
void \textbf{ shell\+Finalize} (int $\ast$p\+Rc, \textbf{ sqlite3\+\_\+stmt} $\ast$p\+Stmt)
\item 
void \textbf{ shell\+Reset} (int $\ast$p\+Rc, \textbf{ sqlite3\+\_\+stmt} $\ast$p\+Stmt)
\item 
static int \textbf{ do\+\_\+meta\+\_\+command} (char $\ast$z\+Line, \textbf{ Shell\+State} $\ast$p)
\item 
static int \textbf{ line\+\_\+contains\+\_\+semicolon} (const char $\ast$z, int N)
\item 
static int \textbf{ \+\_\+all\+\_\+whitespace} (const char $\ast$z)
\item 
static int \textbf{ line\+\_\+is\+\_\+command\+\_\+terminator} (const char $\ast$z\+Line)
\item 
static int \textbf{ line\+\_\+is\+\_\+complete} (char $\ast$z\+Sql, int n\+Sql)
\item 
static int \textbf{ run\+One\+Sql\+Line} (\textbf{ Shell\+State} $\ast$p, char $\ast$z\+Sql, F\+I\+LE $\ast$in, int startline)
\item 
static char $\ast$ \textbf{ find\+\_\+home\+\_\+dir} (int clear\+Flag)
\item 
static void \textbf{ process\+\_\+sqliterc} (\textbf{ Shell\+State} $\ast$p, const char $\ast$sqliterc\+\_\+override)
\item 
static void \textbf{ usage} (int show\+Detail)
\item 
static void \textbf{ verify\+\_\+uninitialized} (void)
\item 
static void \textbf{ main\+\_\+init} (\textbf{ Shell\+State} $\ast$data)
\item 
static void \textbf{ print\+Bold} (const char $\ast$z\+Text)
\item 
static char $\ast$ \textbf{ cmdline\+\_\+option\+\_\+value} (int argc, char $\ast$$\ast$argv, int i)
\item 
int \textbf{ S\+Q\+L\+I\+T\+E\+\_\+\+C\+D\+E\+CL} \textbf{ main} (int argc, char $\ast$$\ast$argv)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static int \textbf{ enable\+Timer} = 0
\item 
static struct rusage \textbf{ s\+Begin}
\item 
static \textbf{ sqlite3\+\_\+int64} \textbf{ i\+Begin}
\item 
static int \textbf{ bail\+\_\+on\+\_\+error} = 0
\item 
static int \textbf{ stdin\+\_\+is\+\_\+interactive} = 1
\item 
static int \textbf{ stdout\+\_\+is\+\_\+console} = 1
\item 
static \textbf{ sqlite3} $\ast$ \textbf{ global\+Db} = 0
\item 
static volatile int \textbf{ seen\+Interrupt} = 0
\item 
static char $\ast$ \textbf{ Argv0}
\item 
static char \textbf{ main\+Prompt} [20]
\item 
static char \textbf{ continue\+Prompt} [20]
\item 
static \textbf{ sqlite3\+\_\+module} \textbf{ completion\+Module}
\item 
static void($\ast$)(void) \textbf{ apnd\+Dl\+Sym} (\textbf{ sqlite3\+\_\+vfs} $\ast$p\+Vfs, void $\ast$p, const char $\ast$z\+Sym)
\item 
static \textbf{ sqlite3\+\_\+vfs} \textbf{ apnd\+\_\+vfs}
\item 
static const \textbf{ sqlite3\+\_\+io\+\_\+methods} \textbf{ apnd\+\_\+io\+\_\+methods}
\item 
static \textbf{ sqlite3\+\_\+mem\+\_\+methods} \textbf{ memtrace\+Base}
\item 
static F\+I\+LE $\ast$ \textbf{ memtrace\+Out}
\item 
static \textbf{ sqlite3\+\_\+mem\+\_\+methods} \textbf{ ersazt\+Methods}
\item 
static const char $\ast$ \textbf{ mode\+Descr} [$\,$]
\item 
static const char \textbf{ need\+Csv\+Quote} [$\,$]
\item 
static const char $\ast$ \textbf{ az\+Help} [$\,$]
\item 
static const char \textbf{ z\+Options} [$\,$]
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\mbox{\label{shell_8c_a44d01ba0a136b8e27ad362f5a823d14e}} 
\index{shell.\+c@{shell.\+c}!\+\_\+\+F\+I\+L\+E\+\_\+\+O\+F\+F\+S\+E\+T\+\_\+\+B\+I\+TS@{\+\_\+\+F\+I\+L\+E\+\_\+\+O\+F\+F\+S\+E\+T\+\_\+\+B\+I\+TS}}
\index{\+\_\+\+F\+I\+L\+E\+\_\+\+O\+F\+F\+S\+E\+T\+\_\+\+B\+I\+TS@{\+\_\+\+F\+I\+L\+E\+\_\+\+O\+F\+F\+S\+E\+T\+\_\+\+B\+I\+TS}!shell.\+c@{shell.\+c}}
\subsubsection{\+\_\+\+F\+I\+L\+E\+\_\+\+O\+F\+F\+S\+E\+T\+\_\+\+B\+I\+TS}
{\footnotesize\ttfamily \#define \+\_\+\+F\+I\+L\+E\+\_\+\+O\+F\+F\+S\+E\+T\+\_\+\+B\+I\+TS~64}



Definition at line 72 of file shell.\+c.

\mbox{\label{shell_8c_a8776ea0e6f826f2b3a962986b3868582}} 
\index{shell.\+c@{shell.\+c}!\+\_\+\+L\+A\+R\+G\+E\+\_\+\+F\+I\+LE@{\+\_\+\+L\+A\+R\+G\+E\+\_\+\+F\+I\+LE}}
\index{\+\_\+\+L\+A\+R\+G\+E\+\_\+\+F\+I\+LE@{\+\_\+\+L\+A\+R\+G\+E\+\_\+\+F\+I\+LE}!shell.\+c@{shell.\+c}}
\subsubsection{\+\_\+\+L\+A\+R\+G\+E\+\_\+\+F\+I\+LE}
{\footnotesize\ttfamily \#define \+\_\+\+L\+A\+R\+G\+E\+\_\+\+F\+I\+LE~1}



Definition at line 70 of file shell.\+c.

\mbox{\label{shell_8c_a0cdbd4d0545340d33dfe595811475ccd}} 
\index{shell.\+c@{shell.\+c}!\+\_\+\+L\+A\+R\+G\+E\+F\+I\+L\+E\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+L\+A\+R\+G\+E\+F\+I\+L\+E\+\_\+\+S\+O\+U\+R\+CE}}
\index{\+\_\+\+L\+A\+R\+G\+E\+F\+I\+L\+E\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+L\+A\+R\+G\+E\+F\+I\+L\+E\+\_\+\+S\+O\+U\+R\+CE}!shell.\+c@{shell.\+c}}
\subsubsection{\+\_\+\+L\+A\+R\+G\+E\+F\+I\+L\+E\+\_\+\+S\+O\+U\+R\+CE}
{\footnotesize\ttfamily \#define \+\_\+\+L\+A\+R\+G\+E\+F\+I\+L\+E\+\_\+\+S\+O\+U\+R\+CE~1}



Definition at line 74 of file shell.\+c.

\mbox{\label{shell_8c_abcdd64614c54a76885587778b89625af}} 
\index{shell.\+c@{shell.\+c}!a00@{a00}}
\index{a00@{a00}!shell.\+c@{shell.\+c}}
\subsubsection{a00}
{\footnotesize\ttfamily \#define a00~(p-\/$>$u.\+s[0])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a87b3cac3f2a50e5f39bcf126e95d26e4}} 
\index{shell.\+c@{shell.\+c}!a01@{a01}}
\index{a01@{a01}!shell.\+c@{shell.\+c}}
\subsubsection{a01}
{\footnotesize\ttfamily \#define a01~(p-\/$>$u.\+s[1])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a60a290e52fbcc01930022a5d4ee0b542}} 
\index{shell.\+c@{shell.\+c}!a02@{a02}}
\index{a02@{a02}!shell.\+c@{shell.\+c}}
\subsubsection{a02}
{\footnotesize\ttfamily \#define a02~(p-\/$>$u.\+s[2])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_abcea3235e61290c7c15d0f72d4ae128e}} 
\index{shell.\+c@{shell.\+c}!a03@{a03}}
\index{a03@{a03}!shell.\+c@{shell.\+c}}
\subsubsection{a03}
{\footnotesize\ttfamily \#define a03~(p-\/$>$u.\+s[3])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a3eee2348f9320e8c457abcef14965308}} 
\index{shell.\+c@{shell.\+c}!a04@{a04}}
\index{a04@{a04}!shell.\+c@{shell.\+c}}
\subsubsection{a04}
{\footnotesize\ttfamily \#define a04~(p-\/$>$u.\+s[4])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_aa0f92f1b1fcdd533d92ea37635751740}} 
\index{shell.\+c@{shell.\+c}!a10@{a10}}
\index{a10@{a10}!shell.\+c@{shell.\+c}}
\subsubsection{a10}
{\footnotesize\ttfamily \#define a10~(p-\/$>$u.\+s[5])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a9d60b7555bdcb35190e37574b7b11a99}} 
\index{shell.\+c@{shell.\+c}!a11@{a11}}
\index{a11@{a11}!shell.\+c@{shell.\+c}}
\subsubsection{a11}
{\footnotesize\ttfamily \#define a11~(p-\/$>$u.\+s[6])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a7c8af197e94c319046aa42aa57d9236c}} 
\index{shell.\+c@{shell.\+c}!a12@{a12}}
\index{a12@{a12}!shell.\+c@{shell.\+c}}
\subsubsection{a12}
{\footnotesize\ttfamily \#define a12~(p-\/$>$u.\+s[7])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a809bbb184ed5e17540c48e924418d287}} 
\index{shell.\+c@{shell.\+c}!a13@{a13}}
\index{a13@{a13}!shell.\+c@{shell.\+c}}
\subsubsection{a13}
{\footnotesize\ttfamily \#define a13~(p-\/$>$u.\+s[8])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a30e0a1609004241e2bab87e975a0a96f}} 
\index{shell.\+c@{shell.\+c}!a14@{a14}}
\index{a14@{a14}!shell.\+c@{shell.\+c}}
\subsubsection{a14}
{\footnotesize\ttfamily \#define a14~(p-\/$>$u.\+s[9])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a240db0cf8f5ed3ab8d18b19ed789fc52}} 
\index{shell.\+c@{shell.\+c}!a20@{a20}}
\index{a20@{a20}!shell.\+c@{shell.\+c}}
\subsubsection{a20}
{\footnotesize\ttfamily \#define a20~(p-\/$>$u.\+s[10])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_ab2beeb03f593e079b37bfe131af6ab3c}} 
\index{shell.\+c@{shell.\+c}!a21@{a21}}
\index{a21@{a21}!shell.\+c@{shell.\+c}}
\subsubsection{a21}
{\footnotesize\ttfamily \#define a21~(p-\/$>$u.\+s[11])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a46920b2a281c18287423d3f9a13577d1}} 
\index{shell.\+c@{shell.\+c}!a22@{a22}}
\index{a22@{a22}!shell.\+c@{shell.\+c}}
\subsubsection{a22}
{\footnotesize\ttfamily \#define a22~(p-\/$>$u.\+s[12])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_afd474c85358352215e0235da39cbc1e6}} 
\index{shell.\+c@{shell.\+c}!a23@{a23}}
\index{a23@{a23}!shell.\+c@{shell.\+c}}
\subsubsection{a23}
{\footnotesize\ttfamily \#define a23~(p-\/$>$u.\+s[13])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a30c7ff68eeef12064fc967863108d0b9}} 
\index{shell.\+c@{shell.\+c}!a24@{a24}}
\index{a24@{a24}!shell.\+c@{shell.\+c}}
\subsubsection{a24}
{\footnotesize\ttfamily \#define a24~(p-\/$>$u.\+s[14])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_aa02b6491041e37d6d2da292c2af86c67}} 
\index{shell.\+c@{shell.\+c}!a30@{a30}}
\index{a30@{a30}!shell.\+c@{shell.\+c}}
\subsubsection{a30}
{\footnotesize\ttfamily \#define a30~(p-\/$>$u.\+s[15])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_ab0888f8eab4990ccae10bc707755c9d4}} 
\index{shell.\+c@{shell.\+c}!a31@{a31}}
\index{a31@{a31}!shell.\+c@{shell.\+c}}
\subsubsection{a31}
{\footnotesize\ttfamily \#define a31~(p-\/$>$u.\+s[16])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a3a2b5ffef4026ac42abfa6f0f9cc1946}} 
\index{shell.\+c@{shell.\+c}!a32@{a32}}
\index{a32@{a32}!shell.\+c@{shell.\+c}}
\subsubsection{a32}
{\footnotesize\ttfamily \#define a32~(p-\/$>$u.\+s[17])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_ad75e236d7040db1ae344408df7652c00}} 
\index{shell.\+c@{shell.\+c}!a33@{a33}}
\index{a33@{a33}!shell.\+c@{shell.\+c}}
\subsubsection{a33}
{\footnotesize\ttfamily \#define a33~(p-\/$>$u.\+s[18])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a671cc0a1ce2292b84347c89315e51d1d}} 
\index{shell.\+c@{shell.\+c}!a34@{a34}}
\index{a34@{a34}!shell.\+c@{shell.\+c}}
\subsubsection{a34}
{\footnotesize\ttfamily \#define a34~(p-\/$>$u.\+s[19])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a6acdf1de6c488914d7454df56f898142}} 
\index{shell.\+c@{shell.\+c}!a40@{a40}}
\index{a40@{a40}!shell.\+c@{shell.\+c}}
\subsubsection{a40}
{\footnotesize\ttfamily \#define a40~(p-\/$>$u.\+s[20])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a88ab0faf4cbc5a0d94c2d3239b6a7d2f}} 
\index{shell.\+c@{shell.\+c}!a41@{a41}}
\index{a41@{a41}!shell.\+c@{shell.\+c}}
\subsubsection{a41}
{\footnotesize\ttfamily \#define a41~(p-\/$>$u.\+s[21])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_a8a54065b72f8c16cc0d30ffc46686250}} 
\index{shell.\+c@{shell.\+c}!a42@{a42}}
\index{a42@{a42}!shell.\+c@{shell.\+c}}
\subsubsection{a42}
{\footnotesize\ttfamily \#define a42~(p-\/$>$u.\+s[22])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_abb8058d80926041f8b13c1a7bd2dcc96}} 
\index{shell.\+c@{shell.\+c}!a43@{a43}}
\index{a43@{a43}!shell.\+c@{shell.\+c}}
\subsubsection{a43}
{\footnotesize\ttfamily \#define a43~(p-\/$>$u.\+s[23])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_abffffc3abcd8431445758d81c056d472}} 
\index{shell.\+c@{shell.\+c}!a44@{a44}}
\index{a44@{a44}!shell.\+c@{shell.\+c}}
\subsubsection{a44}
{\footnotesize\ttfamily \#define a44~(p-\/$>$u.\+s[24])}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_afc19fb79cd6d8b0b8ce048989eaa0912}} 
\index{shell.\+c@{shell.\+c}!A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+IX@{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+IX}}
\index{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+IX@{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+IX}!shell.\+c@{shell.\+c}}
\subsubsection{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+IX}
{\footnotesize\ttfamily \#define A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+IX~\char`\"{}Start-\/Of-\/S\+Q\+Lite3-\/\char`\"{}}



Definition at line 3600 of file shell.\+c.



Referenced by apnd\+Read\+Mark(), and apnd\+Write\+Mark().

\mbox{\label{shell_8c_aa9ebdba98c9f10173c45a7ac1d32dda9}} 
\index{shell.\+c@{shell.\+c}!A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+SZ@{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+SZ}}
\index{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+SZ@{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+SZ}!shell.\+c@{shell.\+c}}
\subsubsection{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+SZ}
{\footnotesize\ttfamily \#define A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+SZ~17}



Definition at line 3601 of file shell.\+c.



Referenced by apnd\+Read\+Mark(), and apnd\+Write\+Mark().

\mbox{\label{shell_8c_aafb6777467a7a590713d4f07917ea1ed}} 
\index{shell.\+c@{shell.\+c}!A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE@{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE}}
\index{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE@{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE}!shell.\+c@{shell.\+c}}
\subsubsection{A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE}
{\footnotesize\ttfamily \#define A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE~25}



Definition at line 3602 of file shell.\+c.



Referenced by apnd\+File\+Size(), apnd\+Read\+Mark(), apnd\+Truncate(), apnd\+Write(), and apnd\+Write\+Mark().

\mbox{\label{shell_8c_a897a14ce2451bce546e33acf220835af}} 
\index{shell.\+c@{shell.\+c}!A\+P\+N\+D\+\_\+\+M\+A\+X\+\_\+\+S\+I\+ZE@{A\+P\+N\+D\+\_\+\+M\+A\+X\+\_\+\+S\+I\+ZE}}
\index{A\+P\+N\+D\+\_\+\+M\+A\+X\+\_\+\+S\+I\+ZE@{A\+P\+N\+D\+\_\+\+M\+A\+X\+\_\+\+S\+I\+ZE}!shell.\+c@{shell.\+c}}
\subsubsection{A\+P\+N\+D\+\_\+\+M\+A\+X\+\_\+\+S\+I\+ZE}
{\footnotesize\ttfamily \#define A\+P\+N\+D\+\_\+\+M\+A\+X\+\_\+\+S\+I\+ZE~(65536$\ast$15259)}



Definition at line 3608 of file shell.\+c.



Referenced by apnd\+Write().

\mbox{\label{shell_8c_a4654592395032f4996615903e6dbc81d}} 
\index{shell.\+c@{shell.\+c}!Array\+Size@{Array\+Size}}
\index{Array\+Size@{Array\+Size}!shell.\+c@{shell.\+c}}
\subsubsection{Array\+Size}
{\footnotesize\ttfamily \#define Array\+Size(\begin{DoxyParamCaption}\item[{}]{\textbf{ X} }\end{DoxyParamCaption})~(int)(sizeof(\textbf{ X})/sizeof(\textbf{ X}[0]))}



Definition at line 385 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), explain\+\_\+data\+\_\+prepare(), integer\+Value(), save\+\_\+err\+\_\+msg(), shell\+\_\+callback(), shell\+\_\+dbinfo\+\_\+command(), and show\+Help().

\mbox{\label{shell_8c_a50442fc9a2fcdcf85d47033c9e19c9b5}} 
\index{shell.\+c@{shell.\+c}!A\+U\+T\+O\+E\+Q\+P\+\_\+full@{A\+U\+T\+O\+E\+Q\+P\+\_\+full}}
\index{A\+U\+T\+O\+E\+Q\+P\+\_\+full@{A\+U\+T\+O\+E\+Q\+P\+\_\+full}!shell.\+c@{shell.\+c}}
\subsubsection{A\+U\+T\+O\+E\+Q\+P\+\_\+full}
{\footnotesize\ttfamily \#define A\+U\+T\+O\+E\+Q\+P\+\_\+full~3           /$\ast$ Show full E\+X\+P\+L\+A\+IN $\ast$/}



Definition at line 9640 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), and shell\+\_\+exec().

\mbox{\label{shell_8c_aad42db4cd8bd5860781db0ab630193d5}} 
\index{shell.\+c@{shell.\+c}!A\+U\+T\+O\+E\+Q\+P\+\_\+off@{A\+U\+T\+O\+E\+Q\+P\+\_\+off}}
\index{A\+U\+T\+O\+E\+Q\+P\+\_\+off@{A\+U\+T\+O\+E\+Q\+P\+\_\+off}!shell.\+c@{shell.\+c}}
\subsubsection{A\+U\+T\+O\+E\+Q\+P\+\_\+off}
{\footnotesize\ttfamily \#define A\+U\+T\+O\+E\+Q\+P\+\_\+off~0           /$\ast$ Automatic E\+X\+P\+L\+A\+IN Q\+U\+E\+RY P\+L\+AN is off $\ast$/}



Definition at line 9637 of file shell.\+c.

\mbox{\label{shell_8c_aaa21e7b4d922d10f6a5516ffce896e65}} 
\index{shell.\+c@{shell.\+c}!A\+U\+T\+O\+E\+Q\+P\+\_\+on@{A\+U\+T\+O\+E\+Q\+P\+\_\+on}}
\index{A\+U\+T\+O\+E\+Q\+P\+\_\+on@{A\+U\+T\+O\+E\+Q\+P\+\_\+on}!shell.\+c@{shell.\+c}}
\subsubsection{A\+U\+T\+O\+E\+Q\+P\+\_\+on}
{\footnotesize\ttfamily \#define A\+U\+T\+O\+E\+Q\+P\+\_\+on~1           /$\ast$ Automatic E\+QP is on $\ast$/}



Definition at line 9638 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and main().

\mbox{\label{shell_8c_a74f14ba1f6fe208c97f722e20a18efa1}} 
\index{shell.\+c@{shell.\+c}!A\+U\+T\+O\+E\+Q\+P\+\_\+trigger@{A\+U\+T\+O\+E\+Q\+P\+\_\+trigger}}
\index{A\+U\+T\+O\+E\+Q\+P\+\_\+trigger@{A\+U\+T\+O\+E\+Q\+P\+\_\+trigger}!shell.\+c@{shell.\+c}}
\subsubsection{A\+U\+T\+O\+E\+Q\+P\+\_\+trigger}
{\footnotesize\ttfamily \#define A\+U\+T\+O\+E\+Q\+P\+\_\+trigger~2           /$\ast$ On and also show plans for triggers $\ast$/}



Definition at line 9639 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and shell\+\_\+exec().

\mbox{\label{shell_8c_aeb561b6eabd96df670450d67c2a9c97d}} 
\index{shell.\+c@{shell.\+c}!B\+E\+G\+I\+N\+\_\+\+T\+I\+M\+ER@{B\+E\+G\+I\+N\+\_\+\+T\+I\+M\+ER}}
\index{B\+E\+G\+I\+N\+\_\+\+T\+I\+M\+ER@{B\+E\+G\+I\+N\+\_\+\+T\+I\+M\+ER}!shell.\+c@{shell.\+c}}
\subsubsection{B\+E\+G\+I\+N\+\_\+\+T\+I\+M\+ER}
{\footnotesize\ttfamily \#define B\+E\+G\+I\+N\+\_\+\+T\+I\+M\+ER~\textbf{ begin\+Timer}()}



Definition at line 290 of file shell.\+c.



Referenced by run\+One\+Sql\+Line().

\mbox{\label{shell_8c_acff8d0ed03bf4d62686e64630f88c9bf}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+L\+A\+T\+I\+O\+NS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+L\+A\+T\+I\+O\+NS}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+L\+A\+T\+I\+O\+NS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+L\+A\+T\+I\+O\+NS}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+L\+A\+T\+I\+O\+NS}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+L\+A\+T\+I\+O\+NS~4}



Definition at line 3111 of file shell.\+c.

\mbox{\label{shell_8c_a8ba2307fef7f946651d2a77c1989b8fb}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+C\+A\+N\+D\+I\+D\+A\+TE@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+C\+A\+N\+D\+I\+D\+A\+TE}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+C\+A\+N\+D\+I\+D\+A\+TE@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+C\+A\+N\+D\+I\+D\+A\+TE}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+C\+A\+N\+D\+I\+D\+A\+TE}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+C\+A\+N\+D\+I\+D\+A\+TE~0  /$\ast$ Suggested completion of the input $\ast$/}



Referenced by completion\+Column().

\mbox{\label{shell_8c_a368af2d26504d8a3e9bc28b5e19ab0f3}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+H\+A\+SE@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+H\+A\+SE}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+H\+A\+SE@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+H\+A\+SE}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+H\+A\+SE}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+H\+A\+SE~3  /$\ast$ e\+Phase -\/ used for debugging only $\ast$/}



Referenced by completion\+Column().

\mbox{\label{shell_8c_a2e8f567dc6d5b59317193c2912e00fc1}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+R\+E\+F\+IX@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+R\+E\+F\+IX}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+R\+E\+F\+IX@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+R\+E\+F\+IX}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+R\+E\+F\+IX}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+R\+E\+F\+IX~1  /$\ast$ Prefix of the word to be completed $\ast$/}



Referenced by completion\+Best\+Index(), and completion\+Column().

\mbox{\label{shell_8c_aa419f82e9943bc58e48b4e064fd05a6c}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+W\+H\+O\+L\+E\+L\+I\+NE@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+W\+H\+O\+L\+E\+L\+I\+NE}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+W\+H\+O\+L\+E\+L\+I\+NE@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+W\+H\+O\+L\+E\+L\+I\+NE}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+W\+H\+O\+L\+E\+L\+I\+NE}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+W\+H\+O\+L\+E\+L\+I\+NE~2  /$\ast$ Entire line seen so far $\ast$/}



Referenced by completion\+Best\+Index(), and completion\+Column().

\mbox{\label{shell_8c_a67c3ba074dcd553c82f15ce08f544ba4}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+NS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+NS}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+NS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+NS}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+NS}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+NS~9}



Definition at line 3116 of file shell.\+c.



Referenced by completion\+Next().

\mbox{\label{shell_8c_a3a0e89aa52e79c2d9aec5fddd13cf653}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+D\+A\+T\+A\+B\+A\+S\+ES@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+D\+A\+T\+A\+B\+A\+S\+ES}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+D\+A\+T\+A\+B\+A\+S\+ES@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+D\+A\+T\+A\+B\+A\+S\+ES}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+D\+A\+T\+A\+B\+A\+S\+ES}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+D\+A\+T\+A\+B\+A\+S\+ES~7}



Definition at line 3114 of file shell.\+c.



Referenced by completion\+Next().

\mbox{\label{shell_8c_acc08c58755cadfa68dd42117c86ad321}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+E\+OF@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+E\+OF}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+E\+OF@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+E\+OF}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+E\+OF}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+E\+OF~11}



Definition at line 3118 of file shell.\+c.



Referenced by completion\+Eof(), and completion\+Next().

\mbox{\label{shell_8c_ac1f1f9c98fbe4eeb9de491f19a027895}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+I\+R\+S\+T\+\_\+\+P\+H\+A\+SE@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+I\+R\+S\+T\+\_\+\+P\+H\+A\+SE}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+I\+R\+S\+T\+\_\+\+P\+H\+A\+SE@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+I\+R\+S\+T\+\_\+\+P\+H\+A\+SE}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+I\+R\+S\+T\+\_\+\+P\+H\+A\+SE}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+I\+R\+S\+T\+\_\+\+P\+H\+A\+SE~1}



Definition at line 3107 of file shell.\+c.



Referenced by completion\+Filter().

\mbox{\label{shell_8c_ad7e21c9856486434cb237a01934153e0}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS~3}



Definition at line 3110 of file shell.\+c.

\mbox{\label{shell_8c_a257111cc3ba3f03adbf1fe8fc15d9aa3}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+I\+N\+D\+E\+X\+ES@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+I\+N\+D\+E\+X\+ES}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+I\+N\+D\+E\+X\+ES@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+I\+N\+D\+E\+X\+ES}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+I\+N\+D\+E\+X\+ES}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+I\+N\+D\+E\+X\+ES~5}



Definition at line 3112 of file shell.\+c.

\mbox{\label{shell_8c_a90c104819cbc8bdeb4dc7b2829b466c1}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+K\+E\+Y\+W\+O\+R\+DS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+K\+E\+Y\+W\+O\+R\+DS}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+K\+E\+Y\+W\+O\+R\+DS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+K\+E\+Y\+W\+O\+R\+DS}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+K\+E\+Y\+W\+O\+R\+DS}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+K\+E\+Y\+W\+O\+R\+DS~1}



Definition at line 3108 of file shell.\+c.



Referenced by completion\+Next().

\mbox{\label{shell_8c_af6babbf0cc20a86b4a2d55c06c853408}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+M\+O\+D\+U\+L\+ES@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+M\+O\+D\+U\+L\+ES}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+M\+O\+D\+U\+L\+ES@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+M\+O\+D\+U\+L\+ES}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+M\+O\+D\+U\+L\+ES}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+M\+O\+D\+U\+L\+ES~10}



Definition at line 3117 of file shell.\+c.

\mbox{\label{shell_8c_a5a496e385320e0540e3e8602e9e2260b}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+P\+R\+A\+G\+M\+AS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+P\+R\+A\+G\+M\+AS}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+P\+R\+A\+G\+M\+AS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+P\+R\+A\+G\+M\+AS}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+P\+R\+A\+G\+M\+AS}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+P\+R\+A\+G\+M\+AS~2}



Definition at line 3109 of file shell.\+c.

\mbox{\label{shell_8c_a94a428b0b885ab94ebda9c74a76c2a3d}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+ES@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+ES}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+ES@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+ES}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+ES}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+ES~8    /$\ast$ Also V\+I\+E\+Ws and T\+R\+I\+G\+G\+E\+Rs $\ast$/}



Definition at line 3115 of file shell.\+c.



Referenced by completion\+Next().

\mbox{\label{shell_8c_a65599ac7e70f049a5df965fb5bcb87ff}} 
\index{shell.\+c@{shell.\+c}!C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+R\+I\+G\+G\+E\+RS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+R\+I\+G\+G\+E\+RS}}
\index{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+R\+I\+G\+G\+E\+RS@{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+R\+I\+G\+G\+E\+RS}!shell.\+c@{shell.\+c}}
\subsubsection{C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+R\+I\+G\+G\+E\+RS}
{\footnotesize\ttfamily \#define C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+R\+I\+G\+G\+E\+RS~6}



Definition at line 3113 of file shell.\+c.

\mbox{\label{shell_8c_a93c9bd8cae0c7b401a651379b10757cc}} 
\index{shell.\+c@{shell.\+c}!C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+AL@{C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+AL}}
\index{C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+AL@{C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+AL}!shell.\+c@{shell.\+c}}
\subsubsection{C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+AL}
{\footnotesize\ttfamily \#define C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+AL(\begin{DoxyParamCaption}\item[{}]{opt }\end{DoxyParamCaption})~\textbf{ C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+A\+L\+\_\+}(opt)}



Referenced by do\+\_\+meta\+\_\+command().

\mbox{\label{shell_8c_a96a6675170d6e10c731e4a9683144847}} 
\index{shell.\+c@{shell.\+c}!C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+A\+L\+\_\+@{C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+A\+L\+\_\+}}
\index{C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+A\+L\+\_\+@{C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+A\+L\+\_\+}!shell.\+c@{shell.\+c}}
\subsubsection{C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+A\+L\+\_\+}
{\footnotesize\ttfamily \#define C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+A\+L\+\_\+(\begin{DoxyParamCaption}\item[{}]{opt }\end{DoxyParamCaption})~\#opt}

\mbox{\label{shell_8c_a58f41cf6b099532590a90bff8b1f7e36}} 
\index{shell.\+c@{shell.\+c}!E\+N\+D\+\_\+\+T\+I\+M\+ER@{E\+N\+D\+\_\+\+T\+I\+M\+ER}}
\index{E\+N\+D\+\_\+\+T\+I\+M\+ER@{E\+N\+D\+\_\+\+T\+I\+M\+ER}!shell.\+c@{shell.\+c}}
\subsubsection{E\+N\+D\+\_\+\+T\+I\+M\+ER}
{\footnotesize\ttfamily \#define E\+N\+D\+\_\+\+T\+I\+M\+ER~\textbf{ end\+Timer}()}



Definition at line 291 of file shell.\+c.



Referenced by run\+One\+Sql\+Line().

\mbox{\label{shell_8c_ac66f204db8033e74c0270c4e26c21e98}} 
\index{shell.\+c@{shell.\+c}!E\+X\+P\+E\+R\+T\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+S\+A\+M\+P\+LE@{E\+X\+P\+E\+R\+T\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+S\+A\+M\+P\+LE}}
\index{E\+X\+P\+E\+R\+T\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+S\+A\+M\+P\+LE@{E\+X\+P\+E\+R\+T\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+S\+A\+M\+P\+LE}!shell.\+c@{shell.\+c}}
\subsubsection{E\+X\+P\+E\+R\+T\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+S\+A\+M\+P\+LE}
{\footnotesize\ttfamily \#define E\+X\+P\+E\+R\+T\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+S\+A\+M\+P\+LE~1    /$\ast$ int $\ast$/}



Definition at line 6595 of file shell.\+c.



Referenced by expert\+Dot\+Command(), and sqlite3\+\_\+expert\+\_\+config().

\mbox{\label{shell_8c_a341675b60e140a2b5b26673eb51de64c}} 
\index{shell.\+c@{shell.\+c}!E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+C\+A\+N\+D\+I\+D\+A\+T\+ES@{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+C\+A\+N\+D\+I\+D\+A\+T\+ES}}
\index{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+C\+A\+N\+D\+I\+D\+A\+T\+ES@{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+C\+A\+N\+D\+I\+D\+A\+T\+ES}!shell.\+c@{shell.\+c}}
\subsubsection{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+C\+A\+N\+D\+I\+D\+A\+T\+ES}
{\footnotesize\ttfamily \#define E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+C\+A\+N\+D\+I\+D\+A\+T\+ES~4}



Definition at line 6694 of file shell.\+c.



Referenced by expert\+Finish(), and sqlite3\+\_\+expert\+\_\+report().

\mbox{\label{shell_8c_ac914a0cd819ebaaacd69904f6e922414}} 
\index{shell.\+c@{shell.\+c}!E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+I\+N\+D\+E\+X\+ES@{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+I\+N\+D\+E\+X\+ES}}
\index{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+I\+N\+D\+E\+X\+ES@{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+I\+N\+D\+E\+X\+ES}!shell.\+c@{shell.\+c}}
\subsubsection{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+I\+N\+D\+E\+X\+ES}
{\footnotesize\ttfamily \#define E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+I\+N\+D\+E\+X\+ES~2}



Definition at line 6692 of file shell.\+c.



Referenced by expert\+Finish(), and sqlite3\+\_\+expert\+\_\+report().

\mbox{\label{shell_8c_a022caed9d0b7a6011d9d626f726222d0}} 
\index{shell.\+c@{shell.\+c}!E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+P\+L\+AN@{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+P\+L\+AN}}
\index{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+P\+L\+AN@{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+P\+L\+AN}!shell.\+c@{shell.\+c}}
\subsubsection{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+P\+L\+AN}
{\footnotesize\ttfamily \#define E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+P\+L\+AN~3}



Definition at line 6693 of file shell.\+c.



Referenced by expert\+Finish(), and sqlite3\+\_\+expert\+\_\+report().

\mbox{\label{shell_8c_a64236e5e66e16526a86643a023c5d3df}} 
\index{shell.\+c@{shell.\+c}!E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+S\+QL@{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+S\+QL}}
\index{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+S\+QL@{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+S\+QL}!shell.\+c@{shell.\+c}}
\subsubsection{E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+S\+QL}
{\footnotesize\ttfamily \#define E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+S\+QL~1}



Definition at line 6691 of file shell.\+c.



Referenced by expert\+Finish(), and sqlite3\+\_\+expert\+\_\+report().

\mbox{\label{shell_8c_a9dab4a62bde89ecd56237bc06ac6a62c}} 
\index{shell.\+c@{shell.\+c}!F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+A\+TA@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+A\+TA}}
\index{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+A\+TA@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+A\+TA}!shell.\+c@{shell.\+c}}
\subsubsection{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+A\+TA}
{\footnotesize\ttfamily \#define F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+A\+TA~3     /$\ast$ File content $\ast$/}



Definition at line 2149 of file shell.\+c.



Referenced by fsdir\+Column().

\mbox{\label{shell_8c_a3ed9a5080989537fa9acb37a1442f7fc}} 
\index{shell.\+c@{shell.\+c}!F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+IR@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+IR}}
\index{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+IR@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+IR}!shell.\+c@{shell.\+c}}
\subsubsection{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+IR}
{\footnotesize\ttfamily \#define F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+IR~5     /$\ast$ Path is relative to this directory $\ast$/}



Definition at line 2151 of file shell.\+c.



Referenced by fsdir\+Best\+Index().

\mbox{\label{shell_8c_aaaa6e4af94833f969c64cbf19b340915}} 
\index{shell.\+c@{shell.\+c}!F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+O\+DE@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+O\+DE}}
\index{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+O\+DE@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+O\+DE}!shell.\+c@{shell.\+c}}
\subsubsection{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+O\+DE}
{\footnotesize\ttfamily \#define F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+O\+DE~1     /$\ast$ Access mode $\ast$/}



Definition at line 2147 of file shell.\+c.



Referenced by fsdir\+Column().

\mbox{\label{shell_8c_a9857bfdd79aab85810616abd38ccd758}} 
\index{shell.\+c@{shell.\+c}!F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+T\+I\+ME@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+T\+I\+ME}}
\index{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+T\+I\+ME@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+T\+I\+ME}!shell.\+c@{shell.\+c}}
\subsubsection{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+T\+I\+ME}
{\footnotesize\ttfamily \#define F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+T\+I\+ME~2     /$\ast$ Last modification time $\ast$/}



Definition at line 2148 of file shell.\+c.



Referenced by fsdir\+Column().

\mbox{\label{shell_8c_addab4f473ecdf074e6784750852066a4}} 
\index{shell.\+c@{shell.\+c}!F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+N\+A\+ME@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+N\+A\+ME}}
\index{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+N\+A\+ME@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+N\+A\+ME}!shell.\+c@{shell.\+c}}
\subsubsection{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+N\+A\+ME}
{\footnotesize\ttfamily \#define F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+N\+A\+ME~0     /$\ast$ Name of the file $\ast$/}



Definition at line 2146 of file shell.\+c.



Referenced by fsdir\+Column().

\mbox{\label{shell_8c_a3446fd7d11604888c5b96e27c7b0fcd9}} 
\index{shell.\+c@{shell.\+c}!F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+A\+TH@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+A\+TH}}
\index{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+A\+TH@{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+A\+TH}!shell.\+c@{shell.\+c}}
\subsubsection{F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+A\+TH}
{\footnotesize\ttfamily \#define F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+A\+TH~4     /$\ast$ Path to top of search $\ast$/}



Definition at line 2150 of file shell.\+c.



Referenced by fsdir\+Best\+Index(), and fsdir\+Column().

\mbox{\label{shell_8c_a425fd0ff50effad5e469aec13296f46d}} 
\index{shell.\+c@{shell.\+c}!F\+S\+D\+I\+R\+\_\+\+S\+C\+H\+E\+MA@{F\+S\+D\+I\+R\+\_\+\+S\+C\+H\+E\+MA}}
\index{F\+S\+D\+I\+R\+\_\+\+S\+C\+H\+E\+MA@{F\+S\+D\+I\+R\+\_\+\+S\+C\+H\+E\+MA}!shell.\+c@{shell.\+c}}
\subsubsection{F\+S\+D\+I\+R\+\_\+\+S\+C\+H\+E\+MA}
{\footnotesize\ttfamily \#define F\+S\+D\+I\+R\+\_\+\+S\+C\+H\+E\+MA~\char`\"{}(name,mode,mtime,data,path H\+I\+D\+D\+EN,dir H\+I\+D\+D\+EN)\char`\"{}}



Definition at line 2145 of file shell.\+c.



Referenced by fsdir\+Connect().

\mbox{\label{shell_8c_a7619c450d37a313aec4406af35c363ac}} 
\index{shell.\+c@{shell.\+c}!G\+E\+T\+P\+ID@{G\+E\+T\+P\+ID}}
\index{G\+E\+T\+P\+ID@{G\+E\+T\+P\+ID}!shell.\+c@{shell.\+c}}
\subsubsection{G\+E\+T\+P\+ID}
{\footnotesize\ttfamily \#define G\+E\+T\+P\+ID~getpid}



Definition at line 100 of file shell.\+c.



Referenced by main().

\mbox{\label{shell_8c_a492513c85e12ae5f4901790665a0c3ab}} 
\index{shell.\+c@{shell.\+c}!H\+A\+S\+\_\+\+T\+I\+M\+ER@{H\+A\+S\+\_\+\+T\+I\+M\+ER}}
\index{H\+A\+S\+\_\+\+T\+I\+M\+ER@{H\+A\+S\+\_\+\+T\+I\+M\+ER}!shell.\+c@{shell.\+c}}
\subsubsection{H\+A\+S\+\_\+\+T\+I\+M\+ER}
{\footnotesize\ttfamily \#define H\+A\+S\+\_\+\+T\+I\+M\+ER~1}



Definition at line 292 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command().

\mbox{\label{shell_8c_a6bdcdbc303f556b7c59c1828778bca73}} 
\index{shell.\+c@{shell.\+c}!I\+D\+X\+\_\+\+H\+A\+S\+H\+\_\+\+S\+I\+ZE@{I\+D\+X\+\_\+\+H\+A\+S\+H\+\_\+\+S\+I\+ZE}}
\index{I\+D\+X\+\_\+\+H\+A\+S\+H\+\_\+\+S\+I\+ZE@{I\+D\+X\+\_\+\+H\+A\+S\+H\+\_\+\+S\+I\+ZE}!shell.\+c@{shell.\+c}}
\subsubsection{I\+D\+X\+\_\+\+H\+A\+S\+H\+\_\+\+S\+I\+ZE}
{\footnotesize\ttfamily \#define I\+D\+X\+\_\+\+H\+A\+S\+H\+\_\+\+S\+I\+ZE~1023}



Definition at line 6825 of file shell.\+c.



Referenced by idx\+Hash\+Clear(), and idx\+Hash\+String().

\mbox{\label{shell_8c_af999dd7bfc5e1f15156fbf37db231280}} 
\index{shell.\+c@{shell.\+c}!Is\+Digit@{Is\+Digit}}
\index{Is\+Digit@{Is\+Digit}!shell.\+c@{shell.\+c}}
\subsubsection{Is\+Digit}
{\footnotesize\ttfamily \#define Is\+Digit(\begin{DoxyParamCaption}\item[{}]{\textbf{ X} }\end{DoxyParamCaption})~isdigit((unsigned char)\textbf{ X})}



Definition at line 190 of file shell.\+c.



Referenced by integer\+Value(), is\+Number(), and testcase\+\_\+glob().

\mbox{\label{shell_8c_a129f518968e591c737a7bd5c366ae77e}} 
\index{shell.\+c@{shell.\+c}!Is\+Space@{Is\+Space}}
\index{Is\+Space@{Is\+Space}!shell.\+c@{shell.\+c}}
\subsubsection{Is\+Space}
{\footnotesize\ttfamily \#define Is\+Space(\begin{DoxyParamCaption}\item[{}]{\textbf{ X} }\end{DoxyParamCaption})~isspace((unsigned char)\textbf{ X})}



Definition at line 189 of file shell.\+c.



Referenced by \+\_\+all\+\_\+whitespace(), do\+\_\+meta\+\_\+command(), line\+\_\+is\+\_\+command\+\_\+terminator(), process\+\_\+input(), shell\+\_\+callback(), shell\+\_\+exec(), testcase\+\_\+glob(), and ws\+To\+Eol().

\mbox{\label{shell_8c_aee30eac804e14afcb1a674fbb86a3069}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+Ascii@{M\+O\+D\+E\+\_\+\+Ascii}}
\index{M\+O\+D\+E\+\_\+\+Ascii@{M\+O\+D\+E\+\_\+\+Ascii}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+Ascii}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+Ascii~10  /$\ast$ Use A\+S\+C\+II unit and record separators (0x1\+F/0x1\+E) $\ast$/}



Definition at line 9696 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), and shell\+\_\+callback().

\mbox{\label{shell_8c_aa4deb50ceb88ff6c8e442a2cf5b6ea9f}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+Column@{M\+O\+D\+E\+\_\+\+Column}}
\index{M\+O\+D\+E\+\_\+\+Column@{M\+O\+D\+E\+\_\+\+Column}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+Column}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+Column~1  /$\ast$ One record per line in neat columns $\ast$/}



Definition at line 9687 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), and shell\+\_\+callback().

\mbox{\label{shell_8c_aabd0c82a272b1102d6166fffcd3e47ed}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+Csv@{M\+O\+D\+E\+\_\+\+Csv}}
\index{M\+O\+D\+E\+\_\+\+Csv@{M\+O\+D\+E\+\_\+\+Csv}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+Csv}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+Csv~8  /$\ast$ Quote strings, numbers are plain $\ast$/}



Definition at line 9694 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), and shell\+\_\+callback().

\mbox{\label{shell_8c_a345bcd06659ab17e7ea6e3fbe2958871}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+E\+QP@{M\+O\+D\+E\+\_\+\+E\+QP}}
\index{M\+O\+D\+E\+\_\+\+E\+QP@{M\+O\+D\+E\+\_\+\+E\+QP}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+E\+QP}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+E\+QP~12  /$\ast$ Converts E\+X\+P\+L\+A\+IN Q\+U\+E\+RY P\+L\+AN output into a graph $\ast$/}



Definition at line 9698 of file shell.\+c.



Referenced by shell\+\_\+callback(), and shell\+\_\+exec().

\mbox{\label{shell_8c_a19ccb86edba8b6a7fb4b37c2c8d79e56}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+Explain@{M\+O\+D\+E\+\_\+\+Explain}}
\index{M\+O\+D\+E\+\_\+\+Explain@{M\+O\+D\+E\+\_\+\+Explain}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+Explain}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+Explain~9  /$\ast$ Like \textbf{ M\+O\+D\+E\+\_\+\+Column}, but do not truncate data $\ast$/}



Definition at line 9695 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), shell\+\_\+callback(), and shell\+\_\+exec().

\mbox{\label{shell_8c_a29ff864d82f3ff664b5431cd6b976d8f}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+Html@{M\+O\+D\+E\+\_\+\+Html}}
\index{M\+O\+D\+E\+\_\+\+Html@{M\+O\+D\+E\+\_\+\+Html}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+Html}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+Html~4  /$\ast$ Generate an X\+H\+T\+ML table $\ast$/}



Definition at line 9690 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), and shell\+\_\+callback().

\mbox{\label{shell_8c_a3d8396db61d71ae98f659d572c71b14e}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+Insert@{M\+O\+D\+E\+\_\+\+Insert}}
\index{M\+O\+D\+E\+\_\+\+Insert@{M\+O\+D\+E\+\_\+\+Insert}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+Insert}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+Insert~5  /$\ast$ Generate S\+QL \char`\"{}insert\char`\"{} statements $\ast$/}



Definition at line 9691 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), dump\+\_\+callback(), exec\+\_\+prepared\+\_\+stmt(), and shell\+\_\+callback().

\mbox{\label{shell_8c_a263016a113c6ae9360a9ec52e30144fe}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+Line@{M\+O\+D\+E\+\_\+\+Line}}
\index{M\+O\+D\+E\+\_\+\+Line@{M\+O\+D\+E\+\_\+\+Line}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+Line}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+Line~0  /$\ast$ One column per line.  Blank line between records $\ast$/}



Definition at line 9686 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), and shell\+\_\+callback().

\mbox{\label{shell_8c_a7ce872b14f83e2069adc18e0e2de9dfd}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+List@{M\+O\+D\+E\+\_\+\+List}}
\index{M\+O\+D\+E\+\_\+\+List@{M\+O\+D\+E\+\_\+\+List}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+List}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+List~2  /$\ast$ One record per line with a separator $\ast$/}



Definition at line 9688 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), main\+\_\+init(), and shell\+\_\+callback().

\mbox{\label{shell_8c_ace4dc32eaf0784d060406d34d447e232}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+Pretty@{M\+O\+D\+E\+\_\+\+Pretty}}
\index{M\+O\+D\+E\+\_\+\+Pretty@{M\+O\+D\+E\+\_\+\+Pretty}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+Pretty}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+Pretty~11  /$\ast$ Pretty-\/print schemas $\ast$/}



Definition at line 9697 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and shell\+\_\+callback().

\mbox{\label{shell_8c_a0c1e1fe64eb39e35eeff7605fbb7ce52}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+Quote@{M\+O\+D\+E\+\_\+\+Quote}}
\index{M\+O\+D\+E\+\_\+\+Quote@{M\+O\+D\+E\+\_\+\+Quote}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+Quote}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+Quote~6  /$\ast$ Quote values as for S\+QL $\ast$/}



Definition at line 9692 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), and shell\+\_\+callback().

\mbox{\label{shell_8c_aedee758a7111dcfc0df31798aa596f00}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+Semi@{M\+O\+D\+E\+\_\+\+Semi}}
\index{M\+O\+D\+E\+\_\+\+Semi@{M\+O\+D\+E\+\_\+\+Semi}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+Semi}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+Semi~3  /$\ast$ Same as \textbf{ M\+O\+D\+E\+\_\+\+List} but append \char`\"{};\char`\"{} to each line $\ast$/}



Definition at line 9689 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and shell\+\_\+callback().

\mbox{\label{shell_8c_ac9de07a61fbe0481195d8c27e46750e0}} 
\index{shell.\+c@{shell.\+c}!M\+O\+D\+E\+\_\+\+Tcl@{M\+O\+D\+E\+\_\+\+Tcl}}
\index{M\+O\+D\+E\+\_\+\+Tcl@{M\+O\+D\+E\+\_\+\+Tcl}!shell.\+c@{shell.\+c}}
\subsubsection{M\+O\+D\+E\+\_\+\+Tcl}
{\footnotesize\ttfamily \#define M\+O\+D\+E\+\_\+\+Tcl~7  /$\ast$ Generate A\+N\+SI-\/C or T\+CL quoted elements $\ast$/}



Definition at line 9693 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and shell\+\_\+callback().

\mbox{\label{shell_8c_a6a14b0ad1f09a6728f098d1930d5eb5d}} 
\index{shell.\+c@{shell.\+c}!O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+K\+E\+E\+P\+A\+L\+I\+VE@{O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+K\+E\+E\+P\+A\+L\+I\+VE}}
\index{O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+K\+E\+E\+P\+A\+L\+I\+VE@{O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+K\+E\+E\+P\+A\+L\+I\+VE}!shell.\+c@{shell.\+c}}
\subsubsection{O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+K\+E\+E\+P\+A\+L\+I\+VE}
{\footnotesize\ttfamily \#define O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+K\+E\+E\+P\+A\+L\+I\+VE~0x001   /$\ast$ Return after error if true $\ast$/}



Definition at line 12680 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and open\+\_\+db().

\mbox{\label{shell_8c_a87408c0d8b2ed2fd0b23ea8cf686f6b3}} 
\index{shell.\+c@{shell.\+c}!O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+Z\+I\+P\+F\+I\+LE@{O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+Z\+I\+P\+F\+I\+LE}}
\index{O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+Z\+I\+P\+F\+I\+LE@{O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+Z\+I\+P\+F\+I\+LE}!shell.\+c@{shell.\+c}}
\subsubsection{O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+Z\+I\+P\+F\+I\+LE}
{\footnotesize\ttfamily \#define O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+Z\+I\+P\+F\+I\+LE~0x002   /$\ast$ Open as Z\+I\+P if name matches $\ast$.\+zip $\ast$/}



Definition at line 12681 of file shell.\+c.



Referenced by main(), and open\+\_\+db().

\mbox{\label{shell_8c_ae57bb535b611932adad5731bd52e812d}} 
\index{shell.\+c@{shell.\+c}!O\+R\+I\+G\+F\+I\+LE@{O\+R\+I\+G\+F\+I\+LE}}
\index{O\+R\+I\+G\+F\+I\+LE@{O\+R\+I\+G\+F\+I\+LE}!shell.\+c@{shell.\+c}}
\subsubsection{O\+R\+I\+G\+F\+I\+LE}
{\footnotesize\ttfamily \#define O\+R\+I\+G\+F\+I\+LE(\begin{DoxyParamCaption}\item[{}]{p }\end{DoxyParamCaption})~((\textbf{ sqlite3\+\_\+file}$\ast$)(((\textbf{ Apnd\+File}$\ast$)(p))+1))}



Definition at line 3620 of file shell.\+c.



Referenced by apnd\+Check\+Reserved\+Lock(), apnd\+Close(), apnd\+Device\+Characteristics(), apnd\+Fetch(), apnd\+File\+Control(), apnd\+File\+Size(), apnd\+Lock(), apnd\+Open(), apnd\+Read(), apnd\+Sector\+Size(), apnd\+Shm\+Barrier(), apnd\+Shm\+Lock(), apnd\+Shm\+Map(), apnd\+Shm\+Unmap(), apnd\+Sync(), apnd\+Truncate(), apnd\+Unfetch(), apnd\+Unlock(), and apnd\+Write().

\mbox{\label{shell_8c_a2a8c708ea860e8516b8c3332c22d9357}} 
\index{shell.\+c@{shell.\+c}!O\+R\+I\+G\+V\+FS@{O\+R\+I\+G\+V\+FS}}
\index{O\+R\+I\+G\+V\+FS@{O\+R\+I\+G\+V\+FS}!shell.\+c@{shell.\+c}}
\subsubsection{O\+R\+I\+G\+V\+FS}
{\footnotesize\ttfamily \#define O\+R\+I\+G\+V\+FS(\begin{DoxyParamCaption}\item[{}]{p }\end{DoxyParamCaption})~((\textbf{ sqlite3\+\_\+vfs}$\ast$)((p)-\/$>$p\+App\+Data))}



Definition at line 3619 of file shell.\+c.



Referenced by apnd\+Access(), apnd\+Current\+Time(), apnd\+Current\+Time\+Int64(), apnd\+Delete(), apnd\+Dl\+Close(), apnd\+Dl\+Error(), apnd\+Dl\+Open(), apnd\+Full\+Pathname(), apnd\+Get\+Last\+Error(), apnd\+Get\+System\+Call(), apnd\+Next\+System\+Call(), apnd\+Open(), apnd\+Randomness(), apnd\+Set\+System\+Call(), apnd\+Sleep(), and sqlite3\+\_\+os\+\_\+end().

\mbox{\label{shell_8c_a7d5f050ead833d889dcd77bb9b6768c6}} 
\index{shell.\+c@{shell.\+c}!raw\+\_\+printf@{raw\+\_\+printf}}
\index{raw\+\_\+printf@{raw\+\_\+printf}!shell.\+c@{shell.\+c}}
\subsubsection{raw\+\_\+printf}
{\footnotesize\ttfamily \#define raw\+\_\+printf~fprintf}



Definition at line 460 of file shell.\+c.



Referenced by display\+\_\+scanstats(), display\+\_\+stats(), display\+Stat\+Line(), do\+\_\+meta\+\_\+command(), dump\+\_\+callback(), expert\+Dot\+Command(), expert\+Finish(), lint\+Dot\+Command(), lint\+Fkey\+Indexes(), main(), new\+Temp\+File(), output\+\_\+c\+\_\+string(), output\+\_\+hex\+\_\+blob(), output\+\_\+html\+\_\+string(), output\+\_\+quoted\+\_\+escaped\+\_\+string(), output\+\_\+quoted\+\_\+string(), process\+\_\+sqliterc(), progress\+\_\+handler(), run\+\_\+schema\+\_\+dump\+\_\+query(), run\+\_\+table\+\_\+dump\+\_\+query(), run\+One\+Sql\+Line(), shell\+\_\+callback(), shell\+\_\+dbinfo\+\_\+command(), shell\+\_\+out\+\_\+of\+\_\+memory(), shell\+Auth(), shell\+Finalize(), shell\+Prepare(), shell\+Reset(), and usage().

\mbox{\label{shell_8c_aa6536b1f198fac5ccd4e3f1a33db7083}} 
\index{shell.\+c@{shell.\+c}!R\+O\+L64@{R\+O\+L64}}
\index{R\+O\+L64@{R\+O\+L64}!shell.\+c@{shell.\+c}}
\subsubsection{R\+O\+L64}
{\footnotesize\ttfamily \#define R\+O\+L64(\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{x }\end{DoxyParamCaption})~((a$<$$<$x)$\vert$(a$>$$>$(64-\/x)))}



Referenced by Keccak\+F1600\+Step().

\mbox{\label{shell_8c_ae5958194097823abcaf38c3a9ae69eac}} 
\index{shell.\+c@{shell.\+c}!S\+E\+P\+\_\+\+Column@{S\+E\+P\+\_\+\+Column}}
\index{S\+E\+P\+\_\+\+Column@{S\+E\+P\+\_\+\+Column}!shell.\+c@{shell.\+c}}
\subsubsection{S\+E\+P\+\_\+\+Column}
{\footnotesize\ttfamily \#define S\+E\+P\+\_\+\+Column~\char`\"{}$\vert$\char`\"{}}



Definition at line 9720 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and main\+\_\+init().

\mbox{\label{shell_8c_a24436636aeb26425739a487e99cce5de}} 
\index{shell.\+c@{shell.\+c}!S\+E\+P\+\_\+\+Comma@{S\+E\+P\+\_\+\+Comma}}
\index{S\+E\+P\+\_\+\+Comma@{S\+E\+P\+\_\+\+Comma}!shell.\+c@{shell.\+c}}
\subsubsection{S\+E\+P\+\_\+\+Comma}
{\footnotesize\ttfamily \#define S\+E\+P\+\_\+\+Comma~\char`\"{},\char`\"{}}



Definition at line 9724 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command().

\mbox{\label{shell_8c_ad9ef28878691c4e7b8a995eb22cd197b}} 
\index{shell.\+c@{shell.\+c}!S\+E\+P\+\_\+\+Cr\+Lf@{S\+E\+P\+\_\+\+Cr\+Lf}}
\index{S\+E\+P\+\_\+\+Cr\+Lf@{S\+E\+P\+\_\+\+Cr\+Lf}!shell.\+c@{shell.\+c}}
\subsubsection{S\+E\+P\+\_\+\+Cr\+Lf}
{\footnotesize\ttfamily \#define S\+E\+P\+\_\+\+Cr\+Lf~\char`\"{}\textbackslash{}r\textbackslash{}n\char`\"{}}



Definition at line 9725 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command().

\mbox{\label{shell_8c_a6f2ec1764d3ebd8e09b108e6c5ea63ad}} 
\index{shell.\+c@{shell.\+c}!S\+E\+P\+\_\+\+Record@{S\+E\+P\+\_\+\+Record}}
\index{S\+E\+P\+\_\+\+Record@{S\+E\+P\+\_\+\+Record}!shell.\+c@{shell.\+c}}
\subsubsection{S\+E\+P\+\_\+\+Record}
{\footnotesize\ttfamily \#define S\+E\+P\+\_\+\+Record~\char`\"{}\textbackslash{}x1E\char`\"{}}



Definition at line 9727 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and main().

\mbox{\label{shell_8c_a066c210a01388b50e6b104c2d5f03c8a}} 
\index{shell.\+c@{shell.\+c}!S\+E\+P\+\_\+\+Row@{S\+E\+P\+\_\+\+Row}}
\index{S\+E\+P\+\_\+\+Row@{S\+E\+P\+\_\+\+Row}!shell.\+c@{shell.\+c}}
\subsubsection{S\+E\+P\+\_\+\+Row}
{\footnotesize\ttfamily \#define S\+E\+P\+\_\+\+Row~\char`\"{}\textbackslash{}n\char`\"{}}



Definition at line 9721 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main\+\_\+init(), and shell\+\_\+callback().

\mbox{\label{shell_8c_acb5d341353dbb9653aeedbcf742171f6}} 
\index{shell.\+c@{shell.\+c}!S\+E\+P\+\_\+\+Space@{S\+E\+P\+\_\+\+Space}}
\index{S\+E\+P\+\_\+\+Space@{S\+E\+P\+\_\+\+Space}!shell.\+c@{shell.\+c}}
\subsubsection{S\+E\+P\+\_\+\+Space}
{\footnotesize\ttfamily \#define S\+E\+P\+\_\+\+Space~\char`\"{} \char`\"{}}



Definition at line 9723 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command().

\mbox{\label{shell_8c_a4448820d17bd2a270cb4d3f4c82acc6d}} 
\index{shell.\+c@{shell.\+c}!S\+E\+P\+\_\+\+Tab@{S\+E\+P\+\_\+\+Tab}}
\index{S\+E\+P\+\_\+\+Tab@{S\+E\+P\+\_\+\+Tab}!shell.\+c@{shell.\+c}}
\subsubsection{S\+E\+P\+\_\+\+Tab}
{\footnotesize\ttfamily \#define S\+E\+P\+\_\+\+Tab~\char`\"{}\textbackslash{}t\char`\"{}}



Definition at line 9722 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command().

\mbox{\label{shell_8c_ab21d7aa322871f6754020397084fc2f3}} 
\index{shell.\+c@{shell.\+c}!S\+E\+P\+\_\+\+Unit@{S\+E\+P\+\_\+\+Unit}}
\index{S\+E\+P\+\_\+\+Unit@{S\+E\+P\+\_\+\+Unit}!shell.\+c@{shell.\+c}}
\subsubsection{S\+E\+P\+\_\+\+Unit}
{\footnotesize\ttfamily \#define S\+E\+P\+\_\+\+Unit~\char`\"{}\textbackslash{}x1F\char`\"{}}



Definition at line 9726 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and main().

\mbox{\label{shell_8c_af2f6efd736a2a645cc5bf5b09b1b13b5}} 
\index{shell.\+c@{shell.\+c}!session\+\_\+close\+\_\+all@{session\+\_\+close\+\_\+all}}
\index{session\+\_\+close\+\_\+all@{session\+\_\+close\+\_\+all}!shell.\+c@{shell.\+c}}
\subsubsection{session\+\_\+close\+\_\+all}
{\footnotesize\ttfamily \#define session\+\_\+close\+\_\+all(\begin{DoxyParamCaption}\item[{}]{\textbf{ X} }\end{DoxyParamCaption})}



Definition at line 12379 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), and read\+File().

\mbox{\label{shell_8c_a00c59736db9d6e5bc8c67c93593b9b99}} 
\index{shell.\+c@{shell.\+c}!set\+Binary\+Mode@{set\+Binary\+Mode}}
\index{set\+Binary\+Mode@{set\+Binary\+Mode}!shell.\+c@{shell.\+c}}
\subsubsection{set\+Binary\+Mode}
{\footnotesize\ttfamily \#define set\+Binary\+Mode(\begin{DoxyParamCaption}\item[{}]{\textbf{ X},  }\item[{}]{Y }\end{DoxyParamCaption})}



Definition at line 219 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), output\+\_\+quoted\+\_\+escaped\+\_\+string(), output\+\_\+quoted\+\_\+string(), and shell\+\_\+callback().

\mbox{\label{shell_8c_a5e00a80e507c8ba1bdbd250630cf08f1}} 
\index{shell.\+c@{shell.\+c}!set\+Text\+Mode@{set\+Text\+Mode}}
\index{set\+Text\+Mode@{set\+Text\+Mode}!shell.\+c@{shell.\+c}}
\subsubsection{set\+Text\+Mode}
{\footnotesize\ttfamily \#define set\+Text\+Mode(\begin{DoxyParamCaption}\item[{}]{\textbf{ X},  }\item[{}]{Y }\end{DoxyParamCaption})}



Definition at line 220 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), output\+\_\+quoted\+\_\+escaped\+\_\+string(), output\+\_\+quoted\+\_\+string(), and shell\+\_\+callback().

\mbox{\label{shell_8c_a2f48bd1fc145b5de026236beed803192}} 
\index{shell.\+c@{shell.\+c}!S\+H\+A3\+\_\+\+B\+Y\+T\+E\+O\+R\+D\+ER@{S\+H\+A3\+\_\+\+B\+Y\+T\+E\+O\+R\+D\+ER}}
\index{S\+H\+A3\+\_\+\+B\+Y\+T\+E\+O\+R\+D\+ER@{S\+H\+A3\+\_\+\+B\+Y\+T\+E\+O\+R\+D\+ER}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+A3\+\_\+\+B\+Y\+T\+E\+O\+R\+D\+ER}
{\footnotesize\ttfamily \#define S\+H\+A3\+\_\+\+B\+Y\+T\+E\+O\+R\+D\+ER~0}



Definition at line 1368 of file shell.\+c.

\mbox{\label{shell_8c_a36c32e17a959753e557f7cdf2b2bc08f}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS}}
\index{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS~2      /$\ast$ Use appendvfs $\ast$/}



Definition at line 9646 of file shell.\+c.



Referenced by deduce\+Database\+Type(), do\+\_\+meta\+\_\+command(), main(), open\+\_\+db(), and shell\+Reset().

\mbox{\label{shell_8c_a76172bd591cf9ec37b0a20ae2925fa08}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+ZE@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+ZE}}
\index{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+ZE@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+ZE}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+ZE}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+ZE~5      /$\ast$ Open using \textbf{ sqlite3\+\_\+deserialize}() $\ast$/}



Definition at line 9649 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), and open\+\_\+db().

\mbox{\label{shell_8c_a560b36c61237d0ad5e1b9b69e0ca4d58}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+H\+E\+X\+DB@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+H\+E\+X\+DB}}
\index{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+H\+E\+X\+DB@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+H\+E\+X\+DB}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+H\+E\+X\+DB}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+H\+E\+X\+DB~6      /$\ast$ Use \char`\"{}dbtotxt\char`\"{} output as data source $\ast$/}



Definition at line 9650 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and open\+\_\+db().

\mbox{\label{shell_8c_adfc88c60db902759fb0ea7121ab82fa1}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+N\+O\+R\+M\+AL@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+N\+O\+R\+M\+AL}}
\index{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+N\+O\+R\+M\+AL@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+N\+O\+R\+M\+AL}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+N\+O\+R\+M\+AL}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+N\+O\+R\+M\+AL~1      /$\ast$ Normal database file $\ast$/}



Definition at line 9645 of file shell.\+c.



Referenced by deduce\+Database\+Type(), and open\+\_\+db().

\mbox{\label{shell_8c_a8dda59719a3fd1891098a8d89737164a}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY}}
\index{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY~4      /$\ast$ Open a normal database read-\/only $\ast$/}



Definition at line 9648 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), and open\+\_\+db().

\mbox{\label{shell_8c_a75c6b2f901fb36ea2d70bfbcf922392b}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+U\+N\+S\+P\+EC@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+U\+N\+S\+P\+EC}}
\index{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+U\+N\+S\+P\+EC@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+U\+N\+S\+P\+EC}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+U\+N\+S\+P\+EC}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+U\+N\+S\+P\+EC~0      /$\ast$ No open-\/mode specified $\ast$/}



Definition at line 9644 of file shell.\+c.



Referenced by deduce\+Database\+Type(), do\+\_\+meta\+\_\+command(), open\+\_\+db(), and shell\+Reset().

\mbox{\label{shell_8c_ae51983a0064abd7b97af8b806704149f}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE}}
\index{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE@{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE~3      /$\ast$ Use the zipfile virtual table $\ast$/}



Definition at line 9647 of file shell.\+c.



Referenced by deduce\+Database\+Type(), do\+\_\+meta\+\_\+command(), main(), open\+\_\+db(), and shell\+Reset().

\mbox{\label{shell_8c_aeb118a430d6b4754f7f375c351289ba7}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+O\+N\+CE@{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+O\+N\+CE}}
\index{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+O\+N\+CE@{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+O\+N\+CE}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+O\+N\+CE}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+O\+N\+CE~0x04  /$\ast$ Cancel the -\/-\/limit after firing once $\ast$/}



Definition at line 9663 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and progress\+\_\+handler().

\mbox{\label{shell_8c_a45dd80658588b5a4618592a8836ead31}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+Q\+U\+I\+ET@{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+Q\+U\+I\+ET}}
\index{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+Q\+U\+I\+ET@{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+Q\+U\+I\+ET}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+Q\+U\+I\+ET}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+Q\+U\+I\+ET~0x01  /$\ast$ Omit announcing every progress callback $\ast$/}



Definition at line 9659 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and progress\+\_\+handler().

\mbox{\label{shell_8c_ad31d2fdfaf952ae6f286cd04a1c274df}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+R\+E\+S\+ET@{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+R\+E\+S\+ET}}
\index{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+R\+E\+S\+ET@{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+R\+E\+S\+ET}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+R\+E\+S\+ET}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+R\+E\+S\+ET}

{\bfseries Value\+:}
\begin{DoxyCode}
0x02  \textcolor{comment}{/* Reset the count when the progres}
\textcolor{comment}{                                   ** callback limit is reached, and for each}
\textcolor{comment}{                                   ** top-level SQL statement */}
\end{DoxyCode}


Definition at line 9660 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), progress\+\_\+handler(), and run\+One\+Sql\+Line().

\mbox{\label{shell_8c_af62606806fc404e5ee286dcac9c392bd}} 
\index{shell.\+c@{shell.\+c}!shell\+\_\+read\+\_\+history@{shell\+\_\+read\+\_\+history}}
\index{shell\+\_\+read\+\_\+history@{shell\+\_\+read\+\_\+history}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+\_\+read\+\_\+history}
{\footnotesize\ttfamily \#define shell\+\_\+read\+\_\+history(\begin{DoxyParamCaption}\item[{}]{\textbf{ X} }\end{DoxyParamCaption})}



Definition at line 141 of file shell.\+c.



Referenced by main().

\mbox{\label{shell_8c_a82db48497f37d4c794fa2fa88a303f34}} 
\index{shell.\+c@{shell.\+c}!shell\+\_\+stifle\+\_\+history@{shell\+\_\+stifle\+\_\+history}}
\index{shell\+\_\+stifle\+\_\+history@{shell\+\_\+stifle\+\_\+history}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+\_\+stifle\+\_\+history}
{\footnotesize\ttfamily \#define shell\+\_\+stifle\+\_\+history(\begin{DoxyParamCaption}\item[{}]{\textbf{ X} }\end{DoxyParamCaption})}



Definition at line 143 of file shell.\+c.



Referenced by main().

\mbox{\label{shell_8c_a7a242a2ed7662ae319c182b50bcc051c}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+E\+X\+P\+A\+N\+D\+ED@{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+E\+X\+P\+A\+N\+D\+ED}}
\index{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+E\+X\+P\+A\+N\+D\+ED@{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+E\+X\+P\+A\+N\+D\+ED}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+E\+X\+P\+A\+N\+D\+ED}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+E\+X\+P\+A\+N\+D\+ED~1      /$\ast$ Show expanded S\+QL text $\ast$/}



Definition at line 9655 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and sql\+\_\+trace\+\_\+callback().

\mbox{\label{shell_8c_a44e38d2428c9e79813acb3982a72ae45}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+ED@{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+ED}}
\index{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+ED@{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+ED}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+ED}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+ED~2      /$\ast$ Show normalized S\+QL text $\ast$/}



Definition at line 9656 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and sql\+\_\+trace\+\_\+callback().

\mbox{\label{shell_8c_a4403d6ba0257639e4ea73481b60d8f14}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+P\+L\+A\+IN@{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+P\+L\+A\+IN}}
\index{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+P\+L\+A\+IN@{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+P\+L\+A\+IN}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+P\+L\+A\+IN}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+P\+L\+A\+IN~0      /$\ast$ Show input S\+QL text $\ast$/}



Definition at line 9654 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command().

\mbox{\label{shell_8c_ac01af6a1e061a1f7a355457173864479}} 
\index{shell.\+c@{shell.\+c}!S\+H\+E\+L\+L\+\_\+\+U\+S\+E\+\_\+\+L\+O\+C\+A\+L\+\_\+\+G\+E\+T\+L\+I\+NE@{S\+H\+E\+L\+L\+\_\+\+U\+S\+E\+\_\+\+L\+O\+C\+A\+L\+\_\+\+G\+E\+T\+L\+I\+NE}}
\index{S\+H\+E\+L\+L\+\_\+\+U\+S\+E\+\_\+\+L\+O\+C\+A\+L\+\_\+\+G\+E\+T\+L\+I\+NE@{S\+H\+E\+L\+L\+\_\+\+U\+S\+E\+\_\+\+L\+O\+C\+A\+L\+\_\+\+G\+E\+T\+L\+I\+NE}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+E\+L\+L\+\_\+\+U\+S\+E\+\_\+\+L\+O\+C\+A\+L\+\_\+\+G\+E\+T\+L\+I\+NE}
{\footnotesize\ttfamily \#define S\+H\+E\+L\+L\+\_\+\+U\+S\+E\+\_\+\+L\+O\+C\+A\+L\+\_\+\+G\+E\+T\+L\+I\+NE~1}



Definition at line 145 of file shell.\+c.

\mbox{\label{shell_8c_a9895a7b8426327c30eaa91633f993c95}} 
\index{shell.\+c@{shell.\+c}!shell\+\_\+write\+\_\+history@{shell\+\_\+write\+\_\+history}}
\index{shell\+\_\+write\+\_\+history@{shell\+\_\+write\+\_\+history}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+\_\+write\+\_\+history}
{\footnotesize\ttfamily \#define shell\+\_\+write\+\_\+history(\begin{DoxyParamCaption}\item[{}]{\textbf{ X} }\end{DoxyParamCaption})}



Definition at line 142 of file shell.\+c.



Referenced by main().

\mbox{\label{shell_8c_a76afee2ec48c101a5b4ff00fa59c2fa0}} 
\index{shell.\+c@{shell.\+c}!Shell\+Clear\+Flag@{Shell\+Clear\+Flag}}
\index{Shell\+Clear\+Flag@{Shell\+Clear\+Flag}!shell.\+c@{shell.\+c}}
\subsubsection{Shell\+Clear\+Flag}
{\footnotesize\ttfamily \#define Shell\+Clear\+Flag(\begin{DoxyParamCaption}\item[{}]{P,  }\item[{}]{\textbf{ X} }\end{DoxyParamCaption})~((P)-\/$>$shell\+Flgs\&=($\sim$(\textbf{ X})))}



Definition at line 9681 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and set\+Or\+Clear\+Flag().

\mbox{\label{shell_8c_a8c84f37a34fc520eef1db2b3b39aabf8}} 
\index{shell.\+c@{shell.\+c}!Shell\+Has\+Flag@{Shell\+Has\+Flag}}
\index{Shell\+Has\+Flag@{Shell\+Has\+Flag}!shell.\+c@{shell.\+c}}
\subsubsection{Shell\+Has\+Flag}
{\footnotesize\ttfamily \#define Shell\+Has\+Flag(\begin{DoxyParamCaption}\item[{}]{P,  }\item[{}]{\textbf{ X} }\end{DoxyParamCaption})~(((P)-\/$>$shell\+Flgs \& (\textbf{ X}))!=0)}



Definition at line 9679 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), process\+\_\+input(), run\+One\+Sql\+Line(), shell\+\_\+callback(), shell\+\_\+exec(), and table\+Column\+List().

\mbox{\label{shell_8c_a32e7ed06345029f7285d0134ef339367}} 
\index{shell.\+c@{shell.\+c}!Shell\+Set\+Flag@{Shell\+Set\+Flag}}
\index{Shell\+Set\+Flag@{Shell\+Set\+Flag}!shell.\+c@{shell.\+c}}
\subsubsection{Shell\+Set\+Flag}
{\footnotesize\ttfamily \#define Shell\+Set\+Flag(\begin{DoxyParamCaption}\item[{}]{P,  }\item[{}]{\textbf{ X} }\end{DoxyParamCaption})~((P)-\/$>$shell\+Flgs$\vert$=(\textbf{ X}))}



Definition at line 9680 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), and set\+Or\+Clear\+Flag().

\mbox{\label{shell_8c_a356bb564ac144c7c357562a27c5c2ae5}} 
\index{shell.\+c@{shell.\+c}!S\+H\+F\+L\+G\+\_\+\+Backslash@{S\+H\+F\+L\+G\+\_\+\+Backslash}}
\index{S\+H\+F\+L\+G\+\_\+\+Backslash@{S\+H\+F\+L\+G\+\_\+\+Backslash}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+F\+L\+G\+\_\+\+Backslash}
{\footnotesize\ttfamily \#define S\+H\+F\+L\+G\+\_\+\+Backslash~0x00000004 /$\ast$ The -\/-\/backslash option is used $\ast$/}



Definition at line 9670 of file shell.\+c.



Referenced by main(), and run\+One\+Sql\+Line().

\mbox{\label{shell_8c_ab87bdefc070646a521e8773e2006c267}} 
\index{shell.\+c@{shell.\+c}!S\+H\+F\+L\+G\+\_\+\+Count\+Changes@{S\+H\+F\+L\+G\+\_\+\+Count\+Changes}}
\index{S\+H\+F\+L\+G\+\_\+\+Count\+Changes@{S\+H\+F\+L\+G\+\_\+\+Count\+Changes}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+F\+L\+G\+\_\+\+Count\+Changes}
{\footnotesize\ttfamily \#define S\+H\+F\+L\+G\+\_\+\+Count\+Changes~0x00000020 /$\ast$ .\+changes setting $\ast$/}



Definition at line 9673 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and run\+One\+Sql\+Line().

\mbox{\label{shell_8c_a8fe736a8e01d51b81dd77324b9c8d270}} 
\index{shell.\+c@{shell.\+c}!S\+H\+F\+L\+G\+\_\+\+Echo@{S\+H\+F\+L\+G\+\_\+\+Echo}}
\index{S\+H\+F\+L\+G\+\_\+\+Echo@{S\+H\+F\+L\+G\+\_\+\+Echo}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+F\+L\+G\+\_\+\+Echo}
{\footnotesize\ttfamily \#define S\+H\+F\+L\+G\+\_\+\+Echo~0x00000040 /$\ast$ .\+echo or -\/-\/echo setting $\ast$/}



Definition at line 9674 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), main(), process\+\_\+input(), and shell\+\_\+exec().

\mbox{\label{shell_8c_a5886586f94d920aeb9e29f544d7afbc5}} 
\index{shell.\+c@{shell.\+c}!S\+H\+F\+L\+G\+\_\+\+Lookaside@{S\+H\+F\+L\+G\+\_\+\+Lookaside}}
\index{S\+H\+F\+L\+G\+\_\+\+Lookaside@{S\+H\+F\+L\+G\+\_\+\+Lookaside}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+F\+L\+G\+\_\+\+Lookaside}
{\footnotesize\ttfamily \#define S\+H\+F\+L\+G\+\_\+\+Lookaside~0x00000002 /$\ast$ Lookaside memory is used $\ast$/}



Definition at line 9669 of file shell.\+c.



Referenced by display\+\_\+stats(), main(), and main\+\_\+init().

\mbox{\label{shell_8c_a8c2dd7cbc2b84a419b103d189dcc0ca5}} 
\index{shell.\+c@{shell.\+c}!S\+H\+F\+L\+G\+\_\+\+Newlines@{S\+H\+F\+L\+G\+\_\+\+Newlines}}
\index{S\+H\+F\+L\+G\+\_\+\+Newlines@{S\+H\+F\+L\+G\+\_\+\+Newlines}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+F\+L\+G\+\_\+\+Newlines}
{\footnotesize\ttfamily \#define S\+H\+F\+L\+G\+\_\+\+Newlines~0x00000010 /$\ast$ .\+dump -\/-\/newline flag $\ast$/}



Definition at line 9672 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and shell\+\_\+callback().

\mbox{\label{shell_8c_a2c3d6c2e9c3b6c0c2bf328da372caf31}} 
\index{shell.\+c@{shell.\+c}!S\+H\+F\+L\+G\+\_\+\+Pagecache@{S\+H\+F\+L\+G\+\_\+\+Pagecache}}
\index{S\+H\+F\+L\+G\+\_\+\+Pagecache@{S\+H\+F\+L\+G\+\_\+\+Pagecache}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+F\+L\+G\+\_\+\+Pagecache}
{\footnotesize\ttfamily \#define S\+H\+F\+L\+G\+\_\+\+Pagecache~0x00000001 /$\ast$ The -\/-\/pagecache option is used $\ast$/}



Definition at line 9668 of file shell.\+c.



Referenced by display\+\_\+stats(), and main().

\mbox{\label{shell_8c_a41837cc99ab29fb2fdf13ccd977e333a}} 
\index{shell.\+c@{shell.\+c}!S\+H\+F\+L\+G\+\_\+\+Preserve\+Rowid@{S\+H\+F\+L\+G\+\_\+\+Preserve\+Rowid}}
\index{S\+H\+F\+L\+G\+\_\+\+Preserve\+Rowid@{S\+H\+F\+L\+G\+\_\+\+Preserve\+Rowid}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+F\+L\+G\+\_\+\+Preserve\+Rowid}
{\footnotesize\ttfamily \#define S\+H\+F\+L\+G\+\_\+\+Preserve\+Rowid~0x00000008 /$\ast$ .\+dump preserves rowid values $\ast$/}



Definition at line 9671 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and table\+Column\+List().

\mbox{\label{shell_8c_afff1053b875c905fa8695b458d836b42}} 
\index{shell.\+c@{shell.\+c}!S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1@{S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1}}
\index{S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1@{S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1}!shell.\+c@{shell.\+c}}
\subsubsection{S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1}
{\footnotesize\ttfamily \#define S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1}



Definition at line 949 of file shell.\+c.



Referenced by sqlite3\+\_\+completion\+\_\+init(), sqlite3\+\_\+expert\+\_\+destroy(), sqlite3\+\_\+fileio\+\_\+init(), sqlite3\+\_\+shathree\+\_\+init(), and sqlite3\+Mem\+Trace\+Deactivate().

\mbox{\label{shell_8c_acabf989eca348cf82099212bd859b206}} 
\index{shell.\+c@{shell.\+c}!S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2@{S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2}}
\index{S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2@{S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2}!shell.\+c@{shell.\+c}}
\subsubsection{S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2}
{\footnotesize\ttfamily \#define S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2(\begin{DoxyParamCaption}\item[{}]{\textbf{ X} }\end{DoxyParamCaption})~(void)(\textbf{ X})}



Definition at line 950 of file shell.\+c.



Referenced by sqlite3\+\_\+appendvfs\+\_\+init(), sqlite3\+\_\+completion\+\_\+init(), sqlite3\+\_\+expert\+\_\+destroy(), sqlite3\+\_\+extension\+\_\+init(), sqlite3\+\_\+fileio\+\_\+init(), sqlite3\+\_\+shathree\+\_\+init(), and sqlite3\+Mem\+Trace\+Deactivate().

\mbox{\label{shell_8c_a11075a4a9ce04cbcb7fa17d111dc016a}} 
\index{shell.\+c@{shell.\+c}!S\+Q\+L\+I\+T\+E\+\_\+\+S\+H\+E\+L\+L\+\_\+\+I\+S\+\_\+\+U\+T\+F8@{S\+Q\+L\+I\+T\+E\+\_\+\+S\+H\+E\+L\+L\+\_\+\+I\+S\+\_\+\+U\+T\+F8}}
\index{S\+Q\+L\+I\+T\+E\+\_\+\+S\+H\+E\+L\+L\+\_\+\+I\+S\+\_\+\+U\+T\+F8@{S\+Q\+L\+I\+T\+E\+\_\+\+S\+H\+E\+L\+L\+\_\+\+I\+S\+\_\+\+U\+T\+F8}!shell.\+c@{shell.\+c}}
\subsubsection{S\+Q\+L\+I\+T\+E\+\_\+\+S\+H\+E\+L\+L\+\_\+\+I\+S\+\_\+\+U\+T\+F8}
{\footnotesize\ttfamily \#define S\+Q\+L\+I\+T\+E\+\_\+\+S\+H\+E\+L\+L\+\_\+\+I\+S\+\_\+\+U\+T\+F8~(1)}



Definition at line 18660 of file shell.\+c.

\mbox{\label{shell_8c_af417b58f69df430b1d1fdb791cbd22e4}} 
\index{shell.\+c@{shell.\+c}!S\+Q\+L\+I\+T\+E\+E\+X\+P\+E\+R\+T\+\_\+H@{S\+Q\+L\+I\+T\+E\+E\+X\+P\+E\+R\+T\+\_\+H}}
\index{S\+Q\+L\+I\+T\+E\+E\+X\+P\+E\+R\+T\+\_\+H@{S\+Q\+L\+I\+T\+E\+E\+X\+P\+E\+R\+T\+\_\+H}!shell.\+c@{shell.\+c}}
\subsubsection{S\+Q\+L\+I\+T\+E\+E\+X\+P\+E\+R\+T\+\_\+H}
{\footnotesize\ttfamily \#define S\+Q\+L\+I\+T\+E\+E\+X\+P\+E\+R\+T\+\_\+H~1}



Definition at line 6549 of file shell.\+c.

\mbox{\label{shell_8c_a278cf415676752815cfb411cb0b32802}} 
\index{shell.\+c@{shell.\+c}!S\+T\+R\+L\+EN@{S\+T\+R\+L\+EN}}
\index{S\+T\+R\+L\+EN@{S\+T\+R\+L\+EN}!shell.\+c@{shell.\+c}}
\subsubsection{S\+T\+R\+L\+EN}
{\footnotesize\ttfamily \#define S\+T\+R\+L\+EN~(int)strlen}



Definition at line 6736 of file shell.\+c.



Referenced by expert\+Dequote(), idx\+Append\+Text(), idx\+Find\+Indexes(), idx\+Get\+Table\+Info(), idx\+Hash\+Add(), idx\+Hash\+Find(), idx\+New\+Constraint(), idx\+Populate\+One\+Stat1(), and sqlite3\+\_\+expert\+\_\+sql().

\mbox{\label{shell_8c_a04c94872ca0f49899c5d650e0445eddc}} 
\index{shell.\+c@{shell.\+c}!To\+Lower@{To\+Lower}}
\index{To\+Lower@{To\+Lower}!shell.\+c@{shell.\+c}}
\subsubsection{To\+Lower}
{\footnotesize\ttfamily \#define To\+Lower(\begin{DoxyParamCaption}\item[{}]{\textbf{ X} }\end{DoxyParamCaption})~(char)tolower((unsigned char)\textbf{ X})}



Definition at line 191 of file shell.\+c.



Referenced by line\+\_\+is\+\_\+command\+\_\+terminator().

\mbox{\label{shell_8c_a24488e8c3ceee0aa5f0289bd19b8cb3f}} 
\index{shell.\+c@{shell.\+c}!U\+N\+I\+Q\+U\+E\+\_\+\+T\+A\+B\+L\+E\+\_\+\+N\+A\+ME@{U\+N\+I\+Q\+U\+E\+\_\+\+T\+A\+B\+L\+E\+\_\+\+N\+A\+ME}}
\index{U\+N\+I\+Q\+U\+E\+\_\+\+T\+A\+B\+L\+E\+\_\+\+N\+A\+ME@{U\+N\+I\+Q\+U\+E\+\_\+\+T\+A\+B\+L\+E\+\_\+\+N\+A\+ME}!shell.\+c@{shell.\+c}}
\subsubsection{U\+N\+I\+Q\+U\+E\+\_\+\+T\+A\+B\+L\+E\+\_\+\+N\+A\+ME}
{\footnotesize\ttfamily \#define U\+N\+I\+Q\+U\+E\+\_\+\+T\+A\+B\+L\+E\+\_\+\+N\+A\+ME~\char`\"{}t592690916721053953805701627921227776\char`\"{}}



Definition at line 6743 of file shell.\+c.



Referenced by idx\+Build\+Sample\+Table(), idx\+Populate\+One\+Stat1(), idx\+Populate\+Stat1(), and idx\+Process\+One\+Trigger().

\mbox{\label{shell_8c_a3c95a90e7806e4b0d21edfae15b73465}} 
\index{shell.\+c@{shell.\+c}!U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER@{U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER}}
\index{U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER@{U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER}!shell.\+c@{shell.\+c}}
\subsubsection{U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER}
{\footnotesize\ttfamily \#define U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER(\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})~(void)(x)}



Definition at line 380 of file shell.\+c.



Referenced by capture\+Output\+Callback(), display\+\_\+scanstats(), dump\+\_\+callback(), interrupt\+\_\+handler(), shell\+Add\+Schema\+Name(), shell\+Escape\+Crnl(), shell\+Id\+Quote(), shell\+Int32(), and shell\+Module\+Schema().

\mbox{\label{shell_8c_aa7bc4ba9077b8add5f607d0d0993a006}} 
\index{shell.\+c@{shell.\+c}!utf8\+\_\+printf@{utf8\+\_\+printf}}
\index{utf8\+\_\+printf@{utf8\+\_\+printf}!shell.\+c@{shell.\+c}}
\subsubsection{utf8\+\_\+printf}
{\footnotesize\ttfamily \#define utf8\+\_\+printf~fprintf}



Definition at line 452 of file shell.\+c.



Referenced by boolean\+Value(), close\+\_\+db(), cmdline\+\_\+option\+\_\+value(), create\+Selftest\+Table(), csv\+\_\+read\+\_\+one\+\_\+field(), deduce\+Database\+Type(), display\+\_\+scanstats(), display\+\_\+stats(), do\+\_\+meta\+\_\+command(), dump\+\_\+callback(), eqp\+\_\+append(), eqp\+\_\+render(), eqp\+\_\+render\+\_\+level(), main(), open\+\_\+db(), output\+\_\+csv(), output\+\_\+file\+\_\+open(), output\+\_\+html\+\_\+string(), output\+\_\+quoted\+\_\+escaped\+\_\+string(), output\+\_\+quoted\+\_\+string(), output\+\_\+reset(), print\+Schema\+Line(), process\+\_\+sqliterc(), run\+\_\+schema\+\_\+dump\+\_\+query(), run\+\_\+table\+\_\+dump\+\_\+query(), run\+One\+Sql\+Line(), save\+\_\+err\+\_\+msg(), shell\+\_\+callback(), shell\+\_\+dbinfo\+\_\+command(), shell\+\_\+exec(), shell\+\_\+out\+\_\+of\+\_\+memory(), shell\+Auth(), shell\+Database\+Error(), shell\+Log(), shell\+Puts\+Func(), shell\+Reset(), show\+Help(), sql\+\_\+trace\+\_\+callback(), try\+To\+Clone(), try\+To\+Clone\+Data(), try\+To\+Clone\+Schema(), usage(), utf8\+\_\+width\+\_\+print(), and verify\+\_\+uninitialized().



\subsection{Typedef Documentation}
\mbox{\label{shell_8c_a56c51fd9a5a18f256e6ccd05e512bb35}} 
\index{shell.\+c@{shell.\+c}!Apnd\+File@{Apnd\+File}}
\index{Apnd\+File@{Apnd\+File}!shell.\+c@{shell.\+c}}
\subsubsection{Apnd\+File}
{\footnotesize\ttfamily typedef struct \textbf{ Apnd\+File} \textbf{ Apnd\+File}}



Definition at line 3614 of file shell.\+c.

\mbox{\label{shell_8c_a48821dd8b93e5fc5cdcddf53274b2740}} 
\index{shell.\+c@{shell.\+c}!Apnd\+Vfs@{Apnd\+Vfs}}
\index{Apnd\+Vfs@{Apnd\+Vfs}!shell.\+c@{shell.\+c}}
\subsubsection{Apnd\+Vfs}
{\footnotesize\ttfamily typedef struct \textbf{ sqlite3\+\_\+vfs} \textbf{ Apnd\+Vfs}}



Definition at line 3613 of file shell.\+c.

\mbox{\label{shell_8c_aa8c9f048c22b0b80873147006457fd50}} 
\index{shell.\+c@{shell.\+c}!completion\+\_\+cursor@{completion\+\_\+cursor}}
\index{completion\+\_\+cursor@{completion\+\_\+cursor}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+\_\+cursor}
{\footnotesize\ttfamily typedef struct \textbf{ completion\+\_\+cursor} \textbf{ completion\+\_\+cursor}}



Definition at line 3090 of file shell.\+c.

\mbox{\label{shell_8c_af878c04db92ed2d05faac2f436a879ae}} 
\index{shell.\+c@{shell.\+c}!completion\+\_\+vtab@{completion\+\_\+vtab}}
\index{completion\+\_\+vtab@{completion\+\_\+vtab}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+\_\+vtab}
{\footnotesize\ttfamily typedef typedef\+S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1 struct \textbf{ completion\+\_\+vtab} \textbf{ completion\+\_\+vtab}}



Definition at line 3080 of file shell.\+c.

\mbox{\label{shell_8c_a7fc13a21ae5da271984d3f211f91738a}} 
\index{shell.\+c@{shell.\+c}!E\+Q\+P\+Graph@{E\+Q\+P\+Graph}}
\index{E\+Q\+P\+Graph@{E\+Q\+P\+Graph}!shell.\+c@{shell.\+c}}
\subsubsection{E\+Q\+P\+Graph}
{\footnotesize\ttfamily typedef struct \textbf{ E\+Q\+P\+Graph} \textbf{ E\+Q\+P\+Graph}}



Definition at line 9561 of file shell.\+c.

\mbox{\label{shell_8c_a7ce0800e038436fe68fa8664993b8da1}} 
\index{shell.\+c@{shell.\+c}!E\+Q\+P\+Graph\+Row@{E\+Q\+P\+Graph\+Row}}
\index{E\+Q\+P\+Graph\+Row@{E\+Q\+P\+Graph\+Row}!shell.\+c@{shell.\+c}}
\subsubsection{E\+Q\+P\+Graph\+Row}
{\footnotesize\ttfamily typedef struct \textbf{ E\+Q\+P\+Graph\+Row} \textbf{ E\+Q\+P\+Graph\+Row}}



Definition at line 9552 of file shell.\+c.

\mbox{\label{shell_8c_a6b720f72855401ab1a213f136e2c77a7}} 
\index{shell.\+c@{shell.\+c}!Expert\+Csr@{Expert\+Csr}}
\index{Expert\+Csr@{Expert\+Csr}!shell.\+c@{shell.\+c}}
\subsubsection{Expert\+Csr}
{\footnotesize\ttfamily typedef struct \textbf{ Expert\+Csr} \textbf{ Expert\+Csr}}



Definition at line 7063 of file shell.\+c.

\mbox{\label{shell_8c_af20bd768a852d057b9e5359a228db046}} 
\index{shell.\+c@{shell.\+c}!Expert\+Info@{Expert\+Info}}
\index{Expert\+Info@{Expert\+Info}!shell.\+c@{shell.\+c}}
\subsubsection{Expert\+Info}
{\footnotesize\ttfamily typedef struct \textbf{ Expert\+Info} \textbf{ Expert\+Info}}



Definition at line 9545 of file shell.\+c.

\mbox{\label{shell_8c_a1445a8721a8ac10a98ab182fcd69075b}} 
\index{shell.\+c@{shell.\+c}!Expert\+Vtab@{Expert\+Vtab}}
\index{Expert\+Vtab@{Expert\+Vtab}!shell.\+c@{shell.\+c}}
\subsubsection{Expert\+Vtab}
{\footnotesize\ttfamily typedef struct \textbf{ Expert\+Vtab} \textbf{ Expert\+Vtab}}



Definition at line 7056 of file shell.\+c.

\mbox{\label{shell_8c_a5b7584a07747418e506a52041076f21b}} 
\index{shell.\+c@{shell.\+c}!fsdir\+\_\+cursor@{fsdir\+\_\+cursor}}
\index{fsdir\+\_\+cursor@{fsdir\+\_\+cursor}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+\_\+cursor}
{\footnotesize\ttfamily typedef struct \textbf{ fsdir\+\_\+cursor} \textbf{ fsdir\+\_\+cursor}}



Definition at line 2571 of file shell.\+c.

\mbox{\label{shell_8c_a2fd39177aea93f3800c460847a5d7ba7}} 
\index{shell.\+c@{shell.\+c}!fsdir\+\_\+tab@{fsdir\+\_\+tab}}
\index{fsdir\+\_\+tab@{fsdir\+\_\+tab}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+\_\+tab}
{\footnotesize\ttfamily typedef struct \textbf{ fsdir\+\_\+tab} \textbf{ fsdir\+\_\+tab}}



Definition at line 2594 of file shell.\+c.

\mbox{\label{shell_8c_ade1e4ddce17bd39a54b7aca067602c54}} 
\index{shell.\+c@{shell.\+c}!Fsdir\+Level@{Fsdir\+Level}}
\index{Fsdir\+Level@{Fsdir\+Level}!shell.\+c@{shell.\+c}}
\subsubsection{Fsdir\+Level}
{\footnotesize\ttfamily typedef struct \textbf{ Fsdir\+Level} \textbf{ Fsdir\+Level}}



Definition at line 2572 of file shell.\+c.

\mbox{\label{shell_8c_a9b2c7298acf62c3803b0fbded620026a}} 
\index{shell.\+c@{shell.\+c}!i64@{i64}}
\index{i64@{i64}!shell.\+c@{shell.\+c}}
\subsubsection{i64}
{\footnotesize\ttfamily typedef \textbf{ sqlite3\+\_\+int64} \textbf{ i64}}



Definition at line 82 of file shell.\+c.

\mbox{\label{shell_8c_a6d7ab9c44863fb26e8abdf85bffdab94}} 
\index{shell.\+c@{shell.\+c}!Idx\+Column@{Idx\+Column}}
\index{Idx\+Column@{Idx\+Column}!shell.\+c@{shell.\+c}}
\subsubsection{Idx\+Column}
{\footnotesize\ttfamily typedef struct \textbf{ Idx\+Column} \textbf{ Idx\+Column}}



Definition at line 6729 of file shell.\+c.

\mbox{\label{shell_8c_a7dc4f709a858680eeda43953cbabd6b2}} 
\index{shell.\+c@{shell.\+c}!Idx\+Constraint@{Idx\+Constraint}}
\index{Idx\+Constraint@{Idx\+Constraint}!shell.\+c@{shell.\+c}}
\subsubsection{Idx\+Constraint}
{\footnotesize\ttfamily typedef struct \textbf{ Idx\+Constraint} \textbf{ Idx\+Constraint}}



Definition at line 6730 of file shell.\+c.

\mbox{\label{shell_8c_ac64ee4ff814ff1ba6117a8a7b5c339ad}} 
\index{shell.\+c@{shell.\+c}!Idx\+Hash@{Idx\+Hash}}
\index{Idx\+Hash@{Idx\+Hash}!shell.\+c@{shell.\+c}}
\subsubsection{Idx\+Hash}
{\footnotesize\ttfamily typedef struct \textbf{ Idx\+Hash} \textbf{ Idx\+Hash}}



Definition at line 6827 of file shell.\+c.

\mbox{\label{shell_8c_a03c34b73ccf717b3993679fdfced1ad8}} 
\index{shell.\+c@{shell.\+c}!Idx\+Hash\+Entry@{Idx\+Hash\+Entry}}
\index{Idx\+Hash\+Entry@{Idx\+Hash\+Entry}!shell.\+c@{shell.\+c}}
\subsubsection{Idx\+Hash\+Entry}
{\footnotesize\ttfamily typedef struct \textbf{ Idx\+Hash\+Entry} \textbf{ Idx\+Hash\+Entry}}



Definition at line 6826 of file shell.\+c.

\mbox{\label{shell_8c_abd9c0f136c1cf0d27bd908e0ad5f65a2}} 
\index{shell.\+c@{shell.\+c}!Idx\+Scan@{Idx\+Scan}}
\index{Idx\+Scan@{Idx\+Scan}!shell.\+c@{shell.\+c}}
\subsubsection{Idx\+Scan}
{\footnotesize\ttfamily typedef struct \textbf{ Idx\+Scan} \textbf{ Idx\+Scan}}



Definition at line 6731 of file shell.\+c.

\mbox{\label{shell_8c_a7f02917c087f36cab586f225800b747c}} 
\index{shell.\+c@{shell.\+c}!Idx\+Statement@{Idx\+Statement}}
\index{Idx\+Statement@{Idx\+Statement}!shell.\+c@{shell.\+c}}
\subsubsection{Idx\+Statement}
{\footnotesize\ttfamily typedef struct \textbf{ Idx\+Statement} \textbf{ Idx\+Statement}}



Definition at line 6732 of file shell.\+c.

\mbox{\label{shell_8c_ad8e03a1cc90ae45c1d29b9c42109d092}} 
\index{shell.\+c@{shell.\+c}!Idx\+Table@{Idx\+Table}}
\index{Idx\+Table@{Idx\+Table}!shell.\+c@{shell.\+c}}
\subsubsection{Idx\+Table}
{\footnotesize\ttfamily typedef struct \textbf{ Idx\+Table} \textbf{ Idx\+Table}}



Definition at line 6733 of file shell.\+c.

\mbox{\label{shell_8c_afb29aeb1541aba06af801495c63287c4}} 
\index{shell.\+c@{shell.\+c}!Idx\+Write@{Idx\+Write}}
\index{Idx\+Write@{Idx\+Write}!shell.\+c@{shell.\+c}}
\subsubsection{Idx\+Write}
{\footnotesize\ttfamily typedef struct \textbf{ Idx\+Write} \textbf{ Idx\+Write}}



Definition at line 6734 of file shell.\+c.

\mbox{\label{shell_8c_a4f85b49f3d8654de355005d5def004ef}} 
\index{shell.\+c@{shell.\+c}!Import\+Ctx@{Import\+Ctx}}
\index{Import\+Ctx@{Import\+Ctx}!shell.\+c@{shell.\+c}}
\subsubsection{Import\+Ctx}
{\footnotesize\ttfamily typedef struct \textbf{ Import\+Ctx} \textbf{ Import\+Ctx}}



Definition at line 13068 of file shell.\+c.

\mbox{\label{shell_8c_a2feca17dfbd8e8fcc0466a62c7d870cd}} 
\index{shell.\+c@{shell.\+c}!Saved\+Mode\+Info@{Saved\+Mode\+Info}}
\index{Saved\+Mode\+Info@{Saved\+Mode\+Info}!shell.\+c@{shell.\+c}}
\subsubsection{Saved\+Mode\+Info}
{\footnotesize\ttfamily typedef struct \textbf{ Saved\+Mode\+Info} \textbf{ Saved\+Mode\+Info}}



Definition at line 9537 of file shell.\+c.

\mbox{\label{shell_8c_aabb5acf00722637e06bb6b52e211145b}} 
\index{shell.\+c@{shell.\+c}!S\+H\+A3\+Context@{S\+H\+A3\+Context}}
\index{S\+H\+A3\+Context@{S\+H\+A3\+Context}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+A3\+Context}
{\footnotesize\ttfamily typedef struct \textbf{ S\+H\+A3\+Context} \textbf{ S\+H\+A3\+Context}}



Definition at line 1376 of file shell.\+c.

\mbox{\label{shell_8c_aa632438ddb8610bac7dcaf0e17b1f14b}} 
\index{shell.\+c@{shell.\+c}!Shell\+State@{Shell\+State}}
\index{Shell\+State@{Shell\+State}!shell.\+c@{shell.\+c}}
\subsubsection{Shell\+State}
{\footnotesize\ttfamily typedef struct \textbf{ Shell\+State} \textbf{ Shell\+State}}



Definition at line 9572 of file shell.\+c.

\mbox{\label{shell_8c_a6d9f54192cd3f08cdfa31ac4cab7e6cc}} 
\index{shell.\+c@{shell.\+c}!Shell\+Text@{Shell\+Text}}
\index{Shell\+Text@{Shell\+Text}!shell.\+c@{shell.\+c}}
\subsubsection{Shell\+Text}
{\footnotesize\ttfamily typedef struct \textbf{ Shell\+Text} \textbf{ Shell\+Text}}



Definition at line 724 of file shell.\+c.

\mbox{\label{shell_8c_a378e805e6bf318509c071201e717181e}} 
\index{shell.\+c@{shell.\+c}!sqlite3expert@{sqlite3expert}}
\index{sqlite3expert@{sqlite3expert}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3expert}
{\footnotesize\ttfamily typedef struct \textbf{ sqlite3expert} \textbf{ sqlite3expert}}



Definition at line 6552 of file shell.\+c.

\mbox{\label{shell_8c_a510e88e5fe50c5bcf5b3ff1ad131e109}} 
\index{shell.\+c@{shell.\+c}!u64@{u64}}
\index{u64@{u64}!shell.\+c@{shell.\+c}}
\subsubsection{u64}
{\footnotesize\ttfamily typedef \textbf{ sqlite3\+\_\+uint64} \textbf{ u64}}



Definition at line 83 of file shell.\+c.

\mbox{\label{shell_8c_aed742c436da53c1080638ce6ef7d13de}} 
\index{shell.\+c@{shell.\+c}!u8@{u8}}
\index{u8@{u8}!shell.\+c@{shell.\+c}}
\subsubsection{u8}
{\footnotesize\ttfamily typedef unsigned char \textbf{ u8}}



Definition at line 84 of file shell.\+c.



\subsection{Function Documentation}
\mbox{\label{shell_8c_a908f756e9954cea801a5daa7e757e0de}} 
\index{shell.\+c@{shell.\+c}!\+\_\+all\+\_\+whitespace@{\+\_\+all\+\_\+whitespace}}
\index{\+\_\+all\+\_\+whitespace@{\+\_\+all\+\_\+whitespace}!shell.\+c@{shell.\+c}}
\subsubsection{\+\_\+all\+\_\+whitespace()}
{\footnotesize\ttfamily static int \+\_\+all\+\_\+whitespace (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18221 of file shell.\+c.



References Is\+Space.



Referenced by line\+\_\+is\+\_\+command\+\_\+terminator(), and process\+\_\+input().


\begin{DoxyCode}
18221                                          \{
18222   \textcolor{keywordflow}{for}(; *z; z++)\{
18223     \textcolor{keywordflow}{if}( IsSpace(z[0]) ) \textcolor{keywordflow}{continue};
18224     \textcolor{keywordflow}{if}( *z==\textcolor{charliteral}{'/'} && z[1]==\textcolor{charliteral}{'*'} )\{
18225       z += 2;
18226       \textcolor{keywordflow}{while}( *z && (*z!=\textcolor{charliteral}{'*'} || z[1]!=\textcolor{charliteral}{'/'}) )\{ z++; \}
18227       \textcolor{keywordflow}{if}( *z==0 ) \textcolor{keywordflow}{return} 0;
18228       z++;
18229       \textcolor{keywordflow}{continue};
18230     \}
18231     \textcolor{keywordflow}{if}( *z==\textcolor{charliteral}{'-'} && z[1]==\textcolor{charliteral}{'-'} )\{
18232       z += 2;
18233       \textcolor{keywordflow}{while}( *z && *z!=\textcolor{charliteral}{'\(\backslash\)n'} )\{ z++; \}
18234       \textcolor{keywordflow}{if}( *z==0 ) \textcolor{keywordflow}{return} 1;
18235       \textcolor{keywordflow}{continue};
18236     \}
18237     \textcolor{keywordflow}{return} 0;
18238   \}
18239   \textcolor{keywordflow}{return} 1;
18240 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a3338671d422f070cd79f77bad4a558ea}} 
\index{shell.\+c@{shell.\+c}!apnd\+Access@{apnd\+Access}}
\index{apnd\+Access@{apnd\+Access}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Access()}
{\footnotesize\ttfamily static int apnd\+Access (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{const char $\ast$}]{z\+Name,  }\item[{int}]{flags,  }\item[{int $\ast$}]{p\+Res\+Out }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4012 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4017  \{
4018   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xAccess(ORIGVFS(pVfs), zPath, flags, pResOut);
4019 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ace03c3639add18c69f43010d57ec9153}} 
\index{shell.\+c@{shell.\+c}!apnd\+Check\+Reserved\+Lock@{apnd\+Check\+Reserved\+Lock}}
\index{apnd\+Check\+Reserved\+Lock@{apnd\+Check\+Reserved\+Lock}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Check\+Reserved\+Lock()}
{\footnotesize\ttfamily static int apnd\+Check\+Reserved\+Lock (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{int $\ast$}]{p\+Res\+Out }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3839 of file shell.\+c.



References O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Check\+Reserved\+Lock.


\begin{DoxyCode}
3839                                                                    \{
3840   pFile = ORIGFILE(pFile);
3841   \textcolor{keywordflow}{return} pFile->pMethods->xCheckReservedLock(pFile, pResOut);
3842 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a9058c304b84213fa127746bab8c07bda}} 
\index{shell.\+c@{shell.\+c}!apnd\+Close@{apnd\+Close}}
\index{apnd\+Close@{apnd\+Close}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Close()}
{\footnotesize\ttfamily static int apnd\+Close (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3723 of file shell.\+c.



References O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Close.


\begin{DoxyCode}
3723                                          \{
3724   pFile = ORIGFILE(pFile);
3725   \textcolor{keywordflow}{return} pFile->pMethods->xClose(pFile);
3726 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ac24f3b577630f858e7c148603da6e68d}} 
\index{shell.\+c@{shell.\+c}!apnd\+Current\+Time@{apnd\+Current\+Time}}
\index{apnd\+Current\+Time@{apnd\+Current\+Time}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Current\+Time()}
{\footnotesize\ttfamily static int apnd\+Current\+Time (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{double $\ast$}]{p\+Time\+Out }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4046 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4046                                                                \{
4047   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xCurrentTime(ORIGVFS(pVfs), pTimeOut);
4048 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a28e524db8ef0085740afe68b120dd8d9}} 
\index{shell.\+c@{shell.\+c}!apnd\+Current\+Time\+Int64@{apnd\+Current\+Time\+Int64}}
\index{apnd\+Current\+Time\+Int64@{apnd\+Current\+Time\+Int64}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Current\+Time\+Int64()}
{\footnotesize\ttfamily static int apnd\+Current\+Time\+Int64 (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{\textbf{ sqlite3\+\_\+int64} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4052 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4052                                                                     \{
4053   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xCurrentTimeInt64(ORIGVFS(pVfs), p);
4054 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a368491730255f236e59b40e2bdddf20f}} 
\index{shell.\+c@{shell.\+c}!apnd\+Delete@{apnd\+Delete}}
\index{apnd\+Delete@{apnd\+Delete}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Delete()}
{\footnotesize\ttfamily static int apnd\+Delete (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{const char $\ast$}]{z\+Name,  }\item[{int}]{sync\+Dir }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4009 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4009                                                                         \{
4010   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xDelete(ORIGVFS(pVfs), zPath, dirSync);
4011 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a24460dd1b75637b1717d45c3e2ad9af7}} 
\index{shell.\+c@{shell.\+c}!apnd\+Device\+Characteristics@{apnd\+Device\+Characteristics}}
\index{apnd\+Device\+Characteristics@{apnd\+Device\+Characteristics}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Device\+Characteristics()}
{\footnotesize\ttfamily static int apnd\+Device\+Characteristics (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3869 of file shell.\+c.



References O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Device\+Characteristics.


\begin{DoxyCode}
3869                                                          \{
3870   pFile = ORIGFILE(pFile);
3871   \textcolor{keywordflow}{return} pFile->pMethods->xDeviceCharacteristics(pFile);
3872 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad67889d5a50a8af32f1ffd3363ca0e29}} 
\index{shell.\+c@{shell.\+c}!apnd\+Dl\+Close@{apnd\+Dl\+Close}}
\index{apnd\+Dl\+Close@{apnd\+Dl\+Close}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Dl\+Close()}
{\footnotesize\ttfamily static void apnd\+Dl\+Close (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{void $\ast$}]{p\+Handle }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4037 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4037                                                          \{
4038   ORIGVFS(pVfs)->xDlClose(ORIGVFS(pVfs), pHandle);
4039 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a37deeb5a92ba0cb8f8107ccc73bea3f0}} 
\index{shell.\+c@{shell.\+c}!apnd\+Dl\+Error@{apnd\+Dl\+Error}}
\index{apnd\+Dl\+Error@{apnd\+Dl\+Error}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Dl\+Error()}
{\footnotesize\ttfamily static void apnd\+Dl\+Error (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{int}]{n\+Byte,  }\item[{char $\ast$}]{z\+Err\+Msg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4031 of file shell.\+c.



References apnd\+Dl\+Sym, and O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4031                                                                     \{
4032   ORIGVFS(pVfs)->xDlError(ORIGVFS(pVfs), nByte, zErrMsg);
4033 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a8d6e3d44b1cdb4548f5221ebd94013a2}} 
\index{shell.\+c@{shell.\+c}!apnd\+Dl\+Open@{apnd\+Dl\+Open}}
\index{apnd\+Dl\+Open@{apnd\+Dl\+Open}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Dl\+Open()}
{\footnotesize\ttfamily static void $\ast$ apnd\+Dl\+Open (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{const char $\ast$}]{z\+Filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4028 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4028                                                              \{
4029   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xDlOpen(ORIGVFS(pVfs), zPath);
4030 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aecf1b767179a22297388ab3d0effadfe}} 
\index{shell.\+c@{shell.\+c}!apnd\+Fetch@{apnd\+Fetch}}
\index{apnd\+Fetch@{apnd\+Fetch}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Fetch()}
{\footnotesize\ttfamily static int apnd\+Fetch (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{\textbf{ sqlite3\+\_\+int64}}]{i\+Ofst,  }\item[{int}]{i\+Amt,  }\item[{void $\ast$$\ast$}]{pp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3905 of file shell.\+c.



References Apnd\+File\+::i\+Pg\+One, O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Fetch.


\begin{DoxyCode}
3910  \{
3911   ApndFile *p = (ApndFile *)pFile;
3912   pFile = ORIGFILE(pFile);
3913   \textcolor{keywordflow}{return} pFile->pMethods->xFetch(pFile, iOfst+p->iPgOne, iAmt, pp);
3914 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a44b6c832481d3f9181f7c5e49fb02dc6}} 
\index{shell.\+c@{shell.\+c}!apnd\+File\+Control@{apnd\+File\+Control}}
\index{apnd\+File\+Control@{apnd\+File\+Control}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+File\+Control()}
{\footnotesize\ttfamily static int apnd\+File\+Control (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{int}]{op,  }\item[{void $\ast$}]{p\+Arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3847 of file shell.\+c.



References Apnd\+File\+::i\+Pg\+One, O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, sqlite3\+\_\+mprintf, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+V\+F\+S\+N\+A\+ME, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and sqlite3\+\_\+io\+\_\+methods\+::x\+File\+Control.


\begin{DoxyCode}
3847                                                                    \{
3848   ApndFile *p = (ApndFile *)pFile;
3849   \textcolor{keywordtype}{int} rc;
3850   pFile = ORIGFILE(pFile);
3851   rc = pFile->pMethods->xFileControl(pFile, op, pArg);
3852   \textcolor{keywordflow}{if}( rc==SQLITE_OK && op==SQLITE_FCNTL_VFSNAME )\{
3853     *(\textcolor{keywordtype}{char}**)pArg = sqlite3_mprintf(\textcolor{stringliteral}{"apnd(%lld)/%z"}, p->iPgOne, *(\textcolor{keywordtype}{char}**)pArg);
3854   \}
3855   \textcolor{keywordflow}{return} rc;
3856 \}
\end{DoxyCode}
\mbox{\label{shell_8c_af3acc4a7f41800f1e0853485725fc810}} 
\index{shell.\+c@{shell.\+c}!apnd\+File\+Size@{apnd\+File\+Size}}
\index{apnd\+File\+Size@{apnd\+File\+Size}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+File\+Size()}
{\footnotesize\ttfamily static int apnd\+File\+Size (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{\textbf{ sqlite3\+\_\+int64} $\ast$}]{p\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3809 of file shell.\+c.



References A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE, Apnd\+File\+::i\+Pg\+One, O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and sqlite3\+\_\+io\+\_\+methods\+::x\+File\+Size.


\begin{DoxyCode}
3809                                                                  \{
3810   ApndFile *p = (ApndFile *)pFile;
3811   \textcolor{keywordtype}{int} rc;
3812   pFile = ORIGFILE(p);
3813   rc = pFile->pMethods->xFileSize(pFile, pSize);
3814   \textcolor{keywordflow}{if}( rc==SQLITE_OK && p->iPgOne )\{
3815     *pSize -= p->iPgOne + APND_MARK_SIZE;
3816   \}
3817   \textcolor{keywordflow}{return} rc;
3818 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a25e29f113ecdf7dc4b15b6a7f7517c6e}} 
\index{shell.\+c@{shell.\+c}!apnd\+Full\+Pathname@{apnd\+Full\+Pathname}}
\index{apnd\+Full\+Pathname@{apnd\+Full\+Pathname}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Full\+Pathname()}
{\footnotesize\ttfamily static int apnd\+Full\+Pathname (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{const char $\ast$}]{z\+Name,  }\item[{int}]{n\+Out,  }\item[{char $\ast$}]{z\+Out }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4020 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4025  \{
4026   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xFullPathname(ORIGVFS(pVfs),zPath,nOut,zOut);
4027 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab3bf715e5cb2bb85d29669605aac6b81}} 
\index{shell.\+c@{shell.\+c}!apnd\+Get\+Last\+Error@{apnd\+Get\+Last\+Error}}
\index{apnd\+Get\+Last\+Error@{apnd\+Get\+Last\+Error}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Get\+Last\+Error()}
{\footnotesize\ttfamily static int apnd\+Get\+Last\+Error (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{int}]{a,  }\item[{char $\ast$}]{b }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4049 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4049                                                               \{
4050   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xGetLastError(ORIGVFS(pVfs), a, b);
4051 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad5ed9227a9fbb33ac59e9d2ac1165fcb}} 
\index{shell.\+c@{shell.\+c}!apnd\+Get\+System\+Call@{apnd\+Get\+System\+Call}}
\index{apnd\+Get\+System\+Call@{apnd\+Get\+System\+Call}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Get\+System\+Call()}
{\footnotesize\ttfamily static \textbf{ sqlite3\+\_\+syscall\+\_\+ptr} apnd\+Get\+System\+Call (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{const char $\ast$}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4062 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4065  \{
4066   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xGetSystemCall(ORIGVFS(pVfs),zName);
4067 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad2daeaaf7d56eb5d01d86ab5df99069e}} 
\index{shell.\+c@{shell.\+c}!apnd\+Is\+Ordinary\+Database\+File@{apnd\+Is\+Ordinary\+Database\+File}}
\index{apnd\+Is\+Ordinary\+Database\+File@{apnd\+Is\+Ordinary\+Database\+File}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Is\+Ordinary\+Database\+File()}
{\footnotesize\ttfamily static int apnd\+Is\+Ordinary\+Database\+File (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+int64}}]{sz,  }\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3926 of file shell.\+c.



References sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Read.



Referenced by apnd\+Open().


\begin{DoxyCode}
3926                                                                             \{
3927   \textcolor{keywordtype}{int} rc;
3928   \textcolor{keywordtype}{char} zHdr[16];
3929   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} aSqliteHdr[] = \textcolor{stringliteral}{"SQLite format 3"};
3930   \textcolor{keywordflow}{if}( sz<512 ) \textcolor{keywordflow}{return} 0;
3931   rc = pFile->pMethods->xRead(pFile, zHdr, \textcolor{keyword}{sizeof}(zHdr), 0);
3932   \textcolor{keywordflow}{if}( rc ) \textcolor{keywordflow}{return} 0;
3933   \textcolor{keywordflow}{return} memcmp(zHdr, aSqliteHdr, \textcolor{keyword}{sizeof}(zHdr))==0;
3934 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a7ec7d9c0d514b7cc9ac9815807206b3a}} 
\index{shell.\+c@{shell.\+c}!apnd\+Lock@{apnd\+Lock}}
\index{apnd\+Lock@{apnd\+Lock}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Lock()}
{\footnotesize\ttfamily static int apnd\+Lock (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{int}]{e\+Lock }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3823 of file shell.\+c.



References O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Lock.


\begin{DoxyCode}
3823                                                    \{
3824   pFile = ORIGFILE(pFile);
3825   \textcolor{keywordflow}{return} pFile->pMethods->xLock(pFile, eLock);
3826 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a8bcbf0e9abb879f9eb2d372dbf2f99b4}} 
\index{shell.\+c@{shell.\+c}!apnd\+Next\+System\+Call@{apnd\+Next\+System\+Call}}
\index{apnd\+Next\+System\+Call@{apnd\+Next\+System\+Call}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Next\+System\+Call()}
{\footnotesize\ttfamily static const char $\ast$ apnd\+Next\+System\+Call (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{const char $\ast$}]{z\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4068 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4068                                                                            \{
4069   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xNextSystemCall(ORIGVFS(pVfs), zName);
4070 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a259c60ec576d3eaf098ed090009a4e8b}} 
\index{shell.\+c@{shell.\+c}!apnd\+Open@{apnd\+Open}}
\index{apnd\+Open@{apnd\+Open}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Open()}
{\footnotesize\ttfamily static int apnd\+Open (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{const char $\ast$}]{z\+Name,  }\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{int}]{flags,  }\item[{int $\ast$}]{p\+Out\+Flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3960 of file shell.\+c.



References apnd\+\_\+io\+\_\+methods, apnd\+Is\+Ordinary\+Database\+File(), apnd\+Read\+Mark(), Apnd\+File\+::base, Apnd\+File\+::i\+Mark, Apnd\+File\+::i\+Pg\+One, O\+R\+I\+G\+F\+I\+LE, O\+R\+I\+G\+V\+FS, sqlite3\+\_\+file\+::p\+Methods, S\+Q\+L\+I\+T\+E\+\_\+\+C\+A\+N\+T\+O\+P\+EN, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+C\+R\+E\+A\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+M\+A\+I\+N\+\_\+\+DB, sqlite3\+\_\+vfs\+::sz\+Os\+File, sqlite3\+\_\+io\+\_\+methods\+::x\+Close, sqlite3\+\_\+io\+\_\+methods\+::x\+File\+Size, and sqlite3\+\_\+vfs\+::x\+Open.


\begin{DoxyCode}
3966  \{
3967   ApndFile *p;
3968   sqlite3_file *pSubFile;
3969   sqlite3_vfs *pSubVfs;
3970   \textcolor{keywordtype}{int} rc;
3971   sqlite3_int64 sz;
3972   pSubVfs = ORIGVFS(pVfs);
3973   \textcolor{keywordflow}{if}( (flags & SQLITE_OPEN_MAIN_DB)==0 )\{
3974     \textcolor{keywordflow}{return} pSubVfs->xOpen(pSubVfs, zName, pFile, flags, pOutFlags);
3975   \}
3976   p = (ApndFile*)pFile;
3977   memset(p, 0, \textcolor{keyword}{sizeof}(*p));
3978   pSubFile = ORIGFILE(pFile);
3979   p->base.pMethods = &apnd_io_methods;
3980   rc = pSubVfs->xOpen(pSubVfs, zName, pSubFile, flags, pOutFlags);
3981   \textcolor{keywordflow}{if}( rc ) \textcolor{keywordflow}{goto} apnd\_open\_done;
3982   rc = pSubFile->pMethods->xFileSize(pSubFile, &sz);
3983   \textcolor{keywordflow}{if}( rc )\{
3984     pSubFile->pMethods->xClose(pSubFile);
3985     \textcolor{keywordflow}{goto} apnd\_open\_done;
3986   \}
3987   \textcolor{keywordflow}{if}( apndIsOrdinaryDatabaseFile(sz, pSubFile) )\{
3988     memmove(pFile, pSubFile, pSubVfs->szOsFile);
3989     \textcolor{keywordflow}{return} SQLITE_OK;
3990   \}
3991   p->iMark = 0;
3992   p->iPgOne = apndReadMark(sz, pFile);
3993   \textcolor{keywordflow}{if}( p->iPgOne>0 )\{
3994     \textcolor{keywordflow}{return} SQLITE_OK;
3995   \}
3996   \textcolor{keywordflow}{if}( (flags & SQLITE_OPEN_CREATE)==0 )\{
3997     pSubFile->pMethods->xClose(pSubFile);
3998     rc = SQLITE_CANTOPEN;
3999   \}
4000   p->iPgOne = (sz+0xfff) & ~(sqlite3_int64)0xfff;
4001 apnd\_open\_done:
4002   \textcolor{keywordflow}{if}( rc ) pFile->pMethods = 0;
4003   \textcolor{keywordflow}{return} rc;
4004 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a504ea3b4aa62fb9f60b440e242d28538}} 
\index{shell.\+c@{shell.\+c}!apnd\+Randomness@{apnd\+Randomness}}
\index{apnd\+Randomness@{apnd\+Randomness}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Randomness()}
{\footnotesize\ttfamily static int apnd\+Randomness (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{int}]{n\+Byte,  }\item[{char $\ast$}]{z\+Out }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4040 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4040                                                                       \{
4041   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xRandomness(ORIGVFS(pVfs), nByte, zBufOut);
4042 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a8841af35431e993f748d31af994d4124}} 
\index{shell.\+c@{shell.\+c}!apnd\+Read@{apnd\+Read}}
\index{apnd\+Read@{apnd\+Read}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Read()}
{\footnotesize\ttfamily static int apnd\+Read (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{void $\ast$}]{z\+Buf,  }\item[{int}]{i\+Amt,  }\item[{\textbf{ sqlite3\+\_\+int64}}]{i\+Ofst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3731 of file shell.\+c.



References Apnd\+File\+::i\+Pg\+One, O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Read.


\begin{DoxyCode}
3736  \{
3737   ApndFile *p = (ApndFile *)pFile;
3738   pFile = ORIGFILE(pFile);
3739   \textcolor{keywordflow}{return} pFile->pMethods->xRead(pFile, zBuf, iAmt, iOfst+p->iPgOne);
3740 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a98981cc0d314a85d78f7a6524a811037}} 
\index{shell.\+c@{shell.\+c}!apnd\+Read\+Mark@{apnd\+Read\+Mark}}
\index{apnd\+Read\+Mark@{apnd\+Read\+Mark}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Read\+Mark()}
{\footnotesize\ttfamily static \textbf{ sqlite3\+\_\+int64} apnd\+Read\+Mark (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+int64}}]{sz,  }\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3941 of file shell.\+c.



References A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+IX, A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+SZ, A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Read.



Referenced by apnd\+Open().


\begin{DoxyCode}
3941                                                                         \{
3942   \textcolor{keywordtype}{int} rc, i;
3943   sqlite3_int64 iMark;
3944   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} a[APND_MARK_SIZE];
3945 
3946   \textcolor{keywordflow}{if}( sz<=APND_MARK_SIZE ) \textcolor{keywordflow}{return} -1;
3947   rc = pFile->pMethods->xRead(pFile, a, APND_MARK_SIZE, sz-APND_MARK_SIZE);
3948   \textcolor{keywordflow}{if}( rc ) \textcolor{keywordflow}{return} -1;
3949   \textcolor{keywordflow}{if}( memcmp(a, APND_MARK_PREFIX, APND_MARK_PREFIX_SZ)!=0 ) \textcolor{keywordflow}{return} -1;
3950   iMark = ((sqlite3_int64)(a[APND_MARK_PREFIX_SZ]&0x7f))<<56;
3951   \textcolor{keywordflow}{for}(i=1; i<8; i++)\{    
3952     iMark += (sqlite3_int64)a[APND_MARK_PREFIX_SZ+i]<<(56-8*i);
3953   \}
3954   \textcolor{keywordflow}{return} iMark;
3955 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a176ba25e6fe049e726c7cf938ce71367}} 
\index{shell.\+c@{shell.\+c}!apnd\+Sector\+Size@{apnd\+Sector\+Size}}
\index{apnd\+Sector\+Size@{apnd\+Sector\+Size}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Sector\+Size()}
{\footnotesize\ttfamily static int apnd\+Sector\+Size (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3861 of file shell.\+c.



References O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Sector\+Size.


\begin{DoxyCode}
3861                                               \{
3862   pFile = ORIGFILE(pFile);
3863   \textcolor{keywordflow}{return} pFile->pMethods->xSectorSize(pFile);
3864 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a797948d0e8d9f7fbf55e81fe616091eb}} 
\index{shell.\+c@{shell.\+c}!apnd\+Set\+System\+Call@{apnd\+Set\+System\+Call}}
\index{apnd\+Set\+System\+Call@{apnd\+Set\+System\+Call}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Set\+System\+Call()}
{\footnotesize\ttfamily static int apnd\+Set\+System\+Call (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{const char $\ast$}]{z\+Name,  }\item[{\textbf{ sqlite3\+\_\+syscall\+\_\+ptr}}]{p\+Call }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4055 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4059  \{
4060   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xSetSystemCall(ORIGVFS(pVfs),zName,pCall);
4061 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a2850053c07d3e73802a64c392a5cc505}} 
\index{shell.\+c@{shell.\+c}!apnd\+Shm\+Barrier@{apnd\+Shm\+Barrier}}
\index{apnd\+Shm\+Barrier@{apnd\+Shm\+Barrier}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Shm\+Barrier()}
{\footnotesize\ttfamily static void apnd\+Shm\+Barrier (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3893 of file shell.\+c.



References O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Shm\+Barrier.


\begin{DoxyCode}
3893                                                \{
3894   pFile = ORIGFILE(pFile);
3895   pFile->pMethods->xShmBarrier(pFile);
3896 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a4d08800d58a64016bdcd385724f691e8}} 
\index{shell.\+c@{shell.\+c}!apnd\+Shm\+Lock@{apnd\+Shm\+Lock}}
\index{apnd\+Shm\+Lock@{apnd\+Shm\+Lock}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Shm\+Lock()}
{\footnotesize\ttfamily static int apnd\+Shm\+Lock (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{int}]{offset,  }\item[{int}]{n,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3887 of file shell.\+c.



References O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Shm\+Lock.


\begin{DoxyCode}
3887                                                                          \{
3888   pFile = ORIGFILE(pFile);
3889   \textcolor{keywordflow}{return} pFile->pMethods->xShmLock(pFile,offset,n,flags);
3890 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a167ef5896a9a56ee17d171fd3a6258ec}} 
\index{shell.\+c@{shell.\+c}!apnd\+Shm\+Map@{apnd\+Shm\+Map}}
\index{apnd\+Shm\+Map@{apnd\+Shm\+Map}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Shm\+Map()}
{\footnotesize\ttfamily static int apnd\+Shm\+Map (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{int}]{i\+Pg,  }\item[{int}]{pgsz,  }\item[{int}]{b\+Extend,  }\item[{void volatile $\ast$$\ast$}]{pp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3875 of file shell.\+c.



References O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Shm\+Map.


\begin{DoxyCode}
3881  \{
3882   pFile = ORIGFILE(pFile);
3883   \textcolor{keywordflow}{return} pFile->pMethods->xShmMap(pFile,iPg,pgsz,bExtend,pp);
3884 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a490bad72b8b72757f952cbff75b72a77}} 
\index{shell.\+c@{shell.\+c}!apnd\+Shm\+Unmap@{apnd\+Shm\+Unmap}}
\index{apnd\+Shm\+Unmap@{apnd\+Shm\+Unmap}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Shm\+Unmap()}
{\footnotesize\ttfamily static int apnd\+Shm\+Unmap (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{int}]{delete\+Flag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3899 of file shell.\+c.



References O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Shm\+Unmap.


\begin{DoxyCode}
3899                                                             \{
3900   pFile = ORIGFILE(pFile);
3901   \textcolor{keywordflow}{return} pFile->pMethods->xShmUnmap(pFile,deleteFlag);
3902 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a6498cf8468071fb7ddf481ea00fdcc24}} 
\index{shell.\+c@{shell.\+c}!apnd\+Sleep@{apnd\+Sleep}}
\index{apnd\+Sleep@{apnd\+Sleep}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Sleep()}
{\footnotesize\ttfamily static int apnd\+Sleep (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vfs} $\ast$}]{p\+Vfs,  }\item[{int}]{microseconds }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4043 of file shell.\+c.



References O\+R\+I\+G\+V\+FS.


\begin{DoxyCode}
4043                                                    \{
4044   \textcolor{keywordflow}{return} ORIGVFS(pVfs)->xSleep(ORIGVFS(pVfs), nMicro);
4045 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a4145c58e00a13901b9db111f1cd6ad93}} 
\index{shell.\+c@{shell.\+c}!apnd\+Sync@{apnd\+Sync}}
\index{apnd\+Sync@{apnd\+Sync}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Sync()}
{\footnotesize\ttfamily static int apnd\+Sync (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3801 of file shell.\+c.



References O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Sync.


\begin{DoxyCode}
3801                                                    \{
3802   pFile = ORIGFILE(pFile);
3803   \textcolor{keywordflow}{return} pFile->pMethods->xSync(pFile, flags);
3804 \}
\end{DoxyCode}
\mbox{\label{shell_8c_abf525bdb54a79173b0b8a9e75d42523f}} 
\index{shell.\+c@{shell.\+c}!apnd\+Truncate@{apnd\+Truncate}}
\index{apnd\+Truncate@{apnd\+Truncate}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Truncate()}
{\footnotesize\ttfamily static int apnd\+Truncate (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{\textbf{ sqlite3\+\_\+int64}}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3786 of file shell.\+c.



References A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE, apnd\+Write\+Mark(), Apnd\+File\+::i\+Mark, Apnd\+File\+::i\+Pg\+One, O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and sqlite3\+\_\+io\+\_\+methods\+::x\+Truncate.


\begin{DoxyCode}
3786                                                                \{
3787   \textcolor{keywordtype}{int} rc;
3788   ApndFile *p = (ApndFile *)pFile;
3789   pFile = ORIGFILE(pFile);
3790   rc = pFile->pMethods->xTruncate(pFile, size+p->iPgOne+APND_MARK_SIZE);
3791   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
3792     p->iMark = p->iPgOne+size;
3793     rc = apndWriteMark(p, pFile);
3794   \}
3795   \textcolor{keywordflow}{return} rc;
3796 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a5cf8f7e6152b7c99955fa800bcb42ccb}} 
\index{shell.\+c@{shell.\+c}!apnd\+Unfetch@{apnd\+Unfetch}}
\index{apnd\+Unfetch@{apnd\+Unfetch}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Unfetch()}
{\footnotesize\ttfamily static int apnd\+Unfetch (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{\textbf{ sqlite3\+\_\+int64}}]{i\+Ofst,  }\item[{void $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3917 of file shell.\+c.



References Apnd\+File\+::i\+Pg\+One, O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Unfetch.


\begin{DoxyCode}
3917                                                                              \{
3918   ApndFile *p = (ApndFile *)pFile;
3919   pFile = ORIGFILE(pFile);
3920   \textcolor{keywordflow}{return} pFile->pMethods->xUnfetch(pFile, iOfst+p->iPgOne, pPage);
3921 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae2e239974dda66ff818d6b9dabb6129c}} 
\index{shell.\+c@{shell.\+c}!apnd\+Unlock@{apnd\+Unlock}}
\index{apnd\+Unlock@{apnd\+Unlock}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Unlock()}
{\footnotesize\ttfamily static int apnd\+Unlock (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{int}]{e\+Lock }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3831 of file shell.\+c.



References O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Unlock.


\begin{DoxyCode}
3831                                                      \{
3832   pFile = ORIGFILE(pFile);
3833   \textcolor{keywordflow}{return} pFile->pMethods->xUnlock(pFile, eLock);
3834 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a8cf8ea995613de257fae55a25639d9b8}} 
\index{shell.\+c@{shell.\+c}!apnd\+Write@{apnd\+Write}}
\index{apnd\+Write@{apnd\+Write}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Write()}
{\footnotesize\ttfamily static int apnd\+Write (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File,  }\item[{const void $\ast$}]{z\+Buf,  }\item[{int}]{i\+Amt,  }\item[{\textbf{ sqlite3\+\_\+int64}}]{i\+Ofst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3758 of file shell.\+c.



References A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE, A\+P\+N\+D\+\_\+\+M\+A\+X\+\_\+\+S\+I\+ZE, apnd\+Write\+Mark(), Apnd\+File\+::i\+Mark, Apnd\+File\+::i\+Pg\+One, O\+R\+I\+G\+F\+I\+LE, sqlite3\+\_\+file\+::p\+Methods, S\+Q\+L\+I\+T\+E\+\_\+\+F\+U\+LL, S\+Q\+L\+I\+T\+E\+\_\+\+OK, sqlite3\+\_\+io\+\_\+methods\+::x\+File\+Size, and sqlite3\+\_\+io\+\_\+methods\+::x\+Write.


\begin{DoxyCode}
3763  \{
3764   \textcolor{keywordtype}{int} rc;
3765   ApndFile *p = (ApndFile *)pFile;
3766   pFile = ORIGFILE(pFile);
3767   \textcolor{keywordflow}{if}( iOfst+iAmt>=APND_MAX_SIZE ) \textcolor{keywordflow}{return} SQLITE_FULL;
3768   rc = pFile->pMethods->xWrite(pFile, zBuf, iAmt, iOfst+p->iPgOne);
3769   \textcolor{keywordflow}{if}( rc==SQLITE_OK &&  iOfst + iAmt + p->iPgOne > p->iMark )\{
3770     sqlite3_int64 sz = 0;
3771     rc = pFile->pMethods->xFileSize(pFile, &sz);
3772     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
3773       p->iMark = sz - APND_MARK_SIZE;
3774       \textcolor{keywordflow}{if}( iOfst + iAmt + p->iPgOne > p->iMark )\{
3775         p->iMark = p->iPgOne + iOfst + iAmt;
3776         rc = apndWriteMark(p, pFile);
3777       \}
3778     \}
3779   \}
3780   \textcolor{keywordflow}{return} rc;
3781 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a00b0e903a410cc1b39c14574abd67387}} 
\index{shell.\+c@{shell.\+c}!apnd\+Write\+Mark@{apnd\+Write\+Mark}}
\index{apnd\+Write\+Mark@{apnd\+Write\+Mark}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Write\+Mark()}
{\footnotesize\ttfamily static int apnd\+Write\+Mark (\begin{DoxyParamCaption}\item[{\textbf{ Apnd\+File} $\ast$}]{p,  }\item[{\textbf{ sqlite3\+\_\+file} $\ast$}]{p\+File }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3745 of file shell.\+c.



References A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+IX, A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+SZ, A\+P\+N\+D\+\_\+\+M\+A\+R\+K\+\_\+\+S\+I\+ZE, Apnd\+File\+::i\+Mark, Apnd\+File\+::i\+Pg\+One, sqlite3\+\_\+file\+::p\+Methods, and sqlite3\+\_\+io\+\_\+methods\+::x\+Write.



Referenced by apnd\+Truncate(), and apnd\+Write().


\begin{DoxyCode}
3745                                                           \{
3746   \textcolor{keywordtype}{int} i;
3747   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} a[APND_MARK_SIZE];
3748   memcpy(a, APND_MARK_PREFIX, APND_MARK_PREFIX_SZ);
3749   \textcolor{keywordflow}{for}(i=0; i<8; i++)\{
3750     a[APND_MARK_PREFIX_SZ+i] = (p->iPgOne >> (56 - i*8)) & 0xff;
3751   \}
3752   \textcolor{keywordflow}{return} pFile->pMethods->xWrite(pFile, a, APND_MARK_SIZE, p->iMark);
3753 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a27a1507709a310ba8da26cbdaead66fd}} 
\index{shell.\+c@{shell.\+c}!append\+Text@{append\+Text}}
\index{append\+Text@{append\+Text}!shell.\+c@{shell.\+c}}
\subsubsection{append\+Text()}
{\footnotesize\ttfamily static void append\+Text (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+Text} $\ast$}]{p,  }\item[{char const $\ast$}]{z\+Append,  }\item[{char}]{quote }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 750 of file shell.\+c.



References Shell\+Text\+::n, Shell\+Text\+::n\+Alloc, shell\+\_\+out\+\_\+of\+\_\+memory(), strlen30(), and Shell\+Text\+::z.



Referenced by capture\+Output\+Callback(), do\+\_\+meta\+\_\+command(), dump\+\_\+callback(), and shell\+Fake\+Schema().


\begin{DoxyCode}
750                                                                      \{
751   \textcolor{keywordtype}{int} len;
752   \textcolor{keywordtype}{int} i;
753   \textcolor{keywordtype}{int} nAppend = strlen30(zAppend);
754 
755   len = nAppend+p->n+1;
756   \textcolor{keywordflow}{if}( quote )\{
757     len += 2;
758     \textcolor{keywordflow}{for}(i=0; i<nAppend; i++)\{
759       \textcolor{keywordflow}{if}( zAppend[i]==quote ) len++;
760     \}
761   \}
762 
763   \textcolor{keywordflow}{if}( p->n+len>=p->nAlloc )\{
764     p->nAlloc = p->nAlloc*2 + len + 20;
765     p->z = realloc(p->z, p->nAlloc);
766     \textcolor{keywordflow}{if}( p->z==0 ) shell_out_of_memory();
767   \}
768 
769   \textcolor{keywordflow}{if}( quote )\{
770     \textcolor{keywordtype}{char} *zCsr = p->z+p->n;
771     *zCsr++ = quote;
772     \textcolor{keywordflow}{for}(i=0; i<nAppend; i++)\{
773       *zCsr++ = zAppend[i];
774       \textcolor{keywordflow}{if}( zAppend[i]==quote ) *zCsr++ = quote;
775     \}
776     *zCsr++ = quote;
777     p->n = (int)(zCsr - p->z);
778     *zCsr = \textcolor{charliteral}{'\(\backslash\)0'};
779   \}\textcolor{keywordflow}{else}\{
780     memcpy(p->z+p->n, zAppend, nAppend);
781     p->n += nAppend;
782     p->z[p->n] = \textcolor{charliteral}{'\(\backslash\)0'};
783   \}
784 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a6ba93580d406f8a3de0be001531a0ed1}} 
\index{shell.\+c@{shell.\+c}!ascii\+\_\+read\+\_\+one\+\_\+field@{ascii\+\_\+read\+\_\+one\+\_\+field}}
\index{ascii\+\_\+read\+\_\+one\+\_\+field@{ascii\+\_\+read\+\_\+one\+\_\+field}!shell.\+c@{shell.\+c}}
\subsubsection{ascii\+\_\+read\+\_\+one\+\_\+field()}
{\footnotesize\ttfamily static char$\ast$ \textbf{ S\+Q\+L\+I\+T\+E\+\_\+\+C\+D\+E\+CL} ascii\+\_\+read\+\_\+one\+\_\+field (\begin{DoxyParamCaption}\item[{\textbf{ Import\+Ctx} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13195 of file shell.\+c.



References Import\+Ctx\+::c\+Col\+Sep, Import\+Ctx\+::c\+Row\+Sep, Import\+Ctx\+::c\+Term, import\+\_\+append\+\_\+char(), Import\+Ctx\+::in, Import\+Ctx\+::n, Import\+Ctx\+::n\+Line, and Import\+Ctx\+::z.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13195                                                             \{
13196   \textcolor{keywordtype}{int} c;
13197   \textcolor{keywordtype}{int} cSep = p->cColSep;
13198   \textcolor{keywordtype}{int} rSep = p->cRowSep;
13199   p->n = 0;
13200   c = fgetc(p->in);
13201   \textcolor{keywordflow}{if}( c==EOF || seenInterrupt )\{
13202     p->cTerm = EOF;
13203     \textcolor{keywordflow}{return} 0;
13204   \}
13205   \textcolor{keywordflow}{while}( c!=EOF && c!=cSep && c!=rSep )\{
13206     import_append_char(p, c);
13207     c = fgetc(p->in);
13208   \}
13209   \textcolor{keywordflow}{if}( c==rSep )\{
13210     p->nLine++;
13211   \}
13212   p->cTerm = c;
13213   \textcolor{keywordflow}{if}( p->z ) p->z[p->n] = 0;
13214   \textcolor{keywordflow}{return} p->z;
13215 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a31c9f9db51b6e82fae6cede125ce6e53}} 
\index{shell.\+c@{shell.\+c}!begin\+Timer@{begin\+Timer}}
\index{begin\+Timer@{begin\+Timer}!shell.\+c@{shell.\+c}}
\subsubsection{begin\+Timer()}
{\footnotesize\ttfamily static void begin\+Timer (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 262 of file shell.\+c.



References s\+Begin, and time\+Of\+Day().


\begin{DoxyCode}
262                             \{
263   \textcolor{keywordflow}{if}( enableTimer )\{
264     getrusage(RUSAGE\_SELF, &sBegin);
265     iBegin = timeOfDay();
266   \}
267 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a54910a6637621adcf6607470f92f8425}} 
\index{shell.\+c@{shell.\+c}!bind\+\_\+prepared\+\_\+stmt@{bind\+\_\+prepared\+\_\+stmt}}
\index{bind\+\_\+prepared\+\_\+stmt@{bind\+\_\+prepared\+\_\+stmt}!shell.\+c@{shell.\+c}}
\subsubsection{bind\+\_\+prepared\+\_\+stmt()}
{\footnotesize\ttfamily static void bind\+\_\+prepared\+\_\+stmt (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p\+Arg,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$}]{p\+Stmt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11356 of file shell.\+c.



References Shell\+State\+::db, sqlite3\+\_\+bind\+\_\+null, sqlite3\+\_\+bind\+\_\+parameter\+\_\+count, sqlite3\+\_\+bind\+\_\+parameter\+\_\+name, sqlite3\+\_\+bind\+\_\+text, sqlite3\+\_\+bind\+\_\+value, sqlite3\+\_\+column\+\_\+value, sqlite3\+\_\+finalize, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+reset, sqlite3\+\_\+snprintf, sqlite3\+\_\+step, sqlite3\+\_\+table\+\_\+column\+\_\+metadata, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, and S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+IC.



Referenced by shell\+\_\+exec().


\begin{DoxyCode}
11356                                                                      \{
11357   \textcolor{keywordtype}{int} nVar;
11358   \textcolor{keywordtype}{int} i;
11359   \textcolor{keywordtype}{int} rc;
11360   sqlite3_stmt *pQ = 0;
11361 
11362   nVar = sqlite3_bind_parameter_count(pStmt);
11363   \textcolor{keywordflow}{if}( nVar==0 ) \textcolor{keywordflow}{return};  \textcolor{comment}{/* Nothing to do */}
11364   \textcolor{keywordflow}{if}( sqlite3_table_column_metadata(pArg->db, \textcolor{stringliteral}{"TEMP"}, \textcolor{stringliteral}{"sqlite\_parameters"},
11365                                     \textcolor{stringliteral}{"key"}, 0, 0, 0, 0, 0)!=SQLITE_OK )\{
11366     \textcolor{keywordflow}{return}; \textcolor{comment}{/* Parameter table does not exist */}
11367   \}
11368   rc = sqlite3_prepare_v2(pArg->db,
11369           \textcolor{stringliteral}{"SELECT value FROM temp.sqlite\_parameters"}
11370           \textcolor{stringliteral}{" WHERE key=?1"}, -1, &pQ, 0);
11371   \textcolor{keywordflow}{if}( rc || pQ==0 ) \textcolor{keywordflow}{return};
11372   \textcolor{keywordflow}{for}(i=1; i<=nVar; i++)\{
11373     \textcolor{keywordtype}{char} zNum[30];
11374     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zVar = sqlite3_bind_parameter_name(pStmt, i);
11375     \textcolor{keywordflow}{if}( zVar==0 )\{
11376       sqlite3_snprintf(\textcolor{keyword}{sizeof}(zNum),zNum,\textcolor{stringliteral}{"?%d"},i);
11377       zVar = zNum;
11378     \}
11379     sqlite3_bind_text(pQ, 1, zVar, -1, SQLITE_STATIC);
11380     \textcolor{keywordflow}{if}( sqlite3_step(pQ)==SQLITE_ROW )\{
11381       sqlite3_bind_value(pStmt, i, sqlite3_column_value(pQ, 0));
11382     \}\textcolor{keywordflow}{else}\{
11383       sqlite3_bind_null(pStmt, i);
11384     \}
11385     sqlite3_reset(pQ);
11386   \}
11387   sqlite3_finalize(pQ);
11388 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a32b28762287080385ef4d628ddfbf2bd}} 
\index{shell.\+c@{shell.\+c}!bind\+\_\+table\+\_\+init@{bind\+\_\+table\+\_\+init}}
\index{bind\+\_\+table\+\_\+init@{bind\+\_\+table\+\_\+init}!shell.\+c@{shell.\+c}}
\subsubsection{bind\+\_\+table\+\_\+init()}
{\footnotesize\ttfamily static void bind\+\_\+table\+\_\+init (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11327 of file shell.\+c.



References Shell\+State\+::db, sqlite3\+\_\+db\+\_\+config, sqlite3\+\_\+exec, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+D\+E\+F\+E\+N\+S\+I\+VE, and S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+W\+R\+I\+T\+A\+B\+L\+E\+\_\+\+S\+C\+H\+E\+MA.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
11327                                           \{
11328   \textcolor{keywordtype}{int} wrSchema = 0;
11329   \textcolor{keywordtype}{int} defensiveMode = 0;
11330   sqlite3_db_config(p->db, SQLITE_DBCONFIG_DEFENSIVE, -1, &defensiveMode);
11331   sqlite3_db_config(p->db, SQLITE_DBCONFIG_DEFENSIVE, 0, 0);
11332   sqlite3_db_config(p->db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, -1, &wrSchema);
11333   sqlite3_db_config(p->db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, 1, 0);
11334   sqlite3_exec(p->db,
11335     \textcolor{stringliteral}{"CREATE TABLE IF NOT EXISTS temp.sqlite\_parameters(\(\backslash\)n"}
11336     \textcolor{stringliteral}{"  key TEXT PRIMARY KEY,\(\backslash\)n"}
11337     \textcolor{stringliteral}{"  value ANY\(\backslash\)n"}
11338     \textcolor{stringliteral}{") WITHOUT ROWID;"},
11339     0, 0, 0);
11340   sqlite3_db_config(p->db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, wrSchema, 0);
11341   sqlite3_db_config(p->db, SQLITE_DBCONFIG_DEFENSIVE, defensiveMode, 0);
11342 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad04a5f42b16e4ed5493b42c2d03eaf4b}} 
\index{shell.\+c@{shell.\+c}!boolean\+Value@{boolean\+Value}}
\index{boolean\+Value@{boolean\+Value}!shell.\+c@{shell.\+c}}
\subsubsection{boolean\+Value()}
{\footnotesize\ttfamily static int boolean\+Value (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12938 of file shell.\+c.



References hex\+Digit\+Value(), integer\+Value(), sqlite3\+\_\+stricmp, and utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command(), and set\+Or\+Clear\+Flag().


\begin{DoxyCode}
12938                                          \{
12939   \textcolor{keywordtype}{int} i;
12940   \textcolor{keywordflow}{if}( zArg[0]==\textcolor{charliteral}{'0'} && zArg[1]==\textcolor{charliteral}{'x'} )\{
12941     \textcolor{keywordflow}{for}(i=2; hexDigitValue(zArg[i])>=0; i++)\{\}
12942   \}\textcolor{keywordflow}{else}\{
12943     \textcolor{keywordflow}{for}(i=0; zArg[i]>=\textcolor{charliteral}{'0'} && zArg[i]<=\textcolor{charliteral}{'9'}; i++)\{\}
12944   \}
12945   \textcolor{keywordflow}{if}( i>0 && zArg[i]==0 ) \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int})(integerValue(zArg) & 0xffffffff);
12946   \textcolor{keywordflow}{if}( sqlite3_stricmp(zArg, \textcolor{stringliteral}{"on"})==0 || sqlite3_stricmp(zArg,\textcolor{stringliteral}{"yes"})==0 )\{
12947     \textcolor{keywordflow}{return} 1;
12948   \}
12949   \textcolor{keywordflow}{if}( sqlite3_stricmp(zArg, \textcolor{stringliteral}{"off"})==0 || sqlite3_stricmp(zArg,\textcolor{stringliteral}{"no"})==0 )\{
12950     \textcolor{keywordflow}{return} 0;
12951   \}
12952   utf8_printf(stderr, \textcolor{stringliteral}{"ERROR: Not a boolean value: \(\backslash\)"%s\(\backslash\)". Assuming \(\backslash\)"no\(\backslash\)".\(\backslash\)n"},
12953           zArg);
12954   \textcolor{keywordflow}{return} 0;
12955 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a0c6dc6c47e267588f0ae3cb5c3b4692a}} 
\index{shell.\+c@{shell.\+c}!callback@{callback}}
\index{callback@{callback}!shell.\+c@{shell.\+c}}
\subsubsection{callback()}
{\footnotesize\ttfamily static int callback (\begin{DoxyParamCaption}\item[{void $\ast$}]{p\+Arg,  }\item[{int}]{n\+Arg,  }\item[{char $\ast$$\ast$}]{az\+Arg,  }\item[{char $\ast$$\ast$}]{az\+Col }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10760 of file shell.\+c.



References shell\+\_\+callback().



Referenced by node\+\_\+sqlite3\+::\+Statement\+::\+Bind(), Nan\+::\+Context\+Disposed\+Notification(), Persistent$<$ T, M $>$\+::\+Copy(), do\+\_\+meta\+\_\+command(), imp\+::\+Function\+Callback\+Wrapper(), imp\+::\+Getter\+Callback\+Wrapper(), imp\+::\+Index\+Deleter\+Callback\+Wrapper(), imp\+::\+Index\+Enumerator\+Callback\+Wrapper(), imp\+::\+Index\+Getter\+Callback\+Wrapper(), imp\+::\+Index\+Query\+Callback\+Wrapper(), imp\+::\+Index\+Setter\+Callback\+Wrapper(), N\+A\+N\+\_\+\+M\+E\+T\+H\+O\+D(), Persistent\+Base$<$ T $>$\+::operator!=(), imp\+::\+Property\+Deleter\+Callback\+Wrapper(), imp\+::\+Property\+Enumerator\+Callback\+Wrapper(), imp\+::\+Property\+Getter\+Callback\+Wrapper(), imp\+::\+Property\+Query\+Callback\+Wrapper(), imp\+::\+Property\+Setter\+Callback\+Wrapper(), Persistent$<$ T, M $>$\+::\+Reset(), node\+\_\+sqlite3\+::\+Database\+::\+Schedule(), node\+\_\+sqlite3\+::\+Backup\+::\+Schedule(), node\+\_\+sqlite3\+::\+Statement\+::\+Schedule(), Nan\+::\+Set\+Method(), Nan\+::\+Set\+Prototype\+Method(), imp\+::\+Setter\+Callback\+Wrapper(), Weak\+Callback\+Info$<$ T $>$\+::unwrap(), Nan\+::\+Async\+Worker\+::\+Work\+Complete(), Nan\+::\+Async\+Worker\+::$\sim$\+Async\+Worker(), node\+\_\+sqlite3\+::\+Backup\+::$\sim$\+Backup(), node\+\_\+sqlite3\+::\+Database\+::$\sim$\+Database(), and node\+\_\+sqlite3\+::\+Statement\+::$\sim$\+Statement().


\begin{DoxyCode}
10760                                                                      \{
10761   \textcolor{comment}{/* since we don't have type info, call the shell\_callback with a NULL value */}
10762   \textcolor{keywordflow}{return} shell_callback(pArg, nArg, azArg, azCol, NULL);
10763 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a9dfdefbfac1c168c17f6ebb68f53d159}} 
\index{shell.\+c@{shell.\+c}!capture\+Output\+Callback@{capture\+Output\+Callback}}
\index{capture\+Output\+Callback@{capture\+Output\+Callback}!shell.\+c@{shell.\+c}}
\subsubsection{capture\+Output\+Callback()}
{\footnotesize\ttfamily static int capture\+Output\+Callback (\begin{DoxyParamCaption}\item[{void $\ast$}]{p\+Arg,  }\item[{int}]{n\+Arg,  }\item[{char $\ast$$\ast$}]{az\+Arg,  }\item[{char $\ast$$\ast$}]{az }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10769 of file shell.\+c.



References append\+Text(), Shell\+Text\+::n, and U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
10769                                                                                \{
10770   ShellText *p = (ShellText*)pArg;
10771   \textcolor{keywordtype}{int} i;
10772   UNUSED_PARAMETER(az);
10773   \textcolor{keywordflow}{if}( azArg==0 ) \textcolor{keywordflow}{return} 0;
10774   \textcolor{keywordflow}{if}( p->n ) appendText(p, \textcolor{stringliteral}{"|"}, 0);
10775   \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10776     \textcolor{keywordflow}{if}( i ) appendText(p, \textcolor{stringliteral}{","}, 0);
10777     \textcolor{keywordflow}{if}( azArg[i] ) appendText(p, azArg[i], 0);
10778   \}
10779   \textcolor{keywordflow}{return} 0;
10780 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae49496a18a1ff227d96f3cd7fc5d6918}} 
\index{shell.\+c@{shell.\+c}!clear\+Temp\+File@{clear\+Temp\+File}}
\index{clear\+Temp\+File@{clear\+Temp\+File}!shell.\+c@{shell.\+c}}
\subsubsection{clear\+Temp\+File()}
{\footnotesize\ttfamily static void clear\+Temp\+File (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13732 of file shell.\+c.



References Shell\+State\+::do\+Xdg\+Open, shell\+Delete\+File(), sqlite3\+\_\+free, and Shell\+State\+::z\+Temp\+File.



Referenced by do\+\_\+meta\+\_\+command(), main(), new\+Temp\+File(), and process\+\_\+input().


\begin{DoxyCode}
13732                                         \{
13733   \textcolor{keywordflow}{if}( p->zTempFile==0 ) \textcolor{keywordflow}{return};
13734   \textcolor{keywordflow}{if}( p->doXdgOpen ) \textcolor{keywordflow}{return};
13735   \textcolor{keywordflow}{if}( shellDeleteFile(p->zTempFile) ) \textcolor{keywordflow}{return};
13736   sqlite3_free(p->zTempFile);
13737   p->zTempFile = 0;
13738 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a4345bbdec858c9c3de6e1a7ebe8924c0}} 
\index{shell.\+c@{shell.\+c}!close\+\_\+db@{close\+\_\+db}}
\index{close\+\_\+db@{close\+\_\+db}!shell.\+c@{shell.\+c}}
\subsubsection{close\+\_\+db()}
{\footnotesize\ttfamily void close\+\_\+db (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db }\end{DoxyParamCaption})}



Definition at line 12802 of file shell.\+c.



References sqlite3\+\_\+close, sqlite3\+\_\+column\+\_\+bytes, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+errmsg, sqlite3\+\_\+exec, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, strlen30(), and utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command(), main(), shell\+Reset(), and try\+To\+Clone().


\begin{DoxyCode}
12802                           \{
12803   \textcolor{keywordtype}{int} rc = sqlite3_close(db);
12804   \textcolor{keywordflow}{if}( rc )\{
12805     utf8_printf(stderr, \textcolor{stringliteral}{"Error: sqlite3\_close() returns %d: %s\(\backslash\)n"},
12806         rc, sqlite3_errmsg(db));
12807   \} 
12808 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a22d588f7badcc45956201450a9307388}} 
\index{shell.\+c@{shell.\+c}!cmdline\+\_\+option\+\_\+value@{cmdline\+\_\+option\+\_\+value}}
\index{cmdline\+\_\+option\+\_\+value@{cmdline\+\_\+option\+\_\+value}!shell.\+c@{shell.\+c}}
\subsubsection{cmdline\+\_\+option\+\_\+value()}
{\footnotesize\ttfamily static char$\ast$ cmdline\+\_\+option\+\_\+value (\begin{DoxyParamCaption}\item[{int}]{argc,  }\item[{char $\ast$$\ast$}]{argv,  }\item[{int}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18647 of file shell.\+c.



References utf8\+\_\+printf.



Referenced by main().


\begin{DoxyCode}
18647                                                                \{
18648   \textcolor{keywordflow}{if}( i==argc )\{
18649     utf8_printf(stderr, \textcolor{stringliteral}{"%s: Error: missing argument to %s\(\backslash\)n"},
18650             argv[0], argv[argc-1]);
18651     exit(1);
18652   \}
18653   \textcolor{keywordflow}{return} argv[i];
18654 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad5165ab4e9fa033fb29687bcef5711ad}} 
\index{shell.\+c@{shell.\+c}!completion\+Best\+Index@{completion\+Best\+Index}}
\index{completion\+Best\+Index@{completion\+Best\+Index}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Best\+Index()}
{\footnotesize\ttfamily static int completion\+Best\+Index (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$}]{tab,  }\item[{\textbf{ sqlite3\+\_\+index\+\_\+info} $\ast$}]{p\+Idx\+Info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3437 of file shell.\+c.



References sqlite3\+\_\+index\+\_\+info\+::a\+Constraint, sqlite3\+\_\+index\+\_\+info\+::a\+Constraint\+Usage, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+constraint\+\_\+usage\+::argv\+Index, C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+R\+E\+F\+IX, C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+W\+H\+O\+L\+E\+L\+I\+NE, sqlite3\+\_\+index\+\_\+info\+::estimated\+Cost, sqlite3\+\_\+index\+\_\+info\+::estimated\+Rows, sqlite3\+\_\+index\+\_\+info\+::idx\+Num, sqlite3\+\_\+index\+\_\+info\+::n\+Constraint, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+constraint\+\_\+usage\+::omit, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+N\+T\+\_\+\+EQ, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.


\begin{DoxyCode}
3440  \{
3441   \textcolor{keywordtype}{int} i;                 \textcolor{comment}{/* Loop over constraints */}
3442   \textcolor{keywordtype}{int} idxNum = 0;        \textcolor{comment}{/* The query plan bitmask */}
3443   \textcolor{keywordtype}{int} prefixIdx = -1;    \textcolor{comment}{/* Index of the start= constraint, or -1 if none */}
3444   \textcolor{keywordtype}{int} wholelineIdx = -1; \textcolor{comment}{/* Index of the stop= constraint, or -1 if none */}
3445   \textcolor{keywordtype}{int} nArg = 0;          \textcolor{comment}{/* Number of arguments that completeFilter() expects */}
3446   \textcolor{keyword}{const} \textcolor{keyword}{struct }sqlite3\_index\_constraint *pConstraint;
3447 
3448   (void)(tab);    \textcolor{comment}{/* Unused parameter */}
3449   pConstraint = pIdxInfo->aConstraint;
3450   \textcolor{keywordflow}{for}(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++)\{
3451     \textcolor{keywordflow}{if}( pConstraint->usable==0 ) \textcolor{keywordflow}{continue};
3452     \textcolor{keywordflow}{if}( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) \textcolor{keywordflow}{continue};
3453     \textcolor{keywordflow}{switch}( pConstraint->iColumn )\{
3454       \textcolor{keywordflow}{case} COMPLETION_COLUMN_PREFIX:
3455         prefixIdx = i;
3456         idxNum |= 1;
3457         \textcolor{keywordflow}{break};
3458       \textcolor{keywordflow}{case} COMPLETION_COLUMN_WHOLELINE:
3459         wholelineIdx = i;
3460         idxNum |= 2;
3461         \textcolor{keywordflow}{break};
3462     \}
3463   \}
3464   \textcolor{keywordflow}{if}( prefixIdx>=0 )\{
3465     pIdxInfo->aConstraintUsage[prefixIdx].argvIndex = ++nArg;
3466     pIdxInfo->aConstraintUsage[prefixIdx].omit = 1;
3467   \}
3468   \textcolor{keywordflow}{if}( wholelineIdx>=0 )\{
3469     pIdxInfo->aConstraintUsage[wholelineIdx].argvIndex = ++nArg;
3470     pIdxInfo->aConstraintUsage[wholelineIdx].omit = 1;
3471   \}
3472   pIdxInfo->idxNum = idxNum;
3473   pIdxInfo->estimatedCost = (double)5000 - 1000*nArg;
3474   pIdxInfo->estimatedRows = 500 - 100*nArg;
3475   \textcolor{keywordflow}{return} SQLITE_OK;
3476 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a1d87b2f9f3fb19b59559c2353f657108}} 
\index{shell.\+c@{shell.\+c}!completion\+Close@{completion\+Close}}
\index{completion\+Close@{completion\+Close}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Close()}
{\footnotesize\ttfamily static int completion\+Close (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3206 of file shell.\+c.



References completion\+Cursor\+Reset(), sqlite3\+\_\+free, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.


\begin{DoxyCode}
3206                                                     \{
3207   completionCursorReset((completion_cursor*)cur);
3208   sqlite3_free(cur);
3209   \textcolor{keywordflow}{return} SQLITE_OK;
3210 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a626602ebdb59f4829f1c5940a63d9c45}} 
\index{shell.\+c@{shell.\+c}!completion\+Column@{completion\+Column}}
\index{completion\+Column@{completion\+Column}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Column()}
{\footnotesize\ttfamily static int completion\+Column (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur,  }\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{ctx,  }\item[{int}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3334 of file shell.\+c.



References C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+C\+A\+N\+D\+I\+D\+A\+TE, C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+H\+A\+SE, C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+R\+E\+F\+IX, C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+W\+H\+O\+L\+E\+L\+I\+NE, completion\+\_\+cursor\+::e\+Phase, sqlite3\+\_\+result\+\_\+int, sqlite3\+\_\+result\+\_\+text, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT, completion\+\_\+cursor\+::sz\+Row, completion\+\_\+cursor\+::z\+Current\+Row, completion\+\_\+cursor\+::z\+Line, and completion\+\_\+cursor\+::z\+Prefix.


\begin{DoxyCode}
3338  \{
3339   completion_cursor *pCur = (completion_cursor*)cur;
3340   \textcolor{keywordflow}{switch}( i )\{
3341     \textcolor{keywordflow}{case} COMPLETION_COLUMN_CANDIDATE: \{
3342       sqlite3_result_text(ctx, pCur->zCurrentRow, pCur->szRow,SQLITE_TRANSIENT);
3343       \textcolor{keywordflow}{break};
3344     \}
3345     \textcolor{keywordflow}{case} COMPLETION_COLUMN_PREFIX: \{
3346       sqlite3_result_text(ctx, pCur->zPrefix, -1, SQLITE_TRANSIENT);
3347       \textcolor{keywordflow}{break};
3348     \}
3349     \textcolor{keywordflow}{case} COMPLETION_COLUMN_WHOLELINE: \{
3350       sqlite3_result_text(ctx, pCur->zLine, -1, SQLITE_TRANSIENT);
3351       \textcolor{keywordflow}{break};
3352     \}
3353     \textcolor{keywordflow}{case} COMPLETION_COLUMN_PHASE: \{
3354       sqlite3_result_int(ctx, pCur->ePhase);
3355       \textcolor{keywordflow}{break};
3356     \}
3357   \}
3358   \textcolor{keywordflow}{return} SQLITE_OK;
3359 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a9a72a8ed1313bd2f35edfe3aefcdb503}} 
\index{shell.\+c@{shell.\+c}!completion\+Connect@{completion\+Connect}}
\index{completion\+Connect@{completion\+Connect}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Connect()}
{\footnotesize\ttfamily static int completion\+Connect (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{void $\ast$}]{p\+Aux,  }\item[{int}]{argc,  }\item[{const char $\ast$const $\ast$}]{argv,  }\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$$\ast$}]{pp\+Vtab,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3133 of file shell.\+c.



References completion\+\_\+vtab\+::db, sqlite3\+\_\+declare\+\_\+vtab, sqlite3\+\_\+malloc, sqlite3\+\_\+vtab\+\_\+config, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and S\+Q\+L\+I\+T\+E\+\_\+\+V\+T\+A\+B\+\_\+\+I\+N\+N\+O\+C\+U\+O\+US.


\begin{DoxyCode}
3139  \{
3140   completion_vtab *pNew;
3141   \textcolor{keywordtype}{int} rc;
3142 
3143   (void)(pAux);    \textcolor{comment}{/* Unused parameter */}
3144   (void)(argc);    \textcolor{comment}{/* Unused parameter */}
3145   (void)(argv);    \textcolor{comment}{/* Unused parameter */}
3146   (void)(pzErr);   \textcolor{comment}{/* Unused parameter */}
3147 
3148 \textcolor{comment}{/* Column numbers */}
3149 \textcolor{preprocessor}{#define COMPLETION\_COLUMN\_CANDIDATE 0  }\textcolor{comment}{/* Suggested completion of the input */}\textcolor{preprocessor}{}
3150 \textcolor{preprocessor}{#define COMPLETION\_COLUMN\_PREFIX    1  }\textcolor{comment}{/* Prefix of the word to be completed */}\textcolor{preprocessor}{}
3151 \textcolor{preprocessor}{#define COMPLETION\_COLUMN\_WHOLELINE 2  }\textcolor{comment}{/* Entire line seen so far */}\textcolor{preprocessor}{}
3152 \textcolor{preprocessor}{#define COMPLETION\_COLUMN\_PHASE     3  }\textcolor{comment}{/* ePhase - used for debugging only */}\textcolor{preprocessor}{}
3153 
3154   sqlite3_vtab_config(db, SQLITE_VTAB_INNOCUOUS);
3155   rc = sqlite3_declare_vtab(db,
3156       \textcolor{stringliteral}{"CREATE TABLE x("}
3157       \textcolor{stringliteral}{"  candidate TEXT,"}
3158       \textcolor{stringliteral}{"  prefix TEXT HIDDEN,"}
3159       \textcolor{stringliteral}{"  wholeline TEXT HIDDEN,"}
3160       \textcolor{stringliteral}{"  phase INT HIDDEN"}        \textcolor{comment}{/* Used for debugging only */}
3161       \textcolor{stringliteral}{")"});
3162   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
3163     pNew = sqlite3_malloc( \textcolor{keyword}{sizeof}(*pNew) );
3164     *ppVtab = (sqlite3_vtab*)pNew;
3165     \textcolor{keywordflow}{if}( pNew==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
3166     memset(pNew, 0, \textcolor{keyword}{sizeof}(*pNew));
3167     pNew->db = db;
3168   \}
3169   \textcolor{keywordflow}{return} rc;
3170 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad263778b9053b200cefb543b4a6d1e2d}} 
\index{shell.\+c@{shell.\+c}!completion\+Cursor\+Reset@{completion\+Cursor\+Reset}}
\index{completion\+Cursor\+Reset@{completion\+Cursor\+Reset}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Cursor\+Reset()}
{\footnotesize\ttfamily static void completion\+Cursor\+Reset (\begin{DoxyParamCaption}\item[{\textbf{ completion\+\_\+cursor} $\ast$}]{p\+Cur }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3196 of file shell.\+c.



References completion\+\_\+cursor\+::j, completion\+\_\+cursor\+::n\+Line, completion\+\_\+cursor\+::n\+Prefix, completion\+\_\+cursor\+::p\+Stmt, sqlite3\+\_\+finalize, sqlite3\+\_\+free, completion\+\_\+cursor\+::z\+Line, and completion\+\_\+cursor\+::z\+Prefix.



Referenced by completion\+Close(), and completion\+Filter().


\begin{DoxyCode}
3196                                                           \{
3197   sqlite3_free(pCur->zPrefix);   pCur->zPrefix = 0;  pCur->nPrefix = 0;
3198   sqlite3_free(pCur->zLine);     pCur->zLine = 0;    pCur->nLine = 0;
3199   sqlite3_finalize(pCur->pStmt); pCur->pStmt = 0;
3200   pCur->j = 0;
3201 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a8bde95c7ae98e590fb3d5244c0880f7a}} 
\index{shell.\+c@{shell.\+c}!completion\+Disconnect@{completion\+Disconnect}}
\index{completion\+Disconnect@{completion\+Disconnect}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Disconnect()}
{\footnotesize\ttfamily static int completion\+Disconnect (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$}]{p\+Vtab }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3175 of file shell.\+c.



References sqlite3\+\_\+free, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.


\begin{DoxyCode}
3175                                                     \{
3176   sqlite3_free(pVtab);
3177   \textcolor{keywordflow}{return} SQLITE_OK;
3178 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a9d41c84d9bba4c30d59cb4c7d961e7e5}} 
\index{shell.\+c@{shell.\+c}!completion\+Eof@{completion\+Eof}}
\index{completion\+Eof@{completion\+Eof}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Eof()}
{\footnotesize\ttfamily static int completion\+Eof (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3375 of file shell.\+c.



References C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+E\+OF, and completion\+\_\+cursor\+::e\+Phase.


\begin{DoxyCode}
3375                                                   \{
3376   completion_cursor *pCur = (completion_cursor*)cur;
3377   \textcolor{keywordflow}{return} pCur->ePhase >= COMPLETION_EOF;
3378 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a29c92da3a9d606eb6796d07f79f364bb}} 
\index{shell.\+c@{shell.\+c}!completion\+Filter@{completion\+Filter}}
\index{completion\+Filter@{completion\+Filter}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Filter()}
{\footnotesize\ttfamily static int completion\+Filter (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{p\+Vtab\+Cursor,  }\item[{int}]{idx\+Num,  }\item[{const char $\ast$}]{idx\+Str,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3386 of file shell.\+c.



References C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+F\+I\+R\+S\+T\+\_\+\+P\+H\+A\+SE, completion\+Cursor\+Reset(), completion\+Next(), completion\+\_\+cursor\+::e\+Phase, completion\+\_\+cursor\+::i\+Rowid, completion\+\_\+cursor\+::n\+Line, completion\+\_\+cursor\+::n\+Prefix, sqlite3\+\_\+mprintf, sqlite3\+\_\+value\+\_\+bytes, sqlite3\+\_\+value\+\_\+text, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, completion\+\_\+cursor\+::z\+Line, and completion\+\_\+cursor\+::z\+Prefix.


\begin{DoxyCode}
3390  \{
3391   completion_cursor *pCur = (completion_cursor *)pVtabCursor;
3392   \textcolor{keywordtype}{int} iArg = 0;
3393   (void)(idxStr);   \textcolor{comment}{/* Unused parameter */}
3394   (void)(argc);     \textcolor{comment}{/* Unused parameter */}
3395   completionCursorReset(pCur);
3396   \textcolor{keywordflow}{if}( idxNum & 1 )\{
3397     pCur->nPrefix = sqlite3_value_bytes(argv[iArg]);
3398     \textcolor{keywordflow}{if}( pCur->nPrefix>0 )\{
3399       pCur->zPrefix = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, sqlite3_value_text(argv[iArg]));
3400       \textcolor{keywordflow}{if}( pCur->zPrefix==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
3401     \}
3402     iArg = 1;
3403   \}
3404   \textcolor{keywordflow}{if}( idxNum & 2 )\{
3405     pCur->nLine = sqlite3_value_bytes(argv[iArg]);
3406     \textcolor{keywordflow}{if}( pCur->nLine>0 )\{
3407       pCur->zLine = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, sqlite3_value_text(argv[iArg]));
3408       \textcolor{keywordflow}{if}( pCur->zLine==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
3409     \}
3410   \}
3411   \textcolor{keywordflow}{if}( pCur->zLine!=0 && pCur->zPrefix==0 )\{
3412     \textcolor{keywordtype}{int} i = pCur->nLine;
3413     \textcolor{keywordflow}{while}( i>0 && (isalnum(pCur->zLine[i-1]) || pCur->zLine[i-1]==\textcolor{charliteral}{'\_'}) )\{
3414       i--;
3415     \}
3416     pCur->nPrefix = pCur->nLine - i;
3417     \textcolor{keywordflow}{if}( pCur->nPrefix>0 )\{
3418       pCur->zPrefix = sqlite3_mprintf(\textcolor{stringliteral}{"%.*s"}, pCur->nPrefix, pCur->zLine + i);
3419       \textcolor{keywordflow}{if}( pCur->zPrefix==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
3420     \}
3421   \}
3422   pCur->iRowid = 0;
3423   pCur->ePhase = COMPLETION_FIRST_PHASE;
3424   \textcolor{keywordflow}{return} completionNext(pVtabCursor);
3425 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a0ce15e3adb844f5fe2a7c45639745d8e}} 
\index{shell.\+c@{shell.\+c}!completion\+Next@{completion\+Next}}
\index{completion\+Next@{completion\+Next}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Next()}
{\footnotesize\ttfamily static int completion\+Next (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3226 of file shell.\+c.



References C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+C\+O\+L\+U\+M\+NS, C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+D\+A\+T\+A\+B\+A\+S\+ES, C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+E\+OF, C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+K\+E\+Y\+W\+O\+R\+DS, C\+O\+M\+P\+L\+E\+T\+I\+O\+N\+\_\+\+T\+A\+B\+L\+ES, completion\+\_\+cursor\+::db, completion\+\_\+cursor\+::e\+Phase, completion\+\_\+cursor\+::i\+Rowid, completion\+\_\+cursor\+::j, completion\+\_\+cursor\+::n\+Prefix, completion\+\_\+cursor\+::p\+Stmt, sqlite3\+\_\+column\+\_\+bytes, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+keyword\+\_\+count, sqlite3\+\_\+keyword\+\_\+name, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+step, sqlite3\+\_\+strnicmp, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, completion\+\_\+cursor\+::sz\+Row, completion\+\_\+cursor\+::z\+Current\+Row, and completion\+\_\+cursor\+::z\+Prefix.



Referenced by completion\+Filter().


\begin{DoxyCode}
3226                                                    \{
3227   completion_cursor *pCur = (completion_cursor*)cur;
3228   \textcolor{keywordtype}{int} eNextPhase = 0;  \textcolor{comment}{/* Next phase to try if current phase reaches end */}
3229   \textcolor{keywordtype}{int} iCol = -1;       \textcolor{comment}{/* If >=0, step pCur->pStmt and use the i-th column */}
3230   pCur->iRowid++;
3231   \textcolor{keywordflow}{while}( pCur->ePhase!=COMPLETION_EOF )\{
3232     \textcolor{keywordflow}{switch}( pCur->ePhase )\{
3233       \textcolor{keywordflow}{case} COMPLETION_KEYWORDS: \{
3234         \textcolor{keywordflow}{if}( pCur->j >= sqlite3_keyword_count() )\{
3235           pCur->zCurrentRow = 0;
3236           pCur->ePhase = COMPLETION_DATABASES;
3237         \}\textcolor{keywordflow}{else}\{
3238           sqlite3_keyword_name(pCur->j++, &pCur->zCurrentRow, &pCur->szRow);
3239         \}
3240         iCol = -1;
3241         \textcolor{keywordflow}{break};
3242       \}
3243       \textcolor{keywordflow}{case} COMPLETION_DATABASES: \{
3244         \textcolor{keywordflow}{if}( pCur->pStmt==0 )\{
3245           sqlite3_prepare_v2(pCur->db, \textcolor{stringliteral}{"PRAGMA database\_list"}, -1,
3246                              &pCur->pStmt, 0);
3247         \}
3248         iCol = 1;
3249         eNextPhase = COMPLETION_TABLES;
3250         \textcolor{keywordflow}{break};
3251       \}
3252       \textcolor{keywordflow}{case} COMPLETION_TABLES: \{
3253         \textcolor{keywordflow}{if}( pCur->pStmt==0 )\{
3254           sqlite3_stmt *pS2;
3255           \textcolor{keywordtype}{char} *zSql = 0;
3256           \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSep = \textcolor{stringliteral}{""};
3257           sqlite3_prepare_v2(pCur->db, \textcolor{stringliteral}{"PRAGMA database\_list"}, -1, &pS2, 0);
3258           \textcolor{keywordflow}{while}( sqlite3_step(pS2)==SQLITE_ROW )\{
3259             \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDb = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pS2, 1);
3260             zSql = sqlite3_mprintf(
3261                \textcolor{stringliteral}{"%z%s"}
3262                \textcolor{stringliteral}{"SELECT name FROM \(\backslash\)"%w\(\backslash\)".sqlite\_master"},
3263                zSql, zSep, zDb
3264             );
3265             \textcolor{keywordflow}{if}( zSql==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
3266             zSep = \textcolor{stringliteral}{" UNION "};
3267           \}
3268           sqlite3_finalize(pS2);
3269           sqlite3_prepare_v2(pCur->db, zSql, -1, &pCur->pStmt, 0);
3270           sqlite3_free(zSql);
3271         \}
3272         iCol = 0;
3273         eNextPhase = COMPLETION_COLUMNS;
3274         \textcolor{keywordflow}{break};
3275       \}
3276       \textcolor{keywordflow}{case} COMPLETION_COLUMNS: \{
3277         \textcolor{keywordflow}{if}( pCur->pStmt==0 )\{
3278           sqlite3_stmt *pS2;
3279           \textcolor{keywordtype}{char} *zSql = 0;
3280           \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSep = \textcolor{stringliteral}{""};
3281           sqlite3_prepare_v2(pCur->db, \textcolor{stringliteral}{"PRAGMA database\_list"}, -1, &pS2, 0);
3282           \textcolor{keywordflow}{while}( sqlite3_step(pS2)==SQLITE_ROW )\{
3283             \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDb = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pS2, 1);
3284             zSql = sqlite3_mprintf(
3285                \textcolor{stringliteral}{"%z%s"}
3286                \textcolor{stringliteral}{"SELECT pti.name FROM \(\backslash\)"%w\(\backslash\)".sqlite\_master AS sm"}
3287                        \textcolor{stringliteral}{" JOIN pragma\_table\_info(sm.name,%Q) AS pti"}
3288                \textcolor{stringliteral}{" WHERE sm.type='table'"},
3289                zSql, zSep, zDb, zDb
3290             );
3291             \textcolor{keywordflow}{if}( zSql==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
3292             zSep = \textcolor{stringliteral}{" UNION "};
3293           \}
3294           sqlite3_finalize(pS2);
3295           sqlite3_prepare_v2(pCur->db, zSql, -1, &pCur->pStmt, 0);
3296           sqlite3_free(zSql);
3297         \}
3298         iCol = 0;
3299         eNextPhase = COMPLETION_EOF;
3300         \textcolor{keywordflow}{break};
3301       \}
3302     \}
3303     \textcolor{keywordflow}{if}( iCol<0 )\{
3304       \textcolor{comment}{/* This case is when the phase presets zCurrentRow */}
3305       \textcolor{keywordflow}{if}( pCur->zCurrentRow==0 ) \textcolor{keywordflow}{continue};
3306     \}\textcolor{keywordflow}{else}\{
3307       \textcolor{keywordflow}{if}( sqlite3_step(pCur->pStmt)==SQLITE_ROW )\{
3308         \textcolor{comment}{/* Extract the next row of content */}
3309         pCur->zCurrentRow = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pCur->pStmt, iCol);
3310         pCur->szRow = sqlite3_column_bytes(pCur->pStmt, iCol);
3311       \}\textcolor{keywordflow}{else}\{
3312         \textcolor{comment}{/* When all rows are finished, advance to the next phase */}
3313         sqlite3_finalize(pCur->pStmt);
3314         pCur->pStmt = 0;
3315         pCur->ePhase = eNextPhase;
3316         \textcolor{keywordflow}{continue};
3317       \}
3318     \}
3319     \textcolor{keywordflow}{if}( pCur->nPrefix==0 ) \textcolor{keywordflow}{break};
3320     \textcolor{keywordflow}{if}( pCur->nPrefix<=pCur->szRow
3321      && sqlite3_strnicmp(pCur->zPrefix, pCur->zCurrentRow, pCur->nPrefix)==0
3322     )\{
3323       \textcolor{keywordflow}{break};
3324     \}
3325   \}
3326 
3327   \textcolor{keywordflow}{return} SQLITE_OK;
3328 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aab1b36be93be63bcdc65c3f134ee9ff5}} 
\index{shell.\+c@{shell.\+c}!completion\+Open@{completion\+Open}}
\index{completion\+Open@{completion\+Open}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Open()}
{\footnotesize\ttfamily static int completion\+Open (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$}]{p,  }\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$$\ast$}]{pp\+Cursor }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3183 of file shell.\+c.



References completion\+\_\+cursor\+::base, completion\+\_\+cursor\+::db, sqlite3\+\_\+malloc, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.


\begin{DoxyCode}
3183                                                                           \{
3184   completion_cursor *pCur;
3185   pCur = sqlite3_malloc( \textcolor{keyword}{sizeof}(*pCur) );
3186   \textcolor{keywordflow}{if}( pCur==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
3187   memset(pCur, 0, \textcolor{keyword}{sizeof}(*pCur));
3188   pCur->db = ((completion_vtab*)p)->db;
3189   *ppCursor = &pCur->base;
3190   \textcolor{keywordflow}{return} SQLITE_OK;
3191 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a5d9717dd0e17227bc8851bcd42855695}} 
\index{shell.\+c@{shell.\+c}!completion\+Rowid@{completion\+Rowid}}
\index{completion\+Rowid@{completion\+Rowid}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Rowid()}
{\footnotesize\ttfamily static int completion\+Rowid (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur,  }\item[{\textbf{ sqlite\+\_\+int64} $\ast$}]{p\+Rowid }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3365 of file shell.\+c.



References completion\+\_\+cursor\+::i\+Rowid, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.


\begin{DoxyCode}
3365                                                                           \{
3366   completion_cursor *pCur = (completion_cursor*)cur;
3367   *pRowid = pCur->iRowid;
3368   \textcolor{keywordflow}{return} SQLITE_OK;
3369 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab6abfc9b1c1a3c71a67e3b891a523016}} 
\index{shell.\+c@{shell.\+c}!create\+Selftest\+Table@{create\+Selftest\+Table}}
\index{create\+Selftest\+Table@{create\+Selftest\+Table}!shell.\+c@{shell.\+c}}
\subsubsection{create\+Selftest\+Table()}
{\footnotesize\ttfamily static void create\+Selftest\+Table (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10785 of file shell.\+c.



References Shell\+State\+::db, sqlite3\+\_\+exec, sqlite3\+\_\+free, and utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
10785                                               \{
10786   \textcolor{keywordtype}{char} *zErrMsg = 0;
10787   sqlite3_exec(p->db,
10788     \textcolor{stringliteral}{"SAVEPOINT selftest\_init;\(\backslash\)n"}
10789     \textcolor{stringliteral}{"CREATE TABLE IF NOT EXISTS selftest(\(\backslash\)n"}
10790     \textcolor{stringliteral}{"  tno INTEGER PRIMARY KEY,\(\backslash\)n"}   \textcolor{comment}{/* Test number */}
10791     \textcolor{stringliteral}{"  op TEXT,\(\backslash\)n"}                   \textcolor{comment}{/* Operator:  memo run */}
10792     \textcolor{stringliteral}{"  cmd TEXT,\(\backslash\)n"}                  \textcolor{comment}{/* Command text */}
10793     \textcolor{stringliteral}{"  ans TEXT\(\backslash\)n"}                   \textcolor{comment}{/* Desired answer */}
10794     \textcolor{stringliteral}{");"}
10795     \textcolor{stringliteral}{"CREATE TEMP TABLE [\_shell$self](op,cmd,ans);\(\backslash\)n"}
10796     \textcolor{stringliteral}{"INSERT INTO [\_shell$self](rowid,op,cmd)\(\backslash\)n"}
10797     \textcolor{stringliteral}{"  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\(\backslash\)n"}
10798     \textcolor{stringliteral}{"         'memo','Tests generated by --init');\(\backslash\)n"}
10799     \textcolor{stringliteral}{"INSERT INTO [\_shell$self]\(\backslash\)n"}
10800     \textcolor{stringliteral}{"  SELECT 'run',\(\backslash\)n"}
10801     \textcolor{stringliteral}{"    'SELECT hex(sha3\_query(''SELECT type,name,tbl\_name,sql "}
10802                                  \textcolor{stringliteral}{"FROM sqlite\_master ORDER BY 2'',224))',\(\backslash\)n"}
10803     \textcolor{stringliteral}{"    hex(sha3\_query('SELECT type,name,tbl\_name,sql "}
10804                           \textcolor{stringliteral}{"FROM sqlite\_master ORDER BY 2',224));\(\backslash\)n"}
10805     \textcolor{stringliteral}{"INSERT INTO [\_shell$self]\(\backslash\)n"}
10806     \textcolor{stringliteral}{"  SELECT 'run',"}
10807     \textcolor{stringliteral}{"    'SELECT hex(sha3\_query(''SELECT * FROM \(\backslash\)"' ||"}
10808     \textcolor{stringliteral}{"        printf('%w',name) || '\(\backslash\)" NOT INDEXED'',224))',\(\backslash\)n"}
10809     \textcolor{stringliteral}{"    hex(sha3\_query(printf('SELECT * FROM \(\backslash\)"%w\(\backslash\)" NOT INDEXED',name),224))\(\backslash\)n"}
10810     \textcolor{stringliteral}{"  FROM (\(\backslash\)n"}
10811     \textcolor{stringliteral}{"    SELECT name FROM sqlite\_master\(\backslash\)n"}
10812     \textcolor{stringliteral}{"     WHERE type='table'\(\backslash\)n"}
10813     \textcolor{stringliteral}{"       AND name<>'selftest'\(\backslash\)n"}
10814     \textcolor{stringliteral}{"       AND coalesce(rootpage,0)>0\(\backslash\)n"}
10815     \textcolor{stringliteral}{"  )\(\backslash\)n"}
10816     \textcolor{stringliteral}{" ORDER BY name;\(\backslash\)n"}
10817     \textcolor{stringliteral}{"INSERT INTO [\_shell$self]\(\backslash\)n"}
10818     \textcolor{stringliteral}{"  VALUES('run','PRAGMA integrity\_check','ok');\(\backslash\)n"}
10819     \textcolor{stringliteral}{"INSERT INTO selftest(tno,op,cmd,ans)"}
10820     \textcolor{stringliteral}{"  SELECT rowid*10,op,cmd,ans FROM [\_shell$self];\(\backslash\)n"}
10821     \textcolor{stringliteral}{"DROP TABLE [\_shell$self];"}
10822     ,0,0,&zErrMsg);
10823   \textcolor{keywordflow}{if}( zErrMsg )\{
10824     utf8_printf(stderr, \textcolor{stringliteral}{"SELFTEST initialization failure: %s\(\backslash\)n"}, zErrMsg);
10825     sqlite3_free(zErrMsg);
10826   \}
10827   sqlite3_exec(p->db, \textcolor{stringliteral}{"RELEASE selftest\_init"},0,0,0);
10828 \}
\end{DoxyCode}
\mbox{\label{shell_8c_adfe221d084edef840bb79fba9fb15415}} 
\index{shell.\+c@{shell.\+c}!csv\+\_\+read\+\_\+one\+\_\+field@{csv\+\_\+read\+\_\+one\+\_\+field}}
\index{csv\+\_\+read\+\_\+one\+\_\+field@{csv\+\_\+read\+\_\+one\+\_\+field}!shell.\+c@{shell.\+c}}
\subsubsection{csv\+\_\+read\+\_\+one\+\_\+field()}
{\footnotesize\ttfamily static char$\ast$ \textbf{ S\+Q\+L\+I\+T\+E\+\_\+\+C\+D\+E\+CL} csv\+\_\+read\+\_\+one\+\_\+field (\begin{DoxyParamCaption}\item[{\textbf{ Import\+Ctx} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13105 of file shell.\+c.



References Import\+Ctx\+::b\+Not\+First, Import\+Ctx\+::c\+Col\+Sep, Import\+Ctx\+::c\+Row\+Sep, Import\+Ctx\+::c\+Term, import\+\_\+append\+\_\+char(), Import\+Ctx\+::in, Import\+Ctx\+::n, Import\+Ctx\+::n\+Line, utf8\+\_\+printf, Import\+Ctx\+::z, and Import\+Ctx\+::z\+File.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13105                                                           \{
13106   \textcolor{keywordtype}{int} c;
13107   \textcolor{keywordtype}{int} cSep = p->cColSep;
13108   \textcolor{keywordtype}{int} rSep = p->cRowSep;
13109   p->n = 0;
13110   c = fgetc(p->in);
13111   \textcolor{keywordflow}{if}( c==EOF || seenInterrupt )\{
13112     p->cTerm = EOF;
13113     \textcolor{keywordflow}{return} 0;
13114   \}
13115   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'"'} )\{
13116     \textcolor{keywordtype}{int} pc, ppc;
13117     \textcolor{keywordtype}{int} startLine = p->nLine;
13118     \textcolor{keywordtype}{int} cQuote = c;
13119     pc = ppc = 0;
13120     \textcolor{keywordflow}{while}( 1 )\{
13121       c = fgetc(p->in);
13122       \textcolor{keywordflow}{if}( c==rSep ) p->nLine++;
13123       \textcolor{keywordflow}{if}( c==cQuote )\{
13124         \textcolor{keywordflow}{if}( pc==cQuote )\{
13125           pc = 0;
13126           \textcolor{keywordflow}{continue};
13127         \}
13128       \}
13129       \textcolor{keywordflow}{if}( (c==cSep && pc==cQuote)
13130        || (c==rSep && pc==cQuote)
13131        || (c==rSep && pc==\textcolor{charliteral}{'\(\backslash\)r'} && ppc==cQuote)
13132        || (c==EOF && pc==cQuote)
13133       )\{
13134         \textcolor{keywordflow}{do}\{ p->n--; \}\textcolor{keywordflow}{while}( p->z[p->n]!=cQuote );
13135         p->cTerm = c;
13136         \textcolor{keywordflow}{break};
13137       \}
13138       \textcolor{keywordflow}{if}( pc==cQuote && c!=\textcolor{charliteral}{'\(\backslash\)r'} )\{
13139         utf8_printf(stderr, \textcolor{stringliteral}{"%s:%d: unescaped %c character\(\backslash\)n"},
13140                 p->zFile, p->nLine, cQuote);
13141       \}
13142       \textcolor{keywordflow}{if}( c==EOF )\{
13143         utf8_printf(stderr, \textcolor{stringliteral}{"%s:%d: unterminated %c-quoted field\(\backslash\)n"},
13144                 p->zFile, startLine, cQuote);
13145         p->cTerm = c;
13146         \textcolor{keywordflow}{break};
13147       \}
13148       import_append_char(p, c);
13149       ppc = pc;
13150       pc = c;
13151     \}
13152   \}\textcolor{keywordflow}{else}\{
13153     \textcolor{comment}{/* If this is the first field being parsed and it begins with the}
13154 \textcolor{comment}{    ** UTF-8 BOM  (0xEF BB BF) then skip the BOM */}
13155     \textcolor{keywordflow}{if}( (c&0xff)==0xef && p->bNotFirst==0 )\{
13156       import_append_char(p, c);
13157       c = fgetc(p->in);
13158       \textcolor{keywordflow}{if}( (c&0xff)==0xbb )\{
13159         import_append_char(p, c);
13160         c = fgetc(p->in);
13161         \textcolor{keywordflow}{if}( (c&0xff)==0xbf )\{
13162           p->bNotFirst = 1;
13163           p->n = 0;
13164           \textcolor{keywordflow}{return} csv_read_one_field(p);
13165         \}
13166       \}
13167     \}
13168     \textcolor{keywordflow}{while}( c!=EOF && c!=cSep && c!=rSep )\{
13169       import_append_char(p, c);
13170       c = fgetc(p->in);
13171     \}
13172     \textcolor{keywordflow}{if}( c==rSep )\{
13173       p->nLine++;
13174       \textcolor{keywordflow}{if}( p->n>0 && p->z[p->n-1]==\textcolor{charliteral}{'\(\backslash\)r'} ) p->n--;
13175     \}
13176     p->cTerm = c;
13177   \}
13178   \textcolor{keywordflow}{if}( p->z ) p->z[p->n] = 0;
13179   p->bNotFirst = 1;
13180   \textcolor{keywordflow}{return} p->z;
13181 \}
\end{DoxyCode}
\mbox{\label{shell_8c_adcfe1f77e48a053a405be1ac0737ef19}} 
\index{shell.\+c@{shell.\+c}!ctx\+Error\+Msg@{ctx\+Error\+Msg}}
\index{ctx\+Error\+Msg@{ctx\+Error\+Msg}!shell.\+c@{shell.\+c}}
\subsubsection{ctx\+Error\+Msg()}
{\footnotesize\ttfamily static void ctx\+Error\+Msg (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{ctx,  }\item[{const char $\ast$}]{z\+Fmt,  }\item[{}]{... }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2223 of file shell.\+c.



References sqlite3\+\_\+free, sqlite3\+\_\+result\+\_\+error, and sqlite3\+\_\+vmprintf.



Referenced by writefile\+Func().


\begin{DoxyCode}
2223                                                                     \{
2224   \textcolor{keywordtype}{char} *zMsg = 0;
2225   va\_list ap;
2226   va\_start(ap, zFmt);
2227   zMsg = sqlite3_vmprintf(zFmt, ap);
2228   sqlite3_result_error(ctx, zMsg, -1);
2229   sqlite3_free(zMsg);
2230   va\_end(ap);
2231 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad3fbf85511218afc74acae1264462ff1}} 
\index{shell.\+c@{shell.\+c}!db\+\_\+int@{db\+\_\+int}}
\index{db\+\_\+int@{db\+\_\+int}!shell.\+c@{shell.\+c}}
\subsubsection{db\+\_\+int()}
{\footnotesize\ttfamily static int db\+\_\+int (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{const char $\ast$}]{z\+Sql }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13472 of file shell.\+c.



References Shell\+State\+::db, sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+finalize, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+step, and S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW.



Referenced by shell\+\_\+dbinfo\+\_\+command().


\begin{DoxyCode}
13472                                                   \{
13473   sqlite3_stmt *pStmt;
13474   \textcolor{keywordtype}{int} res = 0;
13475   sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
13476   \textcolor{keywordflow}{if}( pStmt && sqlite3_step(pStmt)==SQLITE_ROW )\{
13477     res = sqlite3_column_int(pStmt,0);
13478   \}
13479   sqlite3_finalize(pStmt);
13480   \textcolor{keywordflow}{return} res;
13481 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aa5662f177794e05c3bb71ecfe9989031}} 
\index{shell.\+c@{shell.\+c}!deduce\+Database\+Type@{deduce\+Database\+Type}}
\index{deduce\+Database\+Type@{deduce\+Database\+Type}!shell.\+c@{shell.\+c}}
\subsubsection{deduce\+Database\+Type()}
{\footnotesize\ttfamily int deduce\+Database\+Type (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Name,  }\item[{int}]{dflt\+Zip }\end{DoxyParamCaption})}



Definition at line 12406 of file shell.\+c.



References Shell\+State\+::in, Shell\+State\+::lineno, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+N\+O\+R\+M\+AL, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+U\+N\+S\+P\+EC, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE, sqlite3\+\_\+free, sqlite3\+\_\+malloc, sqlite3\+\_\+strlike, utf8\+\_\+printf, time\+\_\+test\+::x, and Shell\+State\+::z\+Db\+Filename.



Referenced by open\+\_\+db(), and shell\+Reset().


\begin{DoxyCode}
12406                                                       \{
12407   FILE *f = fopen(zName, \textcolor{stringliteral}{"rb"});
12408   \textcolor{keywordtype}{size\_t} n;
12409   \textcolor{keywordtype}{int} rc = SHELL_OPEN_UNSPEC;
12410   \textcolor{keywordtype}{char} zBuf[100];
12411   \textcolor{keywordflow}{if}( f==0 )\{
12412     \textcolor{keywordflow}{if}( dfltZip && sqlite3_strlike(\textcolor{stringliteral}{"%.zip"},zName,0)==0 )\{
12413        \textcolor{keywordflow}{return} SHELL_OPEN_ZIPFILE;
12414     \}\textcolor{keywordflow}{else}\{
12415        \textcolor{keywordflow}{return} SHELL_OPEN_NORMAL;
12416     \}
12417   \}
12418   n = fread(zBuf, 16, 1, f);
12419   \textcolor{keywordflow}{if}( n==1 && memcmp(zBuf, \textcolor{stringliteral}{"SQLite format 3"}, 16)==0 )\{
12420     fclose(f);
12421     \textcolor{keywordflow}{return} SHELL_OPEN_NORMAL;
12422   \}
12423   fseek(f, -25, SEEK\_END);
12424   n = fread(zBuf, 25, 1, f);
12425   \textcolor{keywordflow}{if}( n==1 && memcmp(zBuf, \textcolor{stringliteral}{"Start-Of-SQLite3-"}, 17)==0 )\{
12426     rc = SHELL_OPEN_APPENDVFS;
12427   \}\textcolor{keywordflow}{else}\{
12428     fseek(f, -22, SEEK\_END);
12429     n = fread(zBuf, 22, 1, f);
12430     \textcolor{keywordflow}{if}( n==1 && zBuf[0]==0x50 && zBuf[1]==0x4b && zBuf[2]==0x05
12431        && zBuf[3]==0x06 )\{
12432       rc = SHELL_OPEN_ZIPFILE;
12433     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( n==0 && dfltZip && sqlite3_strlike(\textcolor{stringliteral}{"%.zip"},zName,0)==0 )\{
12434       rc = SHELL_OPEN_ZIPFILE;
12435     \}
12436   \}
12437   fclose(f);
12438   \textcolor{keywordflow}{return} rc;  
12439 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aed86831a3fc8c34aab0c9727f8394f62}} 
\index{shell.\+c@{shell.\+c}!disable\+\_\+debug\+\_\+trace\+\_\+modes@{disable\+\_\+debug\+\_\+trace\+\_\+modes}}
\index{disable\+\_\+debug\+\_\+trace\+\_\+modes@{disable\+\_\+debug\+\_\+trace\+\_\+modes}!shell.\+c@{shell.\+c}}
\subsubsection{disable\+\_\+debug\+\_\+trace\+\_\+modes()}
{\footnotesize\ttfamily static void disable\+\_\+debug\+\_\+trace\+\_\+modes (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11307 of file shell.\+c.



Referenced by shell\+\_\+exec().


\begin{DoxyCode}
11307                                            \{
11308 \textcolor{preprocessor}{#if defined(SQLITE\_DEBUG) && defined(SQLITE\_ENABLE\_SELECTTRACE)}
11309   savedSelectTrace = sqlite3SelectTrace;
11310   sqlite3SelectTrace = 0;
11311 \textcolor{preprocessor}{#endif}
11312 \textcolor{preprocessor}{#if defined(SQLITE\_DEBUG) && defined(SQLITE\_ENABLE\_WHERETRACE)}
11313   savedWhereTrace = sqlite3WhereTrace;
11314   sqlite3WhereTrace = 0;
11315 \textcolor{preprocessor}{#endif}
11316 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a3249bf38864ddd9a6b526fc1f4a500b1}} 
\index{shell.\+c@{shell.\+c}!display\+\_\+scanstats@{display\+\_\+scanstats}}
\index{display\+\_\+scanstats@{display\+\_\+scanstats}!shell.\+c@{shell.\+c}}
\subsubsection{display\+\_\+scanstats()}
{\footnotesize\ttfamily static void display\+\_\+scanstats (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{\textbf{ Shell\+State} $\ast$}]{p\+Arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11129 of file shell.\+c.



References Shell\+State\+::out, Shell\+State\+::p\+Stmt, raw\+\_\+printf, sqlite3\+\_\+stmt\+\_\+scanstatus(), S\+Q\+L\+I\+T\+E\+\_\+\+S\+C\+A\+N\+S\+T\+A\+T\+\_\+\+E\+ST, S\+Q\+L\+I\+T\+E\+\_\+\+S\+C\+A\+N\+S\+T\+A\+T\+\_\+\+E\+X\+P\+L\+A\+IN, S\+Q\+L\+I\+T\+E\+\_\+\+S\+C\+A\+N\+S\+T\+A\+T\+\_\+\+N\+L\+O\+OP, S\+Q\+L\+I\+T\+E\+\_\+\+S\+C\+A\+N\+S\+T\+A\+T\+\_\+\+N\+V\+I\+S\+IT, S\+Q\+L\+I\+T\+E\+\_\+\+S\+C\+A\+N\+S\+T\+A\+T\+\_\+\+S\+E\+L\+E\+C\+T\+ID, U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER, and utf8\+\_\+printf.



Referenced by shell\+\_\+exec().


\begin{DoxyCode}
11132  \{
11133 \textcolor{preprocessor}{#ifndef SQLITE\_ENABLE\_STMT\_SCANSTATUS}
11134   UNUSED_PARAMETER(db);
11135   UNUSED_PARAMETER(pArg);
11136 \textcolor{preprocessor}{#else}
11137   \textcolor{keywordtype}{int} i, k, n, mx;
11138   raw_printf(pArg->out, \textcolor{stringliteral}{"-------- scanstats --------\(\backslash\)n"});
11139   mx = 0;
11140   \textcolor{keywordflow}{for}(k=0; k<=mx; k++)\{
11141     \textcolor{keywordtype}{double} rEstLoop = 1.0;
11142     \textcolor{keywordflow}{for}(i=n=0; 1; i++)\{
11143       sqlite3_stmt *p = pArg->pStmt;
11144       sqlite3_int64 nLoop, nVisit;
11145       \textcolor{keywordtype}{double} rEst;
11146       \textcolor{keywordtype}{int} iSid;
11147       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zExplain;
11148       \textcolor{keywordflow}{if}( sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_NLOOP, (\textcolor{keywordtype}{void}*)&nLoop) )\{
11149         \textcolor{keywordflow}{break};
11150       \}
11151       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_SELECTID, (\textcolor{keywordtype}{void}*)&iSid);
11152       \textcolor{keywordflow}{if}( iSid>mx ) mx = iSid;
11153       \textcolor{keywordflow}{if}( iSid!=k ) \textcolor{keywordflow}{continue};
11154       \textcolor{keywordflow}{if}( n==0 )\{
11155         rEstLoop = (double)nLoop;
11156         \textcolor{keywordflow}{if}( k>0 ) raw_printf(pArg->out, \textcolor{stringliteral}{"-------- subquery %d -------\(\backslash\)n"}, k);
11157       \}
11158       n++;
11159       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_NVISIT, (\textcolor{keywordtype}{void}*)&nVisit);
11160       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_EST, (\textcolor{keywordtype}{void}*)&rEst);
11161       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_EXPLAIN, (\textcolor{keywordtype}{void}*)&zExplain);
11162       utf8_printf(pArg->out, \textcolor{stringliteral}{"Loop %2d: %s\(\backslash\)n"}, n, zExplain);
11163       rEstLoop *= rEst;
11164       raw_printf(pArg->out,
11165           \textcolor{stringliteral}{"         nLoop=%-8lld nRow=%-8lld estRow=%-8lld estRow/Loop=%-8g\(\backslash\)n"},
11166           nLoop, nVisit, (sqlite3_int64)(rEstLoop+0.5), rEst
11167       );
11168     \}
11169   \}
11170   raw_printf(pArg->out, \textcolor{stringliteral}{"---------------------------\(\backslash\)n"});
11171 \textcolor{preprocessor}{#endif}
11172 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad7455b80c3c1fc9bfaf60817a5ec04c3}} 
\index{shell.\+c@{shell.\+c}!display\+\_\+stats@{display\+\_\+stats}}
\index{display\+\_\+stats@{display\+\_\+stats}!shell.\+c@{shell.\+c}}
\subsubsection{display\+\_\+stats()}
{\footnotesize\ttfamily static int display\+\_\+stats (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{\textbf{ Shell\+State} $\ast$}]{p\+Arg,  }\item[{int}]{b\+Reset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10998 of file shell.\+c.



References display\+Stat\+Line(), Shell\+State\+::out, Shell\+State\+::p\+Stmt, raw\+\_\+printf, Shell\+State\+::shell\+Flgs, S\+H\+F\+L\+G\+\_\+\+Lookaside, S\+H\+F\+L\+G\+\_\+\+Pagecache, sqlite3\+\_\+column\+\_\+count, sqlite3\+\_\+column\+\_\+database\+\_\+name, sqlite3\+\_\+column\+\_\+decltype, sqlite3\+\_\+column\+\_\+name, sqlite3\+\_\+column\+\_\+origin\+\_\+name, sqlite3\+\_\+column\+\_\+table\+\_\+name, sqlite3\+\_\+db\+\_\+status, sqlite3\+\_\+snprintf, sqlite3\+\_\+stmt\+\_\+status, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+S\+T\+A\+T\+U\+S\+\_\+\+C\+A\+C\+H\+E\+\_\+\+H\+IT, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+S\+T\+A\+T\+U\+S\+\_\+\+C\+A\+C\+H\+E\+\_\+\+M\+I\+SS, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+S\+T\+A\+T\+U\+S\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+P\+I\+LL, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+S\+T\+A\+T\+U\+S\+\_\+\+C\+A\+C\+H\+E\+\_\+\+U\+S\+ED, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+S\+T\+A\+T\+U\+S\+\_\+\+C\+A\+C\+H\+E\+\_\+\+W\+R\+I\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+S\+T\+A\+T\+U\+S\+\_\+\+L\+O\+O\+K\+A\+S\+I\+D\+E\+\_\+\+H\+IT, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+S\+T\+A\+T\+U\+S\+\_\+\+L\+O\+O\+K\+A\+S\+I\+D\+E\+\_\+\+M\+I\+S\+S\+\_\+\+F\+U\+LL, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+S\+T\+A\+T\+U\+S\+\_\+\+L\+O\+O\+K\+A\+S\+I\+D\+E\+\_\+\+M\+I\+S\+S\+\_\+\+S\+I\+ZE, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+S\+T\+A\+T\+U\+S\+\_\+\+L\+O\+O\+K\+A\+S\+I\+D\+E\+\_\+\+U\+S\+ED, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+S\+T\+A\+T\+U\+S\+\_\+\+S\+C\+H\+E\+M\+A\+\_\+\+U\+S\+ED, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+S\+T\+A\+T\+U\+S\+\_\+\+S\+T\+M\+T\+\_\+\+U\+S\+ED, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+M\+A\+L\+L\+O\+C\+\_\+\+C\+O\+U\+NT, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+M\+A\+L\+L\+O\+C\+\_\+\+S\+I\+ZE, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+M\+E\+M\+O\+R\+Y\+\_\+\+U\+S\+ED, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+P\+A\+G\+E\+C\+A\+C\+H\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+P\+A\+G\+E\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+P\+A\+G\+E\+C\+A\+C\+H\+E\+\_\+\+U\+S\+ED, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+P\+A\+R\+S\+E\+R\+\_\+\+S\+T\+A\+CK, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+M\+T\+S\+T\+A\+T\+U\+S\+\_\+\+A\+U\+T\+O\+I\+N\+D\+EX, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+M\+T\+S\+T\+A\+T\+U\+S\+\_\+\+F\+U\+L\+L\+S\+C\+A\+N\+\_\+\+S\+T\+EP, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+M\+T\+S\+T\+A\+T\+U\+S\+\_\+\+M\+E\+M\+U\+S\+ED, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+M\+T\+S\+T\+A\+T\+U\+S\+\_\+\+R\+E\+P\+R\+E\+P\+A\+RE, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+M\+T\+S\+T\+A\+T\+U\+S\+\_\+\+R\+UN, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+M\+T\+S\+T\+A\+T\+U\+S\+\_\+\+S\+O\+RT, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+M\+T\+S\+T\+A\+T\+U\+S\+\_\+\+V\+M\+\_\+\+S\+T\+EP, Shell\+State\+::stats\+On, utf8\+\_\+printf, and time\+\_\+test\+::x.



Referenced by do\+\_\+meta\+\_\+command(), and shell\+\_\+exec().


\begin{DoxyCode}
11002  \{
11003   \textcolor{keywordtype}{int} iCur;
11004   \textcolor{keywordtype}{int} iHiwtr;
11005   FILE *out;
11006   \textcolor{keywordflow}{if}( pArg==0 || pArg->out==0 ) \textcolor{keywordflow}{return} 0;
11007   out = pArg->out;
11008 
11009   \textcolor{keywordflow}{if}( pArg->pStmt && (pArg->statsOn & 2) )\{
11010     \textcolor{keywordtype}{int} nCol, i, x;
11011     sqlite3_stmt *pStmt = pArg->pStmt;
11012     \textcolor{keywordtype}{char} z[100];
11013     nCol = sqlite3_column_count(pStmt);
11014     raw_printf(out, \textcolor{stringliteral}{"%-36s %d\(\backslash\)n"}, \textcolor{stringliteral}{"Number of output columns:"}, nCol);
11015     \textcolor{keywordflow}{for}(i=0; i<nCol; i++)\{
11016       sqlite3_snprintf(\textcolor{keyword}{sizeof}(z),z,\textcolor{stringliteral}{"Column %d %nname:"}, i, &x);
11017       utf8_printf(out, \textcolor{stringliteral}{"%-36s %s\(\backslash\)n"}, z, sqlite3_column_name(pStmt,i));
11018 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_DECLTYPE}
11019       sqlite3_snprintf(30, z+x, \textcolor{stringliteral}{"declared type:"});
11020       utf8_printf(out, \textcolor{stringliteral}{"%-36s %s\(\backslash\)n"}, z, sqlite3_column_decltype(pStmt, i));
11021 \textcolor{preprocessor}{#endif}
11022 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_COLUMN\_METADATA}
11023       sqlite3_snprintf(30, z+x, \textcolor{stringliteral}{"database name:"});
11024       utf8_printf(out, \textcolor{stringliteral}{"%-36s %s\(\backslash\)n"}, z, sqlite3_column_database_name(pStmt,i));
11025       sqlite3_snprintf(30, z+x, \textcolor{stringliteral}{"table name:"});
11026       utf8_printf(out, \textcolor{stringliteral}{"%-36s %s\(\backslash\)n"}, z, sqlite3_column_table_name(pStmt,i));
11027       sqlite3_snprintf(30, z+x, \textcolor{stringliteral}{"origin name:"});
11028       utf8_printf(out, \textcolor{stringliteral}{"%-36s %s\(\backslash\)n"}, z, sqlite3_column_origin_name(pStmt,i));
11029 \textcolor{preprocessor}{#endif}
11030     \}
11031   \}
11032 
11033   displayStatLine(pArg, \textcolor{stringliteral}{"Memory Used:"},
11034      \textcolor{stringliteral}{"%lld (max %lld) bytes"}, SQLITE_STATUS_MEMORY_USED, bReset);
11035   displayStatLine(pArg, \textcolor{stringliteral}{"Number of Outstanding Allocations:"},
11036      \textcolor{stringliteral}{"%lld (max %lld)"}, SQLITE_STATUS_MALLOC_COUNT, bReset);
11037   \textcolor{keywordflow}{if}( pArg->shellFlgs & SHFLG_Pagecache )\{
11038     displayStatLine(pArg, \textcolor{stringliteral}{"Number of Pcache Pages Used:"},
11039        \textcolor{stringliteral}{"%lld (max %lld) pages"}, SQLITE_STATUS_PAGECACHE_USED, bReset);
11040   \}
11041   displayStatLine(pArg, \textcolor{stringliteral}{"Number of Pcache Overflow Bytes:"},
11042      \textcolor{stringliteral}{"%lld (max %lld) bytes"}, SQLITE_STATUS_PAGECACHE_OVERFLOW, bReset);
11043   displayStatLine(pArg, \textcolor{stringliteral}{"Largest Allocation:"},
11044      \textcolor{stringliteral}{"%lld bytes"}, SQLITE_STATUS_MALLOC_SIZE, bReset);
11045   displayStatLine(pArg, \textcolor{stringliteral}{"Largest Pcache Allocation:"},
11046      \textcolor{stringliteral}{"%lld bytes"}, SQLITE_STATUS_PAGECACHE_SIZE, bReset);
11047 \textcolor{preprocessor}{#ifdef YYTRACKMAXSTACKDEPTH}
11048   displayStatLine(pArg, \textcolor{stringliteral}{"Deepest Parser Stack:"},
11049      \textcolor{stringliteral}{"%lld (max %lld)"}, SQLITE_STATUS_PARSER_STACK, bReset);
11050 \textcolor{preprocessor}{#endif}
11051 
11052   \textcolor{keywordflow}{if}( db )\{
11053     \textcolor{keywordflow}{if}( pArg->shellFlgs & SHFLG_Lookaside )\{
11054       iHiwtr = iCur = -1;
11055       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_USED,
11056                         &iCur, &iHiwtr, bReset);
11057       raw_printf(pArg->out,
11058               \textcolor{stringliteral}{"Lookaside Slots Used:                %d (max %d)\(\backslash\)n"},
11059               iCur, iHiwtr);
11060       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_HIT,
11061                         &iCur, &iHiwtr, bReset);
11062       raw_printf(pArg->out, \textcolor{stringliteral}{"Successful lookaside attempts:       %d\(\backslash\)n"},
11063               iHiwtr);
11064       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE,
11065                         &iCur, &iHiwtr, bReset);
11066       raw_printf(pArg->out, \textcolor{stringliteral}{"Lookaside failures due to size:      %d\(\backslash\)n"},
11067               iHiwtr);
11068       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL,
11069                         &iCur, &iHiwtr, bReset);
11070       raw_printf(pArg->out, \textcolor{stringliteral}{"Lookaside failures due to OOM:       %d\(\backslash\)n"},
11071               iHiwtr);
11072     \}
11073     iHiwtr = iCur = -1;
11074     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_USED, &iCur, &iHiwtr, bReset);
11075     raw_printf(pArg->out, \textcolor{stringliteral}{"Pager Heap Usage:                    %d bytes\(\backslash\)n"},
11076             iCur);
11077     iHiwtr = iCur = -1;
11078     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_HIT, &iCur, &iHiwtr, 1);
11079     raw_printf(pArg->out, \textcolor{stringliteral}{"Page cache hits:                     %d\(\backslash\)n"}, iCur);
11080     iHiwtr = iCur = -1;
11081     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_MISS, &iCur, &iHiwtr, 1);
11082     raw_printf(pArg->out, \textcolor{stringliteral}{"Page cache misses:                   %d\(\backslash\)n"}, iCur);
11083     iHiwtr = iCur = -1;
11084     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_WRITE, &iCur, &iHiwtr, 1);
11085     raw_printf(pArg->out, \textcolor{stringliteral}{"Page cache writes:                   %d\(\backslash\)n"}, iCur);
11086     iHiwtr = iCur = -1;
11087     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_SPILL, &iCur, &iHiwtr, 1);
11088     raw_printf(pArg->out, \textcolor{stringliteral}{"Page cache spills:                   %d\(\backslash\)n"}, iCur);
11089     iHiwtr = iCur = -1;
11090     sqlite3_db_status(db, SQLITE_DBSTATUS_SCHEMA_USED, &iCur, &iHiwtr, bReset);
11091     raw_printf(pArg->out, \textcolor{stringliteral}{"Schema Heap Usage:                   %d bytes\(\backslash\)n"},
11092             iCur);
11093     iHiwtr = iCur = -1;
11094     sqlite3_db_status(db, SQLITE_DBSTATUS_STMT_USED, &iCur, &iHiwtr, bReset);
11095     raw_printf(pArg->out, \textcolor{stringliteral}{"Statement Heap/Lookaside Usage:      %d bytes\(\backslash\)n"},
11096             iCur);
11097   \}
11098 
11099   \textcolor{keywordflow}{if}( pArg->pStmt )\{
11100     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_FULLSCAN_STEP,
11101                                bReset);
11102     raw_printf(pArg->out, \textcolor{stringliteral}{"Fullscan Steps:                      %d\(\backslash\)n"}, iCur);
11103     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_SORT, bReset);
11104     raw_printf(pArg->out, \textcolor{stringliteral}{"Sort Operations:                     %d\(\backslash\)n"}, iCur);
11105     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_AUTOINDEX,bReset);
11106     raw_printf(pArg->out, \textcolor{stringliteral}{"Autoindex Inserts:                   %d\(\backslash\)n"}, iCur);
11107     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_VM_STEP, bReset);
11108     raw_printf(pArg->out, \textcolor{stringliteral}{"Virtual Machine Steps:               %d\(\backslash\)n"}, iCur);
11109     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_REPREPARE,bReset);
11110     raw_printf(pArg->out, \textcolor{stringliteral}{"Reprepare operations:                %d\(\backslash\)n"}, iCur);
11111     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_RUN, bReset);
11112     raw_printf(pArg->out, \textcolor{stringliteral}{"Number of times run:                 %d\(\backslash\)n"}, iCur);
11113     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_MEMUSED, bReset);
11114     raw_printf(pArg->out, \textcolor{stringliteral}{"Memory used by prepared stmt:        %d\(\backslash\)n"}, iCur);
11115   \}
11116 
11117 \textcolor{preprocessor}{#ifdef \_\_linux\_\_}
11118   displayLinuxIoStats(pArg->out);
11119 \textcolor{preprocessor}{#endif}
11120 
11121   \textcolor{comment}{/* Do not remove this machine readable comment: extra-stats-output-here */}
11122 
11123   \textcolor{keywordflow}{return} 0;
11124 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a7e304a7c24d9001c7c3507cc694c0803}} 
\index{shell.\+c@{shell.\+c}!display\+Stat\+Line@{display\+Stat\+Line}}
\index{display\+Stat\+Line@{display\+Stat\+Line}!shell.\+c@{shell.\+c}}
\subsubsection{display\+Stat\+Line()}
{\footnotesize\ttfamily static void display\+Stat\+Line (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{char $\ast$}]{z\+Label,  }\item[{char $\ast$}]{z\+Format,  }\item[{int}]{i\+Status\+Ctrl,  }\item[{int}]{b\+Reset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10972 of file shell.\+c.



References Shell\+State\+::out, raw\+\_\+printf, sqlite3\+\_\+snprintf, and sqlite3\+\_\+status64.



Referenced by display\+\_\+stats().


\begin{DoxyCode}
10978  \{
10979   sqlite3_int64 iCur = -1;
10980   sqlite3_int64 iHiwtr = -1;
10981   \textcolor{keywordtype}{int} i, nPercent;
10982   \textcolor{keywordtype}{char} zLine[200];
10983   sqlite3_status64(iStatusCtrl, &iCur, &iHiwtr, bReset);
10984   \textcolor{keywordflow}{for}(i=0, nPercent=0; zFormat[i]; i++)\{
10985     \textcolor{keywordflow}{if}( zFormat[i]==\textcolor{charliteral}{'%'} ) nPercent++;
10986   \}
10987   \textcolor{keywordflow}{if}( nPercent>1 )\{
10988     sqlite3_snprintf(\textcolor{keyword}{sizeof}(zLine), zLine, zFormat, iCur, iHiwtr);
10989   \}\textcolor{keywordflow}{else}\{
10990     sqlite3_snprintf(\textcolor{keyword}{sizeof}(zLine), zLine, zFormat, iHiwtr);
10991   \}
10992   raw_printf(p->out, \textcolor{stringliteral}{"%-36s %s\(\backslash\)n"}, zLabel, zLine);
10993 \}
\end{DoxyCode}
\mbox{\label{shell_8c_afa163532116cd4bc3cc15aa8e451c2a1}} 
\index{shell.\+c@{shell.\+c}!do\+\_\+meta\+\_\+command@{do\+\_\+meta\+\_\+command}}
\index{do\+\_\+meta\+\_\+command@{do\+\_\+meta\+\_\+command}!shell.\+c@{shell.\+c}}
\subsubsection{do\+\_\+meta\+\_\+command()}
{\footnotesize\ttfamily static int do\+\_\+meta\+\_\+command (\begin{DoxyParamCaption}\item[{char $\ast$}]{z\+Line,  }\item[{\textbf{ Shell\+State} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 15481 of file shell.\+c.



References append\+Text(), Array\+Size, ascii\+\_\+read\+\_\+one\+\_\+field(), Shell\+State\+::auto\+E\+QP, A\+U\+T\+O\+E\+Q\+P\+\_\+full, A\+U\+T\+O\+E\+Q\+P\+\_\+on, A\+U\+T\+O\+E\+Q\+P\+\_\+trigger, Shell\+State\+::auto\+E\+Q\+Ptest, Shell\+State\+::auto\+E\+Q\+Ptrace, Shell\+State\+::auto\+Explain, bind\+\_\+table\+\_\+init(), boolean\+Value(), callback(), capture\+Output\+Callback(), Import\+Ctx\+::c\+Col\+Sep, clear\+Temp\+File(), close\+\_\+db(), Shell\+State\+::c\+Mode, Shell\+State\+::cnt, Shell\+State\+::col\+Separator, Shell\+State\+::col\+Width, create\+Selftest\+Table(), Import\+Ctx\+::c\+Row\+Sep, csv\+\_\+read\+\_\+one\+\_\+field(), Import\+Ctx\+::c\+Term, C\+T\+I\+M\+E\+O\+P\+T\+\_\+\+V\+AL, main3\+::data, Shell\+State\+::db, display\+\_\+stats(), Shell\+State\+::do\+Xdg\+Open, Shell\+State\+::e\+Trace\+Type, Shell\+State\+::expert, expert\+Dot\+Command(), expert\+Finish(), Shell\+State\+::flg\+Progress, free\+Text(), H\+A\+S\+\_\+\+T\+I\+M\+ER, import\+\_\+append\+\_\+char(), Shell\+State\+::in, Import\+Ctx\+::in, init\+Text(), integer\+Value(), Is\+Space, sqlite3\+\_\+vfs\+::i\+Version, Shell\+State\+::lineno, lint\+Dot\+Command(), Shell\+State\+::mode, M\+O\+D\+E\+\_\+\+Ascii, M\+O\+D\+E\+\_\+\+Column, M\+O\+D\+E\+\_\+\+Csv, M\+O\+D\+E\+\_\+\+Explain, M\+O\+D\+E\+\_\+\+Html, M\+O\+D\+E\+\_\+\+Insert, M\+O\+D\+E\+\_\+\+Line, M\+O\+D\+E\+\_\+\+List, M\+O\+D\+E\+\_\+\+Pretty, M\+O\+D\+E\+\_\+\+Quote, M\+O\+D\+E\+\_\+\+Semi, M\+O\+D\+E\+\_\+\+Tcl, sqlite3\+\_\+vfs\+::mx\+Pathname, Shell\+State\+::mx\+Progress, Shell\+Text\+::n, Shell\+State\+::n\+Check, Shell\+State\+::n\+Err, new\+Temp\+File(), Import\+Ctx\+::n\+Line, Shell\+State\+::normal\+Mode, Shell\+State\+::n\+Progress, Shell\+State\+::null\+Value, open\+\_\+db(), O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+K\+E\+E\+P\+A\+L\+I\+VE, Shell\+State\+::open\+Flags, Shell\+State\+::open\+Mode, option\+Match(), Shell\+State\+::out, Shell\+State\+::out\+Count, Shell\+State\+::outfile, output\+\_\+c\+\_\+string(), output\+\_\+file\+\_\+close(), output\+\_\+file\+\_\+open(), output\+\_\+reset(), output\+Mode\+Push(), pclose(), Expert\+Info\+::p\+Expert, Shell\+State\+::p\+Log, sqlite3\+\_\+vfs\+::p\+Next, popen(), process\+\_\+input(), progress\+\_\+handler(), quote\+Char(), raw\+\_\+printf, read\+File(), resolve\+\_\+backslashes(), Shell\+State\+::row\+Separator, run\+\_\+schema\+\_\+dump\+\_\+query(), run\+\_\+table\+\_\+dump\+\_\+query(), Shell\+State\+::scanstats\+On, S\+E\+P\+\_\+\+Column, S\+E\+P\+\_\+\+Comma, S\+E\+P\+\_\+\+Cr\+Lf, S\+E\+P\+\_\+\+Record, S\+E\+P\+\_\+\+Row, S\+E\+P\+\_\+\+Space, S\+E\+P\+\_\+\+Tab, S\+E\+P\+\_\+\+Unit, session\+\_\+close\+\_\+all, set\+\_\+table\+\_\+name(), set\+Binary\+Mode, set\+Or\+Clear\+Flag(), set\+Text\+Mode, shell\+\_\+dbinfo\+\_\+command(), shell\+\_\+exec(), S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+ZE, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+H\+E\+X\+DB, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+U\+N\+S\+P\+EC, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE, shell\+\_\+out\+\_\+of\+\_\+memory(), S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+O\+N\+CE, S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+Q\+U\+I\+ET, S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+R\+E\+S\+ET, S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+E\+X\+P\+A\+N\+D\+ED, S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+ED, S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+P\+L\+A\+IN, shell\+Auth(), Shell\+Clear\+Flag, shell\+Database\+Error(), shell\+Delete\+File(), Shell\+State\+::shell\+Flgs, Shell\+Has\+Flag, Shell\+Set\+Flag, S\+H\+F\+L\+G\+\_\+\+Count\+Changes, S\+H\+F\+L\+G\+\_\+\+Echo, S\+H\+F\+L\+G\+\_\+\+Newlines, S\+H\+F\+L\+G\+\_\+\+Preserve\+Rowid, Shell\+State\+::show\+Header, show\+Help(), sql\+\_\+trace\+\_\+callback(), sqlite3\+\_\+backup\+\_\+finish, sqlite3\+\_\+backup\+\_\+init, sqlite3\+\_\+backup\+\_\+step, sqlite3\+\_\+bind\+\_\+null, sqlite3\+\_\+bind\+\_\+text, sqlite3\+\_\+busy\+\_\+timeout, sqlite3\+\_\+column\+\_\+count, sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+create\+\_\+module, sqlite3\+\_\+db\+\_\+config, sqlite3\+\_\+drop\+\_\+modules, sqlite3\+\_\+errmsg, sqlite3\+\_\+exec, sqlite3\+\_\+file\+\_\+control, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+get\+\_\+autocommit, sqlite3\+\_\+libversion, sqlite3\+\_\+limit, sqlite3\+\_\+load\+\_\+extension, sqlite3\+\_\+malloc, sqlite3\+\_\+malloc64, sqlite3\+\_\+mprintf, sqlite3\+\_\+open, sqlite3\+\_\+open\+\_\+v2, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+progress\+\_\+handler, sqlite3\+\_\+randomness, sqlite3\+\_\+realloc64, sqlite3\+\_\+reset, sqlite3\+\_\+set\+\_\+authorizer, sqlite3\+\_\+sleep, sqlite3\+\_\+snprintf, sqlite3\+\_\+sourceid, sqlite3\+\_\+step, sqlite3\+\_\+strglob, sqlite3\+\_\+stricmp, sqlite3\+\_\+strlike, sqlite3\+\_\+strnicmp, sqlite3\+\_\+table\+\_\+column\+\_\+metadata, sqlite3\+\_\+test\+\_\+control, sqlite3\+\_\+trace\+\_\+v2, sqlite3\+\_\+vfs\+\_\+find, S\+Q\+L\+I\+T\+E\+\_\+\+A\+PI, S\+Q\+L\+I\+T\+E\+\_\+\+B\+U\+SY, S\+Q\+L\+I\+T\+E\+\_\+\+C\+D\+E\+CL, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+D\+E\+F\+E\+N\+S\+I\+VE, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+D\+Q\+S\+\_\+\+D\+DL, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+D\+Q\+S\+\_\+\+D\+ML, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+F\+K\+EY, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+F\+T\+S3\+\_\+\+T\+O\+K\+E\+N\+I\+Z\+ER, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+L\+O\+A\+D\+\_\+\+E\+X\+T\+E\+N\+S\+I\+ON, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+Q\+P\+SG, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+T\+R\+I\+G\+G\+ER, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+V\+I\+EW, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+L\+E\+G\+A\+C\+Y\+\_\+\+A\+L\+T\+E\+R\+\_\+\+T\+A\+B\+LE, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+L\+E\+G\+A\+C\+Y\+\_\+\+F\+I\+L\+E\+\_\+\+F\+O\+R\+M\+AT, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+N\+O\+\_\+\+C\+K\+P\+T\+\_\+\+O\+N\+\_\+\+C\+L\+O\+SE, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+R\+E\+S\+E\+T\+\_\+\+D\+A\+T\+A\+B\+A\+SE, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+T\+R\+I\+G\+G\+E\+R\+\_\+\+E\+QP, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+T\+R\+U\+S\+T\+E\+D\+\_\+\+S\+C\+H\+E\+MA, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+W\+R\+I\+T\+A\+B\+L\+E\+\_\+\+S\+C\+H\+E\+MA, S\+Q\+L\+I\+T\+E\+\_\+\+D\+O\+NE, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+C\+H\+U\+N\+K\+\_\+\+S\+I\+ZE, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+H\+A\+S\+\_\+\+M\+O\+V\+ED, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+L\+O\+C\+K\+\_\+\+T\+I\+M\+E\+O\+UT, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+P\+E\+R\+S\+I\+S\+T\+\_\+\+W\+AL, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+P\+O\+W\+E\+R\+S\+A\+F\+E\+\_\+\+O\+V\+E\+R\+W\+R\+I\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+S\+I\+Z\+E\+\_\+\+L\+I\+M\+IT, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+T\+E\+M\+P\+F\+I\+L\+E\+N\+A\+ME, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+V\+F\+S\+\_\+\+P\+O\+I\+N\+T\+ER, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+V\+F\+S\+N\+A\+ME, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+A\+T\+T\+A\+C\+H\+ED, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+C\+O\+L\+U\+MN, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+C\+O\+M\+P\+O\+U\+N\+D\+\_\+\+S\+E\+L\+E\+CT, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+E\+X\+P\+R\+\_\+\+D\+E\+P\+TH, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+F\+U\+N\+C\+T\+I\+O\+N\+\_\+\+A\+RG, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+L\+E\+N\+G\+TH, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+L\+I\+K\+E\+\_\+\+P\+A\+T\+T\+E\+R\+N\+\_\+\+L\+E\+N\+G\+TH, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+S\+Q\+L\+\_\+\+L\+E\+N\+G\+TH, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+T\+R\+I\+G\+G\+E\+R\+\_\+\+D\+E\+P\+TH, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+V\+A\+R\+I\+A\+B\+L\+E\+\_\+\+N\+U\+M\+B\+ER, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+V\+D\+B\+E\+\_\+\+OP, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+W\+O\+R\+K\+E\+R\+\_\+\+T\+H\+R\+E\+A\+DS, S\+Q\+L\+I\+T\+E\+\_\+\+L\+O\+C\+K\+ED, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+C\+R\+E\+A\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+N\+O\+F\+O\+L\+L\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+W\+R\+I\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+IC, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+A\+L\+W\+A\+YS, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+A\+S\+S\+E\+RT, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+B\+Y\+T\+E\+O\+R\+D\+ER, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+E\+X\+T\+R\+A\+\_\+\+S\+C\+H\+E\+M\+A\+\_\+\+C\+H\+E\+C\+KS, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+I\+M\+P\+O\+S\+T\+ER, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+F\+U\+N\+C\+T\+I\+O\+NS, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+L\+O\+C\+A\+L\+T\+I\+M\+E\+\_\+\+F\+A\+U\+LT, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+N\+E\+V\+E\+R\+\_\+\+C\+O\+R\+R\+U\+PT, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+O\+P\+T\+I\+M\+I\+Z\+A\+T\+I\+O\+NS, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+P\+A\+R\+S\+E\+R\+\_\+\+C\+O\+V\+E\+R\+A\+GE, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+P\+E\+N\+D\+I\+N\+G\+\_\+\+B\+Y\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+P\+R\+N\+G\+\_\+\+R\+E\+S\+ET, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+P\+R\+N\+G\+\_\+\+R\+E\+S\+T\+O\+RE, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+P\+R\+N\+G\+\_\+\+S\+A\+VE, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+P\+R\+N\+G\+\_\+\+S\+E\+ED, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+S\+T\+C\+T\+R\+L\+\_\+\+R\+E\+S\+E\+R\+VE, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+C\+E\+\_\+\+C\+L\+O\+SE, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+C\+E\+\_\+\+P\+R\+O\+F\+I\+LE, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+C\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+C\+E\+\_\+\+S\+T\+MT, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT, Shell\+State\+::stats\+On, strlen30(), Shell\+State\+::sz\+Max, sqlite3\+\_\+vfs\+::sz\+Os\+File, test\+\_\+breakpoint(), testcase\+\_\+glob(), Shell\+State\+::trace\+Out, try\+To\+Clone(), utf8\+\_\+printf, Shell\+State\+::writable\+Schema, time\+\_\+test\+::x, Shell\+Text\+::z, Import\+Ctx\+::z, Shell\+State\+::z\+Db\+Filename, Shell\+State\+::z\+Dest\+Table, Import\+Ctx\+::z\+File, Shell\+State\+::z\+Free\+On\+Close, sqlite3\+\_\+vfs\+::z\+Name, z\+Name, Shell\+State\+::z\+Temp\+File, and Shell\+State\+::z\+Testcase.



Referenced by main(), and process\+\_\+input().


\begin{DoxyCode}
15481                                                       \{
15482   \textcolor{keywordtype}{int} h = 1;
15483   \textcolor{keywordtype}{int} nArg = 0;
15484   \textcolor{keywordtype}{int} n, c;
15485   \textcolor{keywordtype}{int} rc = 0;
15486   \textcolor{keywordtype}{char} *azArg[52];
15487 
15488 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_VIRTUALTABLE}
15489   \textcolor{keywordflow}{if}( p->expert.pExpert )\{
15490     expertFinish(p, 1, 0);
15491   \}
15492 \textcolor{preprocessor}{#endif}
15493 
15494   \textcolor{comment}{/* Parse the input line into tokens.}
15495 \textcolor{comment}{  */}
15496   \textcolor{keywordflow}{while}( zLine[h] && nArg<ArraySize(azArg)-1 )\{
15497     \textcolor{keywordflow}{while}( IsSpace(zLine[h]) )\{ h++; \}
15498     \textcolor{keywordflow}{if}( zLine[h]==0 ) \textcolor{keywordflow}{break};
15499     \textcolor{keywordflow}{if}( zLine[h]==\textcolor{charliteral}{'\(\backslash\)''} || zLine[h]==\textcolor{charliteral}{'"'} )\{
15500       \textcolor{keywordtype}{int} delim = zLine[h++];
15501       azArg[nArg++] = &zLine[h];
15502       \textcolor{keywordflow}{while}( zLine[h] && zLine[h]!=delim )\{
15503         \textcolor{keywordflow}{if}( zLine[h]==\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} && delim==\textcolor{charliteral}{'"'} && zLine[h+1]!=0 ) h++;
15504         h++;
15505       \}
15506       \textcolor{keywordflow}{if}( zLine[h]==delim )\{
15507         zLine[h++] = 0;
15508       \}
15509       \textcolor{keywordflow}{if}( delim==\textcolor{charliteral}{'"'} ) resolve_backslashes(azArg[nArg-1]);
15510     \}\textcolor{keywordflow}{else}\{
15511       azArg[nArg++] = &zLine[h];
15512       \textcolor{keywordflow}{while}( zLine[h] && !IsSpace(zLine[h]) )\{ h++; \}
15513       \textcolor{keywordflow}{if}( zLine[h] ) zLine[h++] = 0;
15514       resolve_backslashes(azArg[nArg-1]);
15515     \}
15516   \}
15517   azArg[nArg] = 0;
15518 
15519   \textcolor{comment}{/* Process the input line.}
15520 \textcolor{comment}{  */}
15521   \textcolor{keywordflow}{if}( nArg==0 ) \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* no tokens, no error */}
15522   n = strlen30(azArg[0]);
15523   c = azArg[0][0];
15524   clearTempFile(p);
15525 
15526 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_AUTHORIZATION}
15527   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'a'} && strncmp(azArg[0], \textcolor{stringliteral}{"auth"}, n)==0 )\{
15528     \textcolor{keywordflow}{if}( nArg!=2 )\{
15529       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .auth ON|OFF\(\backslash\)n"});
15530       rc = 1;
15531       \textcolor{keywordflow}{goto} meta\_command\_exit;
15532     \}
15533     open_db(p, 0);
15534     \textcolor{keywordflow}{if}( booleanValue(azArg[1]) )\{
15535       sqlite3_set_authorizer(p->db, shellAuth, p);
15536     \}\textcolor{keywordflow}{else}\{
15537       sqlite3_set_authorizer(p->db, 0, 0);
15538     \}
15539   \}\textcolor{keywordflow}{else}
15540 \textcolor{preprocessor}{#endif}
15541 
15542 \textcolor{preprocessor}{#if !defined(SQLITE\_OMIT\_VIRTUALTABLE) && defined(SQLITE\_HAVE\_ZLIB)}
15543   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'a'} && strncmp(azArg[0], \textcolor{stringliteral}{"archive"}, n)==0 )\{
15544     open_db(p, 0);
15545     rc = arDotCommand(p, 0, azArg, nArg);
15546   \}\textcolor{keywordflow}{else}
15547 \textcolor{preprocessor}{#endif}
15548 
15549   \textcolor{keywordflow}{if}( (c==\textcolor{charliteral}{'b'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"backup"}, n)==0)
15550    || (c==\textcolor{charliteral}{'s'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"save"}, n)==0)
15551   )\{
15552     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDestFile = 0;
15553     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDb = 0;
15554     sqlite3 *pDest;
15555     sqlite3_backup *pBackup;
15556     \textcolor{keywordtype}{int} j;
15557     \textcolor{keywordtype}{int} bAsync = 0;
15558     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zVfs = 0;
15559     \textcolor{keywordflow}{for}(j=1; j<nArg; j++)\{
15560       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z = azArg[j];
15561       \textcolor{keywordflow}{if}( z[0]==\textcolor{charliteral}{'-'} )\{
15562         \textcolor{keywordflow}{if}( z[1]==\textcolor{charliteral}{'-'} ) z++;
15563         \textcolor{keywordflow}{if}( strcmp(z, \textcolor{stringliteral}{"-append"})==0 )\{
15564           zVfs = \textcolor{stringliteral}{"apndvfs"};
15565         \}\textcolor{keywordflow}{else}
15566         \textcolor{keywordflow}{if}( strcmp(z, \textcolor{stringliteral}{"-async"})==0 )\{
15567           bAsync = 1;
15568         \}\textcolor{keywordflow}{else}
15569         \{
15570           utf8_printf(stderr, \textcolor{stringliteral}{"unknown option: %s\(\backslash\)n"}, azArg[j]);
15571           \textcolor{keywordflow}{return} 1;
15572         \}
15573       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( zDestFile==0 )\{
15574         zDestFile = azArg[j];
15575       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( zDb==0 )\{
15576         zDb = zDestFile;
15577         zDestFile = azArg[j];
15578       \}\textcolor{keywordflow}{else}\{
15579         raw_printf(stderr, \textcolor{stringliteral}{"Usage: .backup ?DB? ?OPTIONS? FILENAME\(\backslash\)n"});
15580         \textcolor{keywordflow}{return} 1;
15581       \}
15582     \}
15583     \textcolor{keywordflow}{if}( zDestFile==0 )\{
15584       raw_printf(stderr, \textcolor{stringliteral}{"missing FILENAME argument on .backup\(\backslash\)n"});
15585       \textcolor{keywordflow}{return} 1;
15586     \}
15587     \textcolor{keywordflow}{if}( zDb==0 ) zDb = \textcolor{stringliteral}{"main"};
15588     rc = sqlite3_open_v2(zDestFile, &pDest, 
15589                   SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE, zVfs);
15590     \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
15591       utf8_printf(stderr, \textcolor{stringliteral}{"Error: cannot open \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, zDestFile);
15592       close_db(pDest);
15593       \textcolor{keywordflow}{return} 1;
15594     \}
15595     \textcolor{keywordflow}{if}( bAsync )\{
15596       sqlite3_exec(pDest, \textcolor{stringliteral}{"PRAGMA synchronous=OFF; PRAGMA journal\_mode=OFF;"},
15597                    0, 0, 0);
15598     \}
15599     open_db(p, 0);
15600     pBackup = sqlite3_backup_init(pDest, \textcolor{stringliteral}{"main"}, p->db, zDb);
15601     \textcolor{keywordflow}{if}( pBackup==0 )\{
15602       utf8_printf(stderr, \textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, sqlite3_errmsg(pDest));
15603       close_db(pDest);
15604       \textcolor{keywordflow}{return} 1;
15605     \}
15606     \textcolor{keywordflow}{while}(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK )\{\}
15607     sqlite3_backup_finish(pBackup);
15608     \textcolor{keywordflow}{if}( rc==SQLITE_DONE )\{
15609       rc = 0;
15610     \}\textcolor{keywordflow}{else}\{
15611       utf8_printf(stderr, \textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, sqlite3_errmsg(pDest));
15612       rc = 1;
15613     \}
15614     close_db(pDest);
15615   \}\textcolor{keywordflow}{else}
15616 
15617   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'b'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"bail"}, n)==0 )\{
15618     \textcolor{keywordflow}{if}( nArg==2 )\{
15619       bail_on_error = booleanValue(azArg[1]);
15620     \}\textcolor{keywordflow}{else}\{
15621       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .bail on|off\(\backslash\)n"});
15622       rc = 1;
15623     \}
15624   \}\textcolor{keywordflow}{else}
15625 
15626   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'b'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"binary"}, n)==0 )\{
15627     \textcolor{keywordflow}{if}( nArg==2 )\{
15628       \textcolor{keywordflow}{if}( booleanValue(azArg[1]) )\{
15629         setBinaryMode(p->out, 1);
15630       \}\textcolor{keywordflow}{else}\{
15631         setTextMode(p->out, 1);
15632       \}
15633     \}\textcolor{keywordflow}{else}\{
15634       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .binary on|off\(\backslash\)n"});
15635       rc = 1;
15636     \}
15637   \}\textcolor{keywordflow}{else}
15638 
15639   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'c'} && strcmp(azArg[0],\textcolor{stringliteral}{"cd"})==0 )\{
15640     \textcolor{keywordflow}{if}( nArg==2 )\{
15641 \textcolor{preprocessor}{#if defined(\_WIN32) || defined(WIN32)}
15642       \textcolor{keywordtype}{wchar\_t} *z = sqlite3\_win32\_utf8\_to\_unicode(azArg[1]);
15643       rc = !SetCurrentDirectoryW(z);
15644       sqlite3_free(z);
15645 \textcolor{preprocessor}{#else}
15646       rc = chdir(azArg[1]);
15647 \textcolor{preprocessor}{#endif}
15648       \textcolor{keywordflow}{if}( rc )\{
15649         utf8_printf(stderr, \textcolor{stringliteral}{"Cannot change to directory \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, azArg[1]);
15650         rc = 1;
15651       \}
15652     \}\textcolor{keywordflow}{else}\{
15653       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .cd DIRECTORY\(\backslash\)n"});
15654       rc = 1;
15655     \}
15656   \}\textcolor{keywordflow}{else}
15657 
15658   \textcolor{comment}{/* The undocumented ".breakpoint" command causes a call to the no-op}
15659 \textcolor{comment}{  ** routine named test\_breakpoint().}
15660 \textcolor{comment}{  */}
15661   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'b'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"breakpoint"}, n)==0 )\{
15662     test_breakpoint();
15663   \}\textcolor{keywordflow}{else}
15664 
15665   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'c'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"changes"}, n)==0 )\{
15666     \textcolor{keywordflow}{if}( nArg==2 )\{
15667       setOrClearFlag(p, SHFLG_CountChanges, azArg[1]);
15668     \}\textcolor{keywordflow}{else}\{
15669       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .changes on|off\(\backslash\)n"});
15670       rc = 1;
15671     \}
15672   \}\textcolor{keywordflow}{else}
15673 
15674   \textcolor{comment}{/* Cancel output redirection, if it is currently set (by .testcase)}
15675 \textcolor{comment}{  ** Then read the content of the testcase-out.txt file and compare against}
15676 \textcolor{comment}{  ** azArg[1].  If there are differences, report an error and exit.}
15677 \textcolor{comment}{  */}
15678   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'c'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"check"}, n)==0 )\{
15679     \textcolor{keywordtype}{char} *zRes = 0;
15680     output_reset(p);
15681     \textcolor{keywordflow}{if}( nArg!=2 )\{
15682       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .check GLOB-PATTERN\(\backslash\)n"});
15683       rc = 2;
15684     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( (zRes = readFile(\textcolor{stringliteral}{"testcase-out.txt"}, 0))==0 )\{
15685       raw_printf(stderr, \textcolor{stringliteral}{"Error: cannot read 'testcase-out.txt'\(\backslash\)n"});
15686       rc = 2;
15687     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( testcase_glob(azArg[1],zRes)==0 )\{
15688       utf8_printf(stderr,
15689                  \textcolor{stringliteral}{"testcase-%s FAILED\(\backslash\)n Expected: [%s]\(\backslash\)n      Got: [%s]\(\backslash\)n"},
15690                  p->zTestcase, azArg[1], zRes);
15691       rc = 1;
15692     \}\textcolor{keywordflow}{else}\{
15693       utf8_printf(stdout, \textcolor{stringliteral}{"testcase-%s ok\(\backslash\)n"}, p->zTestcase);
15694       p->nCheck++;
15695     \}
15696     sqlite3_free(zRes);
15697   \}\textcolor{keywordflow}{else}
15698 
15699   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'c'} && strncmp(azArg[0], \textcolor{stringliteral}{"clone"}, n)==0 )\{
15700     \textcolor{keywordflow}{if}( nArg==2 )\{
15701       tryToClone(p, azArg[1]);
15702     \}\textcolor{keywordflow}{else}\{
15703       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .clone FILENAME\(\backslash\)n"});
15704       rc = 1;
15705     \}
15706   \}\textcolor{keywordflow}{else}
15707 
15708   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'d'} && n>1 && strncmp(azArg[0], \textcolor{stringliteral}{"databases"}, n)==0 )\{
15709     ShellState data;
15710     \textcolor{keywordtype}{char} *zErrMsg = 0;
15711     open_db(p, 0);
15712     memcpy(&data, p, \textcolor{keyword}{sizeof}(data));
15713     data.showHeader = 0;
15714     data.cMode = data.mode = MODE_List;
15715     sqlite3_snprintf(\textcolor{keyword}{sizeof}(data.colSeparator),data.colSeparator,\textcolor{stringliteral}{": "});
15716     data.cnt = 0;
15717     sqlite3_exec(p->db, \textcolor{stringliteral}{"SELECT name, file FROM pragma\_database\_list"},
15718                  callback, &data, &zErrMsg);
15719     \textcolor{keywordflow}{if}( zErrMsg )\{
15720       utf8_printf(stderr,\textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, zErrMsg);
15721       sqlite3_free(zErrMsg);
15722       rc = 1;
15723     \}
15724   \}\textcolor{keywordflow}{else}
15725 
15726   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'d'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"dbconfig"}, n)==0 )\{
15727     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }DbConfigChoices \{
15728       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zName;
15729       \textcolor{keywordtype}{int} op;
15730     \} aDbConfig[] = \{
15731         \{ \textcolor{stringliteral}{"defensive"},          SQLITE_DBCONFIG_DEFENSIVE             \},
15732         \{ \textcolor{stringliteral}{"dqs\_ddl"},            SQLITE_DBCONFIG_DQS_DDL               \},
15733         \{ \textcolor{stringliteral}{"dqs\_dml"},            SQLITE_DBCONFIG_DQS_DML               \},
15734         \{ \textcolor{stringliteral}{"enable\_fkey"},        SQLITE_DBCONFIG_ENABLE_FKEY           \},
15735         \{ \textcolor{stringliteral}{"enable\_qpsg"},        SQLITE_DBCONFIG_ENABLE_QPSG           \},
15736         \{ \textcolor{stringliteral}{"enable\_trigger"},     SQLITE_DBCONFIG_ENABLE_TRIGGER        \},
15737         \{ \textcolor{stringliteral}{"enable\_view"},        SQLITE_DBCONFIG_ENABLE_VIEW           \},
15738         \{ \textcolor{stringliteral}{"fts3\_tokenizer"},     SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER \},
15739         \{ \textcolor{stringliteral}{"legacy\_alter\_table"}, SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    \},
15740         \{ \textcolor{stringliteral}{"legacy\_file\_format"}, SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    \},
15741         \{ \textcolor{stringliteral}{"load\_extension"},     SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION \},
15742         \{ \textcolor{stringliteral}{"no\_ckpt\_on\_close"},   SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      \},
15743         \{ \textcolor{stringliteral}{"reset\_database"},     SQLITE_DBCONFIG_RESET_DATABASE        \},
15744         \{ \textcolor{stringliteral}{"trigger\_eqp"},        SQLITE_DBCONFIG_TRIGGER_EQP           \},
15745         \{ \textcolor{stringliteral}{"trusted\_schema"},     SQLITE_DBCONFIG_TRUSTED_SCHEMA        \},
15746         \{ \textcolor{stringliteral}{"writable\_schema"},    SQLITE_DBCONFIG_WRITABLE_SCHEMA       \},
15747     \};
15748     \textcolor{keywordtype}{int} ii, v;
15749     open_db(p, 0);
15750     \textcolor{keywordflow}{for}(ii=0; ii<ArraySize(aDbConfig); ii++)\{
15751       \textcolor{keywordflow}{if}( nArg>1 && strcmp(azArg[1], aDbConfig[ii].zName)!=0 ) \textcolor{keywordflow}{continue};
15752       \textcolor{keywordflow}{if}( nArg>=3 )\{
15753         sqlite3_db_config(p->db, aDbConfig[ii].op, booleanValue(azArg[2]), 0);
15754       \}
15755       sqlite3_db_config(p->db, aDbConfig[ii].op, -1, &v);
15756       utf8_printf(p->out, \textcolor{stringliteral}{"%19s %s\(\backslash\)n"}, aDbConfig[ii].zName, v ? \textcolor{stringliteral}{"on"} : \textcolor{stringliteral}{"off"});
15757       \textcolor{keywordflow}{if}( nArg>1 ) \textcolor{keywordflow}{break};
15758     \}
15759     \textcolor{keywordflow}{if}( nArg>1 && ii==ArraySize(aDbConfig) )\{
15760       utf8_printf(stderr, \textcolor{stringliteral}{"Error: unknown dbconfig \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, azArg[1]);
15761       utf8_printf(stderr, \textcolor{stringliteral}{"Enter \(\backslash\)".dbconfig\(\backslash\)" with no arguments for a list\(\backslash\)n"});
15762     \}   
15763   \}\textcolor{keywordflow}{else}
15764 
15765   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'d'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"dbinfo"}, n)==0 )\{
15766     rc = shell_dbinfo_command(p, nArg, azArg);
15767   \}\textcolor{keywordflow}{else}
15768 
15769 \textcolor{preprocessor}{#if !defined(SQLITE\_OMIT\_VIRTUALTABLE) && defined(SQLITE\_ENABLE\_DBPAGE\_VTAB)}
15770   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'r'} && strncmp(azArg[0], \textcolor{stringliteral}{"recover"}, n)==0 )\{
15771     open_db(p, 0);
15772     rc = recoverDatabaseCmd(p, nArg, azArg);
15773   \}\textcolor{keywordflow}{else}
15774 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !(SQLITE\_OMIT\_VIRTUALTABLE) && defined(SQLITE\_ENABLE\_DBPAGE\_VTAB) */}\textcolor{preprocessor}{}
15775 
15776   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'d'} && strncmp(azArg[0], \textcolor{stringliteral}{"dump"}, n)==0 )\{
15777     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zLike = 0;
15778     \textcolor{keywordtype}{int} i;
15779     \textcolor{keywordtype}{int} savedShowHeader = p->showHeader;
15780     \textcolor{keywordtype}{int} savedShellFlags = p->shellFlgs;
15781     ShellClearFlag(p, SHFLG_PreserveRowid|SHFLG_Newlines|SHFLG_Echo);
15782     \textcolor{keywordflow}{for}(i=1; i<nArg; i++)\{
15783       \textcolor{keywordflow}{if}( azArg[i][0]==\textcolor{charliteral}{'-'} )\{
15784         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z = azArg[i]+1;
15785         \textcolor{keywordflow}{if}( z[0]==\textcolor{charliteral}{'-'} ) z++;
15786         \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"preserve-rowids"})==0 )\{
15787 \textcolor{preprocessor}{#ifdef SQLITE\_OMIT\_VIRTUALTABLE}
15788           raw_printf(stderr, \textcolor{stringliteral}{"The --preserve-rowids option is not compatible"}
15789                              \textcolor{stringliteral}{" with SQLITE\_OMIT\_VIRTUALTABLE\(\backslash\)n"});
15790           rc = 1;
15791           \textcolor{keywordflow}{goto} meta\_command\_exit;
15792 \textcolor{preprocessor}{#else}
15793           ShellSetFlag(p, SHFLG_PreserveRowid);
15794 \textcolor{preprocessor}{#endif}
15795         \}\textcolor{keywordflow}{else}
15796         \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"newlines"})==0 )\{
15797           ShellSetFlag(p, SHFLG_Newlines);
15798         \}\textcolor{keywordflow}{else}
15799         \{
15800           raw_printf(stderr, \textcolor{stringliteral}{"Unknown option \(\backslash\)"%s\(\backslash\)" on \(\backslash\)".dump\(\backslash\)"\(\backslash\)n"}, azArg[i]);
15801           rc = 1;
15802           \textcolor{keywordflow}{goto} meta\_command\_exit;
15803         \}
15804       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( zLike )\{
15805         raw_printf(stderr, \textcolor{stringliteral}{"Usage: .dump ?--preserve-rowids? "}
15806                            \textcolor{stringliteral}{"?--newlines? ?LIKE-PATTERN?\(\backslash\)n"});
15807         rc = 1;
15808         \textcolor{keywordflow}{goto} meta\_command\_exit;
15809       \}\textcolor{keywordflow}{else}\{
15810         zLike = azArg[i];
15811       \}
15812     \}
15813 
15814     open_db(p, 0);
15815 
15816     \textcolor{comment}{/* When playing back a "dump", the content might appear in an order}
15817 \textcolor{comment}{    ** which causes immediate foreign key constraints to be violated.}
15818 \textcolor{comment}{    ** So disable foreign-key constraint enforcement to prevent problems. */}
15819     raw_printf(p->out, \textcolor{stringliteral}{"PRAGMA foreign\_keys=OFF;\(\backslash\)n"});
15820     raw_printf(p->out, \textcolor{stringliteral}{"BEGIN TRANSACTION;\(\backslash\)n"});
15821     p->writableSchema = 0;
15822     p->showHeader = 0;
15823     \textcolor{comment}{/* Set writable\_schema=ON since doing so forces SQLite to initialize}
15824 \textcolor{comment}{    ** as much of the schema as it can even if the sqlite\_master table is}
15825 \textcolor{comment}{    ** corrupt. */}
15826     sqlite3_exec(p->db, \textcolor{stringliteral}{"SAVEPOINT dump; PRAGMA writable\_schema=ON"}, 0, 0, 0);
15827     p->nErr = 0;
15828     \textcolor{keywordflow}{if}( zLike==0 )\{
15829       run_schema_dump_query(p,
15830         \textcolor{stringliteral}{"SELECT name, type, sql FROM sqlite\_master "}
15831         \textcolor{stringliteral}{"WHERE sql NOT NULL AND type=='table' AND name!='sqlite\_sequence'"}
15832       );
15833       run_schema_dump_query(p,
15834         \textcolor{stringliteral}{"SELECT name, type, sql FROM sqlite\_master "}
15835         \textcolor{stringliteral}{"WHERE name=='sqlite\_sequence'"}
15836       );
15837       run_table_dump_query(p,
15838         \textcolor{stringliteral}{"SELECT sql FROM sqlite\_master "}
15839         \textcolor{stringliteral}{"WHERE sql NOT NULL AND type IN ('index','trigger','view')"}, 0
15840       );
15841     \}\textcolor{keywordflow}{else}\{
15842       \textcolor{keywordtype}{char} *zSql;
15843       zSql = sqlite3_mprintf(
15844         \textcolor{stringliteral}{"SELECT name, type, sql FROM sqlite\_master "}
15845         \textcolor{stringliteral}{"WHERE tbl\_name LIKE %Q AND type=='table'"}
15846         \textcolor{stringliteral}{"  AND sql NOT NULL"}, zLike);
15847       run_schema_dump_query(p,zSql);
15848       sqlite3_free(zSql);
15849       zSql = sqlite3_mprintf(
15850         \textcolor{stringliteral}{"SELECT sql FROM sqlite\_master "}
15851         \textcolor{stringliteral}{"WHERE sql NOT NULL"}
15852         \textcolor{stringliteral}{"  AND type IN ('index','trigger','view')"}
15853         \textcolor{stringliteral}{"  AND tbl\_name LIKE %Q"}, zLike);
15854       run_table_dump_query(p, zSql, 0);
15855       sqlite3_free(zSql);
15856     \}
15857     \textcolor{keywordflow}{if}( p->writableSchema )\{
15858       raw_printf(p->out, \textcolor{stringliteral}{"PRAGMA writable\_schema=OFF;\(\backslash\)n"});
15859       p->writableSchema = 0;
15860     \}
15861     sqlite3_exec(p->db, \textcolor{stringliteral}{"PRAGMA writable\_schema=OFF;"}, 0, 0, 0);
15862     sqlite3_exec(p->db, \textcolor{stringliteral}{"RELEASE dump;"}, 0, 0, 0);
15863     raw_printf(p->out, p->nErr?\textcolor{stringliteral}{"ROLLBACK; -- due to errors\(\backslash\)n"}:\textcolor{stringliteral}{"COMMIT;\(\backslash\)n"});
15864     p->showHeader = savedShowHeader;
15865     p->shellFlgs = savedShellFlags;
15866   \}\textcolor{keywordflow}{else}
15867 
15868   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'e'} && strncmp(azArg[0], \textcolor{stringliteral}{"echo"}, n)==0 )\{
15869     \textcolor{keywordflow}{if}( nArg==2 )\{
15870       setOrClearFlag(p, SHFLG_Echo, azArg[1]);
15871     \}\textcolor{keywordflow}{else}\{
15872       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .echo on|off\(\backslash\)n"});
15873       rc = 1;
15874     \}
15875   \}\textcolor{keywordflow}{else}
15876 
15877   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'e'} && strncmp(azArg[0], \textcolor{stringliteral}{"eqp"}, n)==0 )\{
15878     \textcolor{keywordflow}{if}( nArg==2 )\{
15879       p->autoEQPtest = 0;
15880       \textcolor{keywordflow}{if}( p->autoEQPtrace )\{
15881         \textcolor{keywordflow}{if}( p->db ) sqlite3_exec(p->db, \textcolor{stringliteral}{"PRAGMA vdbe\_trace=OFF;"}, 0, 0, 0);
15882         p->autoEQPtrace = 0;
15883       \}
15884       \textcolor{keywordflow}{if}( strcmp(azArg[1],\textcolor{stringliteral}{"full"})==0 )\{
15885         p->autoEQP = AUTOEQP_full;
15886       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(azArg[1],\textcolor{stringliteral}{"trigger"})==0 )\{
15887         p->autoEQP = AUTOEQP_trigger;
15888 \textcolor{preprocessor}{#ifdef SQLITE\_DEBUG}
15889       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(azArg[1],\textcolor{stringliteral}{"test"})==0 )\{
15890         p->autoEQP = AUTOEQP_on;
15891         p->autoEQPtest = 1;
15892       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(azArg[1],\textcolor{stringliteral}{"trace"})==0 )\{
15893         p->autoEQP = AUTOEQP_full;
15894         p->autoEQPtrace = 1;
15895         open_db(p, 0);
15896         sqlite3_exec(p->db, \textcolor{stringliteral}{"SELECT name FROM sqlite\_master LIMIT 1"}, 0, 0, 0);
15897         sqlite3_exec(p->db, \textcolor{stringliteral}{"PRAGMA vdbe\_trace=ON;"}, 0, 0, 0);
15898 \textcolor{preprocessor}{#endif}
15899       \}\textcolor{keywordflow}{else}\{
15900         p->autoEQP = (u8)booleanValue(azArg[1]);
15901       \}
15902     \}\textcolor{keywordflow}{else}\{
15903       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .eqp off|on|trace|trigger|full\(\backslash\)n"});
15904       rc = 1;
15905     \}
15906   \}\textcolor{keywordflow}{else}
15907 
15908   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'e'} && strncmp(azArg[0], \textcolor{stringliteral}{"exit"}, n)==0 )\{
15909     \textcolor{keywordflow}{if}( nArg>1 && (rc = (\textcolor{keywordtype}{int})integerValue(azArg[1]))!=0 ) exit(rc);
15910     rc = 2;
15911   \}\textcolor{keywordflow}{else}
15912 
15913   \textcolor{comment}{/* The ".explain" command is automatic now.  It is largely pointless.  It}
15914 \textcolor{comment}{  ** retained purely for backwards compatibility */}
15915   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'e'} && strncmp(azArg[0], \textcolor{stringliteral}{"explain"}, n)==0 )\{
15916     \textcolor{keywordtype}{int} val = 1;
15917     \textcolor{keywordflow}{if}( nArg>=2 )\{
15918       \textcolor{keywordflow}{if}( strcmp(azArg[1],\textcolor{stringliteral}{"auto"})==0 )\{
15919         val = 99;
15920       \}\textcolor{keywordflow}{else}\{
15921         val =  booleanValue(azArg[1]);
15922       \}
15923     \}
15924     \textcolor{keywordflow}{if}( val==1 && p->mode!=MODE_Explain )\{
15925       p->normalMode = p->mode;
15926       p->mode = MODE_Explain;
15927       p->autoExplain = 0;
15928     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( val==0 )\{
15929       \textcolor{keywordflow}{if}( p->mode==MODE_Explain ) p->mode = p->normalMode;
15930       p->autoExplain = 0;
15931     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( val==99 )\{
15932       \textcolor{keywordflow}{if}( p->mode==MODE_Explain ) p->mode = p->normalMode;
15933       p->autoExplain = 1;
15934     \}
15935   \}\textcolor{keywordflow}{else}
15936 
15937 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_VIRTUALTABLE}
15938   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'e'} && strncmp(azArg[0], \textcolor{stringliteral}{"expert"}, n)==0 )\{
15939     open_db(p, 0);
15940     expertDotCommand(p, azArg, nArg);
15941   \}\textcolor{keywordflow}{else}
15942 \textcolor{preprocessor}{#endif}
15943 
15944   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'f'} && strncmp(azArg[0], \textcolor{stringliteral}{"filectrl"}, n)==0 )\{
15945     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }\{
15946        \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCtrlName;   \textcolor{comment}{/* Name of a test-control option */}
15947        \textcolor{keywordtype}{int} ctrlCode;            \textcolor{comment}{/* Integer code for that option */}
15948        \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zUsage;      \textcolor{comment}{/* Usage notes */}
15949     \} aCtrl[] = \{
15950       \{ \textcolor{stringliteral}{"size\_limit"},     SQLITE_FCNTL_SIZE_LIMIT,      \textcolor{stringliteral}{"[LIMIT]"}        \},
15951       \{ \textcolor{stringliteral}{"chunk\_size"},     SQLITE_FCNTL_CHUNK_SIZE,      \textcolor{stringliteral}{"SIZE"}           \},
15952    \textcolor{comment}{/* \{ "win32\_av\_retry", SQLITE\_FCNTL\_WIN32\_AV\_RETRY,  "COUNT DELAY"    \},*/}
15953       \{ \textcolor{stringliteral}{"persist\_wal"},    SQLITE_FCNTL_PERSIST_WAL,     \textcolor{stringliteral}{"[BOOLEAN]"}      \},
15954       \{ \textcolor{stringliteral}{"psow"},       SQLITE_FCNTL_POWERSAFE_OVERWRITE, \textcolor{stringliteral}{"[BOOLEAN]"}      \},
15955    \textcolor{comment}{/* \{ "pragma",         SQLITE\_FCNTL\_PRAGMA,          "NAME ARG"       \},*/}
15956       \{ \textcolor{stringliteral}{"tempfilename"},   SQLITE_FCNTL_TEMPFILENAME,    \textcolor{stringliteral}{""}               \},
15957       \{ \textcolor{stringliteral}{"has\_moved"},      SQLITE_FCNTL_HAS_MOVED,       \textcolor{stringliteral}{""}               \},  
15958       \{ \textcolor{stringliteral}{"lock\_timeout"},   SQLITE_FCNTL_LOCK_TIMEOUT,    \textcolor{stringliteral}{"MILLISEC"}       \},
15959     \};
15960     \textcolor{keywordtype}{int} filectrl = -1;
15961     \textcolor{keywordtype}{int} iCtrl = -1;
15962     sqlite3_int64 iRes = 0;  \textcolor{comment}{/* Integer result to display if rc2==1 */}
15963     \textcolor{keywordtype}{int} isOk = 0;            \textcolor{comment}{/* 0: usage  1: %lld  2: no-result */}
15964     \textcolor{keywordtype}{int} n2, i;
15965     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCmd = 0;
15966 
15967     open_db(p, 0);
15968     zCmd = nArg>=2 ? azArg[1] : \textcolor{stringliteral}{"help"};
15969 
15970     \textcolor{comment}{/* The argument can optionally begin with "-" or "--" */}
15971     \textcolor{keywordflow}{if}( zCmd[0]==\textcolor{charliteral}{'-'} && zCmd[1] )\{
15972       zCmd++;
15973       \textcolor{keywordflow}{if}( zCmd[0]==\textcolor{charliteral}{'-'} && zCmd[1] ) zCmd++;
15974     \}
15975 
15976     \textcolor{comment}{/* --help lists all file-controls */}
15977     \textcolor{keywordflow}{if}( strcmp(zCmd,\textcolor{stringliteral}{"help"})==0 )\{
15978       utf8_printf(p->out, \textcolor{stringliteral}{"Available file-controls:\(\backslash\)n"});
15979       \textcolor{keywordflow}{for}(i=0; i<ArraySize(aCtrl); i++)\{
15980         utf8_printf(p->out, \textcolor{stringliteral}{"  .filectrl %s %s\(\backslash\)n"},
15981                     aCtrl[i].zCtrlName, aCtrl[i].zUsage);
15982       \}
15983       rc = 1;
15984       \textcolor{keywordflow}{goto} meta\_command\_exit;
15985     \}
15986 
15987     \textcolor{comment}{/* convert filectrl text option to value. allow any unique prefix}
15988 \textcolor{comment}{    ** of the option name, or a numerical value. */}
15989     n2 = strlen30(zCmd);
15990     \textcolor{keywordflow}{for}(i=0; i<ArraySize(aCtrl); i++)\{
15991       \textcolor{keywordflow}{if}( strncmp(zCmd, aCtrl[i].zCtrlName, n2)==0 )\{
15992         \textcolor{keywordflow}{if}( filectrl<0 )\{
15993           filectrl = aCtrl[i].ctrlCode;
15994           iCtrl = i;
15995         \}\textcolor{keywordflow}{else}\{
15996           utf8_printf(stderr, \textcolor{stringliteral}{"Error: ambiguous file-control: \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}
15997                               \textcolor{stringliteral}{"Use \(\backslash\)".filectrl --help\(\backslash\)" for help\(\backslash\)n"}, zCmd);
15998           rc = 1;
15999           \textcolor{keywordflow}{goto} meta\_command\_exit;
16000         \}
16001       \}
16002     \}
16003     \textcolor{keywordflow}{if}( filectrl<0 )\{
16004       utf8_printf(stderr,\textcolor{stringliteral}{"Error: unknown file-control: %s\(\backslash\)n"}
16005                          \textcolor{stringliteral}{"Use \(\backslash\)".filectrl --help\(\backslash\)" for help\(\backslash\)n"}, zCmd);
16006     \}\textcolor{keywordflow}{else}\{
16007       \textcolor{keywordflow}{switch}(filectrl)\{
16008         \textcolor{keywordflow}{case} SQLITE_FCNTL_SIZE_LIMIT: \{
16009           \textcolor{keywordflow}{if}( nArg!=2 && nArg!=3 ) \textcolor{keywordflow}{break};
16010           iRes = nArg==3 ? integerValue(azArg[2]) : -1;
16011           sqlite3_file_control(p->db, 0, SQLITE_FCNTL_SIZE_LIMIT, &iRes);
16012           isOk = 1;
16013           \textcolor{keywordflow}{break};
16014         \}
16015         \textcolor{keywordflow}{case} SQLITE_FCNTL_LOCK_TIMEOUT:
16016         \textcolor{keywordflow}{case} SQLITE_FCNTL_CHUNK_SIZE: \{
16017           \textcolor{keywordtype}{int} x;
16018           \textcolor{keywordflow}{if}( nArg!=3 ) \textcolor{keywordflow}{break};
16019           x = (int)integerValue(azArg[2]);
16020           sqlite3_file_control(p->db, 0, filectrl, &x);
16021           isOk = 2;
16022           \textcolor{keywordflow}{break};
16023         \}
16024         \textcolor{keywordflow}{case} SQLITE_FCNTL_PERSIST_WAL:
16025         \textcolor{keywordflow}{case} SQLITE_FCNTL_POWERSAFE_OVERWRITE: \{
16026           \textcolor{keywordtype}{int} x;
16027           \textcolor{keywordflow}{if}( nArg!=2 && nArg!=3 ) \textcolor{keywordflow}{break};
16028           x = nArg==3 ? booleanValue(azArg[2]) : -1;
16029           sqlite3_file_control(p->db, 0, filectrl, &x);
16030           iRes = x;
16031           isOk = 1;
16032           \textcolor{keywordflow}{break};
16033         \}
16034         \textcolor{keywordflow}{case} SQLITE_FCNTL_HAS_MOVED: \{
16035           \textcolor{keywordtype}{int} x;
16036           \textcolor{keywordflow}{if}( nArg!=2 ) \textcolor{keywordflow}{break};
16037           sqlite3_file_control(p->db, 0, filectrl, &x);
16038           iRes = x;
16039           isOk = 1;
16040           \textcolor{keywordflow}{break};
16041         \}
16042         \textcolor{keywordflow}{case} SQLITE_FCNTL_TEMPFILENAME: \{
16043           \textcolor{keywordtype}{char} *z = 0;
16044           \textcolor{keywordflow}{if}( nArg!=2 ) \textcolor{keywordflow}{break};
16045           sqlite3_file_control(p->db, 0, filectrl, &z);
16046           \textcolor{keywordflow}{if}( z )\{
16047             utf8_printf(p->out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, z);
16048             sqlite3_free(z);
16049           \}
16050           isOk = 2;
16051           \textcolor{keywordflow}{break};
16052         \}
16053       \}
16054     \}
16055     \textcolor{keywordflow}{if}( isOk==0 && iCtrl>=0 )\{
16056       utf8_printf(p->out, \textcolor{stringliteral}{"Usage: .filectrl %s %s\(\backslash\)n"}, zCmd,aCtrl[iCtrl].zUsage);
16057       rc = 1;
16058     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( isOk==1 )\{
16059       \textcolor{keywordtype}{char} zBuf[100];
16060       sqlite3_snprintf(\textcolor{keyword}{sizeof}(zBuf), zBuf, \textcolor{stringliteral}{"%lld"}, iRes);
16061       raw_printf(p->out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, zBuf);
16062     \}
16063   \}\textcolor{keywordflow}{else}
16064 
16065   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'f'} && strncmp(azArg[0], \textcolor{stringliteral}{"fullschema"}, n)==0 )\{
16066     ShellState data;
16067     \textcolor{keywordtype}{char} *zErrMsg = 0;
16068     \textcolor{keywordtype}{int} doStats = 0;
16069     memcpy(&data, p, \textcolor{keyword}{sizeof}(data));
16070     data.showHeader = 0;
16071     data.cMode = data.mode = MODE_Semi;
16072     \textcolor{keywordflow}{if}( nArg==2 && optionMatch(azArg[1], \textcolor{stringliteral}{"indent"}) )\{
16073       data.cMode = data.mode = MODE_Pretty;
16074       nArg = 1;
16075     \}
16076     \textcolor{keywordflow}{if}( nArg!=1 )\{
16077       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .fullschema ?--indent?\(\backslash\)n"});
16078       rc = 1;
16079       \textcolor{keywordflow}{goto} meta\_command\_exit;
16080     \}
16081     open_db(p, 0);
16082     rc = sqlite3_exec(p->db,
16083        \textcolor{stringliteral}{"SELECT sql FROM"}
16084        \textcolor{stringliteral}{"  (SELECT sql sql, type type, tbl\_name tbl\_name, name name, rowid x"}
16085        \textcolor{stringliteral}{"     FROM sqlite\_master UNION ALL"}
16086        \textcolor{stringliteral}{"   SELECT sql, type, tbl\_name, name, rowid FROM sqlite\_temp\_master) "}
16087        \textcolor{stringliteral}{"WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite\_%' "}
16088        \textcolor{stringliteral}{"ORDER BY rowid"},
16089        callback, &data, &zErrMsg
16090     );
16091     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
16092       sqlite3_stmt *pStmt;
16093       rc = sqlite3_prepare_v2(p->db,
16094                \textcolor{stringliteral}{"SELECT rowid FROM sqlite\_master"}
16095                \textcolor{stringliteral}{" WHERE name GLOB 'sqlite\_stat[134]'"},
16096                -1, &pStmt, 0);
16097       doStats = sqlite3_step(pStmt)==SQLITE_ROW;
16098       sqlite3_finalize(pStmt);
16099     \}
16100     \textcolor{keywordflow}{if}( doStats==0 )\{
16101       raw_printf(p->out, \textcolor{stringliteral}{"/* No STAT tables available */\(\backslash\)n"});
16102     \}\textcolor{keywordflow}{else}\{
16103       raw_printf(p->out, \textcolor{stringliteral}{"ANALYZE sqlite\_master;\(\backslash\)n"});
16104       sqlite3_exec(p->db, \textcolor{stringliteral}{"SELECT 'ANALYZE sqlite\_master'"},
16105                    callback, &data, &zErrMsg);
16106       data.cMode = data.mode = MODE_Insert;
16107       data.zDestTable = \textcolor{stringliteral}{"sqlite\_stat1"};
16108       shell_exec(&data, \textcolor{stringliteral}{"SELECT * FROM sqlite\_stat1"}, &zErrMsg);
16109       data.zDestTable = \textcolor{stringliteral}{"sqlite\_stat4"};
16110       shell_exec(&data, \textcolor{stringliteral}{"SELECT * FROM sqlite\_stat4"}, &zErrMsg);
16111       raw_printf(p->out, \textcolor{stringliteral}{"ANALYZE sqlite\_master;\(\backslash\)n"});
16112     \}
16113   \}\textcolor{keywordflow}{else}
16114 
16115   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'h'} && strncmp(azArg[0], \textcolor{stringliteral}{"headers"}, n)==0 )\{
16116     \textcolor{keywordflow}{if}( nArg==2 )\{
16117       p->showHeader = booleanValue(azArg[1]);
16118     \}\textcolor{keywordflow}{else}\{
16119       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .headers on|off\(\backslash\)n"});
16120       rc = 1;
16121     \}
16122   \}\textcolor{keywordflow}{else}
16123 
16124   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'h'} && strncmp(azArg[0], \textcolor{stringliteral}{"help"}, n)==0 )\{
16125     \textcolor{keywordflow}{if}( nArg>=2 )\{
16126       n = showHelp(p->out, azArg[1]);
16127       \textcolor{keywordflow}{if}( n==0 )\{
16128         utf8_printf(p->out, \textcolor{stringliteral}{"Nothing matches '%s'\(\backslash\)n"}, azArg[1]);
16129       \}
16130     \}\textcolor{keywordflow}{else}\{
16131       showHelp(p->out, 0);
16132     \}
16133   \}\textcolor{keywordflow}{else}
16134 
16135   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'i'} && strncmp(azArg[0], \textcolor{stringliteral}{"import"}, n)==0 )\{
16136     \textcolor{keywordtype}{char} *zTable;               \textcolor{comment}{/* Insert data into this table */}
16137     \textcolor{keywordtype}{char} *zFile;                \textcolor{comment}{/* Name of file to extra content from */}
16138     sqlite3_stmt *pStmt = NULL; \textcolor{comment}{/* A statement */}
16139     \textcolor{keywordtype}{int} nCol;                   \textcolor{comment}{/* Number of columns in the table */}
16140     \textcolor{keywordtype}{int} nByte;                  \textcolor{comment}{/* Number of bytes in an SQL string */}
16141     \textcolor{keywordtype}{int} i, j;                   \textcolor{comment}{/* Loop counters */}
16142     \textcolor{keywordtype}{int} needCommit;             \textcolor{comment}{/* True to COMMIT or ROLLBACK at end */}
16143     \textcolor{keywordtype}{int} nSep;                   \textcolor{comment}{/* Number of bytes in p->colSeparator[] */}
16144     \textcolor{keywordtype}{char} *zSql;                 \textcolor{comment}{/* An SQL statement */}
16145     ImportCtx sCtx;             \textcolor{comment}{/* Reader context */}
16146     \textcolor{keywordtype}{char} *(SQLITE_CDECL *xRead)(ImportCtx*); \textcolor{comment}{/* Func to read one value */}
16147     int (SQLITE_CDECL *xCloser)(FILE*);      \textcolor{comment}{/* Func to close file */}
16148 
16149     \textcolor{keywordflow}{if}( nArg!=3 )\{
16150       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .import FILE TABLE\(\backslash\)n"});
16151       \textcolor{keywordflow}{goto} meta\_command\_exit;
16152     \}
16153     zFile = azArg[1];
16154     zTable = azArg[2];
16155     seenInterrupt = 0;
16156     memset(&sCtx, 0, \textcolor{keyword}{sizeof}(sCtx));
16157     open_db(p, 0);
16158     nSep = strlen30(p->colSeparator);
16159     \textcolor{keywordflow}{if}( nSep==0 )\{
16160       raw_printf(stderr,
16161                  \textcolor{stringliteral}{"Error: non-null column separator required for import\(\backslash\)n"});
16162       \textcolor{keywordflow}{return} 1;
16163     \}
16164     \textcolor{keywordflow}{if}( nSep>1 )\{
16165       raw_printf(stderr, \textcolor{stringliteral}{"Error: multi-character column separators not allowed"}
16166                       \textcolor{stringliteral}{" for import\(\backslash\)n"});
16167       \textcolor{keywordflow}{return} 1;
16168     \}
16169     nSep = strlen30(p->rowSeparator);
16170     \textcolor{keywordflow}{if}( nSep==0 )\{
16171       raw_printf(stderr, \textcolor{stringliteral}{"Error: non-null row separator required for import\(\backslash\)n"});
16172       \textcolor{keywordflow}{return} 1;
16173     \}
16174     \textcolor{keywordflow}{if}( nSep==2 && p->mode==MODE_Csv && strcmp(p->rowSeparator, SEP_CrLf)==0 )\{
16175       \textcolor{comment}{/* When importing CSV (only), if the row separator is set to the}
16176 \textcolor{comment}{      ** default output row separator, change it to the default input}
16177 \textcolor{comment}{      ** row separator.  This avoids having to maintain different input}
16178 \textcolor{comment}{      ** and output row separators. */}
16179       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->rowSeparator), p->rowSeparator, SEP_Row);
16180       nSep = strlen30(p->rowSeparator);
16181     \}
16182     \textcolor{keywordflow}{if}( nSep>1 )\{
16183       raw_printf(stderr, \textcolor{stringliteral}{"Error: multi-character row separators not allowed"}
16184                       \textcolor{stringliteral}{" for import\(\backslash\)n"});
16185       \textcolor{keywordflow}{return} 1;
16186     \}
16187     sCtx.zFile = zFile;
16188     sCtx.nLine = 1;
16189     \textcolor{keywordflow}{if}( sCtx.zFile[0]==\textcolor{charliteral}{'|'} )\{
16190 \textcolor{preprocessor}{#ifdef SQLITE\_OMIT\_POPEN}
16191       raw_printf(stderr, \textcolor{stringliteral}{"Error: pipes are not supported in this OS\(\backslash\)n"});
16192       \textcolor{keywordflow}{return} 1;
16193 \textcolor{preprocessor}{#else}
16194       sCtx.in = popen(sCtx.zFile+1, \textcolor{stringliteral}{"r"});
16195       sCtx.zFile = \textcolor{stringliteral}{"<pipe>"};
16196       xCloser = pclose;
16197 \textcolor{preprocessor}{#endif}
16198     \}\textcolor{keywordflow}{else}\{
16199       sCtx.in = fopen(sCtx.zFile, \textcolor{stringliteral}{"rb"});
16200       xCloser = fclose;
16201     \}
16202     \textcolor{keywordflow}{if}( p->mode==MODE_Ascii )\{
16203       xRead = ascii_read_one_field;
16204     \}\textcolor{keywordflow}{else}\{
16205       xRead = csv_read_one_field;
16206     \}
16207     \textcolor{keywordflow}{if}( sCtx.in==0 )\{
16208       utf8_printf(stderr, \textcolor{stringliteral}{"Error: cannot open \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, zFile);
16209       \textcolor{keywordflow}{return} 1;
16210     \}
16211     sCtx.cColSep = p->colSeparator[0];
16212     sCtx.cRowSep = p->rowSeparator[0];
16213     zSql = sqlite3_mprintf(\textcolor{stringliteral}{"SELECT * FROM %s"}, zTable);
16214     \textcolor{keywordflow}{if}( zSql==0 )\{
16215       xCloser(sCtx.in);
16216       shell_out_of_memory();
16217     \}
16218     nByte = strlen30(zSql);
16219     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
16220     import_append_char(&sCtx, 0);    \textcolor{comment}{/* To ensure sCtx.z is allocated */}
16221     \textcolor{keywordflow}{if}( rc && sqlite3_strglob(\textcolor{stringliteral}{"no such table: *"}, sqlite3_errmsg(p->db))==0 )\{
16222       \textcolor{keywordtype}{char} *zCreate = sqlite3_mprintf(\textcolor{stringliteral}{"CREATE TABLE %s"}, zTable);
16223       \textcolor{keywordtype}{char} cSep = \textcolor{charliteral}{'('};
16224       \textcolor{keywordflow}{while}( xRead(&sCtx) )\{
16225         zCreate = sqlite3_mprintf(\textcolor{stringliteral}{"%z%c\(\backslash\)n  \(\backslash\)"%w\(\backslash\)" TEXT"}, zCreate, cSep, sCtx.z);
16226         cSep = \textcolor{charliteral}{','};
16227         \textcolor{keywordflow}{if}( sCtx.cTerm!=sCtx.cColSep ) \textcolor{keywordflow}{break};
16228       \}
16229       \textcolor{keywordflow}{if}( cSep==\textcolor{charliteral}{'('} )\{
16230         sqlite3_free(zCreate);
16231         sqlite3_free(sCtx.z);
16232         xCloser(sCtx.in);
16233         utf8_printf(stderr,\textcolor{stringliteral}{"%s: empty file\(\backslash\)n"}, sCtx.zFile);
16234         \textcolor{keywordflow}{return} 1;
16235       \}
16236       zCreate = sqlite3_mprintf(\textcolor{stringliteral}{"%z\(\backslash\)n)"}, zCreate);
16237       rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);
16238       sqlite3_free(zCreate);
16239       \textcolor{keywordflow}{if}( rc )\{
16240         utf8_printf(stderr, \textcolor{stringliteral}{"CREATE TABLE %s(...) failed: %s\(\backslash\)n"}, zTable,
16241                 sqlite3_errmsg(p->db));
16242         sqlite3_free(sCtx.z);
16243         xCloser(sCtx.in);
16244         \textcolor{keywordflow}{return} 1;
16245       \}
16246       rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
16247     \}
16248     sqlite3_free(zSql);
16249     \textcolor{keywordflow}{if}( rc )\{
16250       \textcolor{keywordflow}{if} (pStmt) sqlite3_finalize(pStmt);
16251       utf8_printf(stderr,\textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, sqlite3_errmsg(p->db));
16252       xCloser(sCtx.in);
16253       \textcolor{keywordflow}{return} 1;
16254     \}
16255     nCol = sqlite3_column_count(pStmt);
16256     sqlite3_finalize(pStmt);
16257     pStmt = 0;
16258     \textcolor{keywordflow}{if}( nCol==0 ) \textcolor{keywordflow}{return} 0; \textcolor{comment}{/* no columns, no error */}
16259     zSql = sqlite3_malloc64( nByte*2 + 20 + nCol*2 );
16260     \textcolor{keywordflow}{if}( zSql==0 )\{
16261       xCloser(sCtx.in);
16262       shell_out_of_memory();
16263     \}
16264     sqlite3_snprintf(nByte+20, zSql, \textcolor{stringliteral}{"INSERT INTO \(\backslash\)"%w\(\backslash\)" VALUES(?"}, zTable);
16265     j = strlen30(zSql);
16266     \textcolor{keywordflow}{for}(i=1; i<nCol; i++)\{
16267       zSql[j++] = \textcolor{charliteral}{','};
16268       zSql[j++] = \textcolor{charliteral}{'?'};
16269     \}
16270     zSql[j++] = \textcolor{charliteral}{')'};
16271     zSql[j] = 0;
16272     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
16273     sqlite3_free(zSql);
16274     \textcolor{keywordflow}{if}( rc )\{
16275       utf8_printf(stderr, \textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, sqlite3_errmsg(p->db));
16276       \textcolor{keywordflow}{if} (pStmt) sqlite3_finalize(pStmt);
16277       xCloser(sCtx.in);
16278       \textcolor{keywordflow}{return} 1;
16279     \}
16280     needCommit = sqlite3_get_autocommit(p->db);
16281     \textcolor{keywordflow}{if}( needCommit ) sqlite3_exec(p->db, \textcolor{stringliteral}{"BEGIN"}, 0, 0, 0);
16282     \textcolor{keywordflow}{do}\{
16283       \textcolor{keywordtype}{int} startLine = sCtx.nLine;
16284       \textcolor{keywordflow}{for}(i=0; i<nCol; i++)\{
16285         \textcolor{keywordtype}{char} *z = xRead(&sCtx);
16286         \textcolor{comment}{/*}
16287 \textcolor{comment}{        ** Did we reach end-of-file before finding any columns?}
16288 \textcolor{comment}{        ** If so, stop instead of NULL filling the remaining columns.}
16289 \textcolor{comment}{        */}
16290         \textcolor{keywordflow}{if}( z==0 && i==0 ) \textcolor{keywordflow}{break};
16291         \textcolor{comment}{/*}
16292 \textcolor{comment}{        ** Did we reach end-of-file OR end-of-line before finding any}
16293 \textcolor{comment}{        ** columns in ASCII mode?  If so, stop instead of NULL filling}
16294 \textcolor{comment}{        ** the remaining columns.}
16295 \textcolor{comment}{        */}
16296         \textcolor{keywordflow}{if}( p->mode==MODE_Ascii && (z==0 || z[0]==0) && i==0 ) \textcolor{keywordflow}{break};
16297         sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);
16298         \textcolor{keywordflow}{if}( i<nCol-1 && sCtx.cTerm!=sCtx.cColSep )\{
16299           utf8_printf(stderr, \textcolor{stringliteral}{"%s:%d: expected %d columns but found %d - "}
16300                           \textcolor{stringliteral}{"filling the rest with NULL\(\backslash\)n"},
16301                           sCtx.zFile, startLine, nCol, i+1);
16302           i += 2;
16303           \textcolor{keywordflow}{while}( i<=nCol )\{ sqlite3_bind_null(pStmt, i); i++; \}
16304         \}
16305       \}
16306       \textcolor{keywordflow}{if}( sCtx.cTerm==sCtx.cColSep )\{
16307         \textcolor{keywordflow}{do}\{
16308           xRead(&sCtx);
16309           i++;
16310         \}\textcolor{keywordflow}{while}( sCtx.cTerm==sCtx.cColSep );
16311         utf8_printf(stderr, \textcolor{stringliteral}{"%s:%d: expected %d columns but found %d - "}
16312                         \textcolor{stringliteral}{"extras ignored\(\backslash\)n"},
16313                         sCtx.zFile, startLine, nCol, i);
16314       \}
16315       \textcolor{keywordflow}{if}( i>=nCol )\{
16316         sqlite3_step(pStmt);
16317         rc = sqlite3_reset(pStmt);
16318         \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
16319           utf8_printf(stderr, \textcolor{stringliteral}{"%s:%d: INSERT failed: %s\(\backslash\)n"}, sCtx.zFile,
16320                       startLine, sqlite3_errmsg(p->db));
16321         \}
16322       \}
16323     \}\textcolor{keywordflow}{while}( sCtx.cTerm!=EOF );
16324 
16325     xCloser(sCtx.in);
16326     sqlite3_free(sCtx.z);
16327     sqlite3_finalize(pStmt);
16328     \textcolor{keywordflow}{if}( needCommit ) sqlite3_exec(p->db, \textcolor{stringliteral}{"COMMIT"}, 0, 0, 0);
16329   \}\textcolor{keywordflow}{else}
16330 
16331 \textcolor{preprocessor}{#ifndef SQLITE\_UNTESTABLE}
16332   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'i'} && strncmp(azArg[0], \textcolor{stringliteral}{"imposter"}, n)==0 )\{
16333     \textcolor{keywordtype}{char} *zSql;
16334     \textcolor{keywordtype}{char} *zCollist = 0;
16335     sqlite3_stmt *pStmt;
16336     \textcolor{keywordtype}{int} tnum = 0;
16337     \textcolor{keywordtype}{int} isWO = 0;  \textcolor{comment}{/* True if making an imposter of a WITHOUT ROWID table */}
16338     \textcolor{keywordtype}{int} lenPK = 0; \textcolor{comment}{/* Length of the PRIMARY KEY string for isWO tables */}
16339     \textcolor{keywordtype}{int} i;
16340     \textcolor{keywordflow}{if}( !(nArg==3 || (nArg==2 && sqlite3_stricmp(azArg[1],\textcolor{stringliteral}{"off"})==0)) )\{
16341       utf8_printf(stderr, \textcolor{stringliteral}{"Usage: .imposter INDEX IMPOSTER\(\backslash\)n"}
16342                           \textcolor{stringliteral}{"       .imposter off\(\backslash\)n"});
16343       \textcolor{comment}{/* Also allowed, but not documented:}
16344 \textcolor{comment}{      **}
16345 \textcolor{comment}{      **    .imposter TABLE IMPOSTER}
16346 \textcolor{comment}{      **}
16347 \textcolor{comment}{      ** where TABLE is a WITHOUT ROWID table.  In that case, the}
16348 \textcolor{comment}{      ** imposter is another WITHOUT ROWID table with the columns in}
16349 \textcolor{comment}{      ** storage order. */}
16350       rc = 1;
16351       \textcolor{keywordflow}{goto} meta\_command\_exit;
16352     \}
16353     open_db(p, 0);
16354     \textcolor{keywordflow}{if}( nArg==2 )\{
16355       sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, \textcolor{stringliteral}{"main"}, 0, 1);
16356       \textcolor{keywordflow}{goto} meta\_command\_exit;
16357     \}
16358     zSql = sqlite3_mprintf(
16359       \textcolor{stringliteral}{"SELECT rootpage, 0 FROM sqlite\_master"}
16360       \textcolor{stringliteral}{" WHERE name='%q' AND type='index'"}
16361       \textcolor{stringliteral}{"UNION ALL "}
16362       \textcolor{stringliteral}{"SELECT rootpage, 1 FROM sqlite\_master"}
16363       \textcolor{stringliteral}{" WHERE name='%q' AND type='table'"}
16364       \textcolor{stringliteral}{"   AND sql LIKE '%%without%%rowid%%'"},
16365       azArg[1], azArg[1]
16366     );
16367     sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
16368     sqlite3_free(zSql);
16369     \textcolor{keywordflow}{if}( sqlite3_step(pStmt)==SQLITE_ROW )\{
16370       tnum = sqlite3_column_int(pStmt, 0);
16371       isWO = sqlite3_column_int(pStmt, 1);
16372     \}
16373     sqlite3_finalize(pStmt);
16374     zSql = sqlite3_mprintf(\textcolor{stringliteral}{"PRAGMA index\_xinfo='%q'"}, azArg[1]);
16375     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
16376     sqlite3_free(zSql);
16377     i = 0;
16378     \textcolor{keywordflow}{while}( sqlite3_step(pStmt)==SQLITE_ROW )\{
16379       \textcolor{keywordtype}{char} zLabel[20];
16380       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCol = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pStmt,2);
16381       i++;
16382       \textcolor{keywordflow}{if}( zCol==0 )\{
16383         \textcolor{keywordflow}{if}( sqlite3_column_int(pStmt,1)==-1 )\{
16384           zCol = \textcolor{stringliteral}{"\_ROWID\_"};
16385         \}\textcolor{keywordflow}{else}\{
16386           sqlite3_snprintf(\textcolor{keyword}{sizeof}(zLabel),zLabel,\textcolor{stringliteral}{"expr%d"},i);
16387           zCol = zLabel;
16388         \}
16389       \}
16390       \textcolor{keywordflow}{if}( isWO && lenPK==0 && sqlite3_column_int(pStmt,5)==0 && zCollist )\{
16391         lenPK = (int)strlen(zCollist);
16392       \}
16393       \textcolor{keywordflow}{if}( zCollist==0 )\{
16394         zCollist = sqlite3_mprintf(\textcolor{stringliteral}{"\(\backslash\)"%w\(\backslash\)""}, zCol);
16395       \}\textcolor{keywordflow}{else}\{
16396         zCollist = sqlite3_mprintf(\textcolor{stringliteral}{"%z,\(\backslash\)"%w\(\backslash\)""}, zCollist, zCol);
16397       \}
16398     \}
16399     sqlite3_finalize(pStmt);
16400     \textcolor{keywordflow}{if}( i==0 || tnum==0 )\{
16401       utf8_printf(stderr, \textcolor{stringliteral}{"no such index: \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, azArg[1]);
16402       rc = 1;
16403       sqlite3_free(zCollist);
16404       \textcolor{keywordflow}{goto} meta\_command\_exit;
16405     \}
16406     \textcolor{keywordflow}{if}( lenPK==0 ) lenPK = 100000;
16407     zSql = sqlite3_mprintf(
16408           \textcolor{stringliteral}{"CREATE TABLE \(\backslash\)"%w\(\backslash\)"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID"},
16409           azArg[2], zCollist, lenPK, zCollist);
16410     sqlite3_free(zCollist);
16411     rc = sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, \textcolor{stringliteral}{"main"}, 1, tnum);
16412     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
16413       rc = sqlite3_exec(p->db, zSql, 0, 0, 0);
16414       sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, \textcolor{stringliteral}{"main"}, 0, 0);
16415       \textcolor{keywordflow}{if}( rc )\{
16416         utf8_printf(stderr, \textcolor{stringliteral}{"Error in [%s]: %s\(\backslash\)n"}, zSql, sqlite3_errmsg(p->db));
16417       \}\textcolor{keywordflow}{else}\{
16418         utf8_printf(stdout, \textcolor{stringliteral}{"%s;\(\backslash\)n"}, zSql);
16419         raw_printf(stdout,
16420           \textcolor{stringliteral}{"WARNING: writing to an imposter table will corrupt the \(\backslash\)"%s\(\backslash\)" %s!\(\backslash\)n"},
16421           azArg[1], isWO ? \textcolor{stringliteral}{"table"} : \textcolor{stringliteral}{"index"}
16422         );
16423       \}
16424     \}\textcolor{keywordflow}{else}\{
16425       raw_printf(stderr, \textcolor{stringliteral}{"SQLITE\_TESTCTRL\_IMPOSTER returns %d\(\backslash\)n"}, rc);
16426       rc = 1;
16427     \}
16428     sqlite3_free(zSql);
16429   \}\textcolor{keywordflow}{else}
16430 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !defined(SQLITE\_OMIT\_TEST\_CONTROL) */}\textcolor{preprocessor}{}
16431 
16432 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_IOTRACE}
16433   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'i'} && strncmp(azArg[0], \textcolor{stringliteral}{"iotrace"}, n)==0 )\{
16434     SQLITE_API \textcolor{keyword}{extern} void (SQLITE_CDECL *sqlite3IoTrace)(\textcolor{keyword}{const} \textcolor{keywordtype}{char}*, ...);
16435     \textcolor{keywordflow}{if}( iotrace && iotrace!=stdout ) fclose(iotrace);
16436     iotrace = 0;
16437     \textcolor{keywordflow}{if}( nArg<2 )\{
16438       sqlite3IoTrace = 0;
16439     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(azArg[1], \textcolor{stringliteral}{"-"})==0 )\{
16440       sqlite3IoTrace = iotracePrintf;
16441       iotrace = stdout;
16442     \}\textcolor{keywordflow}{else}\{
16443       iotrace = fopen(azArg[1], \textcolor{stringliteral}{"w"});
16444       \textcolor{keywordflow}{if}( iotrace==0 )\{
16445         utf8_printf(stderr, \textcolor{stringliteral}{"Error: cannot open \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, azArg[1]);
16446         sqlite3IoTrace = 0;
16447         rc = 1;
16448       \}\textcolor{keywordflow}{else}\{
16449         sqlite3IoTrace = iotracePrintf;
16450       \}
16451     \}
16452   \}\textcolor{keywordflow}{else}
16453 \textcolor{preprocessor}{#endif}
16454 
16455   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'l'} && n>=5 && strncmp(azArg[0], \textcolor{stringliteral}{"limits"}, n)==0 )\{
16456     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }\{
16457        \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zLimitName;   \textcolor{comment}{/* Name of a limit */}
16458        \textcolor{keywordtype}{int} limitCode;            \textcolor{comment}{/* Integer code for that limit */}
16459     \} aLimit[] = \{
16460       \{ \textcolor{stringliteral}{"length"},                SQLITE_LIMIT_LENGTH                    \},
16461       \{ \textcolor{stringliteral}{"sql\_length"},            SQLITE_LIMIT_SQL_LENGTH                \},
16462       \{ \textcolor{stringliteral}{"column"},                SQLITE_LIMIT_COLUMN                    \},
16463       \{ \textcolor{stringliteral}{"expr\_depth"},            SQLITE_LIMIT_EXPR_DEPTH                \},
16464       \{ \textcolor{stringliteral}{"compound\_select"},       SQLITE_LIMIT_COMPOUND_SELECT           \},
16465       \{ \textcolor{stringliteral}{"vdbe\_op"},               SQLITE_LIMIT_VDBE_OP                   \},
16466       \{ \textcolor{stringliteral}{"function\_arg"},          SQLITE_LIMIT_FUNCTION_ARG              \},
16467       \{ \textcolor{stringliteral}{"attached"},              SQLITE_LIMIT_ATTACHED                  \},
16468       \{ \textcolor{stringliteral}{"like\_pattern\_length"},   SQLITE_LIMIT_LIKE_PATTERN_LENGTH       \},
16469       \{ \textcolor{stringliteral}{"variable\_number"},       SQLITE_LIMIT_VARIABLE_NUMBER           \},
16470       \{ \textcolor{stringliteral}{"trigger\_depth"},         SQLITE_LIMIT_TRIGGER_DEPTH             \},
16471       \{ \textcolor{stringliteral}{"worker\_threads"},        SQLITE_LIMIT_WORKER_THREADS            \},
16472     \};
16473     \textcolor{keywordtype}{int} i, n2;
16474     open_db(p, 0);
16475     \textcolor{keywordflow}{if}( nArg==1 )\{
16476       \textcolor{keywordflow}{for}(i=0; i<ArraySize(aLimit); i++)\{
16477         printf(\textcolor{stringliteral}{"%20s %d\(\backslash\)n"}, aLimit[i].zLimitName,
16478                sqlite3_limit(p->db, aLimit[i].limitCode, -1));
16479       \}
16480     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( nArg>3 )\{
16481       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .limit NAME ?NEW-VALUE?\(\backslash\)n"});
16482       rc = 1;
16483       \textcolor{keywordflow}{goto} meta\_command\_exit;
16484     \}\textcolor{keywordflow}{else}\{
16485       \textcolor{keywordtype}{int} iLimit = -1;
16486       n2 = strlen30(azArg[1]);
16487       \textcolor{keywordflow}{for}(i=0; i<ArraySize(aLimit); i++)\{
16488         \textcolor{keywordflow}{if}( sqlite3_strnicmp(aLimit[i].zLimitName, azArg[1], n2)==0 )\{
16489           \textcolor{keywordflow}{if}( iLimit<0 )\{
16490             iLimit = i;
16491           \}\textcolor{keywordflow}{else}\{
16492             utf8_printf(stderr, \textcolor{stringliteral}{"ambiguous limit: \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, azArg[1]);
16493             rc = 1;
16494             \textcolor{keywordflow}{goto} meta\_command\_exit;
16495           \}
16496         \}
16497       \}
16498       \textcolor{keywordflow}{if}( iLimit<0 )\{
16499         utf8_printf(stderr, \textcolor{stringliteral}{"unknown limit: \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}
16500                         \textcolor{stringliteral}{"enter \(\backslash\)".limits\(\backslash\)" with no arguments for a list.\(\backslash\)n"},
16501                          azArg[1]);
16502         rc = 1;
16503         \textcolor{keywordflow}{goto} meta\_command\_exit;
16504       \}
16505       \textcolor{keywordflow}{if}( nArg==3 )\{
16506         sqlite3_limit(p->db, aLimit[iLimit].limitCode,
16507                       (\textcolor{keywordtype}{int})integerValue(azArg[2]));
16508       \}
16509       printf(\textcolor{stringliteral}{"%20s %d\(\backslash\)n"}, aLimit[iLimit].zLimitName,
16510              sqlite3_limit(p->db, aLimit[iLimit].limitCode, -1));
16511     \}
16512   \}\textcolor{keywordflow}{else}
16513 
16514   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'l'} && n>2 && strncmp(azArg[0], \textcolor{stringliteral}{"lint"}, n)==0 )\{
16515     open_db(p, 0);
16516     lintDotCommand(p, azArg, nArg);
16517   \}\textcolor{keywordflow}{else}
16518 
16519 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_LOAD\_EXTENSION}
16520   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'l'} && strncmp(azArg[0], \textcolor{stringliteral}{"load"}, n)==0 )\{
16521     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zFile, *zProc;
16522     \textcolor{keywordtype}{char} *zErrMsg = 0;
16523     \textcolor{keywordflow}{if}( nArg<2 )\{
16524       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .load FILE ?ENTRYPOINT?\(\backslash\)n"});
16525       rc = 1;
16526       \textcolor{keywordflow}{goto} meta\_command\_exit;
16527     \}
16528     zFile = azArg[1];
16529     zProc = nArg>=3 ? azArg[2] : 0;
16530     open_db(p, 0);
16531     rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);
16532     \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
16533       utf8_printf(stderr, \textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, zErrMsg);
16534       sqlite3_free(zErrMsg);
16535       rc = 1;
16536     \}
16537   \}\textcolor{keywordflow}{else}
16538 \textcolor{preprocessor}{#endif}
16539 
16540   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'l'} && strncmp(azArg[0], \textcolor{stringliteral}{"log"}, n)==0 )\{
16541     \textcolor{keywordflow}{if}( nArg!=2 )\{
16542       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .log FILENAME\(\backslash\)n"});
16543       rc = 1;
16544     \}\textcolor{keywordflow}{else}\{
16545       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zFile = azArg[1];
16546       output_file_close(p->pLog);
16547       p->pLog = output_file_open(zFile, 0);
16548     \}
16549   \}\textcolor{keywordflow}{else}
16550 
16551   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'m'} && strncmp(azArg[0], \textcolor{stringliteral}{"mode"}, n)==0 )\{
16552     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zMode = nArg>=2 ? azArg[1] : \textcolor{stringliteral}{""};
16553     \textcolor{keywordtype}{int} n2 = strlen30(zMode);
16554     \textcolor{keywordtype}{int} c2 = zMode[0];
16555     \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'l'} && n2>2 && strncmp(azArg[1],\textcolor{stringliteral}{"lines"},n2)==0 )\{
16556       p->mode = MODE_Line;
16557       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->rowSeparator), p->rowSeparator, SEP_Row);
16558     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'c'} && strncmp(azArg[1],\textcolor{stringliteral}{"columns"},n2)==0 )\{
16559       p->mode = MODE_Column;
16560       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->rowSeparator), p->rowSeparator, SEP_Row);
16561     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'l'} && n2>2 && strncmp(azArg[1],\textcolor{stringliteral}{"list"},n2)==0 )\{
16562       p->mode = MODE_List;
16563       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->colSeparator), p->colSeparator, SEP_Column);
16564       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->rowSeparator), p->rowSeparator, SEP_Row);
16565     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'h'} && strncmp(azArg[1],\textcolor{stringliteral}{"html"},n2)==0 )\{
16566       p->mode = MODE_Html;
16567     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'t'} && strncmp(azArg[1],\textcolor{stringliteral}{"tcl"},n2)==0 )\{
16568       p->mode = MODE_Tcl;
16569       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->colSeparator), p->colSeparator, SEP_Space);
16570       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->rowSeparator), p->rowSeparator, SEP_Row);
16571     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'c'} && strncmp(azArg[1],\textcolor{stringliteral}{"csv"},n2)==0 )\{
16572       p->mode = MODE_Csv;
16573       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->colSeparator), p->colSeparator, SEP_Comma);
16574       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->rowSeparator), p->rowSeparator, SEP_CrLf);
16575     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'t'} && strncmp(azArg[1],\textcolor{stringliteral}{"tabs"},n2)==0 )\{
16576       p->mode = MODE_List;
16577       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->colSeparator), p->colSeparator, SEP_Tab);
16578     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'i'} && strncmp(azArg[1],\textcolor{stringliteral}{"insert"},n2)==0 )\{
16579       p->mode = MODE_Insert;
16580       set_table_name(p, nArg>=3 ? azArg[2] : \textcolor{stringliteral}{"table"});
16581     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'q'} && strncmp(azArg[1],\textcolor{stringliteral}{"quote"},n2)==0 )\{
16582       p->mode = MODE_Quote;
16583     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'a'} && strncmp(azArg[1],\textcolor{stringliteral}{"ascii"},n2)==0 )\{
16584       p->mode = MODE_Ascii;
16585       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->colSeparator), p->colSeparator, SEP_Unit);
16586       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->rowSeparator), p->rowSeparator, SEP_Record);
16587     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( nArg==1 )\{
16588       raw_printf(p->out, \textcolor{stringliteral}{"current output mode: %s\(\backslash\)n"}, modeDescr[p->mode]);
16589     \}\textcolor{keywordflow}{else}\{
16590       raw_printf(stderr, \textcolor{stringliteral}{"Error: mode should be one of: "}
16591          \textcolor{stringliteral}{"ascii column csv html insert line list quote tabs tcl\(\backslash\)n"});
16592       rc = 1;
16593     \}
16594     p->cMode = p->mode;
16595   \}\textcolor{keywordflow}{else}
16596 
16597   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'n'} && strncmp(azArg[0], \textcolor{stringliteral}{"nullvalue"}, n)==0 )\{
16598     \textcolor{keywordflow}{if}( nArg==2 )\{
16599       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->nullValue), p->nullValue,
16600                        \textcolor{stringliteral}{"%.*s"}, (\textcolor{keywordtype}{int})ArraySize(p->nullValue)-1, azArg[1]);
16601     \}\textcolor{keywordflow}{else}\{
16602       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .nullvalue STRING\(\backslash\)n"});
16603       rc = 1;
16604     \}
16605   \}\textcolor{keywordflow}{else}
16606 
16607   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'o'} && strncmp(azArg[0], \textcolor{stringliteral}{"open"}, n)==0 && n>=2 )\{
16608     \textcolor{keywordtype}{char} *zNewFilename;  \textcolor{comment}{/* Name of the database file to open */}
16609     \textcolor{keywordtype}{int} iName = 1;       \textcolor{comment}{/* Index in azArg[] of the filename */}
16610     \textcolor{keywordtype}{int} newFlag = 0;     \textcolor{comment}{/* True to delete file before opening */}
16611     \textcolor{comment}{/* Close the existing database */}
16612     session_close_all(p);
16613     close_db(p->db);
16614     p->db = 0;
16615     p->zDbFilename = 0;
16616     sqlite3_free(p->zFreeOnClose);
16617     p->zFreeOnClose = 0;
16618     p->openMode = SHELL_OPEN_UNSPEC;
16619     p->openFlags = 0;
16620     p->szMax = 0;
16621     \textcolor{comment}{/* Check for command-line arguments */}
16622     \textcolor{keywordflow}{for}(iName=1; iName<nArg && azArg[iName][0]==\textcolor{charliteral}{'-'}; iName++)\{
16623       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z = azArg[iName];
16624       \textcolor{keywordflow}{if}( optionMatch(z,\textcolor{stringliteral}{"new"}) )\{
16625         newFlag = 1;
16626 \textcolor{preprocessor}{#ifdef SQLITE\_HAVE\_ZLIB}
16627       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"zip"}) )\{
16628         p->openMode = SHELL_OPEN_ZIPFILE;
16629 \textcolor{preprocessor}{#endif}
16630       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"append"}) )\{
16631         p->openMode = SHELL_OPEN_APPENDVFS;
16632       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"readonly"}) )\{
16633         p->openMode = SHELL_OPEN_READONLY;
16634       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"nofollow"}) )\{
16635         p->openFlags |= SQLITE_OPEN_NOFOLLOW;
16636 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_DESERIALIZE}
16637       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"deserialize"}) )\{
16638         p->openMode = SHELL_OPEN_DESERIALIZE;
16639       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"hexdb"}) )\{
16640         p->openMode = SHELL_OPEN_HEXDB;
16641       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"maxsize"}) && iName+1<nArg )\{
16642         p->szMax = integerValue(azArg[++iName]);
16643 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* SQLITE\_ENABLE\_DESERIALIZE */}\textcolor{preprocessor}{}
16644       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( z[0]==\textcolor{charliteral}{'-'} )\{
16645         utf8_printf(stderr, \textcolor{stringliteral}{"unknown option: %s\(\backslash\)n"}, z);
16646         rc = 1;
16647         \textcolor{keywordflow}{goto} meta\_command\_exit;
16648       \}
16649     \}
16650     \textcolor{comment}{/* If a filename is specified, try to open it first */}
16651     zNewFilename = nArg>iName ? sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, azArg[iName]) : 0;
16652     \textcolor{keywordflow}{if}( zNewFilename || p->openMode==SHELL_OPEN_HEXDB )\{
16653       \textcolor{keywordflow}{if}( newFlag ) shellDeleteFile(zNewFilename);
16654       p->zDbFilename = zNewFilename;
16655       open_db(p, OPEN_DB_KEEPALIVE);
16656       \textcolor{keywordflow}{if}( p->db==0 )\{
16657         utf8_printf(stderr, \textcolor{stringliteral}{"Error: cannot open '%s'\(\backslash\)n"}, zNewFilename);
16658         sqlite3_free(zNewFilename);
16659       \}\textcolor{keywordflow}{else}\{
16660         p->zFreeOnClose = zNewFilename;
16661       \}
16662     \}
16663     \textcolor{keywordflow}{if}( p->db==0 )\{
16664       \textcolor{comment}{/* As a fall-back open a TEMP database */}
16665       p->zDbFilename = 0;
16666       open_db(p, 0);
16667     \}
16668   \}\textcolor{keywordflow}{else}
16669 
16670   \textcolor{keywordflow}{if}( (c==\textcolor{charliteral}{'o'}
16671         && (strncmp(azArg[0], \textcolor{stringliteral}{"output"}, n)==0||strncmp(azArg[0], \textcolor{stringliteral}{"once"}, n)==0))
16672    || (c==\textcolor{charliteral}{'e'} && n==5 && strcmp(azArg[0],\textcolor{stringliteral}{"excel"})==0)
16673   )\{
16674     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zFile = nArg>=2 ? azArg[1] : \textcolor{stringliteral}{"stdout"};
16675     \textcolor{keywordtype}{int} bTxtMode = 0;
16676     \textcolor{keywordflow}{if}( azArg[0][0]==\textcolor{charliteral}{'e'} )\{
16677       \textcolor{comment}{/* Transform the ".excel" command into ".once -x" */}
16678       nArg = 2;
16679       azArg[0] = \textcolor{stringliteral}{"once"};
16680       zFile = azArg[1] = \textcolor{stringliteral}{"-x"};
16681       n = 4;
16682     \}
16683     \textcolor{keywordflow}{if}( nArg>2 )\{
16684       utf8_printf(stderr, \textcolor{stringliteral}{"Usage: .%s [-e|-x|FILE]\(\backslash\)n"}, azArg[0]);
16685       rc = 1;
16686       \textcolor{keywordflow}{goto} meta\_command\_exit;
16687     \}
16688     \textcolor{keywordflow}{if}( n>1 && strncmp(azArg[0], \textcolor{stringliteral}{"once"}, n)==0 )\{
16689       \textcolor{keywordflow}{if}( nArg<2 )\{
16690         raw_printf(stderr, \textcolor{stringliteral}{"Usage: .once (-e|-x|FILE)\(\backslash\)n"});
16691         rc = 1;
16692         \textcolor{keywordflow}{goto} meta\_command\_exit;
16693       \}
16694       p->outCount = 2;
16695     \}\textcolor{keywordflow}{else}\{
16696       p->outCount = 0;
16697     \}
16698     output_reset(p);
16699     \textcolor{keywordflow}{if}( zFile[0]==\textcolor{charliteral}{'-'} && zFile[1]==\textcolor{charliteral}{'-'} ) zFile++;
16700 \textcolor{preprocessor}{#ifndef SQLITE\_NOHAVE\_SYSTEM}
16701     \textcolor{keywordflow}{if}( strcmp(zFile, \textcolor{stringliteral}{"-e"})==0 || strcmp(zFile, \textcolor{stringliteral}{"-x"})==0 )\{
16702       p->doXdgOpen = 1;
16703       outputModePush(p);
16704       \textcolor{keywordflow}{if}( zFile[1]==\textcolor{charliteral}{'x'} )\{
16705         newTempFile(p, \textcolor{stringliteral}{"csv"});
16706         p->mode = MODE_Csv;
16707         sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->colSeparator), p->colSeparator, SEP_Comma);
16708         sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->rowSeparator), p->rowSeparator, SEP_CrLf);
16709       \}\textcolor{keywordflow}{else}\{
16710         newTempFile(p, \textcolor{stringliteral}{"txt"});
16711         bTxtMode = 1;
16712       \}
16713       zFile = p->zTempFile;
16714     \}
16715 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* SQLITE\_NOHAVE\_SYSTEM */}\textcolor{preprocessor}{}
16716     \textcolor{keywordflow}{if}( zFile[0]==\textcolor{charliteral}{'|'} )\{
16717 \textcolor{preprocessor}{#ifdef SQLITE\_OMIT\_POPEN}
16718       raw_printf(stderr, \textcolor{stringliteral}{"Error: pipes are not supported in this OS\(\backslash\)n"});
16719       rc = 1;
16720       p->out = stdout;
16721 \textcolor{preprocessor}{#else}
16722       p->out = popen(zFile + 1, \textcolor{stringliteral}{"w"});
16723       \textcolor{keywordflow}{if}( p->out==0 )\{
16724         utf8_printf(stderr,\textcolor{stringliteral}{"Error: cannot open pipe \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, zFile + 1);
16725         p->out = stdout;
16726         rc = 1;
16727       \}\textcolor{keywordflow}{else}\{
16728         sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->outfile), p->outfile, \textcolor{stringliteral}{"%s"}, zFile);
16729       \}
16730 \textcolor{preprocessor}{#endif}
16731     \}\textcolor{keywordflow}{else}\{
16732       p->out = output_file_open(zFile, bTxtMode);
16733       \textcolor{keywordflow}{if}( p->out==0 )\{
16734         \textcolor{keywordflow}{if}( strcmp(zFile,\textcolor{stringliteral}{"off"})!=0 )\{
16735           utf8_printf(stderr,\textcolor{stringliteral}{"Error: cannot write to \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, zFile);
16736         \}
16737         p->out = stdout;
16738         rc = 1;
16739       \} \textcolor{keywordflow}{else} \{
16740         sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->outfile), p->outfile, \textcolor{stringliteral}{"%s"}, zFile);
16741       \}
16742     \}
16743   \}\textcolor{keywordflow}{else}
16744 
16745   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'p'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"parameter"}, n)==0 )\{
16746     open_db(p,0);
16747     \textcolor{keywordflow}{if}( nArg<=1 ) \textcolor{keywordflow}{goto} parameter\_syntax\_error;
16748 
16749     \textcolor{comment}{/* .parameter clear}
16750 \textcolor{comment}{    ** Clear all bind parameters by dropping the TEMP table that holds them.}
16751 \textcolor{comment}{    */}
16752     \textcolor{keywordflow}{if}( nArg==2 && strcmp(azArg[1],\textcolor{stringliteral}{"clear"})==0 )\{
16753       sqlite3_exec(p->db, \textcolor{stringliteral}{"DROP TABLE IF EXISTS temp.sqlite\_parameters;"},
16754                    0, 0, 0);
16755     \}\textcolor{keywordflow}{else}
16756 
16757     \textcolor{comment}{/* .parameter list}
16758 \textcolor{comment}{    ** List all bind parameters.}
16759 \textcolor{comment}{    */}
16760     \textcolor{keywordflow}{if}( nArg==2 && strcmp(azArg[1],\textcolor{stringliteral}{"list"})==0 )\{
16761       sqlite3_stmt *pStmt = 0;
16762       \textcolor{keywordtype}{int} rx;
16763       \textcolor{keywordtype}{int} len = 0;
16764       rx = sqlite3_prepare_v2(p->db,
16765              \textcolor{stringliteral}{"SELECT max(length(key)) "}
16766              \textcolor{stringliteral}{"FROM temp.sqlite\_parameters;"}, -1, &pStmt, 0);
16767       \textcolor{keywordflow}{if}( rx==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW )\{
16768         len = sqlite3_column_int(pStmt, 0);
16769         \textcolor{keywordflow}{if}( len>40 ) len = 40;
16770       \}
16771       sqlite3_finalize(pStmt);
16772       pStmt = 0;
16773       \textcolor{keywordflow}{if}( len )\{
16774         rx = sqlite3_prepare_v2(p->db,
16775              \textcolor{stringliteral}{"SELECT key, quote(value) "}
16776              \textcolor{stringliteral}{"FROM temp.sqlite\_parameters;"}, -1, &pStmt, 0);
16777         \textcolor{keywordflow}{while}( sqlite3_step(pStmt)==SQLITE_ROW )\{
16778           utf8_printf(p->out, \textcolor{stringliteral}{"%-*s %s\(\backslash\)n"}, len, sqlite3_column_text(pStmt,0),
16779                       sqlite3_column_text(pStmt,1));
16780         \}
16781         sqlite3_finalize(pStmt);
16782       \}
16783     \}\textcolor{keywordflow}{else}
16784 
16785     \textcolor{comment}{/* .parameter init}
16786 \textcolor{comment}{    ** Make sure the TEMP table used to hold bind parameters exists.}
16787 \textcolor{comment}{    ** Create it if necessary.}
16788 \textcolor{comment}{    */}
16789     \textcolor{keywordflow}{if}( nArg==2 && strcmp(azArg[1],\textcolor{stringliteral}{"init"})==0 )\{
16790       bind_table_init(p);
16791     \}\textcolor{keywordflow}{else}
16792 
16793     \textcolor{comment}{/* .parameter set NAME VALUE}
16794 \textcolor{comment}{    ** Set or reset a bind parameter.  NAME should be the full parameter}
16795 \textcolor{comment}{    ** name exactly as it appears in the query.  (ex: $abc, @def).  The}
16796 \textcolor{comment}{    ** VALUE can be in either SQL literal notation, or if not it will be}
16797 \textcolor{comment}{    ** understood to be a text string.}
16798 \textcolor{comment}{    */}
16799     \textcolor{keywordflow}{if}( nArg==4 && strcmp(azArg[1],\textcolor{stringliteral}{"set"})==0 )\{
16800       \textcolor{keywordtype}{int} rx;
16801       \textcolor{keywordtype}{char} *zSql;
16802       sqlite3_stmt *pStmt;
16803       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zKey = azArg[2];
16804       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zValue = azArg[3];
16805       bind_table_init(p);
16806       zSql = sqlite3_mprintf(
16807                   \textcolor{stringliteral}{"REPLACE INTO temp.sqlite\_parameters(key,value)"}
16808                   \textcolor{stringliteral}{"VALUES(%Q,%s);"}, zKey, zValue);
16809       \textcolor{keywordflow}{if}( zSql==0 ) shell_out_of_memory();
16810       pStmt = 0;
16811       rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
16812       sqlite3_free(zSql);
16813       \textcolor{keywordflow}{if}( rx!=SQLITE_OK )\{
16814         sqlite3_finalize(pStmt);
16815         pStmt = 0;
16816         zSql = sqlite3_mprintf(
16817                    \textcolor{stringliteral}{"REPLACE INTO temp.sqlite\_parameters(key,value)"}
16818                    \textcolor{stringliteral}{"VALUES(%Q,%Q);"}, zKey, zValue);
16819         \textcolor{keywordflow}{if}( zSql==0 ) shell_out_of_memory();
16820         rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
16821         sqlite3_free(zSql);
16822         \textcolor{keywordflow}{if}( rx!=SQLITE_OK )\{
16823           utf8_printf(p->out, \textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, sqlite3_errmsg(p->db));
16824           sqlite3_finalize(pStmt);
16825           pStmt = 0;
16826           rc = 1;
16827         \}
16828       \}
16829       sqlite3_step(pStmt);
16830       sqlite3_finalize(pStmt);
16831     \}\textcolor{keywordflow}{else}
16832 
16833     \textcolor{comment}{/* .parameter unset NAME}
16834 \textcolor{comment}{    ** Remove the NAME binding from the parameter binding table, if it}
16835 \textcolor{comment}{    ** exists.}
16836 \textcolor{comment}{    */}
16837     \textcolor{keywordflow}{if}( nArg==3 && strcmp(azArg[1],\textcolor{stringliteral}{"unset"})==0 )\{
16838       \textcolor{keywordtype}{char} *zSql = sqlite3_mprintf(
16839           \textcolor{stringliteral}{"DELETE FROM temp.sqlite\_parameters WHERE key=%Q"}, azArg[2]);
16840       \textcolor{keywordflow}{if}( zSql==0 ) shell_out_of_memory();
16841       sqlite3_exec(p->db, zSql, 0, 0, 0);
16842       sqlite3_free(zSql);
16843     \}\textcolor{keywordflow}{else}
16844     \textcolor{comment}{/* If no command name matches, show a syntax error */}
16845     parameter\_syntax\_error:
16846     showHelp(p->out, \textcolor{stringliteral}{"parameter"});
16847   \}\textcolor{keywordflow}{else}
16848 
16849   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'p'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"print"}, n)==0 )\{
16850     \textcolor{keywordtype}{int} i;
16851     \textcolor{keywordflow}{for}(i=1; i<nArg; i++)\{
16852       \textcolor{keywordflow}{if}( i>1 ) raw_printf(p->out, \textcolor{stringliteral}{" "});
16853       utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, azArg[i]);
16854     \}
16855     raw_printf(p->out, \textcolor{stringliteral}{"\(\backslash\)n"});
16856   \}\textcolor{keywordflow}{else}
16857 
16858 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_PROGRESS\_CALLBACK}
16859   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'p'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"progress"}, n)==0 )\{
16860     \textcolor{keywordtype}{int} i;
16861     \textcolor{keywordtype}{int} nn = 0;
16862     p->flgProgress = 0;
16863     p->mxProgress = 0;
16864     p->nProgress = 0;
16865     \textcolor{keywordflow}{for}(i=1; i<nArg; i++)\{
16866       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z = azArg[i];
16867       \textcolor{keywordflow}{if}( z[0]==\textcolor{charliteral}{'-'} )\{
16868         z++;
16869         \textcolor{keywordflow}{if}( z[0]==\textcolor{charliteral}{'-'} ) z++;
16870         \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"quiet"})==0 || strcmp(z,\textcolor{stringliteral}{"q"})==0 )\{
16871           p->flgProgress |= SHELL_PROGRESS_QUIET;
16872           \textcolor{keywordflow}{continue};
16873         \}
16874         \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"reset"})==0 )\{
16875           p->flgProgress |= SHELL_PROGRESS_RESET;
16876           \textcolor{keywordflow}{continue};
16877         \}
16878         \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"once"})==0 )\{
16879           p->flgProgress |= SHELL_PROGRESS_ONCE;
16880           \textcolor{keywordflow}{continue};
16881         \}
16882         \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"limit"})==0 )\{
16883           \textcolor{keywordflow}{if}( i+1>=nArg )\{
16884             utf8_printf(stderr, \textcolor{stringliteral}{"Error: missing argument on --limit\(\backslash\)n"});
16885             rc = 1;
16886             \textcolor{keywordflow}{goto} meta\_command\_exit;
16887           \}\textcolor{keywordflow}{else}\{
16888             p->mxProgress = (int)integerValue(azArg[++i]);
16889           \}
16890           \textcolor{keywordflow}{continue};
16891         \}
16892         utf8_printf(stderr, \textcolor{stringliteral}{"Error: unknown option: \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, azArg[i]);
16893         rc = 1;
16894         \textcolor{keywordflow}{goto} meta\_command\_exit;
16895       \}\textcolor{keywordflow}{else}\{
16896         nn = (int)integerValue(z);
16897       \}
16898     \}
16899     open_db(p, 0);
16900     sqlite3_progress_handler(p->db, nn, progress_handler, p);
16901   \}\textcolor{keywordflow}{else}
16902 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* SQLITE\_OMIT\_PROGRESS\_CALLBACK */}\textcolor{preprocessor}{}
16903 
16904   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'p'} && strncmp(azArg[0], \textcolor{stringliteral}{"prompt"}, n)==0 )\{
16905     \textcolor{keywordflow}{if}( nArg >= 2) \{
16906       strncpy(mainPrompt,azArg[1],(\textcolor{keywordtype}{int})ArraySize(mainPrompt)-1);
16907     \}
16908     \textcolor{keywordflow}{if}( nArg >= 3) \{
16909       strncpy(continuePrompt,azArg[2],(\textcolor{keywordtype}{int})ArraySize(continuePrompt)-1);
16910     \}
16911   \}\textcolor{keywordflow}{else}
16912 
16913   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'q'} && strncmp(azArg[0], \textcolor{stringliteral}{"quit"}, n)==0 )\{
16914     rc = 2;
16915   \}\textcolor{keywordflow}{else}
16916 
16917   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'r'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"read"}, n)==0 )\{
16918     FILE *inSaved = p->in;
16919     \textcolor{keywordtype}{int} savedLineno = p->lineno;
16920     \textcolor{keywordflow}{if}( nArg!=2 )\{
16921       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .read FILE\(\backslash\)n"});
16922       rc = 1;
16923       \textcolor{keywordflow}{goto} meta\_command\_exit;
16924     \}
16925     p->in = fopen(azArg[1], \textcolor{stringliteral}{"rb"});
16926     \textcolor{keywordflow}{if}( p->in==0 )\{
16927       utf8_printf(stderr,\textcolor{stringliteral}{"Error: cannot open \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, azArg[1]);
16928       rc = 1;
16929     \}\textcolor{keywordflow}{else}\{
16930       rc = process_input(p);
16931       fclose(p->in);
16932     \}
16933     p->in = inSaved;
16934     p->lineno = savedLineno;
16935   \}\textcolor{keywordflow}{else}
16936 
16937   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'r'} && n>=3 && strncmp(azArg[0], \textcolor{stringliteral}{"restore"}, n)==0 )\{
16938     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSrcFile;
16939     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDb;
16940     sqlite3 *pSrc;
16941     sqlite3_backup *pBackup;
16942     \textcolor{keywordtype}{int} nTimeout = 0;
16943 
16944     \textcolor{keywordflow}{if}( nArg==2 )\{
16945       zSrcFile = azArg[1];
16946       zDb = \textcolor{stringliteral}{"main"};
16947     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( nArg==3 )\{
16948       zSrcFile = azArg[2];
16949       zDb = azArg[1];
16950     \}\textcolor{keywordflow}{else}\{
16951       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .restore ?DB? FILE\(\backslash\)n"});
16952       rc = 1;
16953       \textcolor{keywordflow}{goto} meta\_command\_exit;
16954     \}
16955     rc = sqlite3_open(zSrcFile, &pSrc);
16956     \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
16957       utf8_printf(stderr, \textcolor{stringliteral}{"Error: cannot open \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, zSrcFile);
16958       close_db(pSrc);
16959       \textcolor{keywordflow}{return} 1;
16960     \}
16961     open_db(p, 0);
16962     pBackup = sqlite3_backup_init(p->db, zDb, pSrc, \textcolor{stringliteral}{"main"});
16963     \textcolor{keywordflow}{if}( pBackup==0 )\{
16964       utf8_printf(stderr, \textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, sqlite3_errmsg(p->db));
16965       close_db(pSrc);
16966       \textcolor{keywordflow}{return} 1;
16967     \}
16968     \textcolor{keywordflow}{while}( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK
16969           || rc==SQLITE_BUSY  )\{
16970       \textcolor{keywordflow}{if}( rc==SQLITE_BUSY )\{
16971         \textcolor{keywordflow}{if}( nTimeout++ >= 3 ) \textcolor{keywordflow}{break};
16972         sqlite3_sleep(100);
16973       \}
16974     \}
16975     sqlite3_backup_finish(pBackup);
16976     \textcolor{keywordflow}{if}( rc==SQLITE_DONE )\{
16977       rc = 0;
16978     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( rc==SQLITE_BUSY || rc==SQLITE_LOCKED )\{
16979       raw_printf(stderr, \textcolor{stringliteral}{"Error: source database is busy\(\backslash\)n"});
16980       rc = 1;
16981     \}\textcolor{keywordflow}{else}\{
16982       utf8_printf(stderr, \textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, sqlite3_errmsg(p->db));
16983       rc = 1;
16984     \}
16985     close_db(pSrc);
16986   \}\textcolor{keywordflow}{else}
16987 
16988   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'s'} && strncmp(azArg[0], \textcolor{stringliteral}{"scanstats"}, n)==0 )\{
16989     \textcolor{keywordflow}{if}( nArg==2 )\{
16990       p->scanstatsOn = (u8)booleanValue(azArg[1]);
16991 \textcolor{preprocessor}{#ifndef SQLITE\_ENABLE\_STMT\_SCANSTATUS}
16992       raw_printf(stderr, \textcolor{stringliteral}{"Warning: .scanstats not available in this build.\(\backslash\)n"});
16993 \textcolor{preprocessor}{#endif}
16994     \}\textcolor{keywordflow}{else}\{
16995       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .scanstats on|off\(\backslash\)n"});
16996       rc = 1;
16997     \}
16998   \}\textcolor{keywordflow}{else}
16999 
17000   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'s'} && strncmp(azArg[0], \textcolor{stringliteral}{"schema"}, n)==0 )\{
17001     ShellText sSelect;
17002     ShellState data;
17003     \textcolor{keywordtype}{char} *zErrMsg = 0;
17004     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDiv = \textcolor{stringliteral}{"("};
17005     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zName = 0;
17006     \textcolor{keywordtype}{int} iSchema = 0;
17007     \textcolor{keywordtype}{int} bDebug = 0;
17008     \textcolor{keywordtype}{int} ii;
17009 
17010     open_db(p, 0);
17011     memcpy(&data, p, \textcolor{keyword}{sizeof}(data));
17012     data.showHeader = 0;
17013     data.cMode = data.mode = MODE_Semi;
17014     initText(&sSelect);
17015     \textcolor{keywordflow}{for}(ii=1; ii<nArg; ii++)\{
17016       \textcolor{keywordflow}{if}( optionMatch(azArg[ii],\textcolor{stringliteral}{"indent"}) )\{
17017         data.cMode = data.mode = MODE_Pretty;
17018       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(azArg[ii],\textcolor{stringliteral}{"debug"}) )\{
17019         bDebug = 1;
17020       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( zName==0 )\{
17021         zName = azArg[ii];
17022       \}\textcolor{keywordflow}{else}\{
17023         raw_printf(stderr, \textcolor{stringliteral}{"Usage: .schema ?--indent? ?LIKE-PATTERN?\(\backslash\)n"});
17024         rc = 1;
17025         \textcolor{keywordflow}{goto} meta\_command\_exit;
17026       \}
17027     \}
17028     \textcolor{keywordflow}{if}( zName!=0 )\{
17029       \textcolor{keywordtype}{int} isMaster = sqlite3_strlike(zName, \textcolor{stringliteral}{"sqlite\_master"}, \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'})==0;
17030       \textcolor{keywordflow}{if}( isMaster || sqlite3_strlike(zName,\textcolor{stringliteral}{"sqlite\_temp\_master"}, \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'})==0 )\{
17031         \textcolor{keywordtype}{char} *new\_argv[2], *new\_colv[2];
17032         new\_argv[0] = sqlite3_mprintf(
17033                       \textcolor{stringliteral}{"CREATE TABLE %s (\(\backslash\)n"}
17034                       \textcolor{stringliteral}{"  type text,\(\backslash\)n"}
17035                       \textcolor{stringliteral}{"  name text,\(\backslash\)n"}
17036                       \textcolor{stringliteral}{"  tbl\_name text,\(\backslash\)n"}
17037                       \textcolor{stringliteral}{"  rootpage integer,\(\backslash\)n"}
17038                       \textcolor{stringliteral}{"  sql text\(\backslash\)n"}
17039                       \textcolor{stringliteral}{")"}, isMaster ? \textcolor{stringliteral}{"sqlite\_master"} : \textcolor{stringliteral}{"sqlite\_temp\_master"});
17040         new\_argv[1] = 0;
17041         new\_colv[0] = \textcolor{stringliteral}{"sql"};
17042         new\_colv[1] = 0;
17043         callback(&data, 1, new\_argv, new\_colv);
17044         sqlite3_free(new\_argv[0]);
17045       \}
17046     \}
17047     \textcolor{keywordflow}{if}( zDiv )\{
17048       sqlite3_stmt *pStmt = 0;
17049       rc = sqlite3_prepare_v2(p->db, \textcolor{stringliteral}{"SELECT name FROM pragma\_database\_list"},
17050                               -1, &pStmt, 0);
17051       \textcolor{keywordflow}{if}( rc )\{
17052         utf8_printf(stderr, \textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, sqlite3_errmsg(p->db));
17053         sqlite3_finalize(pStmt);
17054         rc = 1;
17055         \textcolor{keywordflow}{goto} meta\_command\_exit;
17056       \}
17057       appendText(&sSelect, \textcolor{stringliteral}{"SELECT sql FROM"}, 0);
17058       iSchema = 0;
17059       \textcolor{keywordflow}{while}( sqlite3_step(pStmt)==SQLITE_ROW )\{
17060         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDb = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pStmt, 0);
17061         \textcolor{keywordtype}{char} zScNum[30];
17062         sqlite3_snprintf(\textcolor{keyword}{sizeof}(zScNum), zScNum, \textcolor{stringliteral}{"%d"}, ++iSchema);
17063         appendText(&sSelect, zDiv, 0);
17064         zDiv = \textcolor{stringliteral}{" UNION ALL "};
17065         appendText(&sSelect, \textcolor{stringliteral}{"SELECT shell\_add\_schema(sql,"}, 0);
17066         \textcolor{keywordflow}{if}( sqlite3_stricmp(zDb, \textcolor{stringliteral}{"main"})!=0 )\{
17067           appendText(&sSelect, zDb, \textcolor{charliteral}{'\(\backslash\)''});
17068         \}\textcolor{keywordflow}{else}\{
17069           appendText(&sSelect, \textcolor{stringliteral}{"NULL"}, 0);
17070         \}
17071         appendText(&sSelect, \textcolor{stringliteral}{",name) AS sql, type, tbl\_name, name, rowid,"}, 0);
17072         appendText(&sSelect, zScNum, 0);
17073         appendText(&sSelect, \textcolor{stringliteral}{" AS snum, "}, 0);
17074         appendText(&sSelect, zDb, \textcolor{charliteral}{'\(\backslash\)''});
17075         appendText(&sSelect, \textcolor{stringliteral}{" AS sname FROM "}, 0);
17076         appendText(&sSelect, zDb, quoteChar(zDb));
17077         appendText(&sSelect, \textcolor{stringliteral}{".sqlite\_master"}, 0);
17078       \}
17079       sqlite3_finalize(pStmt);
17080 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_INTROSPECTION\_PRAGMAS}
17081       \textcolor{keywordflow}{if}( zName )\{
17082         appendText(&sSelect,
17083            \textcolor{stringliteral}{" UNION ALL SELECT shell\_module\_schema(name),"}
17084            \textcolor{stringliteral}{" 'table', name, name, name, 9e+99, 'main' FROM pragma\_module\_list"},
17085         0);
17086       \}
17087 \textcolor{preprocessor}{#endif}
17088       appendText(&sSelect, \textcolor{stringliteral}{") WHERE "}, 0);
17089       \textcolor{keywordflow}{if}( zName )\{
17090         \textcolor{keywordtype}{char} *zQarg = sqlite3_mprintf(\textcolor{stringliteral}{"%Q"}, zName);
17091         \textcolor{keywordtype}{int} bGlob = strchr(zName, \textcolor{charliteral}{'*'}) != 0 || strchr(zName, \textcolor{charliteral}{'?'}) != 0 ||
17092                     strchr(zName, \textcolor{charliteral}{'['}) != 0;
17093         \textcolor{keywordflow}{if}( strchr(zName, \textcolor{charliteral}{'.'}) )\{
17094           appendText(&sSelect, \textcolor{stringliteral}{"lower(printf('%s.%s',sname,tbl\_name))"}, 0);
17095         \}\textcolor{keywordflow}{else}\{
17096           appendText(&sSelect, \textcolor{stringliteral}{"lower(tbl\_name)"}, 0);
17097         \}
17098         appendText(&sSelect, bGlob ? \textcolor{stringliteral}{" GLOB "} : \textcolor{stringliteral}{" LIKE "}, 0);
17099         appendText(&sSelect, zQarg, 0);
17100         \textcolor{keywordflow}{if}( !bGlob )\{
17101           appendText(&sSelect, \textcolor{stringliteral}{" ESCAPE '\(\backslash\)\(\backslash\)' "}, 0);
17102         \}
17103         appendText(&sSelect, \textcolor{stringliteral}{" AND "}, 0);
17104         sqlite3_free(zQarg);
17105       \}
17106       appendText(&sSelect, \textcolor{stringliteral}{"type!='meta' AND sql IS NOT NULL"}
17107                            \textcolor{stringliteral}{" ORDER BY snum, rowid"}, 0);
17108       \textcolor{keywordflow}{if}( bDebug )\{
17109         utf8_printf(p->out, \textcolor{stringliteral}{"SQL: %s;\(\backslash\)n"}, sSelect.z);
17110       \}\textcolor{keywordflow}{else}\{
17111         rc = sqlite3_exec(p->db, sSelect.z, callback, &data, &zErrMsg);
17112       \}
17113       freeText(&sSelect);
17114     \}
17115     \textcolor{keywordflow}{if}( zErrMsg )\{
17116       utf8_printf(stderr,\textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, zErrMsg);
17117       sqlite3_free(zErrMsg);
17118       rc = 1;
17119     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( rc != SQLITE_OK )\{
17120       raw_printf(stderr,\textcolor{stringliteral}{"Error: querying schema information\(\backslash\)n"});
17121       rc = 1;
17122     \}\textcolor{keywordflow}{else}\{
17123       rc = 0;
17124     \}
17125   \}\textcolor{keywordflow}{else}
17126 
17127 \textcolor{preprocessor}{#if defined(SQLITE\_DEBUG) && defined(SQLITE\_ENABLE\_SELECTTRACE)}
17128   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'s'} && n==11 && strncmp(azArg[0], \textcolor{stringliteral}{"selecttrace"}, n)==0 )\{
17129     sqlite3SelectTrace = (int)integerValue(azArg[1]);
17130   \}\textcolor{keywordflow}{else}
17131 \textcolor{preprocessor}{#endif}
17132 
17133 \textcolor{preprocessor}{#if defined(SQLITE\_ENABLE\_SESSION)}
17134   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'s'} && strncmp(azArg[0],\textcolor{stringliteral}{"session"},n)==0 && n>=3 )\{
17135     OpenSession *pSession = &p->aSession[0];
17136     \textcolor{keywordtype}{char} **azCmd = &azArg[1];
17137     \textcolor{keywordtype}{int} iSes = 0;
17138     \textcolor{keywordtype}{int} nCmd = nArg - 1;
17139     \textcolor{keywordtype}{int} i;
17140     \textcolor{keywordflow}{if}( nArg<=1 ) \textcolor{keywordflow}{goto} session\_syntax\_error;
17141     open_db(p, 0);
17142     \textcolor{keywordflow}{if}( nArg>=3 )\{
17143       \textcolor{keywordflow}{for}(iSes=0; iSes<p->nSession; iSes++)\{
17144         \textcolor{keywordflow}{if}( strcmp(p->aSession[iSes].zName, azArg[1])==0 ) \textcolor{keywordflow}{break};
17145       \}
17146       \textcolor{keywordflow}{if}( iSes<p->nSession )\{
17147         pSession = &p->aSession[iSes];
17148         azCmd++;
17149         nCmd--;
17150       \}\textcolor{keywordflow}{else}\{
17151         pSession = &p->aSession[0];
17152         iSes = 0;
17153       \}
17154     \}
17155 
17156     \textcolor{comment}{/* .session attach TABLE}
17157 \textcolor{comment}{    ** Invoke the sqlite3session\_attach() interface to attach a particular}
17158 \textcolor{comment}{    ** table so that it is never filtered.}
17159 \textcolor{comment}{    */}
17160     \textcolor{keywordflow}{if}( strcmp(azCmd[0],\textcolor{stringliteral}{"attach"})==0 )\{
17161       \textcolor{keywordflow}{if}( nCmd!=2 ) \textcolor{keywordflow}{goto} session\_syntax\_error;
17162       \textcolor{keywordflow}{if}( pSession->p==0 )\{
17163         session\_not\_open:
17164         raw_printf(stderr, \textcolor{stringliteral}{"ERROR: No sessions are open\(\backslash\)n"});
17165       \}\textcolor{keywordflow}{else}\{
17166         rc = sqlite3session\_attach(pSession->p, azCmd[1]);
17167         \textcolor{keywordflow}{if}( rc )\{
17168           raw_printf(stderr, \textcolor{stringliteral}{"ERROR: sqlite3session\_attach() returns %d\(\backslash\)n"}, rc);
17169           rc = 0;
17170         \}
17171       \}
17172     \}\textcolor{keywordflow}{else}
17173 
17174     \textcolor{comment}{/* .session changeset FILE}
17175 \textcolor{comment}{    ** .session patchset FILE}
17176 \textcolor{comment}{    ** Write a changeset or patchset into a file.  The file is overwritten.}
17177 \textcolor{comment}{    */}
17178     \textcolor{keywordflow}{if}( strcmp(azCmd[0],\textcolor{stringliteral}{"changeset"})==0 || strcmp(azCmd[0],\textcolor{stringliteral}{"patchset"})==0 )\{
17179       FILE *out = 0;
17180       \textcolor{keywordflow}{if}( nCmd!=2 ) \textcolor{keywordflow}{goto} session\_syntax\_error;
17181       \textcolor{keywordflow}{if}( pSession->p==0 ) \textcolor{keywordflow}{goto} session\_not\_open;
17182       out = fopen(azCmd[1], \textcolor{stringliteral}{"wb"});
17183       \textcolor{keywordflow}{if}( out==0 )\{
17184         utf8_printf(stderr, \textcolor{stringliteral}{"ERROR: cannot open \(\backslash\)"%s\(\backslash\)" for writing\(\backslash\)n"},
17185                     azCmd[1]);
17186       \}\textcolor{keywordflow}{else}\{
17187         \textcolor{keywordtype}{int} szChng;
17188         \textcolor{keywordtype}{void} *pChng;
17189         \textcolor{keywordflow}{if}( azCmd[0][0]==\textcolor{charliteral}{'c'} )\{
17190           rc = sqlite3session\_changeset(pSession->p, &szChng, &pChng);
17191         \}\textcolor{keywordflow}{else}\{
17192           rc = sqlite3session\_patchset(pSession->p, &szChng, &pChng);
17193         \}
17194         \textcolor{keywordflow}{if}( rc )\{
17195           printf(\textcolor{stringliteral}{"Error: error code %d\(\backslash\)n"}, rc);
17196           rc = 0;
17197         \}
17198         \textcolor{keywordflow}{if}( pChng
17199           && fwrite(pChng, szChng, 1, out)!=1 )\{
17200           raw_printf(stderr, \textcolor{stringliteral}{"ERROR: Failed to write entire %d-byte output\(\backslash\)n"},
17201                   szChng);
17202         \}
17203         sqlite3_free(pChng);
17204         fclose(out);
17205       \}
17206     \}\textcolor{keywordflow}{else}
17207 
17208     \textcolor{comment}{/* .session close}
17209 \textcolor{comment}{    ** Close the identified session}
17210 \textcolor{comment}{    */}
17211     \textcolor{keywordflow}{if}( strcmp(azCmd[0], \textcolor{stringliteral}{"close"})==0 )\{
17212       \textcolor{keywordflow}{if}( nCmd!=1 ) \textcolor{keywordflow}{goto} session\_syntax\_error;
17213       \textcolor{keywordflow}{if}( p->nSession )\{
17214         session\_close(pSession);
17215         p->aSession[iSes] = p->aSession[--p->nSession];
17216       \}
17217     \}\textcolor{keywordflow}{else}
17218 
17219     \textcolor{comment}{/* .session enable ?BOOLEAN?}
17220 \textcolor{comment}{    ** Query or set the enable flag}
17221 \textcolor{comment}{    */}
17222     \textcolor{keywordflow}{if}( strcmp(azCmd[0], \textcolor{stringliteral}{"enable"})==0 )\{
17223       \textcolor{keywordtype}{int} ii;
17224       \textcolor{keywordflow}{if}( nCmd>2 ) \textcolor{keywordflow}{goto} session\_syntax\_error;
17225       ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);
17226       \textcolor{keywordflow}{if}( p->nSession )\{
17227         ii = sqlite3session\_enable(pSession->p, ii);
17228         utf8_printf(p->out, \textcolor{stringliteral}{"session %s enable flag = %d\(\backslash\)n"},
17229                     pSession->zName, ii);
17230       \}
17231     \}\textcolor{keywordflow}{else}
17232 
17233     \textcolor{comment}{/* .session filter GLOB ....}
17234 \textcolor{comment}{    ** Set a list of GLOB patterns of table names to be excluded.}
17235 \textcolor{comment}{    */}
17236     \textcolor{keywordflow}{if}( strcmp(azCmd[0], \textcolor{stringliteral}{"filter"})==0 )\{
17237       \textcolor{keywordtype}{int} ii, nByte;
17238       \textcolor{keywordflow}{if}( nCmd<2 ) \textcolor{keywordflow}{goto} session\_syntax\_error;
17239       \textcolor{keywordflow}{if}( p->nSession )\{
17240         \textcolor{keywordflow}{for}(ii=0; ii<pSession->nFilter; ii++)\{
17241           sqlite3_free(pSession->azFilter[ii]);
17242         \}
17243         sqlite3_free(pSession->azFilter);
17244         nByte = \textcolor{keyword}{sizeof}(pSession->azFilter[0])*(nCmd-1);
17245         pSession->azFilter = sqlite3_malloc( nByte );
17246         \textcolor{keywordflow}{if}( pSession->azFilter==0 )\{
17247           raw_printf(stderr, \textcolor{stringliteral}{"Error: out or memory\(\backslash\)n"});
17248           exit(1);
17249         \}
17250         \textcolor{keywordflow}{for}(ii=1; ii<nCmd; ii++)\{
17251           pSession->azFilter[ii-1] = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, azCmd[ii]);
17252         \}
17253         pSession->nFilter = ii-1;
17254       \}
17255     \}\textcolor{keywordflow}{else}
17256 
17257     \textcolor{comment}{/* .session indirect ?BOOLEAN?}
17258 \textcolor{comment}{    ** Query or set the indirect flag}
17259 \textcolor{comment}{    */}
17260     \textcolor{keywordflow}{if}( strcmp(azCmd[0], \textcolor{stringliteral}{"indirect"})==0 )\{
17261       \textcolor{keywordtype}{int} ii;
17262       \textcolor{keywordflow}{if}( nCmd>2 ) \textcolor{keywordflow}{goto} session\_syntax\_error;
17263       ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);
17264       \textcolor{keywordflow}{if}( p->nSession )\{
17265         ii = sqlite3session\_indirect(pSession->p, ii);
17266         utf8_printf(p->out, \textcolor{stringliteral}{"session %s indirect flag = %d\(\backslash\)n"},
17267                     pSession->zName, ii);
17268       \}
17269     \}\textcolor{keywordflow}{else}
17270 
17271     \textcolor{comment}{/* .session isempty}
17272 \textcolor{comment}{    ** Determine if the session is empty}
17273 \textcolor{comment}{    */}
17274     \textcolor{keywordflow}{if}( strcmp(azCmd[0], \textcolor{stringliteral}{"isempty"})==0 )\{
17275       \textcolor{keywordtype}{int} ii;
17276       \textcolor{keywordflow}{if}( nCmd!=1 ) \textcolor{keywordflow}{goto} session\_syntax\_error;
17277       \textcolor{keywordflow}{if}( p->nSession )\{
17278         ii = sqlite3session\_isempty(pSession->p);
17279         utf8_printf(p->out, \textcolor{stringliteral}{"session %s isempty flag = %d\(\backslash\)n"},
17280                     pSession->zName, ii);
17281       \}
17282     \}\textcolor{keywordflow}{else}
17283 
17284     \textcolor{comment}{/* .session list}
17285 \textcolor{comment}{    ** List all currently open sessions}
17286 \textcolor{comment}{    */}
17287     \textcolor{keywordflow}{if}( strcmp(azCmd[0],\textcolor{stringliteral}{"list"})==0 )\{
17288       \textcolor{keywordflow}{for}(i=0; i<p->nSession; i++)\{
17289         utf8_printf(p->out, \textcolor{stringliteral}{"%d %s\(\backslash\)n"}, i, p->aSession[i].zName);
17290       \}
17291     \}\textcolor{keywordflow}{else}
17292 
17293     \textcolor{comment}{/* .session open DB NAME}
17294 \textcolor{comment}{    ** Open a new session called NAME on the attached database DB.}
17295 \textcolor{comment}{    ** DB is normally "main".}
17296 \textcolor{comment}{    */}
17297     \textcolor{keywordflow}{if}( strcmp(azCmd[0],\textcolor{stringliteral}{"open"})==0 )\{
17298       \textcolor{keywordtype}{char} *zName;
17299       \textcolor{keywordflow}{if}( nCmd!=3 ) \textcolor{keywordflow}{goto} session\_syntax\_error;
17300       zName = azCmd[2];
17301       \textcolor{keywordflow}{if}( zName[0]==0 ) \textcolor{keywordflow}{goto} session\_syntax\_error;
17302       \textcolor{keywordflow}{for}(i=0; i<p->nSession; i++)\{
17303         \textcolor{keywordflow}{if}( strcmp(p->aSession[i].zName,zName)==0 )\{
17304           utf8_printf(stderr, \textcolor{stringliteral}{"Session \(\backslash\)"%s\(\backslash\)" already exists\(\backslash\)n"}, zName);
17305           \textcolor{keywordflow}{goto} meta\_command\_exit;
17306         \}
17307       \}
17308       \textcolor{keywordflow}{if}( p->nSession>=ArraySize(p->aSession) )\{
17309         raw_printf(stderr, \textcolor{stringliteral}{"Maximum of %d sessions\(\backslash\)n"}, ArraySize(p->aSession));
17310         \textcolor{keywordflow}{goto} meta\_command\_exit;
17311       \}
17312       pSession = &p->aSession[p->nSession];
17313       rc = sqlite3session\_create(p->db, azCmd[1], &pSession->p);
17314       \textcolor{keywordflow}{if}( rc )\{
17315         raw_printf(stderr, \textcolor{stringliteral}{"Cannot open session: error code=%d\(\backslash\)n"}, rc);
17316         rc = 0;
17317         \textcolor{keywordflow}{goto} meta\_command\_exit;
17318       \}
17319       pSession->nFilter = 0;
17320       sqlite3session\_table\_filter(pSession->p, session\_filter, pSession);
17321       p->nSession++;
17322       pSession->zName = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, zName);
17323     \}\textcolor{keywordflow}{else}
17324     \textcolor{comment}{/* If no command name matches, show a syntax error */}
17325     session\_syntax\_error:
17326     showHelp(p->out, \textcolor{stringliteral}{"session"});
17327   \}\textcolor{keywordflow}{else}
17328 \textcolor{preprocessor}{#endif}
17329 
17330 \textcolor{preprocessor}{#ifdef SQLITE\_DEBUG}
17331   \textcolor{comment}{/* Undocumented commands for internal testing.  Subject to change}
17332 \textcolor{comment}{  ** without notice. */}
17333   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'s'} && n>=10 && strncmp(azArg[0], \textcolor{stringliteral}{"selftest-"}, 9)==0 )\{
17334     \textcolor{keywordflow}{if}( strncmp(azArg[0]+9, \textcolor{stringliteral}{"boolean"}, n-9)==0 )\{
17335       \textcolor{keywordtype}{int} i, v;
17336       \textcolor{keywordflow}{for}(i=1; i<nArg; i++)\{
17337         v = booleanValue(azArg[i]);
17338         utf8_printf(p->out, \textcolor{stringliteral}{"%s: %d 0x%x\(\backslash\)n"}, azArg[i], v, v);
17339       \}
17340     \}
17341     \textcolor{keywordflow}{if}( strncmp(azArg[0]+9, \textcolor{stringliteral}{"integer"}, n-9)==0 )\{
17342       \textcolor{keywordtype}{int} i; sqlite3_int64 v;
17343       \textcolor{keywordflow}{for}(i=1; i<nArg; i++)\{
17344         \textcolor{keywordtype}{char} zBuf[200];
17345         v = integerValue(azArg[i]);
17346         sqlite3_snprintf(\textcolor{keyword}{sizeof}(zBuf),zBuf,\textcolor{stringliteral}{"%s: %lld 0x%llx\(\backslash\)n"}, azArg[i],v,v);
17347         utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, zBuf);
17348       \}
17349     \}
17350   \}\textcolor{keywordflow}{else}
17351 \textcolor{preprocessor}{#endif}
17352 
17353   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'s'} && n>=4 && strncmp(azArg[0],\textcolor{stringliteral}{"selftest"},n)==0 )\{
17354     \textcolor{keywordtype}{int} bIsInit = 0;         \textcolor{comment}{/* True to initialize the SELFTEST table */}
17355     \textcolor{keywordtype}{int} bVerbose = 0;        \textcolor{comment}{/* Verbose output */}
17356     \textcolor{keywordtype}{int} bSelftestExists;     \textcolor{comment}{/* True if SELFTEST already exists */}
17357     \textcolor{keywordtype}{int} i, k;                \textcolor{comment}{/* Loop counters */}
17358     \textcolor{keywordtype}{int} nTest = 0;           \textcolor{comment}{/* Number of tests runs */}
17359     \textcolor{keywordtype}{int} nErr = 0;            \textcolor{comment}{/* Number of errors seen */}
17360     ShellText str;           \textcolor{comment}{/* Answer for a query */}
17361     sqlite3_stmt *pStmt = 0; \textcolor{comment}{/* Query against the SELFTEST table */}
17362 
17363     open_db(p,0);
17364     \textcolor{keywordflow}{for}(i=1; i<nArg; i++)\{
17365       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z = azArg[i];
17366       \textcolor{keywordflow}{if}( z[0]==\textcolor{charliteral}{'-'} && z[1]==\textcolor{charliteral}{'-'} ) z++;
17367       \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-init"})==0 )\{
17368         bIsInit = 1;
17369       \}\textcolor{keywordflow}{else}
17370       \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-v"})==0 )\{
17371         bVerbose++;
17372       \}\textcolor{keywordflow}{else}
17373       \{
17374         utf8_printf(stderr, \textcolor{stringliteral}{"Unknown option \(\backslash\)"%s\(\backslash\)" on \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"},
17375                     azArg[i], azArg[0]);
17376         raw_printf(stderr, \textcolor{stringliteral}{"Should be one of: --init -v\(\backslash\)n"});
17377         rc = 1;
17378         \textcolor{keywordflow}{goto} meta\_command\_exit;
17379       \}
17380     \}
17381     \textcolor{keywordflow}{if}( sqlite3_table_column_metadata(p->db,\textcolor{stringliteral}{"main"},\textcolor{stringliteral}{"selftest"},0,0,0,0,0,0)
17382            != SQLITE_OK )\{
17383       bSelftestExists = 0;
17384     \}\textcolor{keywordflow}{else}\{
17385       bSelftestExists = 1;
17386     \}
17387     \textcolor{keywordflow}{if}( bIsInit )\{
17388       createSelftestTable(p);
17389       bSelftestExists = 1;
17390     \}
17391     initText(&str);
17392     appendText(&str, \textcolor{stringliteral}{"x"}, 0);
17393     \textcolor{keywordflow}{for}(k=bSelftestExists; k>=0; k--)\{
17394       \textcolor{keywordflow}{if}( k==1 )\{
17395         rc = sqlite3_prepare_v2(p->db,
17396             \textcolor{stringliteral}{"SELECT tno,op,cmd,ans FROM selftest ORDER BY tno"},
17397             -1, &pStmt, 0);
17398       \}\textcolor{keywordflow}{else}\{
17399         rc = sqlite3_prepare_v2(p->db,
17400           \textcolor{stringliteral}{"VALUES(0,'memo','Missing SELFTEST table - default checks only',''),"}
17401           \textcolor{stringliteral}{"      (1,'run','PRAGMA integrity\_check','ok')"},
17402           -1, &pStmt, 0);
17403       \}
17404       \textcolor{keywordflow}{if}( rc )\{
17405         raw_printf(stderr, \textcolor{stringliteral}{"Error querying the selftest table\(\backslash\)n"});
17406         rc = 1;
17407         sqlite3_finalize(pStmt);
17408         \textcolor{keywordflow}{goto} meta\_command\_exit;
17409       \}
17410       \textcolor{keywordflow}{for}(i=1; sqlite3_step(pStmt)==SQLITE_ROW; i++)\{
17411         \textcolor{keywordtype}{int} tno = sqlite3_column_int(pStmt, 0);
17412         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zOp = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pStmt, 1);
17413         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pStmt, 2);
17414         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zAns = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pStmt, 3);
17415 
17416         k = 0;
17417         \textcolor{keywordflow}{if}( bVerbose>0 )\{
17418           \textcolor{keywordtype}{char} *zQuote = sqlite3_mprintf(\textcolor{stringliteral}{"%q"}, zSql);
17419           printf(\textcolor{stringliteral}{"%d: %s %s\(\backslash\)n"}, tno, zOp, zSql);
17420           sqlite3_free(zQuote);
17421         \}
17422         \textcolor{keywordflow}{if}( strcmp(zOp,\textcolor{stringliteral}{"memo"})==0 )\{
17423           utf8_printf(p->out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, zSql);
17424         \}\textcolor{keywordflow}{else}
17425         \textcolor{keywordflow}{if}( strcmp(zOp,\textcolor{stringliteral}{"run"})==0 )\{
17426           \textcolor{keywordtype}{char} *zErrMsg = 0;
17427           str.n = 0;
17428           str.z[0] = 0;
17429           rc = sqlite3_exec(p->db, zSql, captureOutputCallback, &str, &zErrMsg);
17430           nTest++;
17431           \textcolor{keywordflow}{if}( bVerbose )\{
17432             utf8_printf(p->out, \textcolor{stringliteral}{"Result: %s\(\backslash\)n"}, str.z);
17433           \}
17434           \textcolor{keywordflow}{if}( rc || zErrMsg )\{
17435             nErr++;
17436             rc = 1;
17437             utf8_printf(p->out, \textcolor{stringliteral}{"%d: error-code-%d: %s\(\backslash\)n"}, tno, rc, zErrMsg);
17438             sqlite3_free(zErrMsg);
17439           \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(zAns,str.z)!=0 )\{
17440             nErr++;
17441             rc = 1;
17442             utf8_printf(p->out, \textcolor{stringliteral}{"%d: Expected: [%s]\(\backslash\)n"}, tno, zAns);
17443             utf8_printf(p->out, \textcolor{stringliteral}{"%d:      Got: [%s]\(\backslash\)n"}, tno, str.z);
17444           \}
17445         \}\textcolor{keywordflow}{else}
17446         \{
17447           utf8_printf(stderr,
17448             \textcolor{stringliteral}{"Unknown operation \(\backslash\)"%s\(\backslash\)" on selftest line %d\(\backslash\)n"}, zOp, tno);
17449           rc = 1;
17450           \textcolor{keywordflow}{break};
17451         \}
17452       \} \textcolor{comment}{/* End loop over rows of content from SELFTEST */}
17453       sqlite3_finalize(pStmt);
17454     \} \textcolor{comment}{/* End loop over k */}
17455     freeText(&str);
17456     utf8_printf(p->out, \textcolor{stringliteral}{"%d errors out of %d tests\(\backslash\)n"}, nErr, nTest);
17457   \}\textcolor{keywordflow}{else}
17458 
17459   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'s'} && strncmp(azArg[0], \textcolor{stringliteral}{"separator"}, n)==0 )\{
17460     \textcolor{keywordflow}{if}( nArg<2 || nArg>3 )\{
17461       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .separator COL ?ROW?\(\backslash\)n"});
17462       rc = 1;
17463     \}
17464     \textcolor{keywordflow}{if}( nArg>=2 )\{
17465       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->colSeparator), p->colSeparator,
17466                        \textcolor{stringliteral}{"%.*s"}, (\textcolor{keywordtype}{int})ArraySize(p->colSeparator)-1, azArg[1]);
17467     \}
17468     \textcolor{keywordflow}{if}( nArg>=3 )\{
17469       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->rowSeparator), p->rowSeparator,
17470                        \textcolor{stringliteral}{"%.*s"}, (\textcolor{keywordtype}{int})ArraySize(p->rowSeparator)-1, azArg[2]);
17471     \}
17472   \}\textcolor{keywordflow}{else}
17473 
17474   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'s'} && n>=4 && strncmp(azArg[0],\textcolor{stringliteral}{"sha3sum"},n)==0 )\{
17475     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zLike = 0;   \textcolor{comment}{/* Which table to checksum. 0 means everything */}
17476     \textcolor{keywordtype}{int} i;                   \textcolor{comment}{/* Loop counter */}
17477     \textcolor{keywordtype}{int} bSchema = 0;         \textcolor{comment}{/* Also hash the schema */}
17478     \textcolor{keywordtype}{int} bSeparate = 0;       \textcolor{comment}{/* Hash each table separately */}
17479     \textcolor{keywordtype}{int} iSize = 224;         \textcolor{comment}{/* Hash algorithm to use */}
17480     \textcolor{keywordtype}{int} bDebug = 0;          \textcolor{comment}{/* Only show the query that would have run */}
17481     sqlite3_stmt *pStmt;     \textcolor{comment}{/* For querying tables names */}
17482     \textcolor{keywordtype}{char} *zSql;              \textcolor{comment}{/* SQL to be run */}
17483     \textcolor{keywordtype}{char} *zSep;              \textcolor{comment}{/* Separator */}
17484     ShellText sSql;          \textcolor{comment}{/* Complete SQL for the query to run the hash */}
17485     ShellText sQuery;        \textcolor{comment}{/* Set of queries used to read all content */}
17486     open_db(p, 0);
17487     \textcolor{keywordflow}{for}(i=1; i<nArg; i++)\{
17488       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z = azArg[i];
17489       \textcolor{keywordflow}{if}( z[0]==\textcolor{charliteral}{'-'} )\{
17490         z++;
17491         \textcolor{keywordflow}{if}( z[0]==\textcolor{charliteral}{'-'} ) z++;
17492         \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"schema"})==0 )\{
17493           bSchema = 1;
17494         \}\textcolor{keywordflow}{else}
17495         \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"sha3-224"})==0 || strcmp(z,\textcolor{stringliteral}{"sha3-256"})==0
17496          || strcmp(z,\textcolor{stringliteral}{"sha3-384"})==0 || strcmp(z,\textcolor{stringliteral}{"sha3-512"})==0
17497         )\{
17498           iSize = atoi(&z[5]);
17499         \}\textcolor{keywordflow}{else}
17500         \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"debug"})==0 )\{
17501           bDebug = 1;
17502         \}\textcolor{keywordflow}{else}
17503         \{
17504           utf8_printf(stderr, \textcolor{stringliteral}{"Unknown option \(\backslash\)"%s\(\backslash\)" on \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"},
17505                       azArg[i], azArg[0]);
17506           showHelp(p->out, azArg[0]);
17507           rc = 1;
17508           \textcolor{keywordflow}{goto} meta\_command\_exit;
17509         \}
17510       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( zLike )\{
17511         raw_printf(stderr, \textcolor{stringliteral}{"Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\(\backslash\)n"});
17512         rc = 1;
17513         \textcolor{keywordflow}{goto} meta\_command\_exit;
17514       \}\textcolor{keywordflow}{else}\{
17515         zLike = z;
17516         bSeparate = 1;
17517         \textcolor{keywordflow}{if}( sqlite3_strlike(\textcolor{stringliteral}{"sqlite\(\backslash\)\(\backslash\)\_%"}, zLike, \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'})==0 ) bSchema = 1;
17518       \}
17519     \}
17520     \textcolor{keywordflow}{if}( bSchema )\{
17521       zSql = \textcolor{stringliteral}{"SELECT lower(name) FROM sqlite\_master"}
17522              \textcolor{stringliteral}{" WHERE type='table' AND coalesce(rootpage,0)>1"}
17523              \textcolor{stringliteral}{" UNION ALL SELECT 'sqlite\_master'"}
17524              \textcolor{stringliteral}{" ORDER BY 1 collate nocase"};
17525     \}\textcolor{keywordflow}{else}\{
17526       zSql = \textcolor{stringliteral}{"SELECT lower(name) FROM sqlite\_master"}
17527              \textcolor{stringliteral}{" WHERE type='table' AND coalesce(rootpage,0)>1"}
17528              \textcolor{stringliteral}{" AND name NOT LIKE 'sqlite\_%'"}
17529              \textcolor{stringliteral}{" ORDER BY 1 collate nocase"};
17530     \}
17531     sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
17532     initText(&sQuery);
17533     initText(&sSql);
17534     appendText(&sSql, \textcolor{stringliteral}{"WITH [sha3sum$query](a,b) AS("},0);
17535     zSep = \textcolor{stringliteral}{"VALUES("};
17536     \textcolor{keywordflow}{while}( SQLITE_ROW==sqlite3_step(pStmt) )\{
17537       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zTab = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pStmt,0);
17538       \textcolor{keywordflow}{if}( zLike && sqlite3_strlike(zLike, zTab, 0)!=0 ) \textcolor{keywordflow}{continue};
17539       \textcolor{keywordflow}{if}( strncmp(zTab, \textcolor{stringliteral}{"sqlite\_"},7)!=0 )\{
17540         appendText(&sQuery,\textcolor{stringliteral}{"SELECT * FROM "}, 0);
17541         appendText(&sQuery,zTab,\textcolor{charliteral}{'"'});
17542         appendText(&sQuery,\textcolor{stringliteral}{" NOT INDEXED;"}, 0);
17543       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(zTab, \textcolor{stringliteral}{"sqlite\_master"})==0 )\{
17544         appendText(&sQuery,\textcolor{stringliteral}{"SELECT type,name,tbl\_name,sql FROM sqlite\_master"}
17545                            \textcolor{stringliteral}{" ORDER BY name;"}, 0);
17546       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(zTab, \textcolor{stringliteral}{"sqlite\_sequence"})==0 )\{
17547         appendText(&sQuery,\textcolor{stringliteral}{"SELECT name,seq FROM sqlite\_sequence"}
17548                            \textcolor{stringliteral}{" ORDER BY name;"}, 0);
17549       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(zTab, \textcolor{stringliteral}{"sqlite\_stat1"})==0 )\{
17550         appendText(&sQuery,\textcolor{stringliteral}{"SELECT tbl,idx,stat FROM sqlite\_stat1"}
17551                            \textcolor{stringliteral}{" ORDER BY tbl,idx;"}, 0);
17552       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(zTab, \textcolor{stringliteral}{"sqlite\_stat4"})==0 )\{
17553         appendText(&sQuery, \textcolor{stringliteral}{"SELECT * FROM "}, 0);
17554         appendText(&sQuery, zTab, 0);
17555         appendText(&sQuery, \textcolor{stringliteral}{" ORDER BY tbl, idx, rowid;\(\backslash\)n"}, 0);
17556       \}
17557       appendText(&sSql, zSep, 0);
17558       appendText(&sSql, sQuery.z, \textcolor{charliteral}{'\(\backslash\)''});
17559       sQuery.n = 0;
17560       appendText(&sSql, \textcolor{stringliteral}{","}, 0);
17561       appendText(&sSql, zTab, \textcolor{charliteral}{'\(\backslash\)''});
17562       zSep = \textcolor{stringliteral}{"),("};
17563     \}
17564     sqlite3_finalize(pStmt);
17565     \textcolor{keywordflow}{if}( bSeparate )\{
17566       zSql = sqlite3_mprintf(
17567           \textcolor{stringliteral}{"%s))"}
17568           \textcolor{stringliteral}{" SELECT lower(hex(sha3\_query(a,%d))) AS hash, b AS label"}
17569           \textcolor{stringliteral}{"   FROM [sha3sum$query]"},
17570           sSql.z, iSize);
17571     \}\textcolor{keywordflow}{else}\{
17572       zSql = sqlite3_mprintf(
17573           \textcolor{stringliteral}{"%s))"}
17574           \textcolor{stringliteral}{" SELECT lower(hex(sha3\_query(group\_concat(a,''),%d))) AS hash"}
17575           \textcolor{stringliteral}{"   FROM [sha3sum$query]"},
17576           sSql.z, iSize);
17577     \}
17578     freeText(&sQuery);
17579     freeText(&sSql);
17580     \textcolor{keywordflow}{if}( bDebug )\{
17581       utf8_printf(p->out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, zSql);
17582     \}\textcolor{keywordflow}{else}\{
17583       shell_exec(p, zSql, 0);
17584     \}
17585     sqlite3_free(zSql);
17586   \}\textcolor{keywordflow}{else}
17587 
17588 \textcolor{preprocessor}{#ifndef SQLITE\_NOHAVE\_SYSTEM}
17589   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'s'}
17590    && (strncmp(azArg[0], \textcolor{stringliteral}{"shell"}, n)==0 || strncmp(azArg[0],\textcolor{stringliteral}{"system"},n)==0)
17591   )\{
17592     \textcolor{keywordtype}{char} *zCmd;
17593     \textcolor{keywordtype}{int} i, x;
17594     \textcolor{keywordflow}{if}( nArg<2 )\{
17595       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .system COMMAND\(\backslash\)n"});
17596       rc = 1;
17597       \textcolor{keywordflow}{goto} meta\_command\_exit;
17598     \}
17599     zCmd = sqlite3_mprintf(strchr(azArg[1],\textcolor{charliteral}{' '})==0?\textcolor{stringliteral}{"%s"}:\textcolor{stringliteral}{"\(\backslash\)"%s\(\backslash\)""}, azArg[1]);
17600     \textcolor{keywordflow}{for}(i=2; i<nArg; i++)\{
17601       zCmd = sqlite3_mprintf(strchr(azArg[i],\textcolor{charliteral}{' '})==0?\textcolor{stringliteral}{"%z %s"}:\textcolor{stringliteral}{"%z \(\backslash\)"%s\(\backslash\)""},
17602                              zCmd, azArg[i]);
17603     \}
17604     x = system(zCmd);
17605     sqlite3_free(zCmd);
17606     \textcolor{keywordflow}{if}( x ) raw_printf(stderr, \textcolor{stringliteral}{"System command returns %d\(\backslash\)n"}, x);
17607   \}\textcolor{keywordflow}{else}
17608 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !defined(SQLITE\_NOHAVE\_SYSTEM) */}\textcolor{preprocessor}{}
17609 
17610   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'s'} && strncmp(azArg[0], \textcolor{stringliteral}{"show"}, n)==0 )\{
17611     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *azBool[] = \{ \textcolor{stringliteral}{"off"}, \textcolor{stringliteral}{"on"}, \textcolor{stringliteral}{"trigger"}, \textcolor{stringliteral}{"full"}\};
17612     \textcolor{keywordtype}{int} i;
17613     \textcolor{keywordflow}{if}( nArg!=1 )\{
17614       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .show\(\backslash\)n"});
17615       rc = 1;
17616       \textcolor{keywordflow}{goto} meta\_command\_exit;
17617     \}
17618     utf8_printf(p->out, \textcolor{stringliteral}{"%12.12s: %s\(\backslash\)n"},\textcolor{stringliteral}{"echo"},
17619                                   azBool[ShellHasFlag(p, SHFLG_Echo)]);
17620     utf8_printf(p->out, \textcolor{stringliteral}{"%12.12s: %s\(\backslash\)n"},\textcolor{stringliteral}{"eqp"}, azBool[p->autoEQP&3]);
17621     utf8_printf(p->out, \textcolor{stringliteral}{"%12.12s: %s\(\backslash\)n"},\textcolor{stringliteral}{"explain"},
17622          p->mode==MODE_Explain ? \textcolor{stringliteral}{"on"} : p->autoExplain ? \textcolor{stringliteral}{"auto"} : \textcolor{stringliteral}{"off"});
17623     utf8_printf(p->out,\textcolor{stringliteral}{"%12.12s: %s\(\backslash\)n"},\textcolor{stringliteral}{"headers"}, azBool[p->showHeader!=0]);
17624     utf8_printf(p->out, \textcolor{stringliteral}{"%12.12s: %s\(\backslash\)n"},\textcolor{stringliteral}{"mode"}, modeDescr[p->mode]);
17625     utf8_printf(p->out, \textcolor{stringliteral}{"%12.12s: "}, \textcolor{stringliteral}{"nullvalue"});
17626       output_c_string(p->out, p->nullValue);
17627       raw_printf(p->out, \textcolor{stringliteral}{"\(\backslash\)n"});
17628     utf8_printf(p->out,\textcolor{stringliteral}{"%12.12s: %s\(\backslash\)n"},\textcolor{stringliteral}{"output"},
17629             strlen30(p->outfile) ? p->outfile : \textcolor{stringliteral}{"stdout"});
17630     utf8_printf(p->out,\textcolor{stringliteral}{"%12.12s: "}, \textcolor{stringliteral}{"colseparator"});
17631       output_c_string(p->out, p->colSeparator);
17632       raw_printf(p->out, \textcolor{stringliteral}{"\(\backslash\)n"});
17633     utf8_printf(p->out,\textcolor{stringliteral}{"%12.12s: "}, \textcolor{stringliteral}{"rowseparator"});
17634       output_c_string(p->out, p->rowSeparator);
17635       raw_printf(p->out, \textcolor{stringliteral}{"\(\backslash\)n"});
17636     utf8_printf(p->out, \textcolor{stringliteral}{"%12.12s: %s\(\backslash\)n"},\textcolor{stringliteral}{"stats"}, azBool[p->statsOn!=0]);
17637     utf8_printf(p->out, \textcolor{stringliteral}{"%12.12s: "}, \textcolor{stringliteral}{"width"});
17638     \textcolor{keywordflow}{for} (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) \{
17639       raw_printf(p->out, \textcolor{stringliteral}{"%d "}, p->colWidth[i]);
17640     \}
17641     raw_printf(p->out, \textcolor{stringliteral}{"\(\backslash\)n"});
17642     utf8_printf(p->out, \textcolor{stringliteral}{"%12.12s: %s\(\backslash\)n"}, \textcolor{stringliteral}{"filename"},
17643                 p->zDbFilename ? p->zDbFilename : \textcolor{stringliteral}{""});
17644   \}\textcolor{keywordflow}{else}
17645 
17646   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'s'} && strncmp(azArg[0], \textcolor{stringliteral}{"stats"}, n)==0 )\{
17647     \textcolor{keywordflow}{if}( nArg==2 )\{
17648       p->statsOn = (u8)booleanValue(azArg[1]);
17649     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( nArg==1 )\{
17650       display_stats(p->db, p, 0);
17651     \}\textcolor{keywordflow}{else}\{
17652       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .stats ?on|off?\(\backslash\)n"});
17653       rc = 1;
17654     \}
17655   \}\textcolor{keywordflow}{else}
17656 
17657   \textcolor{keywordflow}{if}( (c==\textcolor{charliteral}{'t'} && n>1 && strncmp(azArg[0], \textcolor{stringliteral}{"tables"}, n)==0)
17658    || (c==\textcolor{charliteral}{'i'} && (strncmp(azArg[0], \textcolor{stringliteral}{"indices"}, n)==0
17659                  || strncmp(azArg[0], \textcolor{stringliteral}{"indexes"}, n)==0) )
17660   )\{
17661     sqlite3_stmt *pStmt;
17662     \textcolor{keywordtype}{char} **azResult;
17663     \textcolor{keywordtype}{int} nRow, nAlloc;
17664     \textcolor{keywordtype}{int} ii;
17665     ShellText s;
17666     initText(&s);
17667     open_db(p, 0);
17668     rc = sqlite3_prepare_v2(p->db, \textcolor{stringliteral}{"PRAGMA database\_list"}, -1, &pStmt, 0);
17669     \textcolor{keywordflow}{if}( rc )\{
17670       sqlite3_finalize(pStmt);
17671       \textcolor{keywordflow}{return} shellDatabaseError(p->db);
17672     \}
17673 
17674     \textcolor{keywordflow}{if}( nArg>2 && c==\textcolor{charliteral}{'i'} )\{
17675       \textcolor{comment}{/* It is an historical accident that the .indexes command shows an error}
17676 \textcolor{comment}{      ** when called with the wrong number of arguments whereas the .tables}
17677 \textcolor{comment}{      ** command does not. */}
17678       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .indexes ?LIKE-PATTERN?\(\backslash\)n"});
17679       rc = 1;
17680       sqlite3_finalize(pStmt);
17681       \textcolor{keywordflow}{goto} meta\_command\_exit;
17682     \}
17683     \textcolor{keywordflow}{for}(ii=0; sqlite3_step(pStmt)==SQLITE_ROW; ii++)\{
17684       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDbName = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pStmt, 1);
17685       \textcolor{keywordflow}{if}( zDbName==0 ) \textcolor{keywordflow}{continue};
17686       \textcolor{keywordflow}{if}( s.z && s.z[0] ) appendText(&s, \textcolor{stringliteral}{" UNION ALL "}, 0);
17687       \textcolor{keywordflow}{if}( sqlite3_stricmp(zDbName, \textcolor{stringliteral}{"main"})==0 )\{
17688         appendText(&s, \textcolor{stringliteral}{"SELECT name FROM "}, 0);
17689       \}\textcolor{keywordflow}{else}\{
17690         appendText(&s, \textcolor{stringliteral}{"SELECT "}, 0);
17691         appendText(&s, zDbName, \textcolor{charliteral}{'\(\backslash\)''});
17692         appendText(&s, \textcolor{stringliteral}{"||'.'||name FROM "}, 0);
17693       \}
17694       appendText(&s, zDbName, \textcolor{charliteral}{'"'});
17695       appendText(&s, \textcolor{stringliteral}{".sqlite\_master "}, 0);
17696       \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'t'} )\{
17697         appendText(&s,\textcolor{stringliteral}{" WHERE type IN ('table','view')"}
17698                       \textcolor{stringliteral}{"   AND name NOT LIKE 'sqlite\_%'"}
17699                       \textcolor{stringliteral}{"   AND name LIKE ?1"}, 0);
17700       \}\textcolor{keywordflow}{else}\{
17701         appendText(&s,\textcolor{stringliteral}{" WHERE type='index'"}
17702                       \textcolor{stringliteral}{"   AND tbl\_name LIKE ?1"}, 0);
17703       \}
17704     \}
17705     rc = sqlite3_finalize(pStmt);
17706     appendText(&s, \textcolor{stringliteral}{" ORDER BY 1"}, 0);
17707     rc = sqlite3_prepare_v2(p->db, s.z, -1, &pStmt, 0);
17708     freeText(&s);
17709     \textcolor{keywordflow}{if}( rc ) \textcolor{keywordflow}{return} shellDatabaseError(p->db);
17710 
17711     \textcolor{comment}{/* Run the SQL statement prepared by the above block. Store the results}
17712 \textcolor{comment}{    ** as an array of nul-terminated strings in azResult[].  */}
17713     nRow = nAlloc = 0;
17714     azResult = 0;
17715     \textcolor{keywordflow}{if}( nArg>1 )\{
17716       sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);
17717     \}\textcolor{keywordflow}{else}\{
17718       sqlite3_bind_text(pStmt, 1, \textcolor{stringliteral}{"%"}, -1, SQLITE_STATIC);
17719     \}
17720     \textcolor{keywordflow}{while}( sqlite3_step(pStmt)==SQLITE_ROW )\{
17721       \textcolor{keywordflow}{if}( nRow>=nAlloc )\{
17722         \textcolor{keywordtype}{char} **azNew;
17723         \textcolor{keywordtype}{int} n2 = nAlloc*2 + 10;
17724         azNew = sqlite3_realloc64(azResult, \textcolor{keyword}{sizeof}(azResult[0])*n2);
17725         \textcolor{keywordflow}{if}( azNew==0 ) shell_out_of_memory();
17726         nAlloc = n2;
17727         azResult = azNew;
17728       \}
17729       azResult[nRow] = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, sqlite3_column_text(pStmt, 0));
17730       \textcolor{keywordflow}{if}( 0==azResult[nRow] ) shell_out_of_memory();
17731       nRow++;
17732     \}
17733     \textcolor{keywordflow}{if}( sqlite3_finalize(pStmt)!=SQLITE_OK )\{
17734       rc = shellDatabaseError(p->db);
17735     \}
17736 
17737     \textcolor{comment}{/* Pretty-print the contents of array azResult[] to the output */}
17738     \textcolor{keywordflow}{if}( rc==0 && nRow>0 )\{
17739       \textcolor{keywordtype}{int} len, maxlen = 0;
17740       \textcolor{keywordtype}{int} i, j;
17741       \textcolor{keywordtype}{int} nPrintCol, nPrintRow;
17742       \textcolor{keywordflow}{for}(i=0; i<nRow; i++)\{
17743         len = strlen30(azResult[i]);
17744         \textcolor{keywordflow}{if}( len>maxlen ) maxlen = len;
17745       \}
17746       nPrintCol = 80/(maxlen+2);
17747       \textcolor{keywordflow}{if}( nPrintCol<1 ) nPrintCol = 1;
17748       nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;
17749       \textcolor{keywordflow}{for}(i=0; i<nPrintRow; i++)\{
17750         \textcolor{keywordflow}{for}(j=i; j<nRow; j+=nPrintRow)\{
17751           \textcolor{keywordtype}{char} *zSp = j<nPrintRow ? \textcolor{stringliteral}{""} : \textcolor{stringliteral}{"  "};
17752           utf8_printf(p->out, \textcolor{stringliteral}{"%s%-*s"}, zSp, maxlen,
17753                       azResult[j] ? azResult[j]:\textcolor{stringliteral}{""});
17754         \}
17755         raw_printf(p->out, \textcolor{stringliteral}{"\(\backslash\)n"});
17756       \}
17757     \}
17758 
17759     \textcolor{keywordflow}{for}(ii=0; ii<nRow; ii++) sqlite3_free(azResult[ii]);
17760     sqlite3_free(azResult);
17761   \}\textcolor{keywordflow}{else}
17762 
17763   \textcolor{comment}{/* Begin redirecting output to the file "testcase-out.txt" */}
17764   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'t'} && strcmp(azArg[0],\textcolor{stringliteral}{"testcase"})==0 )\{
17765     output_reset(p);
17766     p->out = output_file_open(\textcolor{stringliteral}{"testcase-out.txt"}, 0);
17767     \textcolor{keywordflow}{if}( p->out==0 )\{
17768       raw_printf(stderr, \textcolor{stringliteral}{"Error: cannot open 'testcase-out.txt'\(\backslash\)n"});
17769     \}
17770     \textcolor{keywordflow}{if}( nArg>=2 )\{
17771       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->zTestcase), p->zTestcase, \textcolor{stringliteral}{"%s"}, azArg[1]);
17772     \}\textcolor{keywordflow}{else}\{
17773       sqlite3_snprintf(\textcolor{keyword}{sizeof}(p->zTestcase), p->zTestcase, \textcolor{stringliteral}{"?"});
17774     \}
17775   \}\textcolor{keywordflow}{else}
17776 
17777 \textcolor{preprocessor}{#ifndef SQLITE\_UNTESTABLE}
17778   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'t'} && n>=8 && strncmp(azArg[0], \textcolor{stringliteral}{"testctrl"}, n)==0 )\{
17779     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }\{
17780        \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCtrlName;   \textcolor{comment}{/* Name of a test-control option */}
17781        \textcolor{keywordtype}{int} ctrlCode;            \textcolor{comment}{/* Integer code for that option */}
17782        \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zUsage;      \textcolor{comment}{/* Usage notes */}
17783     \} aCtrl[] = \{
17784       \{ \textcolor{stringliteral}{"always"},             SQLITE_TESTCTRL_ALWAYS,        \textcolor{stringliteral}{"BOOLEAN"}        \},
17785       \{ \textcolor{stringliteral}{"assert"},             SQLITE_TESTCTRL_ASSERT,        \textcolor{stringliteral}{"BOOLEAN"}        \},
17786     \textcolor{comment}{/*\{ "benign\_malloc\_hooks",SQLITE\_TESTCTRL\_BENIGN\_MALLOC\_HOOKS, ""       \},*/}
17787     \textcolor{comment}{/*\{ "bitvec\_test",        SQLITE\_TESTCTRL\_BITVEC\_TEST,   ""             \},*/}
17788       \{ \textcolor{stringliteral}{"byteorder"},          SQLITE_TESTCTRL_BYTEORDER,     \textcolor{stringliteral}{""}               \},
17789       \{ \textcolor{stringliteral}{"extra\_schema\_checks"},SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS,\textcolor{stringliteral}{"BOOLEAN"}   \},
17790     \textcolor{comment}{/*\{ "fault\_install",      SQLITE\_TESTCTRL\_FAULT\_INSTALL, ""             \},*/}
17791       \{ \textcolor{stringliteral}{"imposter"},         SQLITE_TESTCTRL_IMPOSTER, \textcolor{stringliteral}{"SCHEMA ON/OFF ROOTPAGE"}\},
17792       \{ \textcolor{stringliteral}{"internal\_functions"}, SQLITE_TESTCTRL_INTERNAL_FUNCTIONS, \textcolor{stringliteral}{""} \},
17793       \{ \textcolor{stringliteral}{"localtime\_fault"},    SQLITE_TESTCTRL_LOCALTIME_FAULT,\textcolor{stringliteral}{"BOOLEAN"}       \},
17794       \{ \textcolor{stringliteral}{"never\_corrupt"},      SQLITE_TESTCTRL_NEVER_CORRUPT, \textcolor{stringliteral}{"BOOLEAN"}        \},
17795       \{ \textcolor{stringliteral}{"optimizations"},      SQLITE_TESTCTRL_OPTIMIZATIONS, \textcolor{stringliteral}{"DISABLE-MASK"}   \},
17796 \textcolor{preprocessor}{#ifdef YYCOVERAGE}
17797       \{ \textcolor{stringliteral}{"parser\_coverage"},    SQLITE_TESTCTRL_PARSER_COVERAGE, \textcolor{stringliteral}{""}             \},
17798 \textcolor{preprocessor}{#endif}
17799       \{ \textcolor{stringliteral}{"pending\_byte"},       SQLITE_TESTCTRL_PENDING_BYTE,  \textcolor{stringliteral}{"OFFSET  "}       \},
17800       \{ \textcolor{stringliteral}{"prng\_restore"},       SQLITE_TESTCTRL_PRNG_RESTORE,  \textcolor{stringliteral}{""}               \},
17801       \{ \textcolor{stringliteral}{"prng\_save"},          SQLITE_TESTCTRL_PRNG_SAVE,     \textcolor{stringliteral}{""}               \},
17802       \{ \textcolor{stringliteral}{"prng\_seed"},          SQLITE_TESTCTRL_PRNG_SEED,     \textcolor{stringliteral}{"SEED ?db?"}      \},
17803       \{ \textcolor{stringliteral}{"reserve"},            SQLITE_TESTCTRL_RESERVE,      \textcolor{stringliteral}{"BYTES-OF-RESERVE"}\},
17804     \};
17805     \textcolor{keywordtype}{int} testctrl = -1;
17806     \textcolor{keywordtype}{int} iCtrl = -1;
17807     \textcolor{keywordtype}{int} rc2 = 0;    \textcolor{comment}{/* 0: usage.  1: %d  2: %x  3: no-output */}
17808     \textcolor{keywordtype}{int} isOk = 0;
17809     \textcolor{keywordtype}{int} i, n2;
17810     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCmd = 0;
17811 
17812     open_db(p, 0);
17813     zCmd = nArg>=2 ? azArg[1] : \textcolor{stringliteral}{"help"};
17814 
17815     \textcolor{comment}{/* The argument can optionally begin with "-" or "--" */}
17816     \textcolor{keywordflow}{if}( zCmd[0]==\textcolor{charliteral}{'-'} && zCmd[1] )\{
17817       zCmd++;
17818       \textcolor{keywordflow}{if}( zCmd[0]==\textcolor{charliteral}{'-'} && zCmd[1] ) zCmd++;
17819     \}
17820 
17821     \textcolor{comment}{/* --help lists all test-controls */}
17822     \textcolor{keywordflow}{if}( strcmp(zCmd,\textcolor{stringliteral}{"help"})==0 )\{
17823       utf8_printf(p->out, \textcolor{stringliteral}{"Available test-controls:\(\backslash\)n"});
17824       \textcolor{keywordflow}{for}(i=0; i<ArraySize(aCtrl); i++)\{
17825         utf8_printf(p->out, \textcolor{stringliteral}{"  .testctrl %s %s\(\backslash\)n"},
17826                     aCtrl[i].zCtrlName, aCtrl[i].zUsage);
17827       \}
17828       rc = 1;
17829       \textcolor{keywordflow}{goto} meta\_command\_exit;
17830     \}
17831 
17832     \textcolor{comment}{/* convert testctrl text option to value. allow any unique prefix}
17833 \textcolor{comment}{    ** of the option name, or a numerical value. */}
17834     n2 = strlen30(zCmd);
17835     \textcolor{keywordflow}{for}(i=0; i<ArraySize(aCtrl); i++)\{
17836       \textcolor{keywordflow}{if}( strncmp(zCmd, aCtrl[i].zCtrlName, n2)==0 )\{
17837         \textcolor{keywordflow}{if}( testctrl<0 )\{
17838           testctrl = aCtrl[i].ctrlCode;
17839           iCtrl = i;
17840         \}\textcolor{keywordflow}{else}\{
17841           utf8_printf(stderr, \textcolor{stringliteral}{"Error: ambiguous test-control: \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}
17842                               \textcolor{stringliteral}{"Use \(\backslash\)".testctrl --help\(\backslash\)" for help\(\backslash\)n"}, zCmd);
17843           rc = 1;
17844           \textcolor{keywordflow}{goto} meta\_command\_exit;
17845         \}
17846       \}
17847     \}
17848     \textcolor{keywordflow}{if}( testctrl<0 )\{
17849       utf8_printf(stderr,\textcolor{stringliteral}{"Error: unknown test-control: %s\(\backslash\)n"}
17850                          \textcolor{stringliteral}{"Use \(\backslash\)".testctrl --help\(\backslash\)" for help\(\backslash\)n"}, zCmd);
17851     \}\textcolor{keywordflow}{else}\{
17852       \textcolor{keywordflow}{switch}(testctrl)\{
17853 
17854         \textcolor{comment}{/* sqlite3\_test\_control(int, db, int) */}
17855         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_OPTIMIZATIONS:
17856         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_RESERVE:
17857           \textcolor{keywordflow}{if}( nArg==3 )\{
17858             \textcolor{keywordtype}{int} opt = (int)strtol(azArg[2], 0, 0);
17859             rc2 = sqlite3_test_control(testctrl, p->db, opt);
17860             isOk = 3;
17861           \}
17862           \textcolor{keywordflow}{break};
17863 
17864         \textcolor{comment}{/* sqlite3\_test\_control(int) */}
17865         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_PRNG_SAVE:
17866         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_PRNG_RESTORE:
17867         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_PRNG_RESET:
17868         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_BYTEORDER:
17869           \textcolor{keywordflow}{if}( nArg==2 )\{
17870             rc2 = sqlite3_test_control(testctrl);
17871             isOk = testctrl==SQLITE_TESTCTRL_BYTEORDER ? 1 : 3;
17872           \}
17873           \textcolor{keywordflow}{break};
17874 
17875         \textcolor{comment}{/* sqlite3\_test\_control(int, uint) */}
17876         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_PENDING_BYTE:
17877           \textcolor{keywordflow}{if}( nArg==3 )\{
17878             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} opt = (\textcolor{keywordtype}{unsigned} int)integerValue(azArg[2]);
17879             rc2 = sqlite3_test_control(testctrl, opt);
17880             isOk = 3;
17881           \}
17882           \textcolor{keywordflow}{break};
17883 
17884         \textcolor{comment}{/* sqlite3\_test\_control(int, int, sqlite3*) */}
17885         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_PRNG_SEED:
17886           \textcolor{keywordflow}{if}( nArg==3 || nArg==4 )\{
17887             \textcolor{keywordtype}{int} ii = (int)integerValue(azArg[2]);
17888             sqlite3 *db;
17889             \textcolor{keywordflow}{if}( ii==0 && strcmp(azArg[2],\textcolor{stringliteral}{"random"})==0 )\{
17890               sqlite3_randomness(\textcolor{keyword}{sizeof}(ii),&ii);
17891               printf(\textcolor{stringliteral}{"-- random seed: %d\(\backslash\)n"}, ii);
17892             \}
17893             \textcolor{keywordflow}{if}( nArg==3 )\{
17894               db = 0;
17895             \}\textcolor{keywordflow}{else}\{
17896               db = p->db;
17897               \textcolor{comment}{/* Make sure the schema has been loaded */}
17898               sqlite3_table_column_metadata(db, 0, \textcolor{stringliteral}{"x"}, 0, 0, 0, 0, 0, 0);
17899             \}
17900             rc2 = sqlite3_test_control(testctrl, ii, db);
17901             isOk = 3;
17902           \}
17903           \textcolor{keywordflow}{break};
17904 
17905         \textcolor{comment}{/* sqlite3\_test\_control(int, int) */}
17906         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_ASSERT:
17907         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_ALWAYS:
17908           \textcolor{keywordflow}{if}( nArg==3 )\{
17909             \textcolor{keywordtype}{int} opt = booleanValue(azArg[2]);
17910             rc2 = sqlite3_test_control(testctrl, opt);
17911             isOk = 1;
17912           \}
17913           \textcolor{keywordflow}{break};
17914 
17915         \textcolor{comment}{/* sqlite3\_test\_control(int, int) */}
17916         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_LOCALTIME_FAULT:
17917         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_NEVER_CORRUPT:
17918           \textcolor{keywordflow}{if}( nArg==3 )\{
17919             \textcolor{keywordtype}{int} opt = booleanValue(azArg[2]);
17920             rc2 = sqlite3_test_control(testctrl, opt);
17921             isOk = 3;
17922           \}
17923           \textcolor{keywordflow}{break};
17924 
17925         \textcolor{comment}{/* sqlite3\_test\_control(sqlite3*) */}
17926         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_INTERNAL_FUNCTIONS:
17927           rc2 = sqlite3_test_control(testctrl, p->db);
17928           isOk = 3;
17929           \textcolor{keywordflow}{break};
17930 
17931         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_IMPOSTER:
17932           \textcolor{keywordflow}{if}( nArg==5 )\{
17933             rc2 = sqlite3_test_control(testctrl, p->db,
17934                           azArg[2],
17935                           integerValue(azArg[3]),
17936                           integerValue(azArg[4]));
17937             isOk = 3;
17938           \}
17939           \textcolor{keywordflow}{break};
17940 
17941 \textcolor{preprocessor}{#ifdef YYCOVERAGE}
17942         \textcolor{keywordflow}{case} SQLITE_TESTCTRL_PARSER_COVERAGE:
17943           \textcolor{keywordflow}{if}( nArg==2 )\{
17944             sqlite3_test_control(testctrl, p->out);
17945             isOk = 3;
17946           \}
17947 \textcolor{preprocessor}{#endif}
17948       \}
17949     \}
17950     \textcolor{keywordflow}{if}( isOk==0 && iCtrl>=0 )\{
17951       utf8_printf(p->out, \textcolor{stringliteral}{"Usage: .testctrl %s %s\(\backslash\)n"}, zCmd,aCtrl[iCtrl].zUsage);
17952       rc = 1;
17953     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( isOk==1 )\{
17954       raw_printf(p->out, \textcolor{stringliteral}{"%d\(\backslash\)n"}, rc2);
17955     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( isOk==2 )\{
17956       raw_printf(p->out, \textcolor{stringliteral}{"0x%08x\(\backslash\)n"}, rc2);
17957     \}
17958   \}\textcolor{keywordflow}{else}
17959 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !defined(SQLITE\_UNTESTABLE) */}\textcolor{preprocessor}{}
17960 
17961   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'t'} && n>4 && strncmp(azArg[0], \textcolor{stringliteral}{"timeout"}, n)==0 )\{
17962     open_db(p, 0);
17963     sqlite3_busy_timeout(p->db, nArg>=2 ? (\textcolor{keywordtype}{int})integerValue(azArg[1]) : 0);
17964   \}\textcolor{keywordflow}{else}
17965 
17966   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'t'} && n>=5 && strncmp(azArg[0], \textcolor{stringliteral}{"timer"}, n)==0 )\{
17967     \textcolor{keywordflow}{if}( nArg==2 )\{
17968       enableTimer = booleanValue(azArg[1]);
17969       \textcolor{keywordflow}{if}( enableTimer && !HAS_TIMER )\{
17970         raw_printf(stderr, \textcolor{stringliteral}{"Error: timer not available on this system.\(\backslash\)n"});
17971         enableTimer = 0;
17972       \}
17973     \}\textcolor{keywordflow}{else}\{
17974       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .timer on|off\(\backslash\)n"});
17975       rc = 1;
17976     \}
17977   \}\textcolor{keywordflow}{else}
17978 
17979 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_TRACE}
17980   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'t'} && strncmp(azArg[0], \textcolor{stringliteral}{"trace"}, n)==0 )\{
17981     \textcolor{keywordtype}{int} mType = 0;
17982     \textcolor{keywordtype}{int} jj;
17983     open_db(p, 0);
17984     \textcolor{keywordflow}{for}(jj=1; jj<nArg; jj++)\{
17985       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z = azArg[jj];
17986       \textcolor{keywordflow}{if}( z[0]==\textcolor{charliteral}{'-'} )\{
17987         \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"expanded"}) )\{
17988           p->eTraceType = SHELL_TRACE_EXPANDED;
17989         \}
17990 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_NORMALIZE}
17991         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"normalized"}) )\{
17992           p->eTraceType = SHELL_TRACE_NORMALIZED;
17993         \}
17994 \textcolor{preprocessor}{#endif}
17995         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"plain"}) )\{
17996           p->eTraceType = SHELL_TRACE_PLAIN;
17997         \}
17998         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"profile"}) )\{
17999           mType |= SQLITE_TRACE_PROFILE;
18000         \}
18001         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"row"}) )\{
18002           mType |= SQLITE_TRACE_ROW;
18003         \}
18004         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"stmt"}) )\{
18005           mType |= SQLITE_TRACE_STMT;
18006         \}
18007         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( optionMatch(z, \textcolor{stringliteral}{"close"}) )\{
18008           mType |= SQLITE_TRACE_CLOSE;
18009         \}
18010         \textcolor{keywordflow}{else} \{
18011           raw_printf(stderr, \textcolor{stringliteral}{"Unknown option \(\backslash\)"%s\(\backslash\)" on \(\backslash\)".trace\(\backslash\)"\(\backslash\)n"}, z);
18012           rc = 1;
18013           \textcolor{keywordflow}{goto} meta\_command\_exit;
18014         \}
18015       \}\textcolor{keywordflow}{else}\{
18016         output_file_close(p->traceOut);
18017         p->traceOut = output_file_open(azArg[1], 0);
18018       \}
18019     \}
18020     \textcolor{keywordflow}{if}( p->traceOut==0 )\{
18021       sqlite3_trace_v2(p->db, 0, 0, 0);
18022     \}\textcolor{keywordflow}{else}\{
18023       \textcolor{keywordflow}{if}( mType==0 ) mType = SQLITE_TRACE_STMT;
18024       sqlite3_trace_v2(p->db, mType, sql_trace_callback, p);
18025     \}
18026   \}\textcolor{keywordflow}{else}
18027 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !defined(SQLITE\_OMIT\_TRACE) */}\textcolor{preprocessor}{}
18028 
18029 \textcolor{preprocessor}{#if defined(SQLITE\_DEBUG) && !defined(SQLITE\_OMIT\_VIRTUALTABLE)}
18030   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'u'} && strncmp(azArg[0], \textcolor{stringliteral}{"unmodule"}, n)==0 )\{
18031     \textcolor{keywordtype}{int} ii;
18032     \textcolor{keywordtype}{int} lenOpt;
18033     \textcolor{keywordtype}{char} *zOpt;
18034     \textcolor{keywordflow}{if}( nArg<2 )\{
18035       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .unmodule [--allexcept] NAME ...\(\backslash\)n"});
18036       rc = 1;
18037       \textcolor{keywordflow}{goto} meta\_command\_exit;
18038     \}
18039     open_db(p, 0);
18040     zOpt = azArg[1];
18041     \textcolor{keywordflow}{if}( zOpt[0]==\textcolor{charliteral}{'-'} && zOpt[1]==\textcolor{charliteral}{'-'} && zOpt[2]!=0 ) zOpt++;
18042     lenOpt = (int)strlen(zOpt);
18043     \textcolor{keywordflow}{if}( lenOpt>=3 && strncmp(zOpt, \textcolor{stringliteral}{"-allexcept"},lenOpt)==0 )\{
18044       assert( azArg[nArg]==0 );
18045       sqlite3_drop_modules(p->db, nArg>2 ? (\textcolor{keyword}{const} \textcolor{keywordtype}{char}**)(azArg+2) : 0);
18046     \}\textcolor{keywordflow}{else}\{
18047       \textcolor{keywordflow}{for}(ii=1; ii<nArg; ii++)\{
18048         sqlite3_create_module(p->db, azArg[ii], 0, 0);
18049       \}
18050     \}
18051   \}\textcolor{keywordflow}{else}
18052 \textcolor{preprocessor}{#endif}
18053 
18054 \textcolor{preprocessor}{#if SQLITE\_USER\_AUTHENTICATION}
18055   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'u'} && strncmp(azArg[0], \textcolor{stringliteral}{"user"}, n)==0 )\{
18056     \textcolor{keywordflow}{if}( nArg<2 )\{
18057       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .user SUBCOMMAND ...\(\backslash\)n"});
18058       rc = 1;
18059       \textcolor{keywordflow}{goto} meta\_command\_exit;
18060     \}
18061     open_db(p, 0);
18062     \textcolor{keywordflow}{if}( strcmp(azArg[1],\textcolor{stringliteral}{"login"})==0 )\{
18063       \textcolor{keywordflow}{if}( nArg!=4 )\{
18064         raw_printf(stderr, \textcolor{stringliteral}{"Usage: .user login USER PASSWORD\(\backslash\)n"});
18065         rc = 1;
18066         \textcolor{keywordflow}{goto} meta\_command\_exit;
18067       \}
18068       rc = sqlite3\_user\_authenticate(p->db, azArg[2], azArg[3],
18069                                      strlen30(azArg[3]));
18070       \textcolor{keywordflow}{if}( rc )\{
18071         utf8_printf(stderr, \textcolor{stringliteral}{"Authentication failed for user %s\(\backslash\)n"}, azArg[2]);
18072         rc = 1;
18073       \}
18074     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(azArg[1],\textcolor{stringliteral}{"add"})==0 )\{
18075       \textcolor{keywordflow}{if}( nArg!=5 )\{
18076         raw_printf(stderr, \textcolor{stringliteral}{"Usage: .user add USER PASSWORD ISADMIN\(\backslash\)n"});
18077         rc = 1;
18078         \textcolor{keywordflow}{goto} meta\_command\_exit;
18079       \}
18080       rc = sqlite3\_user\_add(p->db, azArg[2], azArg[3], strlen30(azArg[3]),
18081                             booleanValue(azArg[4]));
18082       \textcolor{keywordflow}{if}( rc )\{
18083         raw_printf(stderr, \textcolor{stringliteral}{"User-Add failed: %d\(\backslash\)n"}, rc);
18084         rc = 1;
18085       \}
18086     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(azArg[1],\textcolor{stringliteral}{"edit"})==0 )\{
18087       \textcolor{keywordflow}{if}( nArg!=5 )\{
18088         raw_printf(stderr, \textcolor{stringliteral}{"Usage: .user edit USER PASSWORD ISADMIN\(\backslash\)n"});
18089         rc = 1;
18090         \textcolor{keywordflow}{goto} meta\_command\_exit;
18091       \}
18092       rc = sqlite3\_user\_change(p->db, azArg[2], azArg[3], strlen30(azArg[3]),
18093                               booleanValue(azArg[4]));
18094       \textcolor{keywordflow}{if}( rc )\{
18095         raw_printf(stderr, \textcolor{stringliteral}{"User-Edit failed: %d\(\backslash\)n"}, rc);
18096         rc = 1;
18097       \}
18098     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(azArg[1],\textcolor{stringliteral}{"delete"})==0 )\{
18099       \textcolor{keywordflow}{if}( nArg!=3 )\{
18100         raw_printf(stderr, \textcolor{stringliteral}{"Usage: .user delete USER\(\backslash\)n"});
18101         rc = 1;
18102         \textcolor{keywordflow}{goto} meta\_command\_exit;
18103       \}
18104       rc = sqlite3\_user\_delete(p->db, azArg[2]);
18105       \textcolor{keywordflow}{if}( rc )\{
18106         raw_printf(stderr, \textcolor{stringliteral}{"User-Delete failed: %d\(\backslash\)n"}, rc);
18107         rc = 1;
18108       \}
18109     \}\textcolor{keywordflow}{else}\{
18110       raw_printf(stderr, \textcolor{stringliteral}{"Usage: .user login|add|edit|delete ...\(\backslash\)n"});
18111       rc = 1;
18112       \textcolor{keywordflow}{goto} meta\_command\_exit;
18113     \}
18114   \}\textcolor{keywordflow}{else}
18115 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* SQLITE\_USER\_AUTHENTICATION */}\textcolor{preprocessor}{}
18116 
18117   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'v'} && strncmp(azArg[0], \textcolor{stringliteral}{"version"}, n)==0 )\{
18118     utf8_printf(p->out, \textcolor{stringliteral}{"SQLite %s %s\(\backslash\)n"} \textcolor{comment}{/*extra-version-info*/},
18119         sqlite3_libversion(), sqlite3_sourceid());
18120 \textcolor{preprocessor}{#if SQLITE\_HAVE\_ZLIB}
18121     utf8_printf(p->out, \textcolor{stringliteral}{"zlib version %s\(\backslash\)n"}, zlibVersion());
18122 \textcolor{preprocessor}{#endif}
18123 \textcolor{preprocessor}{#define CTIMEOPT\_VAL\_(opt) #opt}
18124 \textcolor{preprocessor}{#define CTIMEOPT\_VAL(opt) CTIMEOPT\_VAL\_(opt)}
18125 \textcolor{preprocessor}{#if defined(\_\_clang\_\_) && defined(\_\_clang\_major\_\_)}
18126     utf8_printf(p->out, \textcolor{stringliteral}{"clang-"} CTIMEOPT_VAL(\_\_clang\_major\_\_) \textcolor{stringliteral}{"."}
18127                     CTIMEOPT_VAL(\_\_clang\_minor\_\_) \textcolor{stringliteral}{"."}
18128                     CTIMEOPT_VAL(\_\_clang\_patchlevel\_\_) \textcolor{stringliteral}{"\(\backslash\)n"});
18129 \textcolor{preprocessor}{#elif defined(\_MSC\_VER)}
18130     utf8_printf(p->out, \textcolor{stringliteral}{"msvc-"} CTIMEOPT_VAL(\_MSC\_VER) \textcolor{stringliteral}{"\(\backslash\)n"});
18131 \textcolor{preprocessor}{#elif defined(\_\_GNUC\_\_) && defined(\_\_VERSION\_\_)}
18132     utf8_printf(p->out, \textcolor{stringliteral}{"gcc-"} \_\_VERSION\_\_ \textcolor{stringliteral}{"\(\backslash\)n"});
18133 \textcolor{preprocessor}{#endif}
18134   \}\textcolor{keywordflow}{else}
18135 
18136   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'v'} && strncmp(azArg[0], \textcolor{stringliteral}{"vfsinfo"}, n)==0 )\{
18137     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDbName = nArg==2 ? azArg[1] : \textcolor{stringliteral}{"main"};
18138     sqlite3_vfs *pVfs = 0;
18139     \textcolor{keywordflow}{if}( p->db )\{
18140       sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFS_POINTER, &pVfs);
18141       \textcolor{keywordflow}{if}( pVfs )\{
18142         utf8_printf(p->out, \textcolor{stringliteral}{"vfs.zName      = \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, pVfs->zName);
18143         raw_printf(p->out, \textcolor{stringliteral}{"vfs.iVersion   = %d\(\backslash\)n"}, pVfs->iVersion);
18144         raw_printf(p->out, \textcolor{stringliteral}{"vfs.szOsFile   = %d\(\backslash\)n"}, pVfs->szOsFile);
18145         raw_printf(p->out, \textcolor{stringliteral}{"vfs.mxPathname = %d\(\backslash\)n"}, pVfs->mxPathname);
18146       \}
18147     \}
18148   \}\textcolor{keywordflow}{else}
18149 
18150   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'v'} && strncmp(azArg[0], \textcolor{stringliteral}{"vfslist"}, n)==0 )\{
18151     sqlite3_vfs *pVfs;
18152     sqlite3_vfs *pCurrent = 0;
18153     \textcolor{keywordflow}{if}( p->db )\{
18154       sqlite3_file_control(p->db, \textcolor{stringliteral}{"main"}, SQLITE_FCNTL_VFS_POINTER, &pCurrent);
18155     \}
18156     \textcolor{keywordflow}{for}(pVfs=sqlite3_vfs_find(0); pVfs; pVfs=pVfs->pNext)\{
18157       utf8_printf(p->out, \textcolor{stringliteral}{"vfs.zName      = \(\backslash\)"%s\(\backslash\)"%s\(\backslash\)n"}, pVfs->zName,
18158            pVfs==pCurrent ? \textcolor{stringliteral}{"  <--- CURRENT"} : \textcolor{stringliteral}{""});
18159       raw_printf(p->out, \textcolor{stringliteral}{"vfs.iVersion   = %d\(\backslash\)n"}, pVfs->iVersion);
18160       raw_printf(p->out, \textcolor{stringliteral}{"vfs.szOsFile   = %d\(\backslash\)n"}, pVfs->szOsFile);
18161       raw_printf(p->out, \textcolor{stringliteral}{"vfs.mxPathname = %d\(\backslash\)n"}, pVfs->mxPathname);
18162       \textcolor{keywordflow}{if}( pVfs->pNext )\{
18163         raw_printf(p->out, \textcolor{stringliteral}{"-----------------------------------\(\backslash\)n"});
18164       \}
18165     \}
18166   \}\textcolor{keywordflow}{else}
18167 
18168   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'v'} && strncmp(azArg[0], \textcolor{stringliteral}{"vfsname"}, n)==0 )\{
18169     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDbName = nArg==2 ? azArg[1] : \textcolor{stringliteral}{"main"};
18170     \textcolor{keywordtype}{char} *zVfsName = 0;
18171     \textcolor{keywordflow}{if}( p->db )\{
18172       sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);
18173       \textcolor{keywordflow}{if}( zVfsName )\{
18174         utf8_printf(p->out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, zVfsName);
18175         sqlite3_free(zVfsName);
18176       \}
18177     \}
18178   \}\textcolor{keywordflow}{else}
18179 
18180 \textcolor{preprocessor}{#if defined(SQLITE\_DEBUG) && defined(SQLITE\_ENABLE\_WHERETRACE)}
18181   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'w'} && strncmp(azArg[0], \textcolor{stringliteral}{"wheretrace"}, n)==0 )\{
18182     sqlite3WhereTrace = nArg>=2 ? booleanValue(azArg[1]) : 0xff;
18183   \}\textcolor{keywordflow}{else}
18184 \textcolor{preprocessor}{#endif}
18185 
18186   \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'w'} && strncmp(azArg[0], \textcolor{stringliteral}{"width"}, n)==0 )\{
18187     \textcolor{keywordtype}{int} j;
18188     assert( nArg<=ArraySize(azArg) );
18189     \textcolor{keywordflow}{for}(j=1; j<nArg && j<ArraySize(p->colWidth); j++)\{
18190       p->colWidth[j-1] = (int)integerValue(azArg[j]);
18191     \}
18192   \}\textcolor{keywordflow}{else}
18193 
18194   \{
18195     utf8_printf(stderr, \textcolor{stringliteral}{"Error: unknown command or invalid arguments: "}
18196       \textcolor{stringliteral}{" \(\backslash\)"%s\(\backslash\)". Enter \(\backslash\)".help\(\backslash\)" for help\(\backslash\)n"}, azArg[0]);
18197     rc = 1;
18198   \}
18199 
18200 meta\_command\_exit:
18201   \textcolor{keywordflow}{if}( p->outCount )\{
18202     p->outCount--;
18203     \textcolor{keywordflow}{if}( p->outCount==0 ) output_reset(p);
18204   \}
18205   \textcolor{keywordflow}{return} rc;
18206 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a57a4b1600ae8c8582a996ee3e4299494}} 
\index{shell.\+c@{shell.\+c}!dump\+\_\+callback@{dump\+\_\+callback}}
\index{dump\+\_\+callback@{dump\+\_\+callback}!shell.\+c@{shell.\+c}}
\subsubsection{dump\+\_\+callback()}
{\footnotesize\ttfamily static int dump\+\_\+callback (\begin{DoxyParamCaption}\item[{void $\ast$}]{p\+Arg,  }\item[{int}]{n\+Arg,  }\item[{char $\ast$$\ast$}]{az\+Arg,  }\item[{char $\ast$$\ast$}]{az\+Not\+Used }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11879 of file shell.\+c.



References append\+Text(), Shell\+State\+::c\+Mode, Shell\+State\+::db, free\+Column\+List(), free\+Text(), init\+Text(), Shell\+State\+::mode, M\+O\+D\+E\+\_\+\+Insert, Shell\+State\+::n\+Err, Shell\+State\+::out, print\+Schema\+Line(), quote\+Char(), raw\+\_\+printf, shell\+\_\+exec(), sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+strglob, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+R\+R\+U\+PT, table\+Column\+List(), toggle\+Select\+Order(), U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER, utf8\+\_\+printf, Shell\+State\+::writable\+Schema, Shell\+Text\+::z, and Shell\+State\+::z\+Dest\+Table.



Referenced by run\+\_\+schema\+\_\+dump\+\_\+query().


\begin{DoxyCode}
11879                                                                               \{
11880   \textcolor{keywordtype}{int} rc;
11881   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zTable;
11882   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zType;
11883   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql;
11884   ShellState *p = (ShellState *)pArg;
11885 
11886   UNUSED_PARAMETER(azNotUsed);
11887   \textcolor{keywordflow}{if}( nArg!=3 || azArg==0 ) \textcolor{keywordflow}{return} 0;
11888   zTable = azArg[0];
11889   zType = azArg[1];
11890   zSql = azArg[2];
11891 
11892   \textcolor{keywordflow}{if}( strcmp(zTable, \textcolor{stringliteral}{"sqlite\_sequence"})==0 )\{
11893     raw_printf(p->out, \textcolor{stringliteral}{"DELETE FROM sqlite\_sequence;\(\backslash\)n"});
11894   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( sqlite3_strglob(\textcolor{stringliteral}{"sqlite\_stat?"}, zTable)==0 )\{
11895     raw_printf(p->out, \textcolor{stringliteral}{"ANALYZE sqlite\_master;\(\backslash\)n"});
11896   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strncmp(zTable, \textcolor{stringliteral}{"sqlite\_"}, 7)==0 )\{
11897     \textcolor{keywordflow}{return} 0;
11898   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strncmp(zSql, \textcolor{stringliteral}{"CREATE VIRTUAL TABLE"}, 20)==0 )\{
11899     \textcolor{keywordtype}{char} *zIns;
11900     \textcolor{keywordflow}{if}( !p->writableSchema )\{
11901       raw_printf(p->out, \textcolor{stringliteral}{"PRAGMA writable\_schema=ON;\(\backslash\)n"});
11902       p->writableSchema = 1;
11903     \}
11904     zIns = sqlite3_mprintf(
11905        \textcolor{stringliteral}{"INSERT INTO sqlite\_master(type,name,tbl\_name,rootpage,sql)"}
11906        \textcolor{stringliteral}{"VALUES('table','%q','%q',0,'%q');"},
11907        zTable, zTable, zSql);
11908     utf8_printf(p->out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, zIns);
11909     sqlite3_free(zIns);
11910     \textcolor{keywordflow}{return} 0;
11911   \}\textcolor{keywordflow}{else}\{
11912     printSchemaLine(p->out, zSql, \textcolor{stringliteral}{";\(\backslash\)n"});
11913   \}
11914 
11915   \textcolor{keywordflow}{if}( strcmp(zType, \textcolor{stringliteral}{"table"})==0 )\{
11916     ShellText sSelect;
11917     ShellText sTable;
11918     \textcolor{keywordtype}{char} **azCol;
11919     \textcolor{keywordtype}{int} i;
11920     \textcolor{keywordtype}{char} *savedDestTable;
11921     \textcolor{keywordtype}{int} savedMode;
11922 
11923     azCol = tableColumnList(p, zTable);
11924     \textcolor{keywordflow}{if}( azCol==0 )\{
11925       p->nErr++;
11926       \textcolor{keywordflow}{return} 0;
11927     \}
11928 
11929     \textcolor{comment}{/* Always quote the table name, even if it appears to be pure ascii,}
11930 \textcolor{comment}{    ** in case it is a keyword. Ex:  INSERT INTO "table" ... */}
11931     initText(&sTable);
11932     appendText(&sTable, zTable, quoteChar(zTable));
11933     \textcolor{comment}{/* If preserving the rowid, add a column list after the table name.}
11934 \textcolor{comment}{    ** In other words:  "INSERT INTO tab(rowid,a,b,c,...) VALUES(...)"}
11935 \textcolor{comment}{    ** instead of the usual "INSERT INTO tab VALUES(...)".}
11936 \textcolor{comment}{    */}
11937     \textcolor{keywordflow}{if}( azCol[0] )\{
11938       appendText(&sTable, \textcolor{stringliteral}{"("}, 0);
11939       appendText(&sTable, azCol[0], 0);
11940       \textcolor{keywordflow}{for}(i=1; azCol[i]; i++)\{
11941         appendText(&sTable, \textcolor{stringliteral}{","}, 0);
11942         appendText(&sTable, azCol[i], quoteChar(azCol[i]));
11943       \}
11944       appendText(&sTable, \textcolor{stringliteral}{")"}, 0);
11945     \}
11946 
11947     \textcolor{comment}{/* Build an appropriate SELECT statement */}
11948     initText(&sSelect);
11949     appendText(&sSelect, \textcolor{stringliteral}{"SELECT "}, 0);
11950     \textcolor{keywordflow}{if}( azCol[0] )\{
11951       appendText(&sSelect, azCol[0], 0);
11952       appendText(&sSelect, \textcolor{stringliteral}{","}, 0);
11953     \}
11954     \textcolor{keywordflow}{for}(i=1; azCol[i]; i++)\{
11955       appendText(&sSelect, azCol[i], quoteChar(azCol[i]));
11956       \textcolor{keywordflow}{if}( azCol[i+1] )\{
11957         appendText(&sSelect, \textcolor{stringliteral}{","}, 0);
11958       \}
11959     \}
11960     freeColumnList(azCol);
11961     appendText(&sSelect, \textcolor{stringliteral}{" FROM "}, 0);
11962     appendText(&sSelect, zTable, quoteChar(zTable));
11963 
11964     savedDestTable = p->zDestTable;
11965     savedMode = p->mode;
11966     p->zDestTable = sTable.z;
11967     p->mode = p->cMode = MODE_Insert;
11968     rc = shell_exec(p, sSelect.z, 0);
11969     \textcolor{keywordflow}{if}( (rc&0xff)==SQLITE_CORRUPT )\{
11970       raw_printf(p->out, \textcolor{stringliteral}{"/****** CORRUPTION ERROR *******/\(\backslash\)n"});
11971       toggleSelectOrder(p->db);
11972       shell_exec(p, sSelect.z, 0);
11973       toggleSelectOrder(p->db);
11974     \}
11975     p->zDestTable = savedDestTable;
11976     p->mode = savedMode;
11977     freeText(&sTable);
11978     freeText(&sSelect);
11979     \textcolor{keywordflow}{if}( rc ) p->nErr++;
11980   \}
11981   \textcolor{keywordflow}{return} 0;
11982 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aa627559456f884f4ede330d165368838}} 
\index{shell.\+c@{shell.\+c}!edit\+Func@{edit\+Func}}
\index{edit\+Func@{edit\+Func}!shell.\+c@{shell.\+c}}
\subsubsection{edit\+Func()}
{\footnotesize\ttfamily static void edit\+Func (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{context,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 9773 of file shell.\+c.



References sqlite3\+\_\+context\+\_\+db\+\_\+handle, sqlite3\+\_\+file\+\_\+control, sqlite3\+\_\+free, sqlite3\+\_\+malloc64, sqlite3\+\_\+mprintf, sqlite3\+\_\+randomness, sqlite3\+\_\+result\+\_\+blob64, sqlite3\+\_\+result\+\_\+error, sqlite3\+\_\+result\+\_\+error\+\_\+nomem, sqlite3\+\_\+result\+\_\+text64, sqlite3\+\_\+value\+\_\+blob, sqlite3\+\_\+value\+\_\+bytes, sqlite3\+\_\+value\+\_\+text, sqlite3\+\_\+value\+\_\+type, S\+Q\+L\+I\+T\+E\+\_\+\+B\+L\+OB, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+T\+E\+M\+P\+F\+I\+L\+E\+N\+A\+ME, S\+Q\+L\+I\+T\+E\+\_\+\+N\+U\+LL, S\+Q\+L\+I\+T\+E\+\_\+\+U\+T\+F8, and time\+\_\+test\+::x.



Referenced by open\+\_\+db().


\begin{DoxyCode}
9777  \{
9778   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zEditor;
9779   \textcolor{keywordtype}{char} *zTempFile = 0;
9780   sqlite3 *db;
9781   \textcolor{keywordtype}{char} *zCmd = 0;
9782   \textcolor{keywordtype}{int} bBin;
9783   \textcolor{keywordtype}{int} rc;
9784   \textcolor{keywordtype}{int} hasCRNL = 0;
9785   FILE *f = 0;
9786   sqlite3_int64 sz;
9787   sqlite3_int64 x;
9788   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *p = 0;
9789 
9790   \textcolor{keywordflow}{if}( argc==2 )\{
9791     zEditor = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(argv[1]);
9792   \}\textcolor{keywordflow}{else}\{
9793     zEditor = getenv(\textcolor{stringliteral}{"VISUAL"});
9794   \}
9795   \textcolor{keywordflow}{if}( zEditor==0 )\{
9796     sqlite3_result_error(context, \textcolor{stringliteral}{"no editor for edit()"}, -1);
9797     \textcolor{keywordflow}{return};
9798   \}
9799   \textcolor{keywordflow}{if}( sqlite3_value_type(argv[0])==SQLITE_NULL )\{
9800     sqlite3_result_error(context, \textcolor{stringliteral}{"NULL input to edit()"}, -1);
9801     \textcolor{keywordflow}{return};
9802   \}
9803   db = sqlite3_context_db_handle(context);
9804   zTempFile = 0;
9805   sqlite3_file_control(db, 0, SQLITE_FCNTL_TEMPFILENAME, &zTempFile);
9806   \textcolor{keywordflow}{if}( zTempFile==0 )\{
9807     sqlite3_uint64 r = 0;
9808     sqlite3_randomness(\textcolor{keyword}{sizeof}(r), &r);
9809     zTempFile = sqlite3_mprintf(\textcolor{stringliteral}{"temp%llx"}, r);
9810     \textcolor{keywordflow}{if}( zTempFile==0 )\{
9811       sqlite3_result_error_nomem(context);
9812       \textcolor{keywordflow}{return};
9813     \}
9814   \}
9815   bBin = sqlite3_value_type(argv[0])==SQLITE_BLOB;
9816   \textcolor{comment}{/* When writing the file to be edited, do \(\backslash\)n to \(\backslash\)r\(\backslash\)n conversions on systems}
9817 \textcolor{comment}{  ** that want \(\backslash\)r\(\backslash\)n line endings */}
9818   f = fopen(zTempFile, bBin ? \textcolor{stringliteral}{"wb"} : \textcolor{stringliteral}{"w"});
9819   \textcolor{keywordflow}{if}( f==0 )\{
9820     sqlite3_result_error(context, \textcolor{stringliteral}{"edit() cannot open temp file"}, -1);
9821     \textcolor{keywordflow}{goto} edit\_func\_end;
9822   \}
9823   sz = sqlite3_value_bytes(argv[0]);
9824   \textcolor{keywordflow}{if}( bBin )\{
9825     x = fwrite(sqlite3_value_blob(argv[0]), 1, (\textcolor{keywordtype}{size\_t})sz, f);
9826   \}\textcolor{keywordflow}{else}\{
9827     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(argv[0]);
9828     \textcolor{comment}{/* Remember whether or not the value originally contained \(\backslash\)r\(\backslash\)n */}
9829     \textcolor{keywordflow}{if}( z && strstr(z,\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"})!=0 ) hasCRNL = 1;
9830     x = fwrite(sqlite3_value_text(argv[0]), 1, (\textcolor{keywordtype}{size\_t})sz, f);
9831   \}
9832   fclose(f);
9833   f = 0;
9834   \textcolor{keywordflow}{if}( x!=sz )\{
9835     sqlite3_result_error(context, \textcolor{stringliteral}{"edit() could not write the whole file"}, -1);
9836     \textcolor{keywordflow}{goto} edit\_func\_end;
9837   \}
9838   zCmd = sqlite3_mprintf(\textcolor{stringliteral}{"%s \(\backslash\)"%s\(\backslash\)""}, zEditor, zTempFile);
9839   \textcolor{keywordflow}{if}( zCmd==0 )\{
9840     sqlite3_result_error_nomem(context);
9841     \textcolor{keywordflow}{goto} edit\_func\_end;
9842   \}
9843   rc = system(zCmd);
9844   sqlite3_free(zCmd);
9845   \textcolor{keywordflow}{if}( rc )\{
9846     sqlite3_result_error(context, \textcolor{stringliteral}{"EDITOR returned non-zero"}, -1);
9847     \textcolor{keywordflow}{goto} edit\_func\_end;
9848   \}
9849   f = fopen(zTempFile, \textcolor{stringliteral}{"rb"});
9850   \textcolor{keywordflow}{if}( f==0 )\{
9851     sqlite3_result_error(context,
9852       \textcolor{stringliteral}{"edit() cannot reopen temp file after edit"}, -1);
9853     \textcolor{keywordflow}{goto} edit\_func\_end;
9854   \}
9855   fseek(f, 0, SEEK\_END);
9856   sz = ftell(f);
9857   rewind(f);
9858   p = sqlite3_malloc64( sz+1 );
9859   \textcolor{keywordflow}{if}( p==0 )\{
9860     sqlite3_result_error_nomem(context);
9861     \textcolor{keywordflow}{goto} edit\_func\_end;
9862   \}
9863   x = fread(p, 1, (\textcolor{keywordtype}{size\_t})sz, f);
9864   fclose(f);
9865   f = 0;
9866   \textcolor{keywordflow}{if}( x!=sz )\{
9867     sqlite3_result_error(context, \textcolor{stringliteral}{"could not read back the whole file"}, -1);
9868     \textcolor{keywordflow}{goto} edit\_func\_end;
9869   \}
9870   \textcolor{keywordflow}{if}( bBin )\{
9871     sqlite3_result_blob64(context, p, sz, sqlite3_free);
9872   \}\textcolor{keywordflow}{else}\{
9873     sqlite3_int64 i, j;
9874     \textcolor{keywordflow}{if}( hasCRNL )\{
9875       \textcolor{comment}{/* If the original contains \(\backslash\)r\(\backslash\)n then do no conversions back to \(\backslash\)n */}
9876       j = sz;
9877     \}\textcolor{keywordflow}{else}\{
9878       \textcolor{comment}{/* If the file did not originally contain \(\backslash\)r\(\backslash\)n then convert any new}
9879 \textcolor{comment}{      ** \(\backslash\)r\(\backslash\)n back into \(\backslash\)n */}
9880       \textcolor{keywordflow}{for}(i=j=0; i<sz; i++)\{
9881         \textcolor{keywordflow}{if}( p[i]==\textcolor{charliteral}{'\(\backslash\)r'} && p[i+1]==\textcolor{charliteral}{'\(\backslash\)n'} ) i++;
9882         p[j++] = p[i];
9883       \}
9884       sz = j;
9885       p[sz] = 0;
9886     \} 
9887     sqlite3_result_text64(context, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)p, sz,
9888                           sqlite3_free, SQLITE_UTF8);
9889   \}
9890   p = 0;
9891 
9892 edit\_func\_end:
9893   \textcolor{keywordflow}{if}( f ) fclose(f);
9894   unlink(zTempFile);
9895   sqlite3_free(zTempFile);
9896   sqlite3_free(p);
9897 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a0ce89847bb1aa008c6f08345247e8a2c}} 
\index{shell.\+c@{shell.\+c}!end\+Timer@{end\+Timer}}
\index{end\+Timer@{end\+Timer}!shell.\+c@{shell.\+c}}
\subsubsection{end\+Timer()}
{\footnotesize\ttfamily static void end\+Timer (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 278 of file shell.\+c.



References s\+Begin, time\+Diff(), and time\+Of\+Day().


\begin{DoxyCode}
278                           \{
279   \textcolor{keywordflow}{if}( enableTimer )\{
280     sqlite3_int64 iEnd = timeOfDay();
281     \textcolor{keyword}{struct }rusage sEnd;
282     getrusage(RUSAGE\_SELF, &sEnd);
283     printf(\textcolor{stringliteral}{"Run Time: real %.3f user %f sys %f\(\backslash\)n"},
284        (iEnd - iBegin)*0.001,
285        timeDiff(&sBegin.ru\_utime, &sEnd.ru\_utime),
286        timeDiff(&sBegin.ru\_stime, &sEnd.ru\_stime));
287   \}
288 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a55f8d955647dd7eea2d4489e37cc272e}} 
\index{shell.\+c@{shell.\+c}!eqp\+\_\+append@{eqp\+\_\+append}}
\index{eqp\+\_\+append@{eqp\+\_\+append}!shell.\+c@{shell.\+c}}
\subsubsection{eqp\+\_\+append()}
{\footnotesize\ttfamily static void eqp\+\_\+append (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{int}]{i\+Eqp\+Id,  }\item[{int}]{p2,  }\item[{const char $\ast$}]{z\+Text }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10283 of file shell.\+c.



References Shell\+State\+::auto\+E\+Q\+Ptest, E\+Q\+P\+Graph\+Row\+::i\+Eqp\+Id, E\+Q\+P\+Graph\+Row\+::i\+Parent\+Id, Shell\+State\+::out, E\+Q\+P\+Graph\+::p\+Last, E\+Q\+P\+Graph\+Row\+::p\+Next, E\+Q\+P\+Graph\+::p\+Row, Shell\+State\+::s\+Graph, shell\+\_\+out\+\_\+of\+\_\+memory(), sqlite3\+\_\+malloc64, strlen30(), utf8\+\_\+printf, and E\+Q\+P\+Graph\+Row\+::z\+Text.



Referenced by shell\+\_\+callback(), and shell\+\_\+exec().


\begin{DoxyCode}
10283                                                                             \{
10284   EQPGraphRow *pNew;
10285   \textcolor{keywordtype}{int} nText = strlen30(zText);
10286   \textcolor{keywordflow}{if}( p->autoEQPtest )\{
10287     utf8_printf(p->out, \textcolor{stringliteral}{"%d,%d,%s\(\backslash\)n"}, iEqpId, p2, zText);
10288   \}
10289   pNew = sqlite3_malloc64( \textcolor{keyword}{sizeof}(*pNew) + nText );
10290   \textcolor{keywordflow}{if}( pNew==0 ) shell_out_of_memory();
10291   pNew->iEqpId = iEqpId;
10292   pNew->iParentId = p2;
10293   memcpy(pNew->zText, zText, nText+1);
10294   pNew->pNext = 0;
10295   \textcolor{keywordflow}{if}( p->sGraph.pLast )\{
10296     p->sGraph.pLast->pNext = pNew;
10297   \}\textcolor{keywordflow}{else}\{
10298     p->sGraph.pRow = pNew;
10299   \}
10300   p->sGraph.pLast = pNew;
10301 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab5acc359e292447197754674a6d912dd}} 
\index{shell.\+c@{shell.\+c}!eqp\+\_\+next\+\_\+row@{eqp\+\_\+next\+\_\+row}}
\index{eqp\+\_\+next\+\_\+row@{eqp\+\_\+next\+\_\+row}!shell.\+c@{shell.\+c}}
\subsubsection{eqp\+\_\+next\+\_\+row()}
{\footnotesize\ttfamily static \textbf{ E\+Q\+P\+Graph\+Row}$\ast$ eqp\+\_\+next\+\_\+row (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{int}]{i\+Eqp\+Id,  }\item[{\textbf{ E\+Q\+P\+Graph\+Row} $\ast$}]{p\+Old }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10319 of file shell.\+c.



References E\+Q\+P\+Graph\+Row\+::i\+Parent\+Id, E\+Q\+P\+Graph\+Row\+::p\+Next, E\+Q\+P\+Graph\+::p\+Row, and Shell\+State\+::s\+Graph.



Referenced by eqp\+\_\+render\+\_\+level().


\begin{DoxyCode}
10319                                                                               \{
10320   EQPGraphRow *pRow = pOld ? pOld->pNext : p->sGraph.pRow;
10321   \textcolor{keywordflow}{while}( pRow && pRow->iParentId!=iEqpId ) pRow = pRow->pNext;
10322   \textcolor{keywordflow}{return} pRow;
10323 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a88af8a73d4d91f370ec2e4c9e7b2d3b1}} 
\index{shell.\+c@{shell.\+c}!eqp\+\_\+render@{eqp\+\_\+render}}
\index{eqp\+\_\+render@{eqp\+\_\+render}!shell.\+c@{shell.\+c}}
\subsubsection{eqp\+\_\+render()}
{\footnotesize\ttfamily static void eqp\+\_\+render (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10348 of file shell.\+c.



References eqp\+\_\+render\+\_\+level(), eqp\+\_\+reset(), Shell\+State\+::out, E\+Q\+P\+Graph\+Row\+::p\+Next, E\+Q\+P\+Graph\+::p\+Row, Shell\+State\+::s\+Graph, sqlite3\+\_\+free, utf8\+\_\+printf, E\+Q\+P\+Graph\+::z\+Prefix, and E\+Q\+P\+Graph\+Row\+::z\+Text.



Referenced by shell\+\_\+exec().


\begin{DoxyCode}
10348                                      \{
10349   EQPGraphRow *pRow = p->sGraph.pRow;
10350   \textcolor{keywordflow}{if}( pRow )\{
10351     \textcolor{keywordflow}{if}( pRow->zText[0]==\textcolor{charliteral}{'-'} )\{
10352       \textcolor{keywordflow}{if}( pRow->pNext==0 )\{
10353         eqp_reset(p);
10354         \textcolor{keywordflow}{return};
10355       \}
10356       utf8_printf(p->out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, pRow->zText+3);
10357       p->sGraph.pRow = pRow->pNext;
10358       sqlite3_free(pRow);
10359     \}\textcolor{keywordflow}{else}\{
10360       utf8_printf(p->out, \textcolor{stringliteral}{"QUERY PLAN\(\backslash\)n"});
10361     \}
10362     p->sGraph.zPrefix[0] = 0;
10363     eqp_render_level(p, 0);
10364     eqp_reset(p);
10365   \}
10366 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a3d0ff2e739f1146c9e475ba83fdc2667}} 
\index{shell.\+c@{shell.\+c}!eqp\+\_\+render\+\_\+level@{eqp\+\_\+render\+\_\+level}}
\index{eqp\+\_\+render\+\_\+level@{eqp\+\_\+render\+\_\+level}!shell.\+c@{shell.\+c}}
\subsubsection{eqp\+\_\+render\+\_\+level()}
{\footnotesize\ttfamily static void eqp\+\_\+render\+\_\+level (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{int}]{i\+Eqp\+Id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10328 of file shell.\+c.



References eqp\+\_\+next\+\_\+row(), E\+Q\+P\+Graph\+Row\+::i\+Eqp\+Id, Shell\+State\+::out, Shell\+State\+::s\+Graph, strlen30(), utf8\+\_\+printf, E\+Q\+P\+Graph\+::z\+Prefix, and E\+Q\+P\+Graph\+Row\+::z\+Text.



Referenced by eqp\+\_\+render().


\begin{DoxyCode}
10328                                                        \{
10329   EQPGraphRow *pRow, *pNext;
10330   \textcolor{keywordtype}{int} n = strlen30(p->sGraph.zPrefix);
10331   \textcolor{keywordtype}{char} *z;
10332   \textcolor{keywordflow}{for}(pRow = eqp_next_row(p, iEqpId, 0); pRow; pRow = pNext)\{
10333     pNext = eqp_next_row(p, iEqpId, pRow);
10334     z = pRow->zText;
10335     utf8_printf(p->out, \textcolor{stringliteral}{"%s%s%s\(\backslash\)n"}, p->sGraph.zPrefix,
10336                 pNext ? \textcolor{stringliteral}{"|--"} : \textcolor{stringliteral}{"`--"}, z);
10337     \textcolor{keywordflow}{if}( n<(\textcolor{keywordtype}{int})\textcolor{keyword}{sizeof}(p->sGraph.zPrefix)-7 )\{
10338       memcpy(&p->sGraph.zPrefix[n], pNext ? \textcolor{stringliteral}{"|  "} : \textcolor{stringliteral}{"   "}, 4);
10339       eqp_render_level(p, pRow->iEqpId);
10340       p->sGraph.zPrefix[n] = 0;
10341     \}
10342   \}
10343 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a497c54c843462b41d0cba499e8e4f4f2}} 
\index{shell.\+c@{shell.\+c}!eqp\+\_\+reset@{eqp\+\_\+reset}}
\index{eqp\+\_\+reset@{eqp\+\_\+reset}!shell.\+c@{shell.\+c}}
\subsubsection{eqp\+\_\+reset()}
{\footnotesize\ttfamily static void eqp\+\_\+reset (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10307 of file shell.\+c.



References E\+Q\+P\+Graph\+Row\+::p\+Next, E\+Q\+P\+Graph\+::p\+Row, Shell\+State\+::s\+Graph, and sqlite3\+\_\+free.



Referenced by eqp\+\_\+render().


\begin{DoxyCode}
10307                                     \{
10308   EQPGraphRow *pRow, *pNext;
10309   \textcolor{keywordflow}{for}(pRow = p->sGraph.pRow; pRow; pRow = pNext)\{
10310     pNext = pRow->pNext;
10311     sqlite3_free(pRow);
10312   \}
10313   memset(&p->sGraph, 0, \textcolor{keyword}{sizeof}(p->sGraph));
10314 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aaa5a1de43472a96ddc2c7189001235b4}} 
\index{shell.\+c@{shell.\+c}!exec\+\_\+prepared\+\_\+stmt@{exec\+\_\+prepared\+\_\+stmt}}
\index{exec\+\_\+prepared\+\_\+stmt@{exec\+\_\+prepared\+\_\+stmt}!shell.\+c@{shell.\+c}}
\subsubsection{exec\+\_\+prepared\+\_\+stmt()}
{\footnotesize\ttfamily static void exec\+\_\+prepared\+\_\+stmt (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p\+Arg,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$}]{p\+Stmt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11393 of file shell.\+c.



References Shell\+State\+::c\+Mode, M\+O\+D\+E\+\_\+\+Insert, shell\+\_\+callback(), sqlite3\+\_\+column\+\_\+count, sqlite3\+\_\+column\+\_\+name, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+column\+\_\+type, sqlite3\+\_\+free, sqlite3\+\_\+malloc64, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+A\+B\+O\+RT, S\+Q\+L\+I\+T\+E\+\_\+\+B\+L\+OB, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+N\+U\+LL, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, and time\+\_\+test\+::x.



Referenced by shell\+\_\+exec().


\begin{DoxyCode}
11396  \{
11397   \textcolor{keywordtype}{int} rc;
11398 
11399   \textcolor{comment}{/* perform the first step.  this will tell us if we}
11400 \textcolor{comment}{  ** have a result set or not and how wide it is.}
11401 \textcolor{comment}{  */}
11402   rc = sqlite3_step(pStmt);
11403   \textcolor{comment}{/* if we have a result set... */}
11404   \textcolor{keywordflow}{if}( SQLITE_ROW == rc )\{
11405     \textcolor{comment}{/* allocate space for col name ptr, value ptr, and type */}
11406     \textcolor{keywordtype}{int} nCol = sqlite3_column_count(pStmt);
11407     \textcolor{keywordtype}{void} *pData = sqlite3_malloc64(3*nCol*\textcolor{keyword}{sizeof}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}*) + 1);
11408     \textcolor{keywordflow}{if}( !pData )\{
11409       rc = SQLITE_NOMEM;
11410     \}\textcolor{keywordflow}{else}\{
11411       \textcolor{keywordtype}{char} **azCols = (\textcolor{keywordtype}{char} **)pData;      \textcolor{comment}{/* Names of result columns */}
11412       \textcolor{keywordtype}{char} **azVals = &azCols[nCol];       \textcolor{comment}{/* Results */}
11413       \textcolor{keywordtype}{int} *aiTypes = (\textcolor{keywordtype}{int} *)&azVals[nCol]; \textcolor{comment}{/* Result types */}
11414       \textcolor{keywordtype}{int} i, x;
11415       assert(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}) <= \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char} *));
11416       \textcolor{comment}{/* save off ptrs to column names */}
11417       \textcolor{keywordflow}{for}(i=0; i<nCol; i++)\{
11418         azCols[i] = (\textcolor{keywordtype}{char} *)sqlite3_column_name(pStmt, i);
11419       \}
11420       \textcolor{keywordflow}{do}\{
11421         \textcolor{comment}{/* extract the data and data types */}
11422         \textcolor{keywordflow}{for}(i=0; i<nCol; i++)\{
11423           aiTypes[i] = x = sqlite3_column_type(pStmt, i);
11424           \textcolor{keywordflow}{if}( x==SQLITE_BLOB && pArg && pArg->cMode==MODE_Insert )\{
11425             azVals[i] = \textcolor{stringliteral}{""};
11426           \}\textcolor{keywordflow}{else}\{
11427             azVals[i] = (\textcolor{keywordtype}{char}*)sqlite3_column_text(pStmt, i);
11428           \}
11429           \textcolor{keywordflow}{if}( !azVals[i] && (aiTypes[i]!=SQLITE_NULL) )\{
11430             rc = SQLITE_NOMEM;
11431             \textcolor{keywordflow}{break}; \textcolor{comment}{/* from for */}
11432           \}
11433         \} \textcolor{comment}{/* end for */}
11434 
11435         \textcolor{comment}{/* if data and types extracted successfully... */}
11436         \textcolor{keywordflow}{if}( SQLITE_ROW == rc )\{
11437           \textcolor{comment}{/* call the supplied callback with the result row data */}
11438           \textcolor{keywordflow}{if}( shell_callback(pArg, nCol, azVals, azCols, aiTypes) )\{
11439             rc = SQLITE_ABORT;
11440           \}\textcolor{keywordflow}{else}\{
11441             rc = sqlite3_step(pStmt);
11442           \}
11443         \}
11444       \} \textcolor{keywordflow}{while}( SQLITE_ROW == rc );
11445       sqlite3_free(pData);
11446     \}
11447   \}
11448 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad313090cadd30bcbabf7a0e2e6f2eff0}} 
\index{shell.\+c@{shell.\+c}!expert\+Best\+Index@{expert\+Best\+Index}}
\index{expert\+Best\+Index@{expert\+Best\+Index}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Best\+Index()}
{\footnotesize\ttfamily static int expert\+Best\+Index (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$}]{p\+Vtab,  }\item[{\textbf{ sqlite3\+\_\+index\+\_\+info} $\ast$}]{p\+Idx\+Info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7143 of file shell.\+c.



References Idx\+Table\+::a\+Col, sqlite3\+\_\+index\+\_\+info\+::a\+Constraint, sqlite3\+\_\+index\+\_\+info\+::a\+Constraint\+Usage, sqlite3\+\_\+index\+\_\+info\+::a\+Order\+By, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+constraint\+\_\+usage\+::argv\+Index, Idx\+Constraint\+::b\+Desc, Idx\+Constraint\+::b\+Range, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+orderby\+::desc, sqlite3\+\_\+index\+\_\+info\+::estimated\+Cost, Idx\+Constraint\+::i\+Col, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+orderby\+::i\+Column, idx\+Malloc(), idx\+New\+Constraint(), Idx\+Column\+::i\+Pk, sqlite3\+\_\+index\+\_\+info\+::n\+Constraint, sqlite3\+\_\+index\+\_\+info\+::n\+Order\+By, Idx\+Scan\+::p\+Eq, Expert\+Vtab\+::p\+Expert, Idx\+Constraint\+::p\+Link, Idx\+Constraint\+::p\+Next, Idx\+Scan\+::p\+Next\+Scan, Idx\+Scan\+::p\+Order, Idx\+Scan\+::p\+Range, sqlite3expert\+::p\+Scan, Idx\+Scan\+::p\+Tab, Expert\+Vtab\+::p\+Tab, sqlite3\+\_\+vtab\+\_\+collation, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+N\+T\+\_\+\+EQ, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+N\+T\+\_\+\+GE, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+N\+T\+\_\+\+GT, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+N\+T\+\_\+\+LE, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+N\+T\+\_\+\+LT, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and Idx\+Column\+::z\+Coll.



Referenced by idx\+Register\+Vtab().


\begin{DoxyCode}
7143                                                                              \{
7144   ExpertVtab *p = (ExpertVtab*)pVtab;
7145   \textcolor{keywordtype}{int} rc = SQLITE_OK;
7146   \textcolor{keywordtype}{int} n = 0;
7147   IdxScan *pScan;
7148   \textcolor{keyword}{const} \textcolor{keywordtype}{int} opmask = 
7149     SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_GT |
7150     SQLITE_INDEX_CONSTRAINT_LT | SQLITE_INDEX_CONSTRAINT_GE |
7151     SQLITE_INDEX_CONSTRAINT_LE;
7152 
7153   pScan = idxMalloc(&rc, \textcolor{keyword}{sizeof}(IdxScan));
7154   \textcolor{keywordflow}{if}( pScan )\{
7155     \textcolor{keywordtype}{int} i;
7156 
7157     \textcolor{comment}{/* Link the new scan object into the list */}
7158     pScan->pTab = p->pTab;
7159     pScan->pNextScan = p->pExpert->pScan;
7160     p->pExpert->pScan = pScan;
7161 
7162     \textcolor{comment}{/* Add the constraints to the IdxScan object */}
7163     \textcolor{keywordflow}{for}(i=0; i<pIdxInfo->nConstraint; i++)\{
7164       \textcolor{keyword}{struct }sqlite3\_index\_constraint *pCons = &pIdxInfo->aConstraint[i];
7165       \textcolor{keywordflow}{if}( pCons->usable 
7166        && pCons->iColumn>=0 
7167        && p->pTab->aCol[pCons->iColumn].iPk==0
7168        && (pCons->op & opmask) 
7169       )\{
7170         IdxConstraint *pNew;
7171         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zColl = sqlite3_vtab_collation(pIdxInfo, i);
7172         pNew = idxNewConstraint(&rc, zColl);
7173         \textcolor{keywordflow}{if}( pNew )\{
7174           pNew->iCol = pCons->iColumn;
7175           \textcolor{keywordflow}{if}( pCons->op==SQLITE_INDEX_CONSTRAINT_EQ )\{
7176             pNew->pNext = pScan->pEq;
7177             pScan->pEq = pNew;
7178           \}\textcolor{keywordflow}{else}\{
7179             pNew->bRange = 1;
7180             pNew->pNext = pScan->pRange;
7181             pScan->pRange = pNew;
7182           \}
7183         \}
7184         n++;
7185         pIdxInfo->aConstraintUsage[i].argvIndex = n;
7186       \}
7187     \}
7188 
7189     \textcolor{comment}{/* Add the ORDER BY to the IdxScan object */}
7190     \textcolor{keywordflow}{for}(i=pIdxInfo->nOrderBy-1; i>=0; i--)\{
7191       \textcolor{keywordtype}{int} iCol = pIdxInfo->aOrderBy[i].iColumn;
7192       \textcolor{keywordflow}{if}( iCol>=0 )\{
7193         IdxConstraint *pNew = idxNewConstraint(&rc, p->pTab->aCol[iCol].zColl);
7194         \textcolor{keywordflow}{if}( pNew )\{
7195           pNew->iCol = iCol;
7196           pNew->bDesc = pIdxInfo->aOrderBy[i].desc;
7197           pNew->pNext = pScan->pOrder;
7198           pNew->pLink = pScan->pOrder;
7199           pScan->pOrder = pNew;
7200           n++;
7201         \}
7202       \}
7203     \}
7204   \}
7205 
7206   pIdxInfo->estimatedCost = 1000000.0 / (n+1);
7207   \textcolor{keywordflow}{return} rc;
7208 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a794fae5ac4fe40a87cbfe62f946a0e58}} 
\index{shell.\+c@{shell.\+c}!expert\+Close@{expert\+Close}}
\index{expert\+Close@{expert\+Close}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Close()}
{\footnotesize\ttfamily static int expert\+Close (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7238 of file shell.\+c.



References Expert\+Csr\+::p\+Data, sqlite3\+\_\+finalize, sqlite3\+\_\+free, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by idx\+Register\+Vtab().


\begin{DoxyCode}
7238                                                 \{
7239   ExpertCsr *pCsr = (ExpertCsr*)cur;
7240   sqlite3_finalize(pCsr->pData);
7241   sqlite3_free(pCsr);
7242   \textcolor{keywordflow}{return} SQLITE_OK;
7243 \}
\end{DoxyCode}
\mbox{\label{shell_8c_abd3c045fcd806e0d9372eb8a0322227a}} 
\index{shell.\+c@{shell.\+c}!expert\+Column@{expert\+Column}}
\index{expert\+Column@{expert\+Column}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Column()}
{\footnotesize\ttfamily static int expert\+Column (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur,  }\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{ctx,  }\item[{int}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7287 of file shell.\+c.



References Expert\+Csr\+::p\+Data, sqlite3\+\_\+column\+\_\+value, sqlite3\+\_\+result\+\_\+value, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by idx\+Register\+Vtab().


\begin{DoxyCode}
7287                                                                               \{
7288   ExpertCsr *pCsr = (ExpertCsr*)cur;
7289   sqlite3_value *pVal;
7290   pVal = sqlite3_column_value(pCsr->pData, i);
7291   \textcolor{keywordflow}{if}( pVal )\{
7292     sqlite3_result_value(ctx, pVal);
7293   \}
7294   \textcolor{keywordflow}{return} SQLITE_OK;
7295 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a98e84d3e375f92a22b69a558c06dab0d}} 
\index{shell.\+c@{shell.\+c}!expert\+Connect@{expert\+Connect}}
\index{expert\+Connect@{expert\+Connect}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Connect()}
{\footnotesize\ttfamily static int expert\+Connect (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{void $\ast$}]{p\+Aux,  }\item[{int}]{argc,  }\item[{const char $\ast$const $\ast$}]{argv,  }\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$$\ast$}]{pp\+Vtab,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7101 of file shell.\+c.



References expert\+Dequote(), idx\+Malloc(), Expert\+Vtab\+::p\+Expert, Expert\+Vtab\+::p\+Tab, sqlite3expert\+::p\+Table, sqlite3\+\_\+declare\+\_\+vtab, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+stricmp, S\+Q\+L\+I\+T\+E\+\_\+\+E\+R\+R\+OR, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and Idx\+Table\+::z\+Name.



Referenced by idx\+Register\+Vtab().


\begin{DoxyCode}
7107  \{
7108   sqlite3expert *pExpert = (sqlite3expert*)pAux;
7109   ExpertVtab *p = 0;
7110   \textcolor{keywordtype}{int} rc;
7111 
7112   \textcolor{keywordflow}{if}( argc!=4 )\{
7113     *pzErr = sqlite3_mprintf(\textcolor{stringliteral}{"internal error!"});
7114     rc = SQLITE_ERROR;
7115   \}\textcolor{keywordflow}{else}\{
7116     \textcolor{keywordtype}{char} *zCreateTable = expertDequote(argv[3]);
7117     \textcolor{keywordflow}{if}( zCreateTable )\{
7118       rc = sqlite3_declare_vtab(db, zCreateTable);
7119       \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7120         p = idxMalloc(&rc, \textcolor{keyword}{sizeof}(ExpertVtab));
7121       \}
7122       \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7123         p->pExpert = pExpert;
7124         p->pTab = pExpert->pTable;
7125         assert( sqlite3_stricmp(p->pTab->zName, argv[2])==0 );
7126       \}
7127       sqlite3_free(zCreateTable);
7128     \}\textcolor{keywordflow}{else}\{
7129       rc = SQLITE_NOMEM;
7130     \}
7131   \}
7132 
7133   *ppVtab = (sqlite3_vtab*)p;
7134   \textcolor{keywordflow}{return} rc;
7135 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aa3223104fda8d1491832d6e08fea83a9}} 
\index{shell.\+c@{shell.\+c}!expert\+Dequote@{expert\+Dequote}}
\index{expert\+Dequote@{expert\+Dequote}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Dequote()}
{\footnotesize\ttfamily static char$\ast$ expert\+Dequote (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+In }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7069 of file shell.\+c.



References sqlite3\+\_\+malloc, and S\+T\+R\+L\+EN.



Referenced by expert\+Connect().


\begin{DoxyCode}
7069                                            \{
7070   \textcolor{keywordtype}{int} n = STRLEN(zIn);
7071   \textcolor{keywordtype}{char} *zRet = sqlite3_malloc(n);
7072 
7073   assert( zIn[0]==\textcolor{charliteral}{'\(\backslash\)''} );
7074   assert( zIn[n-1]==\textcolor{charliteral}{'\(\backslash\)''} );
7075 
7076   \textcolor{keywordflow}{if}( zRet )\{
7077     \textcolor{keywordtype}{int} iOut = 0;
7078     \textcolor{keywordtype}{int} iIn = 0;
7079     \textcolor{keywordflow}{for}(iIn=1; iIn<(n-1); iIn++)\{
7080       \textcolor{keywordflow}{if}( zIn[iIn]==\textcolor{charliteral}{'\(\backslash\)''} )\{
7081         assert( zIn[iIn+1]==\textcolor{charliteral}{'\(\backslash\)''} );
7082         iIn++;
7083       \}
7084       zRet[iOut++] = zIn[iIn];
7085     \}
7086     zRet[iOut] = \textcolor{charliteral}{'\(\backslash\)0'};
7087   \}
7088 
7089   \textcolor{keywordflow}{return} zRet;
7090 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aaa7c792ff9f354b2d2e2b3a92201ec1e}} 
\index{shell.\+c@{shell.\+c}!expert\+Disconnect@{expert\+Disconnect}}
\index{expert\+Disconnect@{expert\+Disconnect}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Disconnect()}
{\footnotesize\ttfamily static int expert\+Disconnect (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$}]{p\+Vtab }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7137 of file shell.\+c.



References sqlite3\+\_\+free, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by idx\+Register\+Vtab().


\begin{DoxyCode}
7137                                                 \{
7138   ExpertVtab *p = (ExpertVtab*)pVtab;
7139   sqlite3_free(p);
7140   \textcolor{keywordflow}{return} SQLITE_OK;
7141 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a42ac27058e51135f2c677fe4ec766aeb}} 
\index{shell.\+c@{shell.\+c}!expert\+Dot\+Command@{expert\+Dot\+Command}}
\index{expert\+Dot\+Command@{expert\+Dot\+Command}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Dot\+Command()}
{\footnotesize\ttfamily static int expert\+Dot\+Command (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p\+State,  }\item[{char $\ast$$\ast$}]{az\+Arg,  }\item[{int}]{n\+Arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11526 of file shell.\+c.



References Expert\+Info\+::b\+Verbose, Shell\+State\+::db, Shell\+State\+::expert, E\+X\+P\+E\+R\+T\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+S\+A\+M\+P\+LE, integer\+Value(), Expert\+Info\+::p\+Expert, raw\+\_\+printf, sqlite3\+\_\+expert\+\_\+config(), sqlite3\+\_\+expert\+\_\+new(), S\+Q\+L\+I\+T\+E\+\_\+\+E\+R\+R\+OR, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and strlen30().



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
11530  \{
11531   \textcolor{keywordtype}{int} rc = SQLITE_OK;
11532   \textcolor{keywordtype}{char} *zErr = 0;
11533   \textcolor{keywordtype}{int} i;
11534   \textcolor{keywordtype}{int} iSample = 0;
11535 
11536   assert( pState->expert.pExpert==0 );
11537   memset(&pState->expert, 0, \textcolor{keyword}{sizeof}(ExpertInfo));
11538 
11539   \textcolor{keywordflow}{for}(i=1; rc==SQLITE_OK && i<nArg; i++)\{
11540     \textcolor{keywordtype}{char} *z = azArg[i];
11541     \textcolor{keywordtype}{int} n;
11542     \textcolor{keywordflow}{if}( z[0]==\textcolor{charliteral}{'-'} && z[1]==\textcolor{charliteral}{'-'} ) z++;
11543     n = strlen30(z);
11544     \textcolor{keywordflow}{if}( n>=2 && 0==strncmp(z, \textcolor{stringliteral}{"-verbose"}, n) )\{
11545       pState->expert.bVerbose = 1;
11546     \}
11547     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( n>=2 && 0==strncmp(z, \textcolor{stringliteral}{"-sample"}, n) )\{
11548       \textcolor{keywordflow}{if}( i==(nArg-1) )\{
11549         raw_printf(stderr, \textcolor{stringliteral}{"option requires an argument: %s\(\backslash\)n"}, z);
11550         rc = SQLITE_ERROR;
11551       \}\textcolor{keywordflow}{else}\{
11552         iSample = (int)integerValue(azArg[++i]);
11553         \textcolor{keywordflow}{if}( iSample<0 || iSample>100 )\{
11554           raw_printf(stderr, \textcolor{stringliteral}{"value out of range: %s\(\backslash\)n"}, azArg[i]);
11555           rc = SQLITE_ERROR;
11556         \}
11557       \}
11558     \}
11559     \textcolor{keywordflow}{else}\{
11560       raw_printf(stderr, \textcolor{stringliteral}{"unknown option: %s\(\backslash\)n"}, z);
11561       rc = SQLITE_ERROR;
11562     \}
11563   \}
11564 
11565   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
11566     pState->expert.pExpert = sqlite3_expert_new(pState->db, &zErr);
11567     \textcolor{keywordflow}{if}( pState->expert.pExpert==0 )\{
11568       raw_printf(stderr, \textcolor{stringliteral}{"sqlite3\_expert\_new: %s\(\backslash\)n"}, zErr);
11569       rc = SQLITE_ERROR;
11570     \}\textcolor{keywordflow}{else}\{
11571       sqlite3_expert_config(
11572           pState->expert.pExpert, EXPERT_CONFIG_SAMPLE, iSample
11573       );
11574     \}
11575   \}
11576 
11577   \textcolor{keywordflow}{return} rc;
11578 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a2983598a5958896552e0ee6a4bbfa729}} 
\index{shell.\+c@{shell.\+c}!expert\+Eof@{expert\+Eof}}
\index{expert\+Eof@{expert\+Eof}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Eof()}
{\footnotesize\ttfamily static int expert\+Eof (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7251 of file shell.\+c.



References Expert\+Csr\+::p\+Data.



Referenced by idx\+Register\+Vtab().


\begin{DoxyCode}
7251                                               \{
7252   ExpertCsr *pCsr = (ExpertCsr*)cur;
7253   \textcolor{keywordflow}{return} pCsr->pData==0;
7254 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a8c6def881fac08b3292406c7b9b444aa}} 
\index{shell.\+c@{shell.\+c}!expert\+Filter@{expert\+Filter}}
\index{expert\+Filter@{expert\+Filter}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Filter()}
{\footnotesize\ttfamily static int expert\+Filter (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur,  }\item[{int}]{idx\+Num,  }\item[{const char $\ast$}]{idx\+Str,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7300 of file shell.\+c.



References Expert\+Vtab\+::base, sqlite3expert\+::db, expert\+Next(), idx\+Printf\+Prepare\+Stmt(), Expert\+Csr\+::p\+Data, Expert\+Vtab\+::p\+Expert, Expert\+Vtab\+::p\+Tab, sqlite3\+\_\+vtab\+\_\+cursor\+::p\+Vtab, sqlite3\+\_\+finalize, S\+Q\+L\+I\+T\+E\+\_\+\+OK, sqlite3\+\_\+vtab\+::z\+Err\+Msg, and Idx\+Table\+::z\+Name.



Referenced by idx\+Register\+Vtab().


\begin{DoxyCode}
7304  \{
7305   ExpertCsr *pCsr = (ExpertCsr*)cur;
7306   ExpertVtab *pVtab = (ExpertVtab*)(cur->pVtab);
7307   sqlite3expert *pExpert = pVtab->pExpert;
7308   \textcolor{keywordtype}{int} rc;
7309 
7310   (void)idxNum;
7311   (void)idxStr;
7312   (void)argc;
7313   (void)argv;
7314   rc = sqlite3_finalize(pCsr->pData);
7315   pCsr->pData = 0;
7316   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7317     rc = idxPrintfPrepareStmt(pExpert->db, &pCsr->pData, &pVtab->base.zErrMsg,
7318         \textcolor{stringliteral}{"SELECT * FROM main.%Q WHERE sample()"}, pVtab->pTab->zName
7319     );
7320   \}
7321 
7322   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7323     rc = expertNext(cur);
7324   \}
7325   \textcolor{keywordflow}{return} rc;
7326 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a4500e73617e6b814e236d544107a7ddf}} 
\index{shell.\+c@{shell.\+c}!expert\+Finish@{expert\+Finish}}
\index{expert\+Finish@{expert\+Finish}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Finish()}
{\footnotesize\ttfamily static int expert\+Finish (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p\+State,  }\item[{int}]{b\+Cancel,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11481 of file shell.\+c.



References Expert\+Info\+::b\+Verbose, Shell\+State\+::expert, E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+C\+A\+N\+D\+I\+D\+A\+T\+ES, E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+I\+N\+D\+E\+X\+ES, E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+P\+L\+AN, E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+S\+QL, Shell\+State\+::out, Expert\+Info\+::p\+Expert, raw\+\_\+printf, sqlite3\+\_\+expert\+\_\+analyze(), sqlite3\+\_\+expert\+\_\+count(), sqlite3\+\_\+expert\+\_\+destroy(), sqlite3\+\_\+expert\+\_\+report(), and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by do\+\_\+meta\+\_\+command(), and shell\+\_\+exec().


\begin{DoxyCode}
11485  \{
11486   \textcolor{keywordtype}{int} rc = SQLITE_OK;
11487   sqlite3expert *p = pState->expert.pExpert;
11488   assert( p );
11489   assert( bCancel || pzErr==0 || *pzErr==0 );
11490   \textcolor{keywordflow}{if}( bCancel==0 )\{
11491     FILE *out = pState->out;
11492     \textcolor{keywordtype}{int} bVerbose = pState->expert.bVerbose;
11493 
11494     rc = sqlite3_expert_analyze(p, pzErr);
11495     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
11496       \textcolor{keywordtype}{int} nQuery = sqlite3_expert_count(p);
11497       \textcolor{keywordtype}{int} i;
11498 
11499       \textcolor{keywordflow}{if}( bVerbose )\{
11500         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCand = sqlite3_expert_report(p,0,EXPERT_REPORT_CANDIDATES);
11501         raw_printf(out, \textcolor{stringliteral}{"-- Candidates -----------------------------\(\backslash\)n"});
11502         raw_printf(out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, zCand);
11503       \}
11504       \textcolor{keywordflow}{for}(i=0; i<nQuery; i++)\{
11505         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql = sqlite3_expert_report(p, i, EXPERT_REPORT_SQL);
11506         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zIdx = sqlite3_expert_report(p, i, EXPERT_REPORT_INDEXES);
11507         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zEQP = sqlite3_expert_report(p, i, EXPERT_REPORT_PLAN);
11508         \textcolor{keywordflow}{if}( zIdx==0 ) zIdx = \textcolor{stringliteral}{"(no new indexes)\(\backslash\)n"};
11509         \textcolor{keywordflow}{if}( bVerbose )\{
11510           raw_printf(out, \textcolor{stringliteral}{"-- Query %d --------------------------------\(\backslash\)n"},i+1);
11511           raw_printf(out, \textcolor{stringliteral}{"%s\(\backslash\)n\(\backslash\)n"}, zSql);
11512         \}
11513         raw_printf(out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, zIdx);
11514         raw_printf(out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, zEQP);
11515       \}
11516     \}
11517   \}
11518   sqlite3_expert_destroy(p);
11519   pState->expert.pExpert = 0;
11520   \textcolor{keywordflow}{return} rc;
11521 \}
\end{DoxyCode}
\mbox{\label{shell_8c_afac74af8953466f3f02cd6d57cbe8504}} 
\index{shell.\+c@{shell.\+c}!expert\+Handle\+S\+QL@{expert\+Handle\+S\+QL}}
\index{expert\+Handle\+S\+QL@{expert\+Handle\+S\+QL}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Handle\+S\+Q\+L()}
{\footnotesize\ttfamily static int expert\+Handle\+S\+QL (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p\+State,  }\item[{const char $\ast$}]{z\+Sql,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11461 of file shell.\+c.



References Shell\+State\+::expert, Expert\+Info\+::p\+Expert, and sqlite3\+\_\+expert\+\_\+sql().



Referenced by shell\+\_\+exec().


\begin{DoxyCode}
11465  \{
11466   assert( pState->expert.pExpert );
11467   assert( pzErr==0 || *pzErr==0 );
11468   \textcolor{keywordflow}{return} sqlite3_expert_sql(pState->expert.pExpert, zSql, pzErr);
11469 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a680204caf9ee77bf5affe1c56ed997c4}} 
\index{shell.\+c@{shell.\+c}!expert\+Next@{expert\+Next}}
\index{expert\+Next@{expert\+Next}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Next()}
{\footnotesize\ttfamily static int expert\+Next (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7259 of file shell.\+c.



References Expert\+Csr\+::p\+Data, sqlite3\+\_\+finalize, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW.



Referenced by expert\+Filter(), and idx\+Register\+Vtab().


\begin{DoxyCode}
7259                                                \{
7260   ExpertCsr *pCsr = (ExpertCsr*)cur;
7261   \textcolor{keywordtype}{int} rc = SQLITE_OK;
7262 
7263   assert( pCsr->pData );
7264   rc = sqlite3_step(pCsr->pData);
7265   \textcolor{keywordflow}{if}( rc!=SQLITE_ROW )\{
7266     rc = sqlite3_finalize(pCsr->pData);
7267     pCsr->pData = 0;
7268   \}\textcolor{keywordflow}{else}\{
7269     rc = SQLITE_OK;
7270   \}
7271 
7272   \textcolor{keywordflow}{return} rc;
7273 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a9e59dadc8de59b5ada8e57b111c2ff83}} 
\index{shell.\+c@{shell.\+c}!expert\+Open@{expert\+Open}}
\index{expert\+Open@{expert\+Open}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Open()}
{\footnotesize\ttfamily static int expert\+Open (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$}]{p\+V\+Tab,  }\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$$\ast$}]{pp\+Cursor }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7226 of file shell.\+c.



References idx\+Malloc(), and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by idx\+Register\+Vtab().


\begin{DoxyCode}
7226                                                                           \{
7227   \textcolor{keywordtype}{int} rc = SQLITE_OK;
7228   ExpertCsr *pCsr;
7229   (void)pVTab;
7230   pCsr = idxMalloc(&rc, \textcolor{keyword}{sizeof}(ExpertCsr));
7231   *ppCursor = (sqlite3_vtab_cursor*)pCsr;
7232   \textcolor{keywordflow}{return} rc;
7233 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae0f9f25fbbdbf7a84f832a117aec2fe3}} 
\index{shell.\+c@{shell.\+c}!expert\+Rowid@{expert\+Rowid}}
\index{expert\+Rowid@{expert\+Rowid}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Rowid()}
{\footnotesize\ttfamily static int expert\+Rowid (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur,  }\item[{\textbf{ sqlite\+\_\+int64} $\ast$}]{p\+Rowid }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7278 of file shell.\+c.



References S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by idx\+Register\+Vtab().


\begin{DoxyCode}
7278                                                                       \{
7279   (void)cur;
7280   *pRowid = 0;
7281   \textcolor{keywordflow}{return} SQLITE_OK;
7282 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ada8da8c2242c93ca2a694ca02abf311c}} 
\index{shell.\+c@{shell.\+c}!expert\+Update@{expert\+Update}}
\index{expert\+Update@{expert\+Update}!shell.\+c@{shell.\+c}}
\subsubsection{expert\+Update()}
{\footnotesize\ttfamily static int expert\+Update (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$}]{p\+Vtab,  }\item[{int}]{n\+Data,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{az\+Data,  }\item[{\textbf{ sqlite\+\_\+int64} $\ast$}]{p\+Rowid }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7210 of file shell.\+c.



References S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by idx\+Register\+Vtab().


\begin{DoxyCode}
7215  \{
7216   (void)pVtab;
7217   (void)nData;
7218   (void)azData;
7219   (void)pRowid;
7220   \textcolor{keywordflow}{return} SQLITE_OK;
7221 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a258b459b941f938c21374dfad28bb2fe}} 
\index{shell.\+c@{shell.\+c}!explain\+\_\+data\+\_\+delete@{explain\+\_\+data\+\_\+delete}}
\index{explain\+\_\+data\+\_\+delete@{explain\+\_\+data\+\_\+delete}!shell.\+c@{shell.\+c}}
\subsubsection{explain\+\_\+data\+\_\+delete()}
{\footnotesize\ttfamily static void explain\+\_\+data\+\_\+delete (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11289 of file shell.\+c.



References Shell\+State\+::ai\+Indent, Shell\+State\+::i\+Indent, Shell\+State\+::n\+Indent, and sqlite3\+\_\+free.



Referenced by shell\+\_\+exec().


\begin{DoxyCode}
11289                                               \{
11290   sqlite3_free(p->aiIndent);
11291   p->aiIndent = 0;
11292   p->nIndent = 0;
11293   p->iIndent = 0;
11294 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab3d16510062eb32cbb278eaf8d92bf40}} 
\index{shell.\+c@{shell.\+c}!explain\+\_\+data\+\_\+prepare@{explain\+\_\+data\+\_\+prepare}}
\index{explain\+\_\+data\+\_\+prepare@{explain\+\_\+data\+\_\+prepare}!shell.\+c@{shell.\+c}}
\subsubsection{explain\+\_\+data\+\_\+prepare()}
{\footnotesize\ttfamily static void explain\+\_\+data\+\_\+prepare (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$}]{p\+Sql }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11206 of file shell.\+c.



References Shell\+State\+::ai\+Indent, Array\+Size, Shell\+State\+::c\+Mode, Shell\+State\+::i\+Indent, Shell\+State\+::mode, Shell\+State\+::n\+Indent, shell\+\_\+out\+\_\+of\+\_\+memory(), sqlite3\+\_\+column\+\_\+count, sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+column\+\_\+name, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+free, sqlite3\+\_\+realloc64, sqlite3\+\_\+reset, sqlite3\+\_\+sql, sqlite3\+\_\+step, sqlite3\+\_\+strnicmp, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, and str\+\_\+in\+\_\+array().



Referenced by shell\+\_\+exec().


\begin{DoxyCode}
11206                                                                    \{
11207   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql;               \textcolor{comment}{/* The text of the SQL statement */}
11208   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z;                  \textcolor{comment}{/* Used to check if this is an EXPLAIN */}
11209   \textcolor{keywordtype}{int} *abYield = 0;               \textcolor{comment}{/* True if op is an OP\_Yield */}
11210   \textcolor{keywordtype}{int} nAlloc = 0;                 \textcolor{comment}{/* Allocated size of p->aiIndent[], abYield */}
11211   \textcolor{keywordtype}{int} iOp;                        \textcolor{comment}{/* Index of operation in p->aiIndent[] */}
11212 
11213   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *azNext[] = \{ \textcolor{stringliteral}{"Next"}, \textcolor{stringliteral}{"Prev"}, \textcolor{stringliteral}{"VPrev"}, \textcolor{stringliteral}{"VNext"}, \textcolor{stringliteral}{"SorterNext"}, 0 \};
11214   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *azYield[] = \{ \textcolor{stringliteral}{"Yield"}, \textcolor{stringliteral}{"SeekLT"}, \textcolor{stringliteral}{"SeekGT"}, \textcolor{stringliteral}{"RowSetRead"},
11215                             \textcolor{stringliteral}{"Rewind"}, 0 \};
11216   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *azGoto[] = \{ \textcolor{stringliteral}{"Goto"}, 0 \};
11217 
11218   \textcolor{comment}{/* Try to figure out if this is really an EXPLAIN statement. If this}
11219 \textcolor{comment}{  ** cannot be verified, return early.  */}
11220   \textcolor{keywordflow}{if}( sqlite3_column_count(pSql)!=8 )\{
11221     p->cMode = p->mode;
11222     \textcolor{keywordflow}{return};
11223   \}
11224   zSql = sqlite3_sql(pSql);
11225   \textcolor{keywordflow}{if}( zSql==0 ) \textcolor{keywordflow}{return};
11226   \textcolor{keywordflow}{for}(z=zSql; *z==\textcolor{charliteral}{' '} || *z==\textcolor{charliteral}{'\(\backslash\)t'} || *z==\textcolor{charliteral}{'\(\backslash\)n'} || *z==\textcolor{charliteral}{'\(\backslash\)f'} || *z==\textcolor{charliteral}{'\(\backslash\)r'}; z++);
11227   \textcolor{keywordflow}{if}( sqlite3_strnicmp(z, \textcolor{stringliteral}{"explain"}, 7) )\{
11228     p->cMode = p->mode;
11229     \textcolor{keywordflow}{return};
11230   \}
11231 
11232   \textcolor{keywordflow}{for}(iOp=0; SQLITE_ROW==sqlite3_step(pSql); iOp++)\{
11233     \textcolor{keywordtype}{int} i;
11234     \textcolor{keywordtype}{int} iAddr = sqlite3_column_int(pSql, 0);
11235     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zOp = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSql, 1);
11236 
11237     \textcolor{comment}{/* Set p2 to the P2 field of the current opcode. Then, assuming that}
11238 \textcolor{comment}{    ** p2 is an instruction address, set variable p2op to the index of that}
11239 \textcolor{comment}{    ** instruction in the aiIndent[] array. p2 and p2op may be different if}
11240 \textcolor{comment}{    ** the current instruction is part of a sub-program generated by an}
11241 \textcolor{comment}{    ** SQL trigger or foreign key.  */}
11242     \textcolor{keywordtype}{int} p2 = sqlite3_column_int(pSql, 3);
11243     \textcolor{keywordtype}{int} p2op = (p2 + (iOp-iAddr));
11244 
11245     \textcolor{comment}{/* Grow the p->aiIndent array as required */}
11246     \textcolor{keywordflow}{if}( iOp>=nAlloc )\{
11247       \textcolor{keywordflow}{if}( iOp==0 )\{
11248         \textcolor{comment}{/* Do further verfication that this is explain output.  Abort if}
11249 \textcolor{comment}{        ** it is not */}
11250         \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *explainCols[] = \{
11251            \textcolor{stringliteral}{"addr"}, \textcolor{stringliteral}{"opcode"}, \textcolor{stringliteral}{"p1"}, \textcolor{stringliteral}{"p2"}, \textcolor{stringliteral}{"p3"}, \textcolor{stringliteral}{"p4"}, \textcolor{stringliteral}{"p5"}, \textcolor{stringliteral}{"comment"} \};
11252         \textcolor{keywordtype}{int} jj;
11253         \textcolor{keywordflow}{for}(jj=0; jj<ArraySize(explainCols); jj++)\{
11254           \textcolor{keywordflow}{if}( strcmp(sqlite3_column_name(pSql,jj),explainCols[jj])!=0 )\{
11255             p->cMode = p->mode;
11256             sqlite3_reset(pSql);
11257             \textcolor{keywordflow}{return};
11258           \}
11259         \}
11260       \}
11261       nAlloc += 100;
11262       p->aiIndent = (\textcolor{keywordtype}{int}*)sqlite3_realloc64(p->aiIndent, nAlloc*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
11263       \textcolor{keywordflow}{if}( p->aiIndent==0 ) shell_out_of_memory();
11264       abYield = (\textcolor{keywordtype}{int}*)sqlite3_realloc64(abYield, nAlloc*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
11265       \textcolor{keywordflow}{if}( abYield==0 ) shell_out_of_memory();
11266     \}
11267     abYield[iOp] = str_in_array(zOp, azYield);
11268     p->aiIndent[iOp] = 0;
11269     p->nIndent = iOp+1;
11270 
11271     \textcolor{keywordflow}{if}( str_in_array(zOp, azNext) )\{
11272       \textcolor{keywordflow}{for}(i=p2op; i<iOp; i++) p->aiIndent[i] += 2;
11273     \}
11274     \textcolor{keywordflow}{if}( str_in_array(zOp, azGoto) && p2op<p->nIndent
11275      && (abYield[p2op] || sqlite3_column_int(pSql, 2))
11276     )\{
11277       \textcolor{keywordflow}{for}(i=p2op; i<iOp; i++) p->aiIndent[i] += 2;
11278     \}
11279   \}
11280 
11281   p->iIndent = 0;
11282   sqlite3_free(abYield);
11283   sqlite3_reset(pSql);
11284 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a2a428f54866d56810df612c425015fc7}} 
\index{shell.\+c@{shell.\+c}!file\+Link\+Stat@{file\+Link\+Stat}}
\index{file\+Link\+Stat@{file\+Link\+Stat}!shell.\+c@{shell.\+c}}
\subsubsection{file\+Link\+Stat()}
{\footnotesize\ttfamily static int file\+Link\+Stat (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Path,  }\item[{struct stat $\ast$}]{p\+Stat\+Buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2311 of file shell.\+c.



Referenced by fsdir\+Filter(), and fsdir\+Next().


\begin{DoxyCode}
2314  \{
2315 \textcolor{preprocessor}{#if defined(\_WIN32)}
2316   \textcolor{keywordtype}{int} rc = lstat(zPath, pStatBuf);
2317   \textcolor{keywordflow}{if}( rc==0 ) statTimesToUtc(zPath, pStatBuf);
2318   \textcolor{keywordflow}{return} rc;
2319 \textcolor{preprocessor}{#else}
2320   \textcolor{keywordflow}{return} lstat(zPath, pStatBuf);
2321 \textcolor{preprocessor}{#endif}
2322 \}
\end{DoxyCode}
\mbox{\label{shell_8c_af362c30b9b646f78669291ed4728039b}} 
\index{shell.\+c@{shell.\+c}!file\+Stat@{file\+Stat}}
\index{file\+Stat@{file\+Stat}!shell.\+c@{shell.\+c}}
\subsubsection{file\+Stat()}
{\footnotesize\ttfamily static int file\+Stat (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Path,  }\item[{struct stat $\ast$}]{p\+Stat\+Buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2293 of file shell.\+c.



Referenced by make\+Directory(), and write\+File().


\begin{DoxyCode}
2296  \{
2297 \textcolor{preprocessor}{#if defined(\_WIN32)}
2298   \textcolor{keywordtype}{int} rc = stat(zPath, pStatBuf);
2299   \textcolor{keywordflow}{if}( rc==0 ) statTimesToUtc(zPath, pStatBuf);
2300   \textcolor{keywordflow}{return} rc;
2301 \textcolor{preprocessor}{#else}
2302   \textcolor{keywordflow}{return} stat(zPath, pStatBuf);
2303 \textcolor{preprocessor}{#endif}
2304 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a18a3937e4fe6e0e0ceb97f6547058df3}} 
\index{shell.\+c@{shell.\+c}!find\+\_\+home\+\_\+dir@{find\+\_\+home\+\_\+dir}}
\index{find\+\_\+home\+\_\+dir@{find\+\_\+home\+\_\+dir}!shell.\+c@{shell.\+c}}
\subsubsection{find\+\_\+home\+\_\+dir()}
{\footnotesize\ttfamily static char$\ast$ find\+\_\+home\+\_\+dir (\begin{DoxyParamCaption}\item[{int}]{clear\+Flag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18419 of file shell.\+c.



References sqlite3\+\_\+snprintf, and strlen30().



Referenced by main(), and process\+\_\+sqliterc().


\begin{DoxyCode}
18419                                          \{
18420   \textcolor{keyword}{static} \textcolor{keywordtype}{char} *home\_dir = NULL;
18421   \textcolor{keywordflow}{if}( clearFlag )\{
18422     free(home\_dir);
18423     home\_dir = 0;
18424     \textcolor{keywordflow}{return} 0;
18425   \}
18426   \textcolor{keywordflow}{if}( home\_dir ) \textcolor{keywordflow}{return} home\_dir;
18427 
18428 \textcolor{preprocessor}{#if !defined(\_WIN32) && !defined(WIN32) && !defined(\_WIN32\_WCE) \(\backslash\)}
18429 \textcolor{preprocessor}{     && !defined(\_\_RTP\_\_) && !defined(\_WRS\_KERNEL)}
18430   \{
18431     \textcolor{keyword}{struct }passwd *pwent;
18432     uid\_t uid = getuid();
18433     \textcolor{keywordflow}{if}( (pwent=getpwuid(uid)) != NULL) \{
18434       home\_dir = pwent->pw\_dir;
18435     \}
18436   \}
18437 \textcolor{preprocessor}{#endif}
18438 
18439 \textcolor{preprocessor}{#if defined(\_WIN32\_WCE)}
18440   \textcolor{comment}{/* Windows CE (arm-wince-mingw32ce-gcc) does not provide getenv()}
18441 \textcolor{comment}{   */}
18442   home\_dir = \textcolor{stringliteral}{"/"};
18443 \textcolor{preprocessor}{#else}
18444 
18445 \textcolor{preprocessor}{#if defined(\_WIN32) || defined(WIN32)}
18446   \textcolor{keywordflow}{if} (!home\_dir) \{
18447     home\_dir = getenv(\textcolor{stringliteral}{"USERPROFILE"});
18448   \}
18449 \textcolor{preprocessor}{#endif}
18450 
18451   \textcolor{keywordflow}{if} (!home\_dir) \{
18452     home\_dir = getenv(\textcolor{stringliteral}{"HOME"});
18453   \}
18454 
18455 \textcolor{preprocessor}{#if defined(\_WIN32) || defined(WIN32)}
18456   \textcolor{keywordflow}{if} (!home\_dir) \{
18457     \textcolor{keywordtype}{char} *zDrive, *zPath;
18458     \textcolor{keywordtype}{int} n;
18459     zDrive = getenv(\textcolor{stringliteral}{"HOMEDRIVE"});
18460     zPath = getenv(\textcolor{stringliteral}{"HOMEPATH"});
18461     \textcolor{keywordflow}{if}( zDrive && zPath )\{
18462       n = strlen30(zDrive) + strlen30(zPath) + 1;
18463       home\_dir = malloc( n );
18464       \textcolor{keywordflow}{if}( home\_dir==0 ) \textcolor{keywordflow}{return} 0;
18465       sqlite3_snprintf(n, home\_dir, \textcolor{stringliteral}{"%s%s"}, zDrive, zPath);
18466       \textcolor{keywordflow}{return} home\_dir;
18467     \}
18468     home\_dir = \textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)"};
18469   \}
18470 \textcolor{preprocessor}{#endif}
18471 
18472 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !\_WIN32\_WCE */}\textcolor{preprocessor}{}
18473 
18474   \textcolor{keywordflow}{if}( home\_dir )\{
18475     \textcolor{keywordtype}{int} n = strlen30(home\_dir) + 1;
18476     \textcolor{keywordtype}{char} *z = malloc( n );
18477     \textcolor{keywordflow}{if}( z ) memcpy(z, home\_dir, n);
18478     home\_dir = z;
18479   \}
18480 
18481   \textcolor{keywordflow}{return} home\_dir;
18482 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ac645ef6c1d815f2daa6d645e1c7d576c}} 
\index{shell.\+c@{shell.\+c}!free\+Column\+List@{free\+Column\+List}}
\index{free\+Column\+List@{free\+Column\+List}!shell.\+c@{shell.\+c}}
\subsubsection{free\+Column\+List()}
{\footnotesize\ttfamily static void free\+Column\+List (\begin{DoxyParamCaption}\item[{char $\ast$$\ast$}]{az\+Col }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11746 of file shell.\+c.



References sqlite3\+\_\+free.



Referenced by dump\+\_\+callback(), and table\+Column\+List().


\begin{DoxyCode}
11746                                         \{
11747   \textcolor{keywordtype}{int} i;
11748   \textcolor{keywordflow}{for}(i=1; azCol[i]; i++)\{
11749     sqlite3_free(azCol[i]);
11750   \}
11751   \textcolor{comment}{/* azCol[0] is a static string */}
11752   sqlite3_free(azCol);
11753 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a27b10d265df7db8e27c7e538e8454d76}} 
\index{shell.\+c@{shell.\+c}!free\+Text@{free\+Text}}
\index{free\+Text@{free\+Text}!shell.\+c@{shell.\+c}}
\subsubsection{free\+Text()}
{\footnotesize\ttfamily static void free\+Text (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+Text} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 737 of file shell.\+c.



References init\+Text(), and Shell\+Text\+::z.



Referenced by do\+\_\+meta\+\_\+command(), dump\+\_\+callback(), and shell\+Fake\+Schema().


\begin{DoxyCode}
737                                   \{
738   free(p->z);
739   initText(p);
740 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a45d3743ff5df4c3cf59a60b91af2e81e}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Best\+Index@{fsdir\+Best\+Index}}
\index{fsdir\+Best\+Index@{fsdir\+Best\+Index}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Best\+Index()}
{\footnotesize\ttfamily static int fsdir\+Best\+Index (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$}]{tab,  }\item[{\textbf{ sqlite3\+\_\+index\+\_\+info} $\ast$}]{p\+Idx\+Info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2902 of file shell.\+c.



References sqlite3\+\_\+index\+\_\+info\+::a\+Constraint, sqlite3\+\_\+index\+\_\+info\+::a\+Constraint\+Usage, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+constraint\+\_\+usage\+::argv\+Index, sqlite3\+\_\+index\+\_\+info\+::estimated\+Cost, sqlite3\+\_\+index\+\_\+info\+::estimated\+Rows, F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+IR, F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+A\+TH, sqlite3\+\_\+index\+\_\+info\+::idx\+Num, sqlite3\+\_\+index\+\_\+info\+::n\+Constraint, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+constraint\+\_\+usage\+::omit, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+NT, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+N\+T\+\_\+\+EQ, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by fsdir\+Register().


\begin{DoxyCode}
2905  \{
2906   \textcolor{keywordtype}{int} i;                 \textcolor{comment}{/* Loop over constraints */}
2907   \textcolor{keywordtype}{int} idxPath = -1;      \textcolor{comment}{/* Index in pIdxInfo->aConstraint of PATH= */}
2908   \textcolor{keywordtype}{int} idxDir = -1;       \textcolor{comment}{/* Index in pIdxInfo->aConstraint of DIR= */}
2909   \textcolor{keywordtype}{int} seenPath = 0;      \textcolor{comment}{/* True if an unusable PATH= constraint is seen */}
2910   \textcolor{keywordtype}{int} seenDir = 0;       \textcolor{comment}{/* True if an unusable DIR= constraint is seen */}
2911   \textcolor{keyword}{const} \textcolor{keyword}{struct }sqlite3\_index\_constraint *pConstraint;
2912 
2913   (void)tab;
2914   pConstraint = pIdxInfo->aConstraint;
2915   \textcolor{keywordflow}{for}(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++)\{
2916     \textcolor{keywordflow}{if}( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) \textcolor{keywordflow}{continue};
2917     \textcolor{keywordflow}{switch}( pConstraint->iColumn )\{
2918       \textcolor{keywordflow}{case} FSDIR_COLUMN_PATH: \{
2919         \textcolor{keywordflow}{if}( pConstraint->usable )\{
2920           idxPath = i;
2921           seenPath = 0;
2922         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( idxPath<0 )\{
2923           seenPath = 1;
2924         \}
2925         \textcolor{keywordflow}{break};
2926       \}
2927       \textcolor{keywordflow}{case} FSDIR_COLUMN_DIR: \{
2928         \textcolor{keywordflow}{if}( pConstraint->usable )\{
2929           idxDir = i;
2930           seenDir = 0;
2931         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( idxDir<0 )\{
2932           seenDir = 1;
2933         \}
2934         \textcolor{keywordflow}{break};
2935       \}
2936     \} 
2937   \}
2938   \textcolor{keywordflow}{if}( seenPath || seenDir )\{
2939     \textcolor{comment}{/* If input parameters are unusable, disallow this plan */}
2940     \textcolor{keywordflow}{return} SQLITE_CONSTRAINT;
2941   \}
2942 
2943   \textcolor{keywordflow}{if}( idxPath<0 )\{
2944     pIdxInfo->idxNum = 0;
2945     \textcolor{comment}{/* The pIdxInfo->estimatedCost should have been initialized to a huge}
2946 \textcolor{comment}{    ** number.  Leave it unchanged. */}
2947     pIdxInfo->estimatedRows = 0x7fffffff;
2948   \}\textcolor{keywordflow}{else}\{
2949     pIdxInfo->aConstraintUsage[idxPath].omit = 1;
2950     pIdxInfo->aConstraintUsage[idxPath].argvIndex = 1;
2951     \textcolor{keywordflow}{if}( idxDir>=0 )\{
2952       pIdxInfo->aConstraintUsage[idxDir].omit = 1;
2953       pIdxInfo->aConstraintUsage[idxDir].argvIndex = 2;
2954       pIdxInfo->idxNum = 2;
2955       pIdxInfo->estimatedCost = 10.0;
2956     \}\textcolor{keywordflow}{else}\{
2957       pIdxInfo->idxNum = 1;
2958       pIdxInfo->estimatedCost = 100.0;
2959     \}
2960   \}
2961 
2962   \textcolor{keywordflow}{return} SQLITE_OK;
2963 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ac8c0b7b47369b8c3193edd370b0c2f60}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Close@{fsdir\+Close}}
\index{fsdir\+Close@{fsdir\+Close}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Close()}
{\footnotesize\ttfamily static int fsdir\+Close (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2673 of file shell.\+c.



References fsdir\+Reset\+Cursor(), sqlite3\+\_\+free, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by fsdir\+Register().


\begin{DoxyCode}
2673                                                \{
2674   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2675 
2676   fsdirResetCursor(pCur);
2677   sqlite3_free(pCur);
2678   \textcolor{keywordflow}{return} SQLITE_OK;
2679 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a50d346f5186444b90b2293d0121523e2}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Column@{fsdir\+Column}}
\index{fsdir\+Column@{fsdir\+Column}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Column()}
{\footnotesize\ttfamily static int fsdir\+Column (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur,  }\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{ctx,  }\item[{int}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2760 of file shell.\+c.



References F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+D\+A\+TA, F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+O\+DE, F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+M\+T\+I\+ME, F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+N\+A\+ME, F\+S\+D\+I\+R\+\_\+\+C\+O\+L\+U\+M\+N\+\_\+\+P\+A\+TH, fsdir\+\_\+cursor\+::n\+Base, read\+File\+Contents(), sqlite3\+\_\+free, sqlite3\+\_\+malloc64, sqlite3\+\_\+result\+\_\+error\+\_\+nomem, sqlite3\+\_\+result\+\_\+int64, sqlite3\+\_\+result\+\_\+null, sqlite3\+\_\+result\+\_\+text, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT, fsdir\+\_\+cursor\+::s\+Stat, and fsdir\+\_\+cursor\+::z\+Path.



Referenced by fsdir\+Register().


\begin{DoxyCode}
2764  \{
2765   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2766   \textcolor{keywordflow}{switch}( i )\{
2767     \textcolor{keywordflow}{case} FSDIR_COLUMN_NAME: \{
2768       sqlite3_result_text(ctx, &pCur->zPath[pCur->nBase], -1, SQLITE_TRANSIENT);
2769       \textcolor{keywordflow}{break};
2770     \}
2771 
2772     \textcolor{keywordflow}{case} FSDIR_COLUMN_MODE:
2773       sqlite3_result_int64(ctx, pCur->sStat.st\_mode);
2774       \textcolor{keywordflow}{break};
2775 
2776     \textcolor{keywordflow}{case} FSDIR_COLUMN_MTIME:
2777       sqlite3_result_int64(ctx, pCur->sStat.st\_mtime);
2778       \textcolor{keywordflow}{break};
2779 
2780     \textcolor{keywordflow}{case} FSDIR_COLUMN_DATA: \{
2781       mode\_t m = pCur->sStat.st\_mode;
2782       \textcolor{keywordflow}{if}( S\_ISDIR(m) )\{
2783         sqlite3_result_null(ctx);
2784 \textcolor{preprocessor}{#if !defined(\_WIN32) && !defined(WIN32)}
2785       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( S\_ISLNK(m) )\{
2786         \textcolor{keywordtype}{char} aStatic[64];
2787         \textcolor{keywordtype}{char} *aBuf = aStatic;
2788         sqlite3_int64 nBuf = 64;
2789         \textcolor{keywordtype}{int} n;
2790 
2791         \textcolor{keywordflow}{while}( 1 )\{
2792           n = readlink(pCur->zPath, aBuf, nBuf);
2793           \textcolor{keywordflow}{if}( n<nBuf ) \textcolor{keywordflow}{break};
2794           \textcolor{keywordflow}{if}( aBuf!=aStatic ) sqlite3_free(aBuf);
2795           nBuf = nBuf*2;
2796           aBuf = sqlite3_malloc64(nBuf);
2797           \textcolor{keywordflow}{if}( aBuf==0 )\{
2798             sqlite3_result_error_nomem(ctx);
2799             \textcolor{keywordflow}{return} SQLITE_NOMEM;
2800           \}
2801         \}
2802 
2803         sqlite3_result_text(ctx, aBuf, n, SQLITE_TRANSIENT);
2804         \textcolor{keywordflow}{if}( aBuf!=aStatic ) sqlite3_free(aBuf);
2805 \textcolor{preprocessor}{#endif}
2806       \}\textcolor{keywordflow}{else}\{
2807         readFileContents(ctx, pCur->zPath);
2808       \}
2809     \}
2810     \textcolor{keywordflow}{case} FSDIR_COLUMN_PATH:
2811     \textcolor{keywordflow}{default}: \{
2812       \textcolor{comment}{/* The FSDIR\_COLUMN\_PATH and FSDIR\_COLUMN\_DIR are input parameters.}
2813 \textcolor{comment}{      ** always return their values as NULL */}
2814       \textcolor{keywordflow}{break};
2815     \}
2816   \}
2817   \textcolor{keywordflow}{return} SQLITE_OK;
2818 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a9e9319ad7e059f597505e007c2e4918d}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Connect@{fsdir\+Connect}}
\index{fsdir\+Connect@{fsdir\+Connect}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Connect()}
{\footnotesize\ttfamily static int fsdir\+Connect (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{void $\ast$}]{p\+Aux,  }\item[{int}]{argc,  }\item[{const char $\ast$const $\ast$}]{argv,  }\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$$\ast$}]{pp\+Vtab,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2602 of file shell.\+c.



References F\+S\+D\+I\+R\+\_\+\+S\+C\+H\+E\+MA, sqlite3\+\_\+declare\+\_\+vtab, sqlite3\+\_\+malloc, sqlite3\+\_\+vtab\+\_\+config, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and S\+Q\+L\+I\+T\+E\+\_\+\+V\+T\+A\+B\+\_\+\+D\+I\+R\+E\+C\+T\+O\+N\+LY.



Referenced by fsdir\+Register().


\begin{DoxyCode}
2608  \{
2609   fsdir_tab *pNew = 0;
2610   \textcolor{keywordtype}{int} rc;
2611   (void)pAux;
2612   (void)argc;
2613   (void)argv;
2614   (void)pzErr;
2615   rc = sqlite3_declare_vtab(db, \textcolor{stringliteral}{"CREATE TABLE x"} FSDIR_SCHEMA);
2616   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
2617     pNew = (fsdir_tab*)sqlite3_malloc( \textcolor{keyword}{sizeof}(*pNew) );
2618     \textcolor{keywordflow}{if}( pNew==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
2619     memset(pNew, 0, \textcolor{keyword}{sizeof}(*pNew));
2620     sqlite3_vtab_config(db, SQLITE_VTAB_DIRECTONLY);
2621   \}
2622   *ppVtab = (sqlite3_vtab*)pNew;
2623   \textcolor{keywordflow}{return} rc;
2624 \}
\end{DoxyCode}
\mbox{\label{shell_8c_af124b9c18c821e8c826ee8a0e4e14c50}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Disconnect@{fsdir\+Disconnect}}
\index{fsdir\+Disconnect@{fsdir\+Disconnect}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Disconnect()}
{\footnotesize\ttfamily static int fsdir\+Disconnect (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$}]{p\+Vtab }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2629 of file shell.\+c.



References sqlite3\+\_\+free, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by fsdir\+Register().


\begin{DoxyCode}
2629                                                \{
2630   sqlite3_free(pVtab);
2631   \textcolor{keywordflow}{return} SQLITE_OK;
2632 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae8f61901508c57fda59ff5189521fbde}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Eof@{fsdir\+Eof}}
\index{fsdir\+Eof@{fsdir\+Eof}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Eof()}
{\footnotesize\ttfamily static int fsdir\+Eof (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2835 of file shell.\+c.



References fsdir\+\_\+cursor\+::z\+Path.



Referenced by fsdir\+Register().


\begin{DoxyCode}
2835                                              \{
2836   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2837   \textcolor{keywordflow}{return} (pCur->zPath==0);
2838 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a4391d1eb32b553785589b2cb67ec61c2}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Filter@{fsdir\+Filter}}
\index{fsdir\+Filter@{fsdir\+Filter}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Filter()}
{\footnotesize\ttfamily static int fsdir\+Filter (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur,  }\item[{int}]{idx\+Num,  }\item[{const char $\ast$}]{idx\+Str,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2846 of file shell.\+c.



References file\+Link\+Stat(), fsdir\+Reset\+Cursor(), fsdir\+Set\+Errmsg(), fsdir\+\_\+cursor\+::n\+Base, sqlite3\+\_\+mprintf, sqlite3\+\_\+value\+\_\+text, S\+Q\+L\+I\+T\+E\+\_\+\+E\+R\+R\+OR, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, fsdir\+\_\+cursor\+::s\+Stat, fsdir\+\_\+cursor\+::z\+Base, and fsdir\+\_\+cursor\+::z\+Path.



Referenced by fsdir\+Register().


\begin{DoxyCode}
2850  \{
2851   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDir = 0;
2852   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2853   (void)idxStr;
2854   fsdirResetCursor(pCur);
2855 
2856   \textcolor{keywordflow}{if}( idxNum==0 )\{
2857     fsdirSetErrmsg(pCur, \textcolor{stringliteral}{"table function fsdir requires an argument"});
2858     \textcolor{keywordflow}{return} SQLITE_ERROR;
2859   \}
2860 
2861   assert( argc==idxNum && (argc==1 || argc==2) );
2862   zDir = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(argv[0]);
2863   \textcolor{keywordflow}{if}( zDir==0 )\{
2864     fsdirSetErrmsg(pCur, \textcolor{stringliteral}{"table function fsdir requires a non-NULL argument"});
2865     \textcolor{keywordflow}{return} SQLITE_ERROR;
2866   \}
2867   \textcolor{keywordflow}{if}( argc==2 )\{
2868     pCur->zBase = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(argv[1]);
2869   \}
2870   \textcolor{keywordflow}{if}( pCur->zBase )\{
2871     pCur->nBase = (int)strlen(pCur->zBase)+1;
2872     pCur->zPath = sqlite3_mprintf(\textcolor{stringliteral}{"%s/%s"}, pCur->zBase, zDir);
2873   \}\textcolor{keywordflow}{else}\{
2874     pCur->zPath = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, zDir);
2875   \}
2876 
2877   \textcolor{keywordflow}{if}( pCur->zPath==0 )\{
2878     \textcolor{keywordflow}{return} SQLITE_NOMEM;
2879   \}
2880   \textcolor{keywordflow}{if}( fileLinkStat(pCur->zPath, &pCur->sStat) )\{
2881     fsdirSetErrmsg(pCur, \textcolor{stringliteral}{"cannot stat file: %s"}, pCur->zPath);
2882     \textcolor{keywordflow}{return} SQLITE_ERROR;
2883   \}
2884 
2885   \textcolor{keywordflow}{return} SQLITE_OK;
2886 \}
\end{DoxyCode}
\mbox{\label{shell_8c_adb404984d598ace2eab4d7743260695f}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Next@{fsdir\+Next}}
\index{fsdir\+Next@{fsdir\+Next}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Next()}
{\footnotesize\ttfamily static int fsdir\+Next (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2696 of file shell.\+c.



References fsdir\+\_\+cursor\+::a\+Lvl, file\+Link\+Stat(), fsdir\+Set\+Errmsg(), fsdir\+\_\+cursor\+::i\+Lvl, fsdir\+\_\+cursor\+::i\+Rowid, fsdir\+\_\+cursor\+::n\+Lvl, Fsdir\+Level\+::p\+Dir, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+realloc64, S\+Q\+L\+I\+T\+E\+\_\+\+E\+R\+R\+OR, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, fsdir\+\_\+cursor\+::s\+Stat, Fsdir\+Level\+::z\+Dir, and fsdir\+\_\+cursor\+::z\+Path.



Referenced by fsdir\+Register().


\begin{DoxyCode}
2696                                               \{
2697   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2698   mode\_t m = pCur->sStat.st\_mode;
2699 
2700   pCur->iRowid++;
2701   \textcolor{keywordflow}{if}( S\_ISDIR(m) )\{
2702     \textcolor{comment}{/* Descend into this directory */}
2703     \textcolor{keywordtype}{int} iNew = pCur->iLvl + 1;
2704     FsdirLevel *pLvl;
2705     \textcolor{keywordflow}{if}( iNew>=pCur->nLvl )\{
2706       \textcolor{keywordtype}{int} nNew = iNew+1;
2707       sqlite3_int64 nByte = nNew*\textcolor{keyword}{sizeof}(FsdirLevel);
2708       FsdirLevel *aNew = (FsdirLevel*)sqlite3_realloc64(pCur->aLvl, nByte);
2709       \textcolor{keywordflow}{if}( aNew==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
2710       memset(&aNew[pCur->nLvl], 0, \textcolor{keyword}{sizeof}(FsdirLevel)*(nNew-pCur->nLvl));
2711       pCur->aLvl = aNew;
2712       pCur->nLvl = nNew;
2713     \}
2714     pCur->iLvl = iNew;
2715     pLvl = &pCur->aLvl[iNew];
2716     
2717     pLvl->zDir = pCur->zPath;
2718     pCur->zPath = 0;
2719     pLvl->pDir = opendir(pLvl->zDir);
2720     \textcolor{keywordflow}{if}( pLvl->pDir==0 )\{
2721       fsdirSetErrmsg(pCur, \textcolor{stringliteral}{"cannot read directory: %s"}, pCur->zPath);
2722       \textcolor{keywordflow}{return} SQLITE_ERROR;
2723     \}
2724   \}
2725 
2726   \textcolor{keywordflow}{while}( pCur->iLvl>=0 )\{
2727     FsdirLevel *pLvl = &pCur->aLvl[pCur->iLvl];
2728     \textcolor{keyword}{struct }dirent *pEntry = readdir(pLvl->pDir);
2729     \textcolor{keywordflow}{if}( pEntry )\{
2730       \textcolor{keywordflow}{if}( pEntry->d\_name[0]==\textcolor{charliteral}{'.'} )\{
2731        \textcolor{keywordflow}{if}( pEntry->d\_name[1]==\textcolor{charliteral}{'.'} && pEntry->d\_name[2]==\textcolor{charliteral}{'\(\backslash\)0'} ) \textcolor{keywordflow}{continue};
2732        \textcolor{keywordflow}{if}( pEntry->d\_name[1]==\textcolor{charliteral}{'\(\backslash\)0'} ) \textcolor{keywordflow}{continue};
2733       \}
2734       sqlite3_free(pCur->zPath);
2735       pCur->zPath = sqlite3_mprintf(\textcolor{stringliteral}{"%s/%s"}, pLvl->zDir, pEntry->d\_name);
2736       \textcolor{keywordflow}{if}( pCur->zPath==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
2737       \textcolor{keywordflow}{if}( fileLinkStat(pCur->zPath, &pCur->sStat) )\{
2738         fsdirSetErrmsg(pCur, \textcolor{stringliteral}{"cannot stat file: %s"}, pCur->zPath);
2739         \textcolor{keywordflow}{return} SQLITE_ERROR;
2740       \}
2741       \textcolor{keywordflow}{return} SQLITE_OK;
2742     \}
2743     closedir(pLvl->pDir);
2744     sqlite3_free(pLvl->zDir);
2745     pLvl->pDir = 0;
2746     pLvl->zDir = 0;
2747     pCur->iLvl--;
2748   \}
2749 
2750   \textcolor{comment}{/* EOF */}
2751   sqlite3_free(pCur->zPath);
2752   pCur->zPath = 0;
2753   \textcolor{keywordflow}{return} SQLITE_OK;
2754 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a76d53507e9c78d64fdc9d13fca5ba97e}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Open@{fsdir\+Open}}
\index{fsdir\+Open@{fsdir\+Open}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Open()}
{\footnotesize\ttfamily static int fsdir\+Open (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab} $\ast$}]{p,  }\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$$\ast$}]{pp\+Cursor }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2637 of file shell.\+c.



References fsdir\+\_\+cursor\+::base, fsdir\+\_\+cursor\+::i\+Lvl, sqlite3\+\_\+malloc, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by fsdir\+Register().


\begin{DoxyCode}
2637                                                                      \{
2638   fsdir_cursor *pCur;
2639   (void)p;
2640   pCur = sqlite3_malloc( \textcolor{keyword}{sizeof}(*pCur) );
2641   \textcolor{keywordflow}{if}( pCur==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
2642   memset(pCur, 0, \textcolor{keyword}{sizeof}(*pCur));
2643   pCur->iLvl = -1;
2644   *ppCursor = &pCur->base;
2645   \textcolor{keywordflow}{return} SQLITE_OK;
2646 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a27f2af8af9f83312a2bcc2258478e77b}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Register@{fsdir\+Register}}
\index{fsdir\+Register@{fsdir\+Register}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Register()}
{\footnotesize\ttfamily static int fsdir\+Register (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2968 of file shell.\+c.



References fsdir\+Best\+Index(), fsdir\+Close(), fsdir\+Column(), fsdir\+Connect(), fsdir\+Disconnect(), fsdir\+Eof(), fsdir\+Filter(), fsdir\+Next(), fsdir\+Open(), fsdir\+Rowid(), and sqlite3\+\_\+create\+\_\+module.



Referenced by sqlite3\+\_\+fileio\+\_\+init().


\begin{DoxyCode}
2968                                      \{
2969   \textcolor{keyword}{static} sqlite3_module fsdirModule = \{
2970     0,                         \textcolor{comment}{/* iVersion */}
2971     0,                         \textcolor{comment}{/* xCreate */}
2972     fsdirConnect,              \textcolor{comment}{/* xConnect */}
2973     fsdirBestIndex,            \textcolor{comment}{/* xBestIndex */}
2974     fsdirDisconnect,           \textcolor{comment}{/* xDisconnect */}
2975     0,                         \textcolor{comment}{/* xDestroy */}
2976     fsdirOpen,                 \textcolor{comment}{/* xOpen - open a cursor */}
2977     fsdirClose,                \textcolor{comment}{/* xClose - close a cursor */}
2978     fsdirFilter,               \textcolor{comment}{/* xFilter - configure scan constraints */}
2979     fsdirNext,                 \textcolor{comment}{/* xNext - advance a cursor */}
2980     fsdirEof,                  \textcolor{comment}{/* xEof - check for end of scan */}
2981     fsdirColumn,               \textcolor{comment}{/* xColumn - read data */}
2982     fsdirRowid,                \textcolor{comment}{/* xRowid - read data */}
2983     0,                         \textcolor{comment}{/* xUpdate */}
2984     0,                         \textcolor{comment}{/* xBegin */}
2985     0,                         \textcolor{comment}{/* xSync */}
2986     0,                         \textcolor{comment}{/* xCommit */}
2987     0,                         \textcolor{comment}{/* xRollback */}
2988     0,                         \textcolor{comment}{/* xFindMethod */}
2989     0,                         \textcolor{comment}{/* xRename */}
2990     0,                         \textcolor{comment}{/* xSavepoint */}
2991     0,                         \textcolor{comment}{/* xRelease */}
2992     0,                         \textcolor{comment}{/* xRollbackTo */}
2993     0,                         \textcolor{comment}{/* xShadowName */}
2994   \};
2995 
2996   \textcolor{keywordtype}{int} rc = sqlite3_create_module(db, \textcolor{stringliteral}{"fsdir"}, &fsdirModule, 0);
2997   \textcolor{keywordflow}{return} rc;
2998 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab31974a8f0b2cc8277d7a473784266d0}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Reset\+Cursor@{fsdir\+Reset\+Cursor}}
\index{fsdir\+Reset\+Cursor@{fsdir\+Reset\+Cursor}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Reset\+Cursor()}
{\footnotesize\ttfamily static void fsdir\+Reset\+Cursor (\begin{DoxyParamCaption}\item[{\textbf{ fsdir\+\_\+cursor} $\ast$}]{p\+Cur }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2652 of file shell.\+c.



References fsdir\+\_\+cursor\+::a\+Lvl, fsdir\+\_\+cursor\+::i\+Lvl, fsdir\+\_\+cursor\+::i\+Rowid, fsdir\+\_\+cursor\+::n\+Base, fsdir\+\_\+cursor\+::n\+Lvl, Fsdir\+Level\+::p\+Dir, sqlite3\+\_\+free, fsdir\+\_\+cursor\+::z\+Base, Fsdir\+Level\+::z\+Dir, and fsdir\+\_\+cursor\+::z\+Path.



Referenced by fsdir\+Close(), and fsdir\+Filter().


\begin{DoxyCode}
2652                                                 \{
2653   \textcolor{keywordtype}{int} i;
2654   \textcolor{keywordflow}{for}(i=0; i<=pCur->iLvl; i++)\{
2655     FsdirLevel *pLvl = &pCur->aLvl[i];
2656     \textcolor{keywordflow}{if}( pLvl->pDir ) closedir(pLvl->pDir);
2657     sqlite3_free(pLvl->zDir);
2658   \}
2659   sqlite3_free(pCur->zPath);
2660   sqlite3_free(pCur->aLvl);
2661   pCur->aLvl = 0;
2662   pCur->zPath = 0;
2663   pCur->zBase = 0;
2664   pCur->nBase = 0;
2665   pCur->nLvl = 0;
2666   pCur->iLvl = -1;
2667   pCur->iRowid = 1;
2668 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a4bc8159df4f5a8b7f41b34da47d42742}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Rowid@{fsdir\+Rowid}}
\index{fsdir\+Rowid@{fsdir\+Rowid}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Rowid()}
{\footnotesize\ttfamily static int fsdir\+Rowid (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+vtab\+\_\+cursor} $\ast$}]{cur,  }\item[{\textbf{ sqlite\+\_\+int64} $\ast$}]{p\+Rowid }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2825 of file shell.\+c.



References fsdir\+\_\+cursor\+::i\+Rowid, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by fsdir\+Register().


\begin{DoxyCode}
2825                                                                      \{
2826   fsdir_cursor *pCur = (fsdir_cursor*)cur;
2827   *pRowid = pCur->iRowid;
2828   \textcolor{keywordflow}{return} SQLITE_OK;
2829 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a090b7c0b5d15e3453bb09dc16ade6cf5}} 
\index{shell.\+c@{shell.\+c}!fsdir\+Set\+Errmsg@{fsdir\+Set\+Errmsg}}
\index{fsdir\+Set\+Errmsg@{fsdir\+Set\+Errmsg}!shell.\+c@{shell.\+c}}
\subsubsection{fsdir\+Set\+Errmsg()}
{\footnotesize\ttfamily static void fsdir\+Set\+Errmsg (\begin{DoxyParamCaption}\item[{\textbf{ fsdir\+\_\+cursor} $\ast$}]{p\+Cur,  }\item[{const char $\ast$}]{z\+Fmt,  }\item[{}]{... }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2685 of file shell.\+c.



References fsdir\+\_\+cursor\+::base, sqlite3\+\_\+vtab\+\_\+cursor\+::p\+Vtab, sqlite3\+\_\+vmprintf, and sqlite3\+\_\+vtab\+::z\+Err\+Msg.



Referenced by fsdir\+Filter(), and fsdir\+Next().


\begin{DoxyCode}
2685                                                                      \{
2686   va\_list ap;
2687   va\_start(ap, zFmt);
2688   pCur->base.pVtab->zErrMsg = sqlite3_vmprintf(zFmt, ap);
2689   va\_end(ap);
2690 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a0f5257621423023ca68abd46df29a547}} 
\index{shell.\+c@{shell.\+c}!get2byte\+Int@{get2byte\+Int}}
\index{get2byte\+Int@{get2byte\+Int}!shell.\+c@{shell.\+c}}
\subsubsection{get2byte\+Int()}
{\footnotesize\ttfamily static unsigned int get2byte\+Int (\begin{DoxyParamCaption}\item[{unsigned char $\ast$}]{a }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13486 of file shell.\+c.



Referenced by shell\+\_\+dbinfo\+\_\+command().


\begin{DoxyCode}
13486                                                  \{
13487   \textcolor{keywordflow}{return} (a[0]<<8) + a[1];
13488 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae804d2dac92f2fe67320d50c0cbb6571}} 
\index{shell.\+c@{shell.\+c}!get4byte\+Int@{get4byte\+Int}}
\index{get4byte\+Int@{get4byte\+Int}!shell.\+c@{shell.\+c}}
\subsubsection{get4byte\+Int()}
{\footnotesize\ttfamily static unsigned int get4byte\+Int (\begin{DoxyParamCaption}\item[{unsigned char $\ast$}]{a }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13489 of file shell.\+c.



Referenced by shell\+\_\+dbinfo\+\_\+command().


\begin{DoxyCode}
13489                                                  \{
13490   \textcolor{keywordflow}{return} (a[0]<<24) + (a[1]<<16) + (a[2]<<8) + a[3];
13491 \}
\end{DoxyCode}
\mbox{\label{shell_8c_afd779eea2331c7ee1852feec1919af4f}} 
\index{shell.\+c@{shell.\+c}!hash\+\_\+step\+\_\+vformat@{hash\+\_\+step\+\_\+vformat}}
\index{hash\+\_\+step\+\_\+vformat@{hash\+\_\+step\+\_\+vformat}!shell.\+c@{shell.\+c}}
\subsubsection{hash\+\_\+step\+\_\+vformat()}
{\footnotesize\ttfamily static void hash\+\_\+step\+\_\+vformat (\begin{DoxyParamCaption}\item[{\textbf{ S\+H\+A3\+Context} $\ast$}]{p,  }\item[{const char $\ast$}]{z\+Format,  }\item[{}]{... }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 1841 of file shell.\+c.



References S\+H\+A3\+Update(), and sqlite3\+\_\+vsnprintf.



Referenced by sha3\+Query\+Func().


\begin{DoxyCode}
1845  \{
1846   va\_list ap;
1847   \textcolor{keywordtype}{int} n;
1848   \textcolor{keywordtype}{char} zBuf[50];
1849   va\_start(ap, zFormat);
1850   sqlite3_vsnprintf(\textcolor{keyword}{sizeof}(zBuf),zBuf,zFormat,ap);
1851   va\_end(ap);
1852   n = (int)strlen(zBuf);
1853   SHA3Update(p, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)zBuf, n);
1854 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad08518ec3a9ff0dc665c54a7eb2a4baa}} 
\index{shell.\+c@{shell.\+c}!hex\+Digit\+Value@{hex\+Digit\+Value}}
\index{hex\+Digit\+Value@{hex\+Digit\+Value}!shell.\+c@{shell.\+c}}
\subsubsection{hex\+Digit\+Value()}
{\footnotesize\ttfamily static int hex\+Digit\+Value (\begin{DoxyParamCaption}\item[{char}]{c }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 668 of file shell.\+c.



Referenced by boolean\+Value(), and integer\+Value().


\begin{DoxyCode}
668                                 \{
669   \textcolor{keywordflow}{if}( c>=\textcolor{charliteral}{'0'} && c<=\textcolor{charliteral}{'9'} ) \textcolor{keywordflow}{return} c - \textcolor{charliteral}{'0'};
670   \textcolor{keywordflow}{if}( c>=\textcolor{charliteral}{'a'} && c<=\textcolor{charliteral}{'f'} ) \textcolor{keywordflow}{return} c - \textcolor{charliteral}{'a'} + 10;
671   \textcolor{keywordflow}{if}( c>=\textcolor{charliteral}{'A'} && c<=\textcolor{charliteral}{'F'} ) \textcolor{keywordflow}{return} c - \textcolor{charliteral}{'A'} + 10;
672   \textcolor{keywordflow}{return} -1;
673 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a10591a12de9d845626f9bac6ead5216e}} 
\index{shell.\+c@{shell.\+c}!idx\+Append\+Col\+Defn@{idx\+Append\+Col\+Defn}}
\index{idx\+Append\+Col\+Defn@{idx\+Append\+Col\+Defn}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Append\+Col\+Defn()}
{\footnotesize\ttfamily static char$\ast$ idx\+Append\+Col\+Defn (\begin{DoxyParamCaption}\item[{int $\ast$}]{p\+Rc,  }\item[{char $\ast$}]{z\+In,  }\item[{\textbf{ Idx\+Table} $\ast$}]{p\+Tab,  }\item[{\textbf{ Idx\+Constraint} $\ast$}]{p\+Cons }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7512 of file shell.\+c.



References Idx\+Table\+::a\+Col, Idx\+Constraint\+::b\+Desc, Idx\+Constraint\+::i\+Col, idx\+Append\+Text(), idx\+Identifier\+Requires\+Quotes(), sqlite3\+\_\+stricmp, Idx\+Constraint\+::z\+Coll, Idx\+Column\+::z\+Coll, and Idx\+Column\+::z\+Name.



Referenced by idx\+Create\+From\+Cons().


\begin{DoxyCode}
7517  \{
7518   \textcolor{keywordtype}{char} *zRet = zIn;
7519   IdxColumn *p = &pTab->aCol[pCons->iCol];
7520   \textcolor{keywordflow}{if}( zRet ) zRet = idxAppendText(pRc, zRet, \textcolor{stringliteral}{", "});
7521 
7522   \textcolor{keywordflow}{if}( idxIdentifierRequiresQuotes(p->zName) )\{
7523     zRet = idxAppendText(pRc, zRet, \textcolor{stringliteral}{"%Q"}, p->zName);
7524   \}\textcolor{keywordflow}{else}\{
7525     zRet = idxAppendText(pRc, zRet, \textcolor{stringliteral}{"%s"}, p->zName);
7526   \}
7527 
7528   \textcolor{keywordflow}{if}( sqlite3_stricmp(p->zColl, pCons->zColl) )\{
7529     \textcolor{keywordflow}{if}( idxIdentifierRequiresQuotes(pCons->zColl) )\{
7530       zRet = idxAppendText(pRc, zRet, \textcolor{stringliteral}{" COLLATE %Q"}, pCons->zColl);
7531     \}\textcolor{keywordflow}{else}\{
7532       zRet = idxAppendText(pRc, zRet, \textcolor{stringliteral}{" COLLATE %s"}, pCons->zColl);
7533     \}
7534   \}
7535 
7536   \textcolor{keywordflow}{if}( pCons->bDesc )\{
7537     zRet = idxAppendText(pRc, zRet, \textcolor{stringliteral}{" DESC"});
7538   \}
7539   \textcolor{keywordflow}{return} zRet;
7540 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aa47ab549ecf0151e076c0f93d8ffd4f5}} 
\index{shell.\+c@{shell.\+c}!idx\+Append\+Text@{idx\+Append\+Text}}
\index{idx\+Append\+Text@{idx\+Append\+Text}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Append\+Text()}
{\footnotesize\ttfamily static char$\ast$ idx\+Append\+Text (\begin{DoxyParamCaption}\item[{int $\ast$}]{p\+Rc,  }\item[{char $\ast$}]{z\+In,  }\item[{const char $\ast$}]{z\+Fmt,  }\item[{}]{... }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7462 of file shell.\+c.



References sqlite3\+\_\+free, sqlite3\+\_\+malloc, sqlite3\+\_\+vmprintf, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and S\+T\+R\+L\+EN.



Referenced by idx\+Append\+Col\+Defn(), idx\+Create\+Vtab\+Schema(), idx\+Find\+Indexes(), idx\+Populate\+One\+Stat1(), idx\+Process\+One\+Trigger(), and sqlite3\+\_\+expert\+\_\+analyze().


\begin{DoxyCode}
7462                                                                       \{
7463   va\_list ap;
7464   \textcolor{keywordtype}{char} *zAppend = 0;
7465   \textcolor{keywordtype}{char} *zRet = 0;
7466   \textcolor{keywordtype}{int} nIn = zIn ? STRLEN(zIn) : 0;
7467   \textcolor{keywordtype}{int} nAppend = 0;
7468   va\_start(ap, zFmt);
7469   \textcolor{keywordflow}{if}( *pRc==SQLITE_OK )\{
7470     zAppend = sqlite3_vmprintf(zFmt, ap);
7471     \textcolor{keywordflow}{if}( zAppend )\{
7472       nAppend = STRLEN(zAppend);
7473       zRet = (\textcolor{keywordtype}{char}*)sqlite3_malloc(nIn + nAppend + 1);
7474     \}
7475     \textcolor{keywordflow}{if}( zAppend && zRet )\{
7476       \textcolor{keywordflow}{if}( nIn ) memcpy(zRet, zIn, nIn);
7477       memcpy(&zRet[nIn], zAppend, nAppend+1);
7478     \}\textcolor{keywordflow}{else}\{
7479       sqlite3_free(zRet);
7480       zRet = 0;
7481       *pRc = SQLITE_NOMEM;
7482     \}
7483     sqlite3_free(zAppend);
7484     sqlite3_free(zIn);
7485   \}
7486   va\_end(ap);
7487   \textcolor{keywordflow}{return} zRet;
7488 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a3c7554b7c77c3fc779ffd65154ae5f72}} 
\index{shell.\+c@{shell.\+c}!idx\+Auth\+Callback@{idx\+Auth\+Callback}}
\index{idx\+Auth\+Callback@{idx\+Auth\+Callback}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Auth\+Callback()}
{\footnotesize\ttfamily static int idx\+Auth\+Callback (\begin{DoxyParamCaption}\item[{void $\ast$}]{p\+Ctx,  }\item[{int}]{e\+Op,  }\item[{const char $\ast$}]{z3,  }\item[{const char $\ast$}]{z4,  }\item[{const char $\ast$}]{z\+Db,  }\item[{const char $\ast$}]{z\+Trigger }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7879 of file shell.\+c.



References Idx\+Write\+::e\+Op, idx\+Malloc(), Idx\+Table\+::p\+Next, Idx\+Write\+::p\+Next, Idx\+Write\+::p\+Tab, sqlite3expert\+::p\+Table, sqlite3expert\+::p\+Write, sqlite3\+\_\+stricmp, S\+Q\+L\+I\+T\+E\+\_\+\+D\+E\+L\+E\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+S\+E\+RT, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+U\+P\+D\+A\+TE, and Idx\+Table\+::z\+Name.



Referenced by sqlite3\+\_\+expert\+\_\+new().


\begin{DoxyCode}
7886  \{
7887   \textcolor{keywordtype}{int} rc = SQLITE_OK;
7888   (void)z4;
7889   (void)zTrigger;
7890   \textcolor{keywordflow}{if}( eOp==SQLITE_INSERT || eOp==SQLITE_UPDATE || eOp==SQLITE_DELETE )\{
7891     \textcolor{keywordflow}{if}( sqlite3_stricmp(zDb, \textcolor{stringliteral}{"main"})==0 )\{
7892       sqlite3expert *p = (sqlite3expert*)pCtx;
7893       IdxTable *pTab;
7894       \textcolor{keywordflow}{for}(pTab=p->pTable; pTab; pTab=pTab->pNext)\{
7895         \textcolor{keywordflow}{if}( 0==sqlite3_stricmp(z3, pTab->zName) ) \textcolor{keywordflow}{break};
7896       \}
7897       \textcolor{keywordflow}{if}( pTab )\{
7898         IdxWrite *pWrite;
7899         \textcolor{keywordflow}{for}(pWrite=p->pWrite; pWrite; pWrite=pWrite->pNext)\{
7900           \textcolor{keywordflow}{if}( pWrite->pTab==pTab && pWrite->eOp==eOp ) \textcolor{keywordflow}{break};
7901         \}
7902         \textcolor{keywordflow}{if}( pWrite==0 )\{
7903           pWrite = idxMalloc(&rc, \textcolor{keyword}{sizeof}(IdxWrite));
7904           \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7905             pWrite->pTab = pTab;
7906             pWrite->eOp = eOp;
7907             pWrite->pNext = p->pWrite;
7908             p->pWrite = pWrite;
7909           \}
7910         \}
7911       \}
7912     \}
7913   \}
7914   \textcolor{keywordflow}{return} rc;
7915 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab58f7088fa5adfe00c9ca9a1444f09cf}} 
\index{shell.\+c@{shell.\+c}!idx\+Build\+Sample\+Table@{idx\+Build\+Sample\+Table}}
\index{idx\+Build\+Sample\+Table@{idx\+Build\+Sample\+Table}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Build\+Sample\+Table()}
{\footnotesize\ttfamily static int idx\+Build\+Sample\+Table (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{const char $\ast$}]{z\+Tab }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 8318 of file shell.\+c.



References sqlite3expert\+::dbv, sqlite3\+\_\+exec, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and U\+N\+I\+Q\+U\+E\+\_\+\+T\+A\+B\+L\+E\+\_\+\+N\+A\+ME.



Referenced by idx\+Populate\+Stat1().


\begin{DoxyCode}
8318                                                                   \{
8319   \textcolor{keywordtype}{int} rc;
8320   \textcolor{keywordtype}{char} *zSql;
8321 
8322   rc = sqlite3_exec(p->dbv,\textcolor{stringliteral}{"DROP TABLE IF EXISTS temp."}UNIQUE_TABLE_NAME,0,0,0);
8323   \textcolor{keywordflow}{if}( rc!=SQLITE_OK ) \textcolor{keywordflow}{return} rc;
8324 
8325   zSql = sqlite3_mprintf(
8326       \textcolor{stringliteral}{"CREATE TABLE temp."} UNIQUE_TABLE_NAME \textcolor{stringliteral}{" AS SELECT * FROM %Q"}, zTab
8327   );
8328   \textcolor{keywordflow}{if}( zSql==0 ) \textcolor{keywordflow}{return} SQLITE_NOMEM;
8329   rc = sqlite3_exec(p->dbv, zSql, 0, 0, 0);
8330   sqlite3_free(zSql);
8331 
8332   \textcolor{keywordflow}{return} rc;
8333 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a86b32ceaad354362ea9077b631dcd3e5}} 
\index{shell.\+c@{shell.\+c}!idx\+Constraint\+Free@{idx\+Constraint\+Free}}
\index{idx\+Constraint\+Free@{idx\+Constraint\+Free}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Constraint\+Free()}
{\footnotesize\ttfamily static void idx\+Constraint\+Free (\begin{DoxyParamCaption}\item[{\textbf{ Idx\+Constraint} $\ast$}]{p\+Constraint }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7742 of file shell.\+c.



References Idx\+Constraint\+::p\+Next, and sqlite3\+\_\+free.



Referenced by idx\+Scan\+Free().


\begin{DoxyCode}
7742                                                          \{
7743   IdxConstraint *pNext;
7744   IdxConstraint *p;
7745 
7746   \textcolor{keywordflow}{for}(p=pConstraint; p; p=pNext)\{
7747     pNext = p->pNext;
7748     sqlite3_free(p);
7749   \}
7750 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ac82108f8d07c996dbc47111007416f18}} 
\index{shell.\+c@{shell.\+c}!idx\+Create\+Candidates@{idx\+Create\+Candidates}}
\index{idx\+Create\+Candidates@{idx\+Create\+Candidates}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Create\+Candidates()}
{\footnotesize\ttfamily static int idx\+Create\+Candidates (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7725 of file shell.\+c.



References idx\+Create\+From\+Where(), Idx\+Scan\+::p\+Next\+Scan, Idx\+Scan\+::p\+Order, sqlite3expert\+::p\+Scan, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by sqlite3\+\_\+expert\+\_\+analyze().


\begin{DoxyCode}
7725                                                 \{
7726   \textcolor{keywordtype}{int} rc = SQLITE_OK;
7727   IdxScan *pIter;
7728 
7729   \textcolor{keywordflow}{for}(pIter=p->pScan; pIter && rc==SQLITE_OK; pIter=pIter->pNextScan)\{
7730     rc = idxCreateFromWhere(p, pIter, 0);
7731     \textcolor{keywordflow}{if}( rc==SQLITE_OK && pIter->pOrder )\{
7732       rc = idxCreateFromWhere(p, pIter, pIter->pOrder);
7733     \}
7734   \}
7735 
7736   \textcolor{keywordflow}{return} rc;
7737 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad742e832559b2b85c54b940adff815ba}} 
\index{shell.\+c@{shell.\+c}!idx\+Create\+From\+Cons@{idx\+Create\+From\+Cons}}
\index{idx\+Create\+From\+Cons@{idx\+Create\+From\+Cons}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Create\+From\+Cons()}
{\footnotesize\ttfamily static int idx\+Create\+From\+Cons (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{\textbf{ Idx\+Scan} $\ast$}]{p\+Scan,  }\item[{\textbf{ Idx\+Constraint} $\ast$}]{p\+Eq,  }\item[{\textbf{ Idx\+Constraint} $\ast$}]{p\+Tail }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7617 of file shell.\+c.



References sqlite3expert\+::dbm, sqlite3expert\+::h\+Idx, idx\+Append\+Col\+Defn(), idx\+Find\+Compatible(), idx\+Hash\+Add(), idx\+Identifier\+Requires\+Quotes(), Idx\+Constraint\+::p\+Link, Idx\+Scan\+::p\+Tab, sqlite3expert\+::pz\+Errmsg, sqlite3\+\_\+exec, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, Idx\+Table\+::z\+Name, and z\+Name.



Referenced by idx\+Create\+From\+Where().


\begin{DoxyCode}
7622  \{
7623   sqlite3 *dbm = p->dbm;
7624   \textcolor{keywordtype}{int} rc = SQLITE_OK;
7625   \textcolor{keywordflow}{if}( (pEq || pTail) && 0==idxFindCompatible(&rc, dbm, pScan, pEq, pTail) )\{
7626     IdxTable *pTab = pScan->pTab;
7627     \textcolor{keywordtype}{char} *zCols = 0;
7628     \textcolor{keywordtype}{char} *zIdx = 0;
7629     IdxConstraint *pCons;
7630     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h = 0;
7631     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zFmt;
7632 
7633     \textcolor{keywordflow}{for}(pCons=pEq; pCons; pCons=pCons->pLink)\{
7634       zCols = idxAppendColDefn(&rc, zCols, pTab, pCons);
7635     \}
7636     \textcolor{keywordflow}{for}(pCons=pTail; pCons; pCons=pCons->pLink)\{
7637       zCols = idxAppendColDefn(&rc, zCols, pTab, pCons);
7638     \}
7639 
7640     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7641       \textcolor{comment}{/* Hash the list of columns to come up with a name for the index */}
7642       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zTable = pScan->pTab->zName;
7643       \textcolor{keywordtype}{char} *zName;                \textcolor{comment}{/* Index name */}
7644       \textcolor{keywordtype}{int} i;
7645       \textcolor{keywordflow}{for}(i=0; zCols[i]; i++)\{
7646         h += ((h<<3) + zCols[i]);
7647       \}
7648       zName = sqlite3_mprintf(\textcolor{stringliteral}{"%s\_idx\_%08x"}, zTable, h);
7649       \textcolor{keywordflow}{if}( zName==0 )\{ 
7650         rc = SQLITE_NOMEM;
7651       \}\textcolor{keywordflow}{else}\{
7652         \textcolor{keywordflow}{if}( idxIdentifierRequiresQuotes(zTable) )\{
7653           zFmt = \textcolor{stringliteral}{"CREATE INDEX '%q' ON %Q(%s)"};
7654         \}\textcolor{keywordflow}{else}\{
7655           zFmt = \textcolor{stringliteral}{"CREATE INDEX %s ON %s(%s)"};
7656         \}
7657         zIdx = sqlite3_mprintf(zFmt, zName, zTable, zCols);
7658         \textcolor{keywordflow}{if}( !zIdx )\{
7659           rc = SQLITE_NOMEM;
7660         \}\textcolor{keywordflow}{else}\{
7661           rc = sqlite3_exec(dbm, zIdx, 0, 0, p->pzErrmsg);
7662           idxHashAdd(&rc, &p->hIdx, zName, zIdx);
7663         \}
7664         sqlite3_free(zName);
7665         sqlite3_free(zIdx);
7666       \}
7667     \}
7668 
7669     sqlite3_free(zCols);
7670   \}
7671   \textcolor{keywordflow}{return} rc;
7672 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a0776be32bd83b00a83cc34cc82635bc7}} 
\index{shell.\+c@{shell.\+c}!idx\+Create\+From\+Where@{idx\+Create\+From\+Where}}
\index{idx\+Create\+From\+Where@{idx\+Create\+From\+Where}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Create\+From\+Where()}
{\footnotesize\ttfamily static int idx\+Create\+From\+Where (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{\textbf{ Idx\+Scan} $\ast$}]{p\+Scan,  }\item[{\textbf{ Idx\+Constraint} $\ast$}]{p\+Tail }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7686 of file shell.\+c.



References idx\+Create\+From\+Cons(), idx\+Find\+Constraint(), Idx\+Scan\+::p\+Eq, Idx\+Constraint\+::p\+Link, Idx\+Constraint\+::p\+Next, Idx\+Scan\+::p\+Range, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by idx\+Create\+Candidates().


\begin{DoxyCode}
7690  \{
7691   IdxConstraint *p1 = 0;
7692   IdxConstraint *pCon;
7693   \textcolor{keywordtype}{int} rc;
7694 
7695   \textcolor{comment}{/* Gather up all the == constraints. */}
7696   \textcolor{keywordflow}{for}(pCon=pScan->pEq; pCon; pCon=pCon->pNext)\{
7697     \textcolor{keywordflow}{if}( !idxFindConstraint(p1, pCon) && !idxFindConstraint(pTail, pCon) )\{
7698       pCon->pLink = p1;
7699       p1 = pCon;
7700     \}
7701   \}
7702 
7703   \textcolor{comment}{/* Create an index using the == constraints collected above. And the}
7704 \textcolor{comment}{  ** range constraint/ORDER BY terms passed in by the caller, if any. */}
7705   rc = idxCreateFromCons(p, pScan, p1, pTail);
7706 
7707   \textcolor{comment}{/* If no range/ORDER BY passed by the caller, create a version of the}
7708 \textcolor{comment}{  ** index for each range constraint.  */}
7709   \textcolor{keywordflow}{if}( pTail==0 )\{
7710     \textcolor{keywordflow}{for}(pCon=pScan->pRange; rc==SQLITE_OK && pCon; pCon=pCon->pNext)\{
7711       assert( pCon->pLink==0 );
7712       \textcolor{keywordflow}{if}( !idxFindConstraint(p1, pCon) && !idxFindConstraint(pTail, pCon) )\{
7713         rc = idxCreateFromCons(p, pScan, p1, pCon);
7714       \}
7715     \}
7716   \}
7717 
7718   \textcolor{keywordflow}{return} rc;
7719 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab0c63e1071b37a4f971679c766a5d479}} 
\index{shell.\+c@{shell.\+c}!idx\+Create\+Vtab\+Schema@{idx\+Create\+Vtab\+Schema}}
\index{idx\+Create\+Vtab\+Schema@{idx\+Create\+Vtab\+Schema}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Create\+Vtab\+Schema()}
{\footnotesize\ttfamily static int idx\+Create\+Vtab\+Schema (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{char $\ast$$\ast$}]{pz\+Errmsg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 8017 of file shell.\+c.



References Idx\+Table\+::a\+Col, sqlite3expert\+::db, sqlite3expert\+::dbv, idx\+Append\+Text(), idx\+Finalize(), idx\+Get\+Table\+Info(), idx\+Prepare\+Stmt(), idx\+Register\+Vtab(), Idx\+Table\+::n\+Col, Idx\+Table\+::p\+Next, sqlite3expert\+::p\+Table, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+exec, sqlite3\+\_\+free, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, Idx\+Column\+::z\+Coll, and Idx\+Column\+::z\+Name.



Referenced by sqlite3\+\_\+expert\+\_\+new().


\begin{DoxyCode}
8017                                                                  \{
8018   \textcolor{keywordtype}{int} rc = idxRegisterVtab(p);
8019   sqlite3_stmt *pSchema = 0;
8020 
8021   \textcolor{comment}{/* For each table in the main db schema:}
8022 \textcolor{comment}{  **}
8023 \textcolor{comment}{  **   1) Add an entry to the p->pTable list, and}
8024 \textcolor{comment}{  **   2) Create the equivalent virtual table in dbv.}
8025 \textcolor{comment}{  */}
8026   rc = idxPrepareStmt(p->db, &pSchema, pzErrmsg,
8027       \textcolor{stringliteral}{"SELECT type, name, sql, 1 FROM sqlite\_master "}
8028       \textcolor{stringliteral}{"WHERE type IN ('table','view') AND name NOT LIKE 'sqlite\_%%' "}
8029       \textcolor{stringliteral}{" UNION ALL "}
8030       \textcolor{stringliteral}{"SELECT type, name, sql, 2 FROM sqlite\_master "}
8031       \textcolor{stringliteral}{"WHERE type = 'trigger'"}
8032       \textcolor{stringliteral}{"  AND tbl\_name IN(SELECT name FROM sqlite\_master WHERE type = 'view') "}
8033       \textcolor{stringliteral}{"ORDER BY 4, 1"}
8034   );
8035   \textcolor{keywordflow}{while}( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSchema) )\{
8036     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zType = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSchema, 0);
8037     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zName = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSchema, 1);
8038     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSchema, 2);
8039 
8040     \textcolor{keywordflow}{if}( zType[0]==\textcolor{charliteral}{'v'} || zType[1]==\textcolor{charliteral}{'r'} )\{
8041       rc = sqlite3_exec(p->dbv, zSql, 0, 0, pzErrmsg);
8042     \}\textcolor{keywordflow}{else}\{
8043       IdxTable *pTab;
8044       rc = idxGetTableInfo(p->db, zName, &pTab, pzErrmsg);
8045       \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8046         \textcolor{keywordtype}{int} i;
8047         \textcolor{keywordtype}{char} *zInner = 0;
8048         \textcolor{keywordtype}{char} *zOuter = 0;
8049         pTab->pNext = p->pTable;
8050         p->pTable = pTab;
8051 
8052         \textcolor{comment}{/* The statement the vtab will pass to sqlite3\_declare\_vtab() */}
8053         zInner = idxAppendText(&rc, 0, \textcolor{stringliteral}{"CREATE TABLE x("});
8054         \textcolor{keywordflow}{for}(i=0; i<pTab->nCol; i++)\{
8055           zInner = idxAppendText(&rc, zInner, \textcolor{stringliteral}{"%s%Q COLLATE %s"}, 
8056               (i==0 ? \textcolor{stringliteral}{""} : \textcolor{stringliteral}{", "}), pTab->aCol[i].zName, pTab->aCol[i].zColl
8057           );
8058         \}
8059         zInner = idxAppendText(&rc, zInner, \textcolor{stringliteral}{")"});
8060 
8061         \textcolor{comment}{/* The CVT statement to create the vtab */}
8062         zOuter = idxAppendText(&rc, 0, 
8063             \textcolor{stringliteral}{"CREATE VIRTUAL TABLE %Q USING expert(%Q)"}, zName, zInner
8064         );
8065         \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8066           rc = sqlite3_exec(p->dbv, zOuter, 0, 0, pzErrmsg);
8067         \}
8068         sqlite3_free(zInner);
8069         sqlite3_free(zOuter);
8070       \}
8071     \}
8072   \}
8073   idxFinalize(&rc, pSchema);
8074   \textcolor{keywordflow}{return} rc;
8075 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad03b183002e80bbe489ff4ae949e1e26}} 
\index{shell.\+c@{shell.\+c}!idx\+Database\+Error@{idx\+Database\+Error}}
\index{idx\+Database\+Error@{idx\+Database\+Error}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Database\+Error()}
{\footnotesize\ttfamily static void idx\+Database\+Error (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{char $\ast$$\ast$}]{pz\+Errmsg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7003 of file shell.\+c.



References sqlite3\+\_\+errmsg, and sqlite3\+\_\+mprintf.



Referenced by idx\+Prepare\+Stmt(), idx\+Process\+One\+Trigger(), and sqlite3\+\_\+expert\+\_\+sql().


\begin{DoxyCode}
7006  \{
7007   *pzErrmsg = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, sqlite3_errmsg(db));
7008 \}
\end{DoxyCode}
\mbox{\label{shell_8c_afb493589062f8fde75339e1f9116904e}} 
\index{shell.\+c@{shell.\+c}!idx\+Finalize@{idx\+Finalize}}
\index{idx\+Finalize@{idx\+Finalize}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Finalize()}
{\footnotesize\ttfamily static void idx\+Finalize (\begin{DoxyParamCaption}\item[{int $\ast$}]{p\+Rc,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$}]{p\+Stmt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7366 of file shell.\+c.



References sqlite3\+\_\+finalize, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by idx\+Create\+Vtab\+Schema(), idx\+Find\+Compatible(), idx\+Find\+Indexes(), idx\+Get\+Table\+Info(), idx\+Largest\+Index(), idx\+Populate\+One\+Stat1(), idx\+Populate\+Stat1(), idx\+Process\+One\+Trigger(), and sqlite3\+\_\+expert\+\_\+new().


\begin{DoxyCode}
7366                                                       \{
7367   \textcolor{keywordtype}{int} rc = sqlite3_finalize(pStmt);
7368   \textcolor{keywordflow}{if}( *pRc==SQLITE_OK ) *pRc = rc;
7369 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ada20aaac7524a883e626dba2a50b0068}} 
\index{shell.\+c@{shell.\+c}!idx\+Find\+Compatible@{idx\+Find\+Compatible}}
\index{idx\+Find\+Compatible@{idx\+Find\+Compatible}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Find\+Compatible()}
{\footnotesize\ttfamily static int idx\+Find\+Compatible (\begin{DoxyParamCaption}\item[{int $\ast$}]{p\+Rc,  }\item[{\textbf{ sqlite3} $\ast$}]{dbm,  }\item[{\textbf{ Idx\+Scan} $\ast$}]{p\+Scan,  }\item[{\textbf{ Idx\+Constraint} $\ast$}]{p\+Eq,  }\item[{\textbf{ Idx\+Constraint} $\ast$}]{p\+Tail }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7550 of file shell.\+c.



References Idx\+Constraint\+::b\+Flag, Idx\+Constraint\+::i\+Col, idx\+Finalize(), idx\+Printf\+Prepare\+Stmt(), Idx\+Constraint\+::p\+Link, Idx\+Scan\+::p\+Tab, sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+finalize, sqlite3\+\_\+step, sqlite3\+\_\+stricmp, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, Idx\+Constraint\+::z\+Coll, and Idx\+Table\+::z\+Name.



Referenced by idx\+Create\+From\+Cons().


\begin{DoxyCode}
7556  \{
7557   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zTbl = pScan->pTab->zName;
7558   sqlite3_stmt *pIdxList = 0;
7559   IdxConstraint *pIter;
7560   \textcolor{keywordtype}{int} nEq = 0;                    \textcolor{comment}{/* Number of elements in pEq */}
7561   \textcolor{keywordtype}{int} rc;
7562 
7563   \textcolor{comment}{/* Count the elements in list pEq */}
7564   \textcolor{keywordflow}{for}(pIter=pEq; pIter; pIter=pIter->pLink) nEq++;
7565 
7566   rc = idxPrintfPrepareStmt(dbm, &pIdxList, 0, \textcolor{stringliteral}{"PRAGMA index\_list=%Q"}, zTbl);
7567   \textcolor{keywordflow}{while}( rc==SQLITE_OK && sqlite3_step(pIdxList)==SQLITE_ROW )\{
7568     \textcolor{keywordtype}{int} bMatch = 1;
7569     IdxConstraint *pT = pTail;
7570     sqlite3_stmt *pInfo = 0;
7571     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zIdx = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pIdxList, 1);
7572 
7573     \textcolor{comment}{/* Zero the IdxConstraint.bFlag values in the pEq list */}
7574     \textcolor{keywordflow}{for}(pIter=pEq; pIter; pIter=pIter->pLink) pIter->bFlag = 0;
7575 
7576     rc = idxPrintfPrepareStmt(dbm, &pInfo, 0, \textcolor{stringliteral}{"PRAGMA index\_xInfo=%Q"}, zIdx);
7577     \textcolor{keywordflow}{while}( rc==SQLITE_OK && sqlite3_step(pInfo)==SQLITE_ROW )\{
7578       \textcolor{keywordtype}{int} iIdx = sqlite3_column_int(pInfo, 0);
7579       \textcolor{keywordtype}{int} iCol = sqlite3_column_int(pInfo, 1);
7580       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zColl = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pInfo, 4);
7581 
7582       \textcolor{keywordflow}{if}( iIdx<nEq )\{
7583         \textcolor{keywordflow}{for}(pIter=pEq; pIter; pIter=pIter->pLink)\{
7584           \textcolor{keywordflow}{if}( pIter->bFlag ) \textcolor{keywordflow}{continue};
7585           \textcolor{keywordflow}{if}( pIter->iCol!=iCol ) \textcolor{keywordflow}{continue};
7586           \textcolor{keywordflow}{if}( sqlite3_stricmp(pIter->zColl, zColl) ) \textcolor{keywordflow}{continue};
7587           pIter->bFlag = 1;
7588           \textcolor{keywordflow}{break};
7589         \}
7590         \textcolor{keywordflow}{if}( pIter==0 )\{
7591           bMatch = 0;
7592           \textcolor{keywordflow}{break};
7593         \}
7594       \}\textcolor{keywordflow}{else}\{
7595         \textcolor{keywordflow}{if}( pT )\{
7596           \textcolor{keywordflow}{if}( pT->iCol!=iCol || sqlite3_stricmp(pT->zColl, zColl) )\{
7597             bMatch = 0;
7598             \textcolor{keywordflow}{break};
7599           \}
7600           pT = pT->pLink;
7601         \}
7602       \}
7603     \}
7604     idxFinalize(&rc, pInfo);
7605 
7606     \textcolor{keywordflow}{if}( rc==SQLITE_OK && bMatch )\{
7607       sqlite3_finalize(pIdxList);
7608       \textcolor{keywordflow}{return} 1;
7609     \}
7610   \}
7611   idxFinalize(&rc, pIdxList);
7612 
7613   *pRc = rc;
7614   \textcolor{keywordflow}{return} 0;
7615 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a9598670acfc8c8fe0e65c8a59bd9955a}} 
\index{shell.\+c@{shell.\+c}!idx\+Find\+Constraint@{idx\+Find\+Constraint}}
\index{idx\+Find\+Constraint@{idx\+Find\+Constraint}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Find\+Constraint()}
{\footnotesize\ttfamily static int idx\+Find\+Constraint (\begin{DoxyParamCaption}\item[{\textbf{ Idx\+Constraint} $\ast$}]{p\+List,  }\item[{\textbf{ Idx\+Constraint} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7678 of file shell.\+c.



References Idx\+Constraint\+::i\+Col, and Idx\+Constraint\+::p\+Link.



Referenced by idx\+Create\+From\+Where().


\begin{DoxyCode}
7678                                                                     \{
7679   IdxConstraint *pCmp;
7680   \textcolor{keywordflow}{for}(pCmp=pList; pCmp; pCmp=pCmp->pLink)\{
7681     \textcolor{keywordflow}{if}( p->iCol==pCmp->iCol ) \textcolor{keywordflow}{return} 1;
7682   \}
7683   \textcolor{keywordflow}{return} 0;
7684 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a2a24413641b93026890d0b8c09959173}} 
\index{shell.\+c@{shell.\+c}!idx\+Find\+Indexes@{idx\+Find\+Indexes}}
\index{idx\+Find\+Indexes@{idx\+Find\+Indexes}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Find\+Indexes()}
{\footnotesize\ttfamily int idx\+Find\+Indexes (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})}



Definition at line 7814 of file shell.\+c.



References sqlite3expert\+::dbm, sqlite3expert\+::h\+Idx, idx\+Append\+Text(), idx\+Finalize(), idx\+Hash\+Add(), idx\+Hash\+Clear(), idx\+Hash\+Init(), idx\+Hash\+Search(), idx\+Printf\+Prepare\+Stmt(), Idx\+Hash\+::p\+First, Idx\+Statement\+::p\+Next, Idx\+Hash\+Entry\+::p\+Next, sqlite3expert\+::p\+Statement, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+T\+R\+L\+EN, Idx\+Statement\+::z\+E\+QP, Idx\+Statement\+::z\+Idx, Idx\+Hash\+Entry\+::z\+Key, and Idx\+Statement\+::z\+Sql.



Referenced by sqlite3\+\_\+expert\+\_\+analyze().


\begin{DoxyCode}
7817  \{
7818   IdxStatement *pStmt;
7819   sqlite3 *dbm = p->dbm;
7820   \textcolor{keywordtype}{int} rc = SQLITE_OK;
7821 
7822   IdxHash hIdx;
7823   idxHashInit(&hIdx);
7824 
7825   \textcolor{keywordflow}{for}(pStmt=p->pStatement; rc==SQLITE_OK && pStmt; pStmt=pStmt->pNext)\{
7826     IdxHashEntry *pEntry;
7827     sqlite3_stmt *pExplain = 0;
7828     idxHashClear(&hIdx);
7829     rc = idxPrintfPrepareStmt(dbm, &pExplain, pzErr,
7830         \textcolor{stringliteral}{"EXPLAIN QUERY PLAN %s"}, pStmt->zSql
7831     );
7832     \textcolor{keywordflow}{while}( rc==SQLITE_OK && sqlite3_step(pExplain)==SQLITE_ROW )\{
7833       \textcolor{comment}{/* int iId = sqlite3\_column\_int(pExplain, 0); */}
7834       \textcolor{comment}{/* int iParent = sqlite3\_column\_int(pExplain, 1); */}
7835       \textcolor{comment}{/* int iNotUsed = sqlite3\_column\_int(pExplain, 2); */}
7836       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDetail = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pExplain, 3);
7837       \textcolor{keywordtype}{int} nDetail = STRLEN(zDetail);
7838       \textcolor{keywordtype}{int} i;
7839 
7840       \textcolor{keywordflow}{for}(i=0; i<nDetail; i++)\{
7841         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zIdx = 0;
7842         \textcolor{keywordflow}{if}( memcmp(&zDetail[i], \textcolor{stringliteral}{" USING INDEX "}, 13)==0 )\{
7843           zIdx = &zDetail[i+13];
7844         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( memcmp(&zDetail[i], \textcolor{stringliteral}{" USING COVERING INDEX "}, 22)==0 )\{
7845           zIdx = &zDetail[i+22];
7846         \}
7847         \textcolor{keywordflow}{if}( zIdx )\{
7848           \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql;
7849           \textcolor{keywordtype}{int} nIdx = 0;
7850           \textcolor{keywordflow}{while}( zIdx[nIdx]!=\textcolor{charliteral}{'\(\backslash\)0'} && (zIdx[nIdx]!=\textcolor{charliteral}{' '} || zIdx[nIdx+1]!=\textcolor{charliteral}{'('}) )\{
7851             nIdx++;
7852           \}
7853           zSql = idxHashSearch(&p->hIdx, zIdx, nIdx);
7854           \textcolor{keywordflow}{if}( zSql )\{
7855             idxHashAdd(&rc, &hIdx, zSql, 0);
7856             \textcolor{keywordflow}{if}( rc ) \textcolor{keywordflow}{goto} find\_indexes\_out;
7857           \}
7858           \textcolor{keywordflow}{break};
7859         \}
7860       \}
7861 
7862       \textcolor{keywordflow}{if}( zDetail[0]!=\textcolor{charliteral}{'-'} )\{
7863         pStmt->zEQP = idxAppendText(&rc, pStmt->zEQP, \textcolor{stringliteral}{"%s\(\backslash\)n"}, zDetail);
7864       \}
7865     \}
7866 
7867     \textcolor{keywordflow}{for}(pEntry=hIdx.pFirst; pEntry; pEntry=pEntry->pNext)\{
7868       pStmt->zIdx = idxAppendText(&rc, pStmt->zIdx, \textcolor{stringliteral}{"%s;\(\backslash\)n"}, pEntry->zKey);
7869     \}
7870 
7871     idxFinalize(&rc, pExplain);
7872   \}
7873 
7874  find\_indexes\_out:
7875   idxHashClear(&hIdx);
7876   \textcolor{keywordflow}{return} rc;
7877 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a782164d1f0dca2eb359dd325721fabed}} 
\index{shell.\+c@{shell.\+c}!idx\+Get\+Table\+Info@{idx\+Get\+Table\+Info}}
\index{idx\+Get\+Table\+Info@{idx\+Get\+Table\+Info}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Get\+Table\+Info()}
{\footnotesize\ttfamily static int idx\+Get\+Table\+Info (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{const char $\ast$}]{z\+Tab,  }\item[{\textbf{ Idx\+Table} $\ast$$\ast$}]{pp\+Out,  }\item[{char $\ast$$\ast$}]{pz\+Errmsg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7381 of file shell.\+c.



References Idx\+Table\+::a\+Col, idx\+Finalize(), idx\+Malloc(), idx\+Printf\+Prepare\+Stmt(), Idx\+Column\+::i\+Pk, Idx\+Table\+::n\+Col, sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+free, sqlite3\+\_\+reset, sqlite3\+\_\+step, sqlite3\+\_\+table\+\_\+column\+\_\+metadata, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+T\+R\+L\+EN, Idx\+Column\+::z\+Coll, Idx\+Column\+::z\+Name, and Idx\+Table\+::z\+Name.



Referenced by idx\+Create\+Vtab\+Schema().


\begin{DoxyCode}
7386  \{
7387   sqlite3_stmt *p1 = 0;
7388   \textcolor{keywordtype}{int} nCol = 0;
7389   \textcolor{keywordtype}{int} nTab = STRLEN(zTab);
7390   \textcolor{keywordtype}{int} nByte = \textcolor{keyword}{sizeof}(IdxTable) + nTab + 1;
7391   IdxTable *pNew = 0;
7392   \textcolor{keywordtype}{int} rc, rc2;
7393   \textcolor{keywordtype}{char} *pCsr = 0;
7394 
7395   rc = idxPrintfPrepareStmt(db, &p1, pzErrmsg, \textcolor{stringliteral}{"PRAGMA table\_info=%Q"}, zTab);
7396   \textcolor{keywordflow}{while}( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) )\{
7397     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCol = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(p1, 1);
7398     nByte += 1 + STRLEN(zCol);
7399     rc = sqlite3_table_column_metadata(
7400         db, \textcolor{stringliteral}{"main"}, zTab, zCol, 0, &zCol, 0, 0, 0
7401     );
7402     nByte += 1 + STRLEN(zCol);
7403     nCol++;
7404   \}
7405   rc2 = sqlite3_reset(p1);
7406   \textcolor{keywordflow}{if}( rc==SQLITE_OK ) rc = rc2;
7407 
7408   nByte += \textcolor{keyword}{sizeof}(IdxColumn) * nCol;
7409   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7410     pNew = idxMalloc(&rc, nByte);
7411   \}
7412   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7413     pNew->aCol = (IdxColumn*)&pNew[1];
7414     pNew->nCol = nCol;
7415     pCsr = (\textcolor{keywordtype}{char}*)&pNew->aCol[nCol];
7416   \}
7417 
7418   nCol = 0;
7419   \textcolor{keywordflow}{while}( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) )\{
7420     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCol = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(p1, 1);
7421     \textcolor{keywordtype}{int} nCopy = STRLEN(zCol) + 1;
7422     pNew->aCol[nCol].zName = pCsr;
7423     pNew->aCol[nCol].iPk = sqlite3_column_int(p1, 5);
7424     memcpy(pCsr, zCol, nCopy);
7425     pCsr += nCopy;
7426 
7427     rc = sqlite3_table_column_metadata(
7428         db, \textcolor{stringliteral}{"main"}, zTab, zCol, 0, &zCol, 0, 0, 0
7429     );
7430     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7431       nCopy = STRLEN(zCol) + 1;
7432       pNew->aCol[nCol].zColl = pCsr;
7433       memcpy(pCsr, zCol, nCopy);
7434       pCsr += nCopy;
7435     \}
7436 
7437     nCol++;
7438   \}
7439   idxFinalize(&rc, p1);
7440 
7441   \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
7442     sqlite3_free(pNew);
7443     pNew = 0;
7444   \}\textcolor{keywordflow}{else}\{
7445     pNew->zName = pCsr;
7446     memcpy(pNew->zName, zTab, nTab+1);
7447   \}
7448 
7449   *ppOut = pNew;
7450   \textcolor{keywordflow}{return} rc;
7451 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ace86bc4c9b8554caaf468996799016b2}} 
\index{shell.\+c@{shell.\+c}!idx\+Hash\+Add@{idx\+Hash\+Add}}
\index{idx\+Hash\+Add@{idx\+Hash\+Add}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Hash\+Add()}
{\footnotesize\ttfamily static int idx\+Hash\+Add (\begin{DoxyParamCaption}\item[{int $\ast$}]{p\+Rc,  }\item[{\textbf{ Idx\+Hash} $\ast$}]{p\+Hash,  }\item[{const char $\ast$}]{z\+Key,  }\item[{const char $\ast$}]{z\+Val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 6919 of file shell.\+c.



References Idx\+Hash\+::a\+Hash, idx\+Hash\+String(), idx\+Malloc(), Idx\+Hash\+::p\+First, Idx\+Hash\+Entry\+::p\+Hash\+Next, Idx\+Hash\+Entry\+::p\+Next, S\+T\+R\+L\+EN, Idx\+Hash\+Entry\+::z\+Key, and Idx\+Hash\+Entry\+::z\+Val.



Referenced by idx\+Create\+From\+Cons(), and idx\+Find\+Indexes().


\begin{DoxyCode}
6924  \{
6925   \textcolor{keywordtype}{int} nKey = STRLEN(zKey);
6926   \textcolor{keywordtype}{int} iHash = idxHashString(zKey, nKey);
6927   \textcolor{keywordtype}{int} nVal = (zVal ? STRLEN(zVal) : 0);
6928   IdxHashEntry *pEntry;
6929   assert( iHash>=0 );
6930   \textcolor{keywordflow}{for}(pEntry=pHash->aHash[iHash]; pEntry; pEntry=pEntry->pHashNext)\{
6931     \textcolor{keywordflow}{if}( STRLEN(pEntry->zKey)==nKey && 0==memcmp(pEntry->zKey, zKey, nKey) )\{
6932       \textcolor{keywordflow}{return} 1;
6933     \}
6934   \}
6935   pEntry = idxMalloc(pRc, \textcolor{keyword}{sizeof}(IdxHashEntry) + nKey+1 + nVal+1);
6936   \textcolor{keywordflow}{if}( pEntry )\{
6937     pEntry->zKey = (\textcolor{keywordtype}{char}*)&pEntry[1];
6938     memcpy(pEntry->zKey, zKey, nKey);
6939     \textcolor{keywordflow}{if}( zVal )\{
6940       pEntry->zVal = &pEntry->zKey[nKey+1];
6941       memcpy(pEntry->zVal, zVal, nVal);
6942     \}
6943     pEntry->pHashNext = pHash->aHash[iHash];
6944     pHash->aHash[iHash] = pEntry;
6945 
6946     pEntry->pNext = pHash->pFirst;
6947     pHash->pFirst = pEntry;
6948   \}
6949   \textcolor{keywordflow}{return} 0;
6950 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a3b64953059312e7fdbff75125a46d74d}} 
\index{shell.\+c@{shell.\+c}!idx\+Hash\+Clear@{idx\+Hash\+Clear}}
\index{idx\+Hash\+Clear@{idx\+Hash\+Clear}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Hash\+Clear()}
{\footnotesize\ttfamily static void idx\+Hash\+Clear (\begin{DoxyParamCaption}\item[{\textbf{ Idx\+Hash} $\ast$}]{p\+Hash }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 6887 of file shell.\+c.



References Idx\+Hash\+::a\+Hash, I\+D\+X\+\_\+\+H\+A\+S\+H\+\_\+\+S\+I\+ZE, Idx\+Hash\+Entry\+::p\+Hash\+Next, sqlite3\+\_\+free, and Idx\+Hash\+Entry\+::z\+Val2.



Referenced by idx\+Find\+Indexes(), and sqlite3\+\_\+expert\+\_\+destroy().


\begin{DoxyCode}
6887                                         \{
6888   \textcolor{keywordtype}{int} i;
6889   \textcolor{keywordflow}{for}(i=0; i<IDX_HASH_SIZE; i++)\{
6890     IdxHashEntry *pEntry;
6891     IdxHashEntry *pNext;
6892     \textcolor{keywordflow}{for}(pEntry=pHash->aHash[i]; pEntry; pEntry=pNext)\{
6893       pNext = pEntry->pHashNext;
6894       sqlite3_free(pEntry->zVal2);
6895       sqlite3_free(pEntry);
6896     \}
6897   \}
6898   memset(pHash, 0, \textcolor{keyword}{sizeof}(IdxHash));
6899 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a9555c1511a6fbc3959309f9c8378f7e6}} 
\index{shell.\+c@{shell.\+c}!idx\+Hash\+Find@{idx\+Hash\+Find}}
\index{idx\+Hash\+Find@{idx\+Hash\+Find}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Hash\+Find()}
{\footnotesize\ttfamily static \textbf{ Idx\+Hash\+Entry}$\ast$ idx\+Hash\+Find (\begin{DoxyParamCaption}\item[{\textbf{ Idx\+Hash} $\ast$}]{p\+Hash,  }\item[{const char $\ast$}]{z\+Key,  }\item[{int}]{n\+Key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 6956 of file shell.\+c.



References Idx\+Hash\+::a\+Hash, idx\+Hash\+String(), Idx\+Hash\+Entry\+::p\+Hash\+Next, S\+T\+R\+L\+EN, and Idx\+Hash\+Entry\+::z\+Key.



Referenced by idx\+Hash\+Search(), and idx\+Populate\+One\+Stat1().


\begin{DoxyCode}
6956                                                                             \{
6957   \textcolor{keywordtype}{int} iHash;
6958   IdxHashEntry *pEntry;
6959   \textcolor{keywordflow}{if}( nKey<0 ) nKey = STRLEN(zKey);
6960   iHash = idxHashString(zKey, nKey);
6961   assert( iHash>=0 );
6962   \textcolor{keywordflow}{for}(pEntry=pHash->aHash[iHash]; pEntry; pEntry=pEntry->pHashNext)\{
6963     \textcolor{keywordflow}{if}( STRLEN(pEntry->zKey)==nKey && 0==memcmp(pEntry->zKey, zKey, nKey) )\{
6964       \textcolor{keywordflow}{return} pEntry;
6965     \}
6966   \}
6967   \textcolor{keywordflow}{return} 0;
6968 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a26017295a646db6b2bebffd274f5325d}} 
\index{shell.\+c@{shell.\+c}!idx\+Hash\+Init@{idx\+Hash\+Init}}
\index{idx\+Hash\+Init@{idx\+Hash\+Init}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Hash\+Init()}
{\footnotesize\ttfamily static void idx\+Hash\+Init (\begin{DoxyParamCaption}\item[{\textbf{ Idx\+Hash} $\ast$}]{p\+Hash }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 6880 of file shell.\+c.



Referenced by idx\+Find\+Indexes().


\begin{DoxyCode}
6880                                        \{
6881   memset(pHash, 0, \textcolor{keyword}{sizeof}(IdxHash));
6882 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ade8050b9a18bb9c6fc32dd0722691786}} 
\index{shell.\+c@{shell.\+c}!idx\+Hash\+Search@{idx\+Hash\+Search}}
\index{idx\+Hash\+Search@{idx\+Hash\+Search}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Hash\+Search()}
{\footnotesize\ttfamily static const char$\ast$ idx\+Hash\+Search (\begin{DoxyParamCaption}\item[{\textbf{ Idx\+Hash} $\ast$}]{p\+Hash,  }\item[{const char $\ast$}]{z\+Key,  }\item[{int}]{n\+Key }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 6976 of file shell.\+c.



References idx\+Hash\+Find(), and Idx\+Hash\+Entry\+::z\+Val.



Referenced by idx\+Find\+Indexes().


\begin{DoxyCode}
6976                                                                             \{
6977   IdxHashEntry *pEntry = idxHashFind(pHash, zKey, nKey);
6978   \textcolor{keywordflow}{if}( pEntry ) \textcolor{keywordflow}{return} pEntry->zVal;
6979   \textcolor{keywordflow}{return} 0;
6980 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a1a37f6568e04cec53eb9580f79b42282}} 
\index{shell.\+c@{shell.\+c}!idx\+Hash\+String@{idx\+Hash\+String}}
\index{idx\+Hash\+String@{idx\+Hash\+String}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Hash\+String()}
{\footnotesize\ttfamily static int idx\+Hash\+String (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z,  }\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 6905 of file shell.\+c.



References I\+D\+X\+\_\+\+H\+A\+S\+H\+\_\+\+S\+I\+ZE.



Referenced by idx\+Hash\+Add(), and idx\+Hash\+Find().


\begin{DoxyCode}
6905                                               \{
6906   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ret = 0;
6907   \textcolor{keywordtype}{int} i;
6908   \textcolor{keywordflow}{for}(i=0; i<n; i++)\{
6909     ret += (ret<<3) + (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char})(z[i]);
6910   \}
6911   \textcolor{keywordflow}{return} (\textcolor{keywordtype}{int})(ret % IDX_HASH_SIZE);
6912 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aaf67b2870bc586f80d1547513d359301}} 
\index{shell.\+c@{shell.\+c}!idx\+Identifier\+Requires\+Quotes@{idx\+Identifier\+Requires\+Quotes}}
\index{idx\+Identifier\+Requires\+Quotes@{idx\+Identifier\+Requires\+Quotes}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Identifier\+Requires\+Quotes()}
{\footnotesize\ttfamily static int idx\+Identifier\+Requires\+Quotes (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7494 of file shell.\+c.



Referenced by idx\+Append\+Col\+Defn(), and idx\+Create\+From\+Cons().


\begin{DoxyCode}
7494                                                        \{
7495   \textcolor{keywordtype}{int} i;
7496   \textcolor{keywordflow}{for}(i=0; zId[i]; i++)\{
7497     \textcolor{keywordflow}{if}( !(zId[i]==\textcolor{charliteral}{'\_'})
7498      && !(zId[i]>=\textcolor{charliteral}{'0'} && zId[i]<=\textcolor{charliteral}{'9'})
7499      && !(zId[i]>=\textcolor{charliteral}{'a'} && zId[i]<=\textcolor{charliteral}{'z'})
7500      && !(zId[i]>=\textcolor{charliteral}{'A'} && zId[i]<=\textcolor{charliteral}{'Z'})
7501     )\{
7502       \textcolor{keywordflow}{return} 1;
7503     \}
7504   \}
7505   \textcolor{keywordflow}{return} 0;
7506 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a3561fea8a2e8d2b55a17e22c50b6ac0f}} 
\index{shell.\+c@{shell.\+c}!idx\+Largest\+Index@{idx\+Largest\+Index}}
\index{idx\+Largest\+Index@{idx\+Largest\+Index}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Largest\+Index()}
{\footnotesize\ttfamily static int idx\+Largest\+Index (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{int $\ast$}]{pn\+Max,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 8198 of file shell.\+c.



References idx\+Finalize(), idx\+Prepare\+Stmt(), sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW.



Referenced by idx\+Populate\+Stat1().


\begin{DoxyCode}
8198                                                                  \{
8199   \textcolor{keywordtype}{int} rc = SQLITE_OK;
8200   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zMax = 
8201     \textcolor{stringliteral}{"SELECT max(i.seqno) FROM "}
8202     \textcolor{stringliteral}{"  sqlite\_master AS s, "}
8203     \textcolor{stringliteral}{"  pragma\_index\_list(s.name) AS l, "}
8204     \textcolor{stringliteral}{"  pragma\_index\_info(l.name) AS i "}
8205     \textcolor{stringliteral}{"WHERE s.type = 'table'"};
8206   sqlite3_stmt *pMax = 0;
8207 
8208   *pnMax = 0;
8209   rc = idxPrepareStmt(db, &pMax, pzErr, zMax);
8210   \textcolor{keywordflow}{if}( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) )\{
8211     *pnMax = sqlite3_column_int(pMax, 0) + 1;
8212   \}
8213   idxFinalize(&rc, pMax);
8214 
8215   \textcolor{keywordflow}{return} rc;
8216 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aff206e9b311f2086145512290034832c}} 
\index{shell.\+c@{shell.\+c}!idx\+Malloc@{idx\+Malloc}}
\index{idx\+Malloc@{idx\+Malloc}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Malloc()}
{\footnotesize\ttfamily static void$\ast$ idx\+Malloc (\begin{DoxyParamCaption}\item[{int $\ast$}]{p\+Rc,  }\item[{int}]{n\+Byte }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 6864 of file shell.\+c.



References sqlite3\+\_\+malloc, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by expert\+Best\+Index(), expert\+Connect(), expert\+Open(), idx\+Auth\+Callback(), idx\+Get\+Table\+Info(), idx\+Hash\+Add(), idx\+New\+Constraint(), idx\+Populate\+One\+Stat1(), idx\+Populate\+Stat1(), sqlite3\+\_\+expert\+\_\+new(), and sqlite3\+\_\+expert\+\_\+sql().


\begin{DoxyCode}
6864                                            \{
6865   \textcolor{keywordtype}{void} *pRet;
6866   assert( *pRc==SQLITE_OK );
6867   assert( nByte>0 );
6868   pRet = sqlite3_malloc(nByte);
6869   \textcolor{keywordflow}{if}( pRet )\{
6870     memset(pRet, 0, nByte);
6871   \}\textcolor{keywordflow}{else}\{
6872     *pRc = SQLITE_NOMEM;
6873   \}
6874   \textcolor{keywordflow}{return} pRet;
6875 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aae8786963deda2cb5cd5fa92ebd775fa}} 
\index{shell.\+c@{shell.\+c}!idx\+New\+Constraint@{idx\+New\+Constraint}}
\index{idx\+New\+Constraint@{idx\+New\+Constraint}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+New\+Constraint()}
{\footnotesize\ttfamily static \textbf{ Idx\+Constraint}$\ast$ idx\+New\+Constraint (\begin{DoxyParamCaption}\item[{int $\ast$}]{p\+Rc,  }\item[{const char $\ast$}]{z\+Coll }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 6986 of file shell.\+c.



References idx\+Malloc(), S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+T\+R\+L\+EN, and Idx\+Constraint\+::z\+Coll.



Referenced by expert\+Best\+Index().


\begin{DoxyCode}
6986                                                                    \{
6987   IdxConstraint *pNew;
6988   \textcolor{keywordtype}{int} nColl = STRLEN(zColl);
6989 
6990   assert( *pRc==SQLITE_OK );
6991   pNew = (IdxConstraint*)idxMalloc(pRc, \textcolor{keyword}{sizeof}(IdxConstraint) * nColl + 1);
6992   \textcolor{keywordflow}{if}( pNew )\{
6993     pNew->zColl = (\textcolor{keywordtype}{char}*)&pNew[1];
6994     memcpy(pNew->zColl, zColl, nColl+1);
6995   \}
6996   \textcolor{keywordflow}{return} pNew;
6997 \}
\end{DoxyCode}
\mbox{\label{shell_8c_acfa10c4168ebb7a78886d879ab6e0230}} 
\index{shell.\+c@{shell.\+c}!idx\+Populate\+One\+Stat1@{idx\+Populate\+One\+Stat1}}
\index{idx\+Populate\+One\+Stat1@{idx\+Populate\+One\+Stat1}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Populate\+One\+Stat1()}
{\footnotesize\ttfamily static int idx\+Populate\+One\+Stat1 (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$}]{p\+Index\+X\+Info,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$}]{p\+Write\+Stat,  }\item[{const char $\ast$}]{z\+Tab,  }\item[{const char $\ast$}]{z\+Idx,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 8218 of file shell.\+c.



References sqlite3expert\+::db, sqlite3expert\+::dbv, sqlite3expert\+::h\+Idx, idx\+Append\+Text(), idx\+Finalize(), idx\+Hash\+Find(), idx\+Malloc(), idx\+Prepare\+Stmt(), sqlite3expert\+::i\+Sample, sqlite3\+\_\+bind\+\_\+text, sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+reset, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+IC, S\+T\+R\+L\+EN, U\+N\+I\+Q\+U\+E\+\_\+\+T\+A\+B\+L\+E\+\_\+\+N\+A\+ME, and Idx\+Hash\+Entry\+::z\+Val2.



Referenced by idx\+Populate\+Stat1().


\begin{DoxyCode}
8225  \{
8226   \textcolor{keywordtype}{char} *zCols = 0;
8227   \textcolor{keywordtype}{char} *zOrder = 0;
8228   \textcolor{keywordtype}{char} *zQuery = 0;
8229   \textcolor{keywordtype}{int} nCol = 0;
8230   \textcolor{keywordtype}{int} i;
8231   sqlite3_stmt *pQuery = 0;
8232   \textcolor{keywordtype}{int} *aStat = 0;
8233   \textcolor{keywordtype}{int} rc = SQLITE_OK;
8234 
8235   assert( p->iSample>0 );
8236 
8237   \textcolor{comment}{/* Formulate the query text */}
8238   sqlite3_bind_text(pIndexXInfo, 1, zIdx, -1, SQLITE_STATIC);
8239   \textcolor{keywordflow}{while}( SQLITE_OK==rc && SQLITE_ROW==sqlite3_step(pIndexXInfo) )\{
8240     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zComma = zCols==0 ? \textcolor{stringliteral}{""} : \textcolor{stringliteral}{", "};
8241     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zName = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pIndexXInfo, 0);
8242     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zColl = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pIndexXInfo, 1);
8243     zCols = idxAppendText(&rc, zCols, 
8244         \textcolor{stringliteral}{"%sx.%Q IS rem(%d, x.%Q) COLLATE %s"}, zComma, zName, nCol, zName, zColl
8245     );
8246     zOrder = idxAppendText(&rc, zOrder, \textcolor{stringliteral}{"%s%d"}, zComma, ++nCol);
8247   \}
8248   sqlite3_reset(pIndexXInfo);
8249   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8250     \textcolor{keywordflow}{if}( p->iSample==100 )\{
8251       zQuery = sqlite3_mprintf(
8252           \textcolor{stringliteral}{"SELECT %s FROM %Q x ORDER BY %s"}, zCols, zTab, zOrder
8253       );
8254     \}\textcolor{keywordflow}{else}\{
8255       zQuery = sqlite3_mprintf(
8256           \textcolor{stringliteral}{"SELECT %s FROM temp."}UNIQUE_TABLE_NAME\textcolor{stringliteral}{" x ORDER BY %s"}, zCols, zOrder
8257       );
8258     \}
8259   \}
8260   sqlite3_free(zCols);
8261   sqlite3_free(zOrder);
8262 
8263   \textcolor{comment}{/* Formulate the query text */}
8264   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8265     sqlite3 *dbrem = (p->iSample==100 ? p->db : p->dbv);
8266     rc = idxPrepareStmt(dbrem, &pQuery, pzErr, zQuery);
8267   \}
8268   sqlite3_free(zQuery);
8269 
8270   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8271     aStat = (\textcolor{keywordtype}{int}*)idxMalloc(&rc, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int})*(nCol+1));
8272   \}
8273   \textcolor{keywordflow}{if}( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pQuery) )\{
8274     IdxHashEntry *pEntry;
8275     \textcolor{keywordtype}{char} *zStat = 0;
8276     \textcolor{keywordflow}{for}(i=0; i<=nCol; i++) aStat[i] = 1;
8277     \textcolor{keywordflow}{while}( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pQuery) )\{
8278       aStat[0]++;
8279       \textcolor{keywordflow}{for}(i=0; i<nCol; i++)\{
8280         \textcolor{keywordflow}{if}( sqlite3_column_int(pQuery, i)==0 ) \textcolor{keywordflow}{break};
8281       \}
8282       \textcolor{keywordflow}{for}(\textcolor{comment}{/*no-op*/}; i<nCol; i++)\{
8283         aStat[i+1]++;
8284       \}
8285     \}
8286 
8287     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8288       \textcolor{keywordtype}{int} s0 = aStat[0];
8289       zStat = sqlite3_mprintf(\textcolor{stringliteral}{"%d"}, s0);
8290       \textcolor{keywordflow}{if}( zStat==0 ) rc = SQLITE_NOMEM;
8291       \textcolor{keywordflow}{for}(i=1; rc==SQLITE_OK && i<=nCol; i++)\{
8292         zStat = idxAppendText(&rc, zStat, \textcolor{stringliteral}{" %d"}, (s0+aStat[i]/2) / aStat[i]);
8293       \}
8294     \}
8295 
8296     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8297       sqlite3_bind_text(pWriteStat, 1, zTab, -1, SQLITE_STATIC);
8298       sqlite3_bind_text(pWriteStat, 2, zIdx, -1, SQLITE_STATIC);
8299       sqlite3_bind_text(pWriteStat, 3, zStat, -1, SQLITE_STATIC);
8300       sqlite3_step(pWriteStat);
8301       rc = sqlite3_reset(pWriteStat);
8302     \}
8303 
8304     pEntry = idxHashFind(&p->hIdx, zIdx, STRLEN(zIdx));
8305     \textcolor{keywordflow}{if}( pEntry )\{
8306       assert( pEntry->zVal2==0 );
8307       pEntry->zVal2 = zStat;
8308     \}\textcolor{keywordflow}{else}\{
8309       sqlite3_free(zStat);
8310     \}
8311   \}
8312   sqlite3_free(aStat);
8313   idxFinalize(&rc, pQuery);
8314 
8315   \textcolor{keywordflow}{return} rc;
8316 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a4810e06bb8750e4c7abbacdf97cd88e5}} 
\index{shell.\+c@{shell.\+c}!idx\+Populate\+Stat1@{idx\+Populate\+Stat1}}
\index{idx\+Populate\+Stat1@{idx\+Populate\+Stat1}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Populate\+Stat1()}
{\footnotesize\ttfamily static int idx\+Populate\+Stat1 (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 8342 of file shell.\+c.



References Idx\+Rem\+Ctx\+::a\+Slot, sqlite3expert\+::db, sqlite3expert\+::dbm, sqlite3expert\+::dbv, idx\+Build\+Sample\+Table(), idx\+Finalize(), idx\+Largest\+Index(), idx\+Malloc(), idx\+Populate\+One\+Stat1(), idx\+Prepare\+Stmt(), idx\+Rem\+Func(), idx\+Sample\+Func(), sqlite3expert\+::i\+Sample, Idx\+Sample\+Ctx\+::i\+Target, Idx\+Sample\+Ctx\+::n\+Ret, Idx\+Sample\+Ctx\+::n\+Row, Idx\+Rem\+Ctx\+::n\+Slot, sqlite3\+\_\+column\+\_\+int64, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+create\+\_\+function, sqlite3\+\_\+exec, sqlite3\+\_\+free, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+U\+T\+F8, Idx\+Sample\+Ctx\+::target, U\+N\+I\+Q\+U\+E\+\_\+\+T\+A\+B\+L\+E\+\_\+\+N\+A\+ME, and Idx\+Rem\+Ctx\+::\+Idx\+Rem\+Slot\+::z.



Referenced by sqlite3\+\_\+expert\+\_\+analyze().


\begin{DoxyCode}
8342                                                            \{
8343   \textcolor{keywordtype}{int} rc = SQLITE_OK;
8344   \textcolor{keywordtype}{int} nMax =0;
8345   \textcolor{keyword}{struct }IdxRemCtx *pCtx = 0;
8346   \textcolor{keyword}{struct }IdxSampleCtx samplectx; 
8347   \textcolor{keywordtype}{int} i;
8348   i64 iPrev = -100000;
8349   sqlite3_stmt *pAllIndex = 0;
8350   sqlite3_stmt *pIndexXInfo = 0;
8351   sqlite3_stmt *pWrite = 0;
8352 
8353   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zAllIndex =
8354     \textcolor{stringliteral}{"SELECT s.rowid, s.name, l.name FROM "}
8355     \textcolor{stringliteral}{"  sqlite\_master AS s, "}
8356     \textcolor{stringliteral}{"  pragma\_index\_list(s.name) AS l "}
8357     \textcolor{stringliteral}{"WHERE s.type = 'table'"};
8358   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zIndexXInfo = 
8359     \textcolor{stringliteral}{"SELECT name, coll FROM pragma\_index\_xinfo(?) WHERE key"};
8360   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zWrite = \textcolor{stringliteral}{"INSERT INTO sqlite\_stat1 VALUES(?, ?, ?)"};
8361 
8362   \textcolor{comment}{/* If iSample==0, no sqlite\_stat1 data is required. */}
8363   \textcolor{keywordflow}{if}( p->iSample==0 ) \textcolor{keywordflow}{return} SQLITE_OK;
8364 
8365   rc = idxLargestIndex(p->dbm, &nMax, pzErr);
8366   \textcolor{keywordflow}{if}( nMax<=0 || rc!=SQLITE_OK ) \textcolor{keywordflow}{return} rc;
8367 
8368   rc = sqlite3_exec(p->dbm, \textcolor{stringliteral}{"ANALYZE; PRAGMA writable\_schema=1"}, 0, 0, 0);
8369 
8370   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8371     \textcolor{keywordtype}{int} nByte = \textcolor{keyword}{sizeof}(\textcolor{keyword}{struct }IdxRemCtx) + (sizeof(struct IdxRemSlot) * nMax);
8372     pCtx = (\textcolor{keyword}{struct }IdxRemCtx*)idxMalloc(&rc, nByte);
8373   \}
8374 
8375   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8376     sqlite3 *dbrem = (p->iSample==100 ? p->db : p->dbv);
8377     rc = sqlite3_create_function(
8378         dbrem, \textcolor{stringliteral}{"rem"}, 2, SQLITE_UTF8, (\textcolor{keywordtype}{void}*)pCtx, idxRemFunc, 0, 0
8379     );
8380   \}
8381   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8382     rc = sqlite3_create_function(
8383         p->db, \textcolor{stringliteral}{"sample"}, 0, SQLITE_UTF8, (\textcolor{keywordtype}{void}*)&samplectx, idxSampleFunc, 0, 0
8384     );
8385   \}
8386 
8387   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8388     pCtx->nSlot = nMax+1;
8389     rc = idxPrepareStmt(p->dbm, &pAllIndex, pzErr, zAllIndex);
8390   \}
8391   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8392     rc = idxPrepareStmt(p->dbm, &pIndexXInfo, pzErr, zIndexXInfo);
8393   \}
8394   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8395     rc = idxPrepareStmt(p->dbm, &pWrite, pzErr, zWrite);
8396   \}
8397 
8398   \textcolor{keywordflow}{while}( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pAllIndex) )\{
8399     i64 iRowid = sqlite3_column_int64(pAllIndex, 0);
8400     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zTab = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pAllIndex, 1);
8401     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zIdx = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pAllIndex, 2);
8402     \textcolor{keywordflow}{if}( p->iSample<100 && iPrev!=iRowid )\{
8403       samplectx.target = (double)p->iSample / 100.0;
8404       samplectx.iTarget = p->iSample;
8405       samplectx.nRow = 0.0;
8406       samplectx.nRet = 0.0;
8407       rc = idxBuildSampleTable(p, zTab);
8408       \textcolor{keywordflow}{if}( rc!=SQLITE_OK ) \textcolor{keywordflow}{break};
8409     \}
8410     rc = idxPopulateOneStat1(p, pIndexXInfo, pWrite, zTab, zIdx, pzErr);
8411     iPrev = iRowid;
8412   \}
8413   \textcolor{keywordflow}{if}( rc==SQLITE_OK && p->iSample<100 )\{
8414     rc = sqlite3_exec(p->dbv, 
8415         \textcolor{stringliteral}{"DROP TABLE IF EXISTS temp."} UNIQUE_TABLE_NAME, 0,0,0
8416     );
8417   \}
8418 
8419   idxFinalize(&rc, pAllIndex);
8420   idxFinalize(&rc, pIndexXInfo);
8421   idxFinalize(&rc, pWrite);
8422 
8423   \textcolor{keywordflow}{for}(i=0; i<pCtx->nSlot; i++)\{
8424     sqlite3_free(pCtx->aSlot[i].z);
8425   \}
8426   sqlite3_free(pCtx);
8427 
8428   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8429     rc = sqlite3_exec(p->dbm, \textcolor{stringliteral}{"ANALYZE sqlite\_master"}, 0, 0, 0);
8430   \}
8431 
8432   sqlite3_exec(p->db, \textcolor{stringliteral}{"DROP TABLE IF EXISTS temp."}UNIQUE_TABLE_NAME,0,0,0);
8433   \textcolor{keywordflow}{return} rc;
8434 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a4ad790c8d14edc02a89d00fc44e64391}} 
\index{shell.\+c@{shell.\+c}!idx\+Prepare\+Stmt@{idx\+Prepare\+Stmt}}
\index{idx\+Prepare\+Stmt@{idx\+Prepare\+Stmt}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Prepare\+Stmt()}
{\footnotesize\ttfamily static int idx\+Prepare\+Stmt (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$$\ast$}]{pp\+Stmt,  }\item[{char $\ast$$\ast$}]{pz\+Errmsg,  }\item[{const char $\ast$}]{z\+Sql }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7013 of file shell.\+c.



References idx\+Database\+Error(), sqlite3\+\_\+prepare\+\_\+v2, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by idx\+Create\+Vtab\+Schema(), idx\+Largest\+Index(), idx\+Populate\+One\+Stat1(), idx\+Populate\+Stat1(), and idx\+Printf\+Prepare\+Stmt().


\begin{DoxyCode}
7018  \{
7019   \textcolor{keywordtype}{int} rc = sqlite3_prepare_v2(db, zSql, -1, ppStmt, 0);
7020   \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
7021     *ppStmt = 0;
7022     idxDatabaseError(db, pzErrmsg);
7023   \}
7024   \textcolor{keywordflow}{return} rc;
7025 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae40fe101378f0ab167164c95cced70ba}} 
\index{shell.\+c@{shell.\+c}!idx\+Printf\+Prepare\+Stmt@{idx\+Printf\+Prepare\+Stmt}}
\index{idx\+Printf\+Prepare\+Stmt@{idx\+Printf\+Prepare\+Stmt}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Printf\+Prepare\+Stmt()}
{\footnotesize\ttfamily static int idx\+Printf\+Prepare\+Stmt (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$$\ast$}]{pp\+Stmt,  }\item[{char $\ast$$\ast$}]{pz\+Errmsg,  }\item[{const char $\ast$}]{z\+Fmt,  }\item[{}]{... }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7030 of file shell.\+c.



References idx\+Prepare\+Stmt(), sqlite3\+\_\+free, sqlite3\+\_\+vmprintf, and S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM.



Referenced by expert\+Filter(), idx\+Find\+Compatible(), idx\+Find\+Indexes(), idx\+Get\+Table\+Info(), idx\+Process\+One\+Trigger(), and sqlite3\+\_\+expert\+\_\+new().


\begin{DoxyCode}
7036  \{
7037   va\_list ap;
7038   \textcolor{keywordtype}{int} rc;
7039   \textcolor{keywordtype}{char} *zSql;
7040   va\_start(ap, zFmt);
7041   zSql = sqlite3_vmprintf(zFmt, ap);
7042   \textcolor{keywordflow}{if}( zSql==0 )\{
7043     rc = SQLITE_NOMEM;
7044   \}\textcolor{keywordflow}{else}\{
7045     rc = idxPrepareStmt(db, ppStmt, pzErrmsg, zSql);
7046     sqlite3_free(zSql);
7047   \}
7048   va\_end(ap);
7049   \textcolor{keywordflow}{return} rc;
7050 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a3b2da0cb684b8584e24ea70ce081386a}} 
\index{shell.\+c@{shell.\+c}!idx\+Process\+One\+Trigger@{idx\+Process\+One\+Trigger}}
\index{idx\+Process\+One\+Trigger@{idx\+Process\+One\+Trigger}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Process\+One\+Trigger()}
{\footnotesize\ttfamily static int idx\+Process\+One\+Trigger (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{\textbf{ Idx\+Write} $\ast$}]{p\+Write,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7917 of file shell.\+c.



References Idx\+Table\+::a\+Col, sqlite3expert\+::db, sqlite3expert\+::dbv, Idx\+Write\+::e\+Op, idx\+Append\+Text(), idx\+Database\+Error(), idx\+Finalize(), idx\+Printf\+Prepare\+Stmt(), Idx\+Table\+::n\+Col, Idx\+Write\+::p\+Tab, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+exec, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+D\+E\+L\+E\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+S\+E\+RT, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+U\+P\+D\+A\+TE, U\+N\+I\+Q\+U\+E\+\_\+\+T\+A\+B\+L\+E\+\_\+\+N\+A\+ME, Idx\+Column\+::z\+Name, and Idx\+Table\+::z\+Name.



Referenced by idx\+Process\+Triggers().


\begin{DoxyCode}
7921  \{
7922   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zInt = UNIQUE_TABLE_NAME;
7923   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zDrop = \textcolor{stringliteral}{"DROP TABLE "} UNIQUE_TABLE_NAME;
7924   IdxTable *pTab = pWrite->pTab;
7925   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zTab = pTab->zName;
7926   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql = 
7927     \textcolor{stringliteral}{"SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite\_master "}
7928     \textcolor{stringliteral}{"WHERE tbl\_name = %Q AND type IN ('table', 'trigger') "}
7929     \textcolor{stringliteral}{"ORDER BY type;"};
7930   sqlite3_stmt *pSelect = 0;
7931   \textcolor{keywordtype}{int} rc = SQLITE_OK;
7932   \textcolor{keywordtype}{char} *zWrite = 0;
7933 
7934   \textcolor{comment}{/* Create the table and its triggers in the temp schema */}
7935   rc = idxPrintfPrepareStmt(p->db, &pSelect, pzErr, zSql, zTab, zTab);
7936   \textcolor{keywordflow}{while}( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSelect) )\{
7937     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCreate = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSelect, 0);
7938     rc = sqlite3_exec(p->dbv, zCreate, 0, 0, pzErr);
7939   \}
7940   idxFinalize(&rc, pSelect);
7941 
7942   \textcolor{comment}{/* Rename the table in the temp schema to zInt */}
7943   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7944     \textcolor{keywordtype}{char} *z = sqlite3_mprintf(\textcolor{stringliteral}{"ALTER TABLE temp.%Q RENAME TO %Q"}, zTab, zInt);
7945     \textcolor{keywordflow}{if}( z==0 )\{
7946       rc = SQLITE_NOMEM;
7947     \}\textcolor{keywordflow}{else}\{
7948       rc = sqlite3_exec(p->dbv, z, 0, 0, pzErr);
7949       sqlite3_free(z);
7950     \}
7951   \}
7952 
7953   \textcolor{keywordflow}{switch}( pWrite->eOp )\{
7954     \textcolor{keywordflow}{case} SQLITE_INSERT: \{
7955       \textcolor{keywordtype}{int} i;
7956       zWrite = idxAppendText(&rc, zWrite, \textcolor{stringliteral}{"INSERT INTO %Q VALUES("}, zInt);
7957       \textcolor{keywordflow}{for}(i=0; i<pTab->nCol; i++)\{
7958         zWrite = idxAppendText(&rc, zWrite, \textcolor{stringliteral}{"%s?"}, i==0 ? \textcolor{stringliteral}{""} : \textcolor{stringliteral}{", "});
7959       \}
7960       zWrite = idxAppendText(&rc, zWrite, \textcolor{stringliteral}{")"});
7961       \textcolor{keywordflow}{break};
7962     \}
7963     \textcolor{keywordflow}{case} SQLITE_UPDATE: \{
7964       \textcolor{keywordtype}{int} i;
7965       zWrite = idxAppendText(&rc, zWrite, \textcolor{stringliteral}{"UPDATE %Q SET "}, zInt);
7966       \textcolor{keywordflow}{for}(i=0; i<pTab->nCol; i++)\{
7967         zWrite = idxAppendText(&rc, zWrite, \textcolor{stringliteral}{"%s%Q=?"}, i==0 ? \textcolor{stringliteral}{""} : \textcolor{stringliteral}{", "}, 
7968             pTab->aCol[i].zName
7969         );
7970       \}
7971       \textcolor{keywordflow}{break};
7972     \}
7973     \textcolor{keywordflow}{default}: \{
7974       assert( pWrite->eOp==SQLITE_DELETE );
7975       \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7976         zWrite = sqlite3_mprintf(\textcolor{stringliteral}{"DELETE FROM %Q"}, zInt);
7977         \textcolor{keywordflow}{if}( zWrite==0 ) rc = SQLITE_NOMEM;
7978       \}
7979     \}
7980   \}
7981 
7982   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7983     sqlite3_stmt *pX = 0;
7984     rc = sqlite3_prepare_v2(p->dbv, zWrite, -1, &pX, 0);
7985     idxFinalize(&rc, pX);
7986     \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
7987       idxDatabaseError(p->dbv, pzErr);
7988     \}
7989   \}
7990   sqlite3_free(zWrite);
7991 
7992   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
7993     rc = sqlite3_exec(p->dbv, zDrop, 0, 0, pzErr);
7994   \}
7995 
7996   \textcolor{keywordflow}{return} rc;
7997 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aeb5a9d9924b5aaa3362e6e81aa3a6470}} 
\index{shell.\+c@{shell.\+c}!idx\+Process\+Triggers@{idx\+Process\+Triggers}}
\index{idx\+Process\+Triggers@{idx\+Process\+Triggers}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Process\+Triggers()}
{\footnotesize\ttfamily static int idx\+Process\+Triggers (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7999 of file shell.\+c.



References idx\+Process\+One\+Trigger(), Idx\+Write\+::p\+Next, sqlite3expert\+::p\+Write, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by sqlite3\+\_\+expert\+\_\+analyze().


\begin{DoxyCode}
7999                                                              \{
8000   \textcolor{keywordtype}{int} rc = SQLITE_OK;
8001   IdxWrite *pEnd = 0;
8002   IdxWrite *pFirst = p->pWrite;
8003 
8004   \textcolor{keywordflow}{while}( rc==SQLITE_OK && pFirst!=pEnd )\{
8005     IdxWrite *pIter;
8006     \textcolor{keywordflow}{for}(pIter=pFirst; rc==SQLITE_OK && pIter!=pEnd; pIter=pIter->pNext)\{
8007       rc = idxProcessOneTrigger(p, pIter, pzErr);
8008     \}
8009     pEnd = pFirst;
8010     pFirst = p->pWrite;
8011   \}
8012 
8013   \textcolor{keywordflow}{return} rc;
8014 \}
\end{DoxyCode}
\mbox{\label{shell_8c_acab9fa71f41fd7897853ffba84fa6f88}} 
\index{shell.\+c@{shell.\+c}!idx\+Register\+Vtab@{idx\+Register\+Vtab}}
\index{idx\+Register\+Vtab@{idx\+Register\+Vtab}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Register\+Vtab()}
{\footnotesize\ttfamily static int idx\+Register\+Vtab (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7328 of file shell.\+c.



References sqlite3expert\+::dbv, expert\+Best\+Index(), expert\+Close(), expert\+Column(), expert\+Connect(), expert\+Disconnect(), expert\+Eof(), expert\+Filter(), expert\+Next(), expert\+Open(), expert\+Rowid(), expert\+Update(), and sqlite3\+\_\+create\+\_\+module.



Referenced by idx\+Create\+Vtab\+Schema().


\begin{DoxyCode}
7328                                             \{
7329   \textcolor{keyword}{static} sqlite3_module expertModule = \{
7330     2,                            \textcolor{comment}{/* iVersion */}
7331     expertConnect,                \textcolor{comment}{/* xCreate - create a table */}
7332     expertConnect,                \textcolor{comment}{/* xConnect - connect to an existing table */}
7333     expertBestIndex,              \textcolor{comment}{/* xBestIndex - Determine search strategy */}
7334     expertDisconnect,             \textcolor{comment}{/* xDisconnect - Disconnect from a table */}
7335     expertDisconnect,             \textcolor{comment}{/* xDestroy - Drop a table */}
7336     expertOpen,                   \textcolor{comment}{/* xOpen - open a cursor */}
7337     expertClose,                  \textcolor{comment}{/* xClose - close a cursor */}
7338     expertFilter,                 \textcolor{comment}{/* xFilter - configure scan constraints */}
7339     expertNext,                   \textcolor{comment}{/* xNext - advance a cursor */}
7340     expertEof,                    \textcolor{comment}{/* xEof */}
7341     expertColumn,                 \textcolor{comment}{/* xColumn - read data */}
7342     expertRowid,                  \textcolor{comment}{/* xRowid - read data */}
7343     expertUpdate,                 \textcolor{comment}{/* xUpdate - write data */}
7344     0,                            \textcolor{comment}{/* xBegin - begin transaction */}
7345     0,                            \textcolor{comment}{/* xSync - sync transaction */}
7346     0,                            \textcolor{comment}{/* xCommit - commit transaction */}
7347     0,                            \textcolor{comment}{/* xRollback - rollback transaction */}
7348     0,                            \textcolor{comment}{/* xFindFunction - function overloading */}
7349     0,                            \textcolor{comment}{/* xRename - rename the table */}
7350     0,                            \textcolor{comment}{/* xSavepoint */}
7351     0,                            \textcolor{comment}{/* xRelease */}
7352     0,                            \textcolor{comment}{/* xRollbackTo */}
7353     0,                            \textcolor{comment}{/* xShadowName */}
7354   \};
7355 
7356   \textcolor{keywordflow}{return} sqlite3_create_module(p->dbv, \textcolor{stringliteral}{"expert"}, &expertModule, (\textcolor{keywordtype}{void}*)p);
7357 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad8b9cf147e719b32c3d6650149a7d180}} 
\index{shell.\+c@{shell.\+c}!idx\+Rem\+Func@{idx\+Rem\+Func}}
\index{idx\+Rem\+Func@{idx\+Rem\+Func}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Rem\+Func()}
{\footnotesize\ttfamily static void idx\+Rem\+Func (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{p\+Ctx,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 8125 of file shell.\+c.



References Idx\+Rem\+Ctx\+::a\+Slot, sqlite3\+\_\+realloc, sqlite3\+\_\+result\+\_\+blob, sqlite3\+\_\+result\+\_\+double, sqlite3\+\_\+result\+\_\+error\+\_\+nomem, sqlite3\+\_\+result\+\_\+int64, sqlite3\+\_\+result\+\_\+text, sqlite3\+\_\+user\+\_\+data, sqlite3\+\_\+value\+\_\+blob, sqlite3\+\_\+value\+\_\+bytes, sqlite3\+\_\+value\+\_\+double, sqlite3\+\_\+value\+\_\+int, sqlite3\+\_\+value\+\_\+int64, sqlite3\+\_\+value\+\_\+text, sqlite3\+\_\+value\+\_\+type, S\+Q\+L\+I\+T\+E\+\_\+\+B\+L\+OB, S\+Q\+L\+I\+T\+E\+\_\+\+F\+L\+O\+AT, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+T\+E\+G\+ER, S\+Q\+L\+I\+T\+E\+\_\+\+N\+U\+LL, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+XT, and S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT.



Referenced by idx\+Populate\+Stat1().


\begin{DoxyCode}
8129  \{
8130   \textcolor{keyword}{struct }IdxRemCtx *p = (\textcolor{keyword}{struct }IdxRemCtx*)sqlite3_user_data(pCtx);
8131   \textcolor{keyword}{struct }IdxRemSlot *pSlot;
8132   \textcolor{keywordtype}{int} iSlot;
8133   assert( argc==2 );
8134 
8135   iSlot = sqlite3_value_int(argv[0]);
8136   assert( iSlot<=p->nSlot );
8137   pSlot = &p->aSlot[iSlot];
8138 
8139   \textcolor{keywordflow}{switch}( pSlot->eType )\{
8140     \textcolor{keywordflow}{case} SQLITE_NULL:
8141       \textcolor{comment}{/* no-op */}
8142       \textcolor{keywordflow}{break};
8143 
8144     \textcolor{keywordflow}{case} SQLITE_INTEGER:
8145       sqlite3_result_int64(pCtx, pSlot->iVal);
8146       \textcolor{keywordflow}{break};
8147 
8148     \textcolor{keywordflow}{case} SQLITE_FLOAT:
8149       sqlite3_result_double(pCtx, pSlot->rVal);
8150       \textcolor{keywordflow}{break};
8151 
8152     \textcolor{keywordflow}{case} SQLITE_BLOB:
8153       sqlite3_result_blob(pCtx, pSlot->z, pSlot->n, SQLITE_TRANSIENT);
8154       \textcolor{keywordflow}{break};
8155 
8156     \textcolor{keywordflow}{case} SQLITE_TEXT:
8157       sqlite3_result_text(pCtx, pSlot->z, pSlot->n, SQLITE_TRANSIENT);
8158       \textcolor{keywordflow}{break};
8159   \}
8160 
8161   pSlot->eType = sqlite3_value_type(argv[1]);
8162   \textcolor{keywordflow}{switch}( pSlot->eType )\{
8163     \textcolor{keywordflow}{case} SQLITE_NULL:
8164       \textcolor{comment}{/* no-op */}
8165       \textcolor{keywordflow}{break};
8166 
8167     \textcolor{keywordflow}{case} SQLITE_INTEGER:
8168       pSlot->iVal = sqlite3_value_int64(argv[1]);
8169       \textcolor{keywordflow}{break};
8170 
8171     \textcolor{keywordflow}{case} SQLITE_FLOAT:
8172       pSlot->rVal = sqlite3_value_double(argv[1]);
8173       \textcolor{keywordflow}{break};
8174 
8175     \textcolor{keywordflow}{case} SQLITE_BLOB:
8176     \textcolor{keywordflow}{case} SQLITE_TEXT: \{
8177       \textcolor{keywordtype}{int} nByte = sqlite3_value_bytes(argv[1]);
8178       \textcolor{keywordflow}{if}( nByte>pSlot->nByte )\{
8179         \textcolor{keywordtype}{char} *zNew = (\textcolor{keywordtype}{char}*)sqlite3_realloc(pSlot->z, nByte*2);
8180         \textcolor{keywordflow}{if}( zNew==0 )\{
8181           sqlite3_result_error_nomem(pCtx);
8182           \textcolor{keywordflow}{return};
8183         \}
8184         pSlot->nByte = nByte*2;
8185         pSlot->z = zNew;
8186       \}
8187       pSlot->n = nByte;
8188       \textcolor{keywordflow}{if}( pSlot->eType==SQLITE_BLOB )\{
8189         memcpy(pSlot->z, sqlite3_value_blob(argv[1]), nByte);
8190       \}\textcolor{keywordflow}{else}\{
8191         memcpy(pSlot->z, sqlite3_value_text(argv[1]), nByte);
8192       \}
8193       \textcolor{keywordflow}{break};
8194     \}
8195   \}
8196 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a95c2ea48965a3475f0ad8d981fcdd0ff}} 
\index{shell.\+c@{shell.\+c}!idx\+Sample\+Func@{idx\+Sample\+Func}}
\index{idx\+Sample\+Func@{idx\+Sample\+Func}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Sample\+Func()}
{\footnotesize\ttfamily static void idx\+Sample\+Func (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{p\+Ctx,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 8084 of file shell.\+c.



References Idx\+Sample\+Ctx\+::i\+Target, Idx\+Sample\+Ctx\+::n\+Ret, Idx\+Sample\+Ctx\+::n\+Row, sqlite3\+\_\+randomness, sqlite3\+\_\+result\+\_\+int, sqlite3\+\_\+user\+\_\+data, and Idx\+Sample\+Ctx\+::target.



Referenced by idx\+Populate\+Stat1().


\begin{DoxyCode}
8088  \{
8089   \textcolor{keyword}{struct }IdxSampleCtx *p = (\textcolor{keyword}{struct }IdxSampleCtx*)sqlite3_user_data(pCtx);
8090   \textcolor{keywordtype}{int} bRet;
8091 
8092   (void)argv;
8093   assert( argc==0 );
8094   \textcolor{keywordflow}{if}( p->nRow==0.0 )\{
8095     bRet = 1;
8096   \}\textcolor{keywordflow}{else}\{
8097     bRet = (p->nRet / p->nRow) <= p->target;
8098     \textcolor{keywordflow}{if}( bRet==0 )\{
8099       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} rnd;
8100       sqlite3_randomness(2, (\textcolor{keywordtype}{void}*)&rnd);
8101       bRet = ((int)rnd % 100) <= p->iTarget;
8102     \}
8103   \}
8104 
8105   sqlite3_result_int(pCtx, bRet);
8106   p->nRow += 1.0;
8107   p->nRet += (double)bRet;
8108 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab1eca350dbd64c20a657fb4f20418281}} 
\index{shell.\+c@{shell.\+c}!idx\+Scan\+Free@{idx\+Scan\+Free}}
\index{idx\+Scan\+Free@{idx\+Scan\+Free}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Scan\+Free()}
{\footnotesize\ttfamily static void idx\+Scan\+Free (\begin{DoxyParamCaption}\item[{\textbf{ Idx\+Scan} $\ast$}]{p\+Scan,  }\item[{\textbf{ Idx\+Scan} $\ast$}]{p\+Last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7756 of file shell.\+c.



References idx\+Constraint\+Free(), Idx\+Scan\+::p\+Eq, Idx\+Scan\+::p\+Next\+Scan, Idx\+Scan\+::p\+Order, Idx\+Scan\+::p\+Range, and sqlite3\+\_\+free.



Referenced by sqlite3\+\_\+expert\+\_\+destroy(), and sqlite3\+\_\+expert\+\_\+sql().


\begin{DoxyCode}
7756                                                        \{
7757   IdxScan *p;
7758   IdxScan *pNext;
7759   \textcolor{keywordflow}{for}(p=pScan; p!=pLast; p=pNext)\{
7760     pNext = p->pNextScan;
7761     idxConstraintFree(p->pOrder);
7762     idxConstraintFree(p->pEq);
7763     idxConstraintFree(p->pRange);
7764     sqlite3_free(p);
7765   \}
7766 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a592cf1c632355ee55fab38e44eff98c4}} 
\index{shell.\+c@{shell.\+c}!idx\+Statement\+Free@{idx\+Statement\+Free}}
\index{idx\+Statement\+Free@{idx\+Statement\+Free}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Statement\+Free()}
{\footnotesize\ttfamily static void idx\+Statement\+Free (\begin{DoxyParamCaption}\item[{\textbf{ Idx\+Statement} $\ast$}]{p\+Statement,  }\item[{\textbf{ Idx\+Statement} $\ast$}]{p\+Last }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7772 of file shell.\+c.



References Idx\+Statement\+::p\+Next, sqlite3\+\_\+free, Idx\+Statement\+::z\+E\+QP, and Idx\+Statement\+::z\+Idx.



Referenced by sqlite3\+\_\+expert\+\_\+destroy(), and sqlite3\+\_\+expert\+\_\+sql().


\begin{DoxyCode}
7772                                                                            \{
7773   IdxStatement *p;
7774   IdxStatement *pNext;
7775   \textcolor{keywordflow}{for}(p=pStatement; p!=pLast; p=pNext)\{
7776     pNext = p->pNext;
7777     sqlite3_free(p->zEQP);
7778     sqlite3_free(p->zIdx);
7779     sqlite3_free(p);
7780   \}
7781 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aa9094cf24c8d7a3a6956874b542ed273}} 
\index{shell.\+c@{shell.\+c}!idx\+Table\+Free@{idx\+Table\+Free}}
\index{idx\+Table\+Free@{idx\+Table\+Free}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Table\+Free()}
{\footnotesize\ttfamily static void idx\+Table\+Free (\begin{DoxyParamCaption}\item[{\textbf{ Idx\+Table} $\ast$}]{p\+Tab }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7786 of file shell.\+c.



References Idx\+Table\+::p\+Next, and sqlite3\+\_\+free.



Referenced by sqlite3\+\_\+expert\+\_\+destroy().


\begin{DoxyCode}
7786                                         \{
7787   IdxTable *pIter;
7788   IdxTable *pNext;
7789   \textcolor{keywordflow}{for}(pIter=pTab; pIter; pIter=pNext)\{
7790     pNext = pIter->pNext;
7791     sqlite3_free(pIter);
7792   \}
7793 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad9a2207b0d4c1e15a803f5adb82f08d7}} 
\index{shell.\+c@{shell.\+c}!idx\+Write\+Free@{idx\+Write\+Free}}
\index{idx\+Write\+Free@{idx\+Write\+Free}!shell.\+c@{shell.\+c}}
\subsubsection{idx\+Write\+Free()}
{\footnotesize\ttfamily static void idx\+Write\+Free (\begin{DoxyParamCaption}\item[{\textbf{ Idx\+Write} $\ast$}]{p\+Tab }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 7798 of file shell.\+c.



References Idx\+Write\+::p\+Next, and sqlite3\+\_\+free.



Referenced by sqlite3\+\_\+expert\+\_\+destroy().


\begin{DoxyCode}
7798                                         \{
7799   IdxWrite *pIter;
7800   IdxWrite *pNext;
7801   \textcolor{keywordflow}{for}(pIter=pTab; pIter; pIter=pNext)\{
7802     pNext = pIter->pNext;
7803     sqlite3_free(pIter);
7804   \}
7805 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a7f9859493159d29216b52e19bcee70d2}} 
\index{shell.\+c@{shell.\+c}!import\+\_\+append\+\_\+char@{import\+\_\+append\+\_\+char}}
\index{import\+\_\+append\+\_\+char@{import\+\_\+append\+\_\+char}!shell.\+c@{shell.\+c}}
\subsubsection{import\+\_\+append\+\_\+char()}
{\footnotesize\ttfamily static void import\+\_\+append\+\_\+char (\begin{DoxyParamCaption}\item[{\textbf{ Import\+Ctx} $\ast$}]{p,  }\item[{int}]{c }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13083 of file shell.\+c.



References Import\+Ctx\+::n, Import\+Ctx\+::n\+Alloc, shell\+\_\+out\+\_\+of\+\_\+memory(), sqlite3\+\_\+realloc64, and Import\+Ctx\+::z.



Referenced by ascii\+\_\+read\+\_\+one\+\_\+field(), csv\+\_\+read\+\_\+one\+\_\+field(), and do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13083                                                    \{
13084   \textcolor{keywordflow}{if}( p->n+1>=p->nAlloc )\{
13085     p->nAlloc += p->nAlloc + 100;
13086     p->z = sqlite3_realloc64(p->z, p->nAlloc);
13087     \textcolor{keywordflow}{if}( p->z==0 ) shell_out_of_memory();
13088   \}
13089   p->z[p->n++] = (char)c;
13090 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae067785b0b5f0398332971074d699162}} 
\index{shell.\+c@{shell.\+c}!init\+Text@{init\+Text}}
\index{init\+Text@{init\+Text}!shell.\+c@{shell.\+c}}
\subsubsection{init\+Text()}
{\footnotesize\ttfamily static void init\+Text (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+Text} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 734 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), dump\+\_\+callback(), free\+Text(), and shell\+Fake\+Schema().


\begin{DoxyCode}
734                                   \{
735   memset(p, 0, \textcolor{keyword}{sizeof}(*p));
736 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a6b013248ac88dba54baa5a29cbe85347}} 
\index{shell.\+c@{shell.\+c}!integer\+Value@{integer\+Value}}
\index{integer\+Value@{integer\+Value}!shell.\+c@{shell.\+c}}
\subsubsection{integer\+Value()}
{\footnotesize\ttfamily static \textbf{ sqlite3\+\_\+int64} integer\+Value (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 678 of file shell.\+c.



References Array\+Size, hex\+Digit\+Value(), Is\+Digit, sqlite3\+\_\+stricmp, and time\+\_\+test\+::x.



Referenced by boolean\+Value(), do\+\_\+meta\+\_\+command(), expert\+Dot\+Command(), and main().


\begin{DoxyCode}
678                                                    \{
679   sqlite3_int64 v = 0;
680   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }\{ \textcolor{keywordtype}{char} *zSuffix; \textcolor{keywordtype}{int} iMult; \} aMult[] = \{
681     \{ \textcolor{stringliteral}{"KiB"}, 1024 \},
682     \{ \textcolor{stringliteral}{"MiB"}, 1024*1024 \},
683     \{ \textcolor{stringliteral}{"GiB"}, 1024*1024*1024 \},
684     \{ \textcolor{stringliteral}{"KB"},  1000 \},
685     \{ \textcolor{stringliteral}{"MB"},  1000000 \},
686     \{ \textcolor{stringliteral}{"GB"},  1000000000 \},
687     \{ \textcolor{stringliteral}{"K"},   1000 \},
688     \{ \textcolor{stringliteral}{"M"},   1000000 \},
689     \{ \textcolor{stringliteral}{"G"},   1000000000 \},
690   \};
691   \textcolor{keywordtype}{int} i;
692   \textcolor{keywordtype}{int} isNeg = 0;
693   \textcolor{keywordflow}{if}( zArg[0]==\textcolor{charliteral}{'-'} )\{
694     isNeg = 1;
695     zArg++;
696   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( zArg[0]==\textcolor{charliteral}{'+'} )\{
697     zArg++;
698   \}
699   \textcolor{keywordflow}{if}( zArg[0]==\textcolor{charliteral}{'0'} && zArg[1]==\textcolor{charliteral}{'x'} )\{
700     \textcolor{keywordtype}{int} x;
701     zArg += 2;
702     \textcolor{keywordflow}{while}( (x = hexDigitValue(zArg[0]))>=0 )\{
703       v = (v<<4) + x;
704       zArg++;
705     \}
706   \}\textcolor{keywordflow}{else}\{
707     \textcolor{keywordflow}{while}( IsDigit(zArg[0]) )\{
708       v = v*10 + zArg[0] - \textcolor{charliteral}{'0'};
709       zArg++;
710     \}
711   \}
712   \textcolor{keywordflow}{for}(i=0; i<ArraySize(aMult); i++)\{
713     \textcolor{keywordflow}{if}( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 )\{
714       v *= aMult[i].iMult;
715       \textcolor{keywordflow}{break};
716     \}
717   \}
718   \textcolor{keywordflow}{return} isNeg? -v : v;
719 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a71739e7821ca0c6515043e841088e88b}} 
\index{shell.\+c@{shell.\+c}!interrupt\+\_\+handler@{interrupt\+\_\+handler}}
\index{interrupt\+\_\+handler@{interrupt\+\_\+handler}!shell.\+c@{shell.\+c}}
\subsubsection{interrupt\+\_\+handler()}
{\footnotesize\ttfamily static void interrupt\+\_\+handler (\begin{DoxyParamCaption}\item[{int}]{Not\+Used }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10174 of file shell.\+c.



References sqlite3\+\_\+interrupt, and U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER.



Referenced by main().


\begin{DoxyCode}
10174                                           \{
10175   UNUSED_PARAMETER(NotUsed);
10176   seenInterrupt++;
10177   \textcolor{keywordflow}{if}( seenInterrupt>2 ) exit(1);
10178   \textcolor{keywordflow}{if}( globalDb ) sqlite3_interrupt(globalDb);
10179 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab4155ffea05dab2dafae68fd88a0517f}} 
\index{shell.\+c@{shell.\+c}!isatty@{isatty}}
\index{isatty@{isatty}!shell.\+c@{shell.\+c}}
\subsubsection{isatty()}
{\footnotesize\ttfamily int isatty (\begin{DoxyParamCaption}\item[{int}]{ }\end{DoxyParamCaption})}



Referenced by main(), and Tclsqlite\+\_\+\+Unload().

\mbox{\label{shell_8c_ad23756db4382a48e46291ecf890fd04d}} 
\index{shell.\+c@{shell.\+c}!is\+Number@{is\+Number}}
\index{is\+Number@{is\+Number}!shell.\+c@{shell.\+c}}
\subsubsection{is\+Number()}
{\footnotesize\ttfamily static int is\+Number (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z,  }\item[{int $\ast$}]{realnum }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 529 of file shell.\+c.



References Is\+Digit.



Referenced by shell\+\_\+callback().


\begin{DoxyCode}
529                                                 \{
530   \textcolor{keywordflow}{if}( *z==\textcolor{charliteral}{'-'} || *z==\textcolor{charliteral}{'+'} ) z++;
531   \textcolor{keywordflow}{if}( !IsDigit(*z) )\{
532     \textcolor{keywordflow}{return} 0;
533   \}
534   z++;
535   \textcolor{keywordflow}{if}( realnum ) *realnum = 0;
536   \textcolor{keywordflow}{while}( IsDigit(*z) )\{ z++; \}
537   \textcolor{keywordflow}{if}( *z==\textcolor{charliteral}{'.'} )\{
538     z++;
539     \textcolor{keywordflow}{if}( !IsDigit(*z) ) \textcolor{keywordflow}{return} 0;
540     \textcolor{keywordflow}{while}( IsDigit(*z) )\{ z++; \}
541     \textcolor{keywordflow}{if}( realnum ) *realnum = 1;
542   \}
543   \textcolor{keywordflow}{if}( *z==\textcolor{charliteral}{'e'} || *z==\textcolor{charliteral}{'E'} )\{
544     z++;
545     \textcolor{keywordflow}{if}( *z==\textcolor{charliteral}{'+'} || *z==\textcolor{charliteral}{'-'} ) z++;
546     \textcolor{keywordflow}{if}( !IsDigit(*z) ) \textcolor{keywordflow}{return} 0;
547     \textcolor{keywordflow}{while}( IsDigit(*z) )\{ z++; \}
548     \textcolor{keywordflow}{if}( realnum ) *realnum = 1;
549   \}
550   \textcolor{keywordflow}{return} *z==0;
551 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aa72e13dd5e5e1ef404f64d9ae4a0e3de}} 
\index{shell.\+c@{shell.\+c}!Keccak\+F1600\+Step@{Keccak\+F1600\+Step}}
\index{Keccak\+F1600\+Step@{Keccak\+F1600\+Step}!shell.\+c@{shell.\+c}}
\subsubsection{Keccak\+F1600\+Step()}
{\footnotesize\ttfamily static void Keccak\+F1600\+Step (\begin{DoxyParamCaption}\item[{\textbf{ S\+H\+A3\+Context} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 1390 of file shell.\+c.



References a00, a01, a02, a03, a04, a10, a11, a12, a13, a14, a20, a21, a22, a23, a24, a30, a31, a32, a33, a34, a40, a41, a42, a43, a44, and R\+O\+L64.



Referenced by S\+H\+A3\+Update().


\begin{DoxyCode}
1390                                            \{
1391   \textcolor{keywordtype}{int} i;
1392   u64 b0, b1, b2, b3, b4;
1393   u64 c0, c1, c2, c3, c4;
1394   u64 d0, d1, d2, d3, d4;
1395   \textcolor{keyword}{static} \textcolor{keyword}{const} u64 RC[] = \{
1396     0x0000000000000001ULL,  0x0000000000008082ULL,
1397     0x800000000000808aULL,  0x8000000080008000ULL,
1398     0x000000000000808bULL,  0x0000000080000001ULL,
1399     0x8000000080008081ULL,  0x8000000000008009ULL,
1400     0x000000000000008aULL,  0x0000000000000088ULL,
1401     0x0000000080008009ULL,  0x000000008000000aULL,
1402     0x000000008000808bULL,  0x800000000000008bULL,
1403     0x8000000000008089ULL,  0x8000000000008003ULL,
1404     0x8000000000008002ULL,  0x8000000000000080ULL,
1405     0x000000000000800aULL,  0x800000008000000aULL,
1406     0x8000000080008081ULL,  0x8000000000008080ULL,
1407     0x0000000080000001ULL,  0x8000000080008008ULL
1408   \};
1409 \textcolor{preprocessor}{# define a00 (p->u.s[0])}
1410 \textcolor{preprocessor}{# define a01 (p->u.s[1])}
1411 \textcolor{preprocessor}{# define a02 (p->u.s[2])}
1412 \textcolor{preprocessor}{# define a03 (p->u.s[3])}
1413 \textcolor{preprocessor}{# define a04 (p->u.s[4])}
1414 \textcolor{preprocessor}{# define a10 (p->u.s[5])}
1415 \textcolor{preprocessor}{# define a11 (p->u.s[6])}
1416 \textcolor{preprocessor}{# define a12 (p->u.s[7])}
1417 \textcolor{preprocessor}{# define a13 (p->u.s[8])}
1418 \textcolor{preprocessor}{# define a14 (p->u.s[9])}
1419 \textcolor{preprocessor}{# define a20 (p->u.s[10])}
1420 \textcolor{preprocessor}{# define a21 (p->u.s[11])}
1421 \textcolor{preprocessor}{# define a22 (p->u.s[12])}
1422 \textcolor{preprocessor}{# define a23 (p->u.s[13])}
1423 \textcolor{preprocessor}{# define a24 (p->u.s[14])}
1424 \textcolor{preprocessor}{# define a30 (p->u.s[15])}
1425 \textcolor{preprocessor}{# define a31 (p->u.s[16])}
1426 \textcolor{preprocessor}{# define a32 (p->u.s[17])}
1427 \textcolor{preprocessor}{# define a33 (p->u.s[18])}
1428 \textcolor{preprocessor}{# define a34 (p->u.s[19])}
1429 \textcolor{preprocessor}{# define a40 (p->u.s[20])}
1430 \textcolor{preprocessor}{# define a41 (p->u.s[21])}
1431 \textcolor{preprocessor}{# define a42 (p->u.s[22])}
1432 \textcolor{preprocessor}{# define a43 (p->u.s[23])}
1433 \textcolor{preprocessor}{# define a44 (p->u.s[24])}
1434 \textcolor{preprocessor}{# define ROL64(a,x) ((a<<x)|(a>>(64-x)))}
1435 
1436   \textcolor{keywordflow}{for}(i=0; i<24; i+=4)\{
1437     c0 = a00^a10^a20^a30^a40;
1438     c1 = a01^a11^a21^a31^a41;
1439     c2 = a02^a12^a22^a32^a42;
1440     c3 = a03^a13^a23^a33^a43;
1441     c4 = a04^a14^a24^a34^a44;
1442     d0 = c4^ROL64(c1, 1);
1443     d1 = c0^ROL64(c2, 1);
1444     d2 = c1^ROL64(c3, 1);
1445     d3 = c2^ROL64(c4, 1);
1446     d4 = c3^ROL64(c0, 1);
1447 
1448     b0 = (a00^d0);
1449     b1 = ROL64((a11^d1), 44);
1450     b2 = ROL64((a22^d2), 43);
1451     b3 = ROL64((a33^d3), 21);
1452     b4 = ROL64((a44^d4), 14);
1453     a00 =   b0 ^((~b1)&  b2 );
1454     a00 ^= RC[i];
1455     a11 =   b1 ^((~b2)&  b3 );
1456     a22 =   b2 ^((~b3)&  b4 );
1457     a33 =   b3 ^((~b4)&  b0 );
1458     a44 =   b4 ^((~b0)&  b1 );
1459 
1460     b2 = ROL64((a20^d0), 3);
1461     b3 = ROL64((a31^d1), 45);
1462     b4 = ROL64((a42^d2), 61);
1463     b0 = ROL64((a03^d3), 28);
1464     b1 = ROL64((a14^d4), 20);
1465     a20 =   b0 ^((~b1)&  b2 );
1466     a31 =   b1 ^((~b2)&  b3 );
1467     a42 =   b2 ^((~b3)&  b4 );
1468     a03 =   b3 ^((~b4)&  b0 );
1469     a14 =   b4 ^((~b0)&  b1 );
1470 
1471     b4 = ROL64((a40^d0), 18);
1472     b0 = ROL64((a01^d1), 1);
1473     b1 = ROL64((a12^d2), 6);
1474     b2 = ROL64((a23^d3), 25);
1475     b3 = ROL64((a34^d4), 8);
1476     a40 =   b0 ^((~b1)&  b2 );
1477     a01 =   b1 ^((~b2)&  b3 );
1478     a12 =   b2 ^((~b3)&  b4 );
1479     a23 =   b3 ^((~b4)&  b0 );
1480     a34 =   b4 ^((~b0)&  b1 );
1481 
1482     b1 = ROL64((a10^d0), 36);
1483     b2 = ROL64((a21^d1), 10);
1484     b3 = ROL64((a32^d2), 15);
1485     b4 = ROL64((a43^d3), 56);
1486     b0 = ROL64((a04^d4), 27);
1487     a10 =   b0 ^((~b1)&  b2 );
1488     a21 =   b1 ^((~b2)&  b3 );
1489     a32 =   b2 ^((~b3)&  b4 );
1490     a43 =   b3 ^((~b4)&  b0 );
1491     a04 =   b4 ^((~b0)&  b1 );
1492 
1493     b3 = ROL64((a30^d0), 41);
1494     b4 = ROL64((a41^d1), 2);
1495     b0 = ROL64((a02^d2), 62);
1496     b1 = ROL64((a13^d3), 55);
1497     b2 = ROL64((a24^d4), 39);
1498     a30 =   b0 ^((~b1)&  b2 );
1499     a41 =   b1 ^((~b2)&  b3 );
1500     a02 =   b2 ^((~b3)&  b4 );
1501     a13 =   b3 ^((~b4)&  b0 );
1502     a24 =   b4 ^((~b0)&  b1 );
1503 
1504     c0 = a00^a20^a40^a10^a30;
1505     c1 = a11^a31^a01^a21^a41;
1506     c2 = a22^a42^a12^a32^a02;
1507     c3 = a33^a03^a23^a43^a13;
1508     c4 = a44^a14^a34^a04^a24;
1509     d0 = c4^ROL64(c1, 1);
1510     d1 = c0^ROL64(c2, 1);
1511     d2 = c1^ROL64(c3, 1);
1512     d3 = c2^ROL64(c4, 1);
1513     d4 = c3^ROL64(c0, 1);
1514 
1515     b0 = (a00^d0);
1516     b1 = ROL64((a31^d1), 44);
1517     b2 = ROL64((a12^d2), 43);
1518     b3 = ROL64((a43^d3), 21);
1519     b4 = ROL64((a24^d4), 14);
1520     a00 =   b0 ^((~b1)&  b2 );
1521     a00 ^= RC[i+1];
1522     a31 =   b1 ^((~b2)&  b3 );
1523     a12 =   b2 ^((~b3)&  b4 );
1524     a43 =   b3 ^((~b4)&  b0 );
1525     a24 =   b4 ^((~b0)&  b1 );
1526 
1527     b2 = ROL64((a40^d0), 3);
1528     b3 = ROL64((a21^d1), 45);
1529     b4 = ROL64((a02^d2), 61);
1530     b0 = ROL64((a33^d3), 28);
1531     b1 = ROL64((a14^d4), 20);
1532     a40 =   b0 ^((~b1)&  b2 );
1533     a21 =   b1 ^((~b2)&  b3 );
1534     a02 =   b2 ^((~b3)&  b4 );
1535     a33 =   b3 ^((~b4)&  b0 );
1536     a14 =   b4 ^((~b0)&  b1 );
1537 
1538     b4 = ROL64((a30^d0), 18);
1539     b0 = ROL64((a11^d1), 1);
1540     b1 = ROL64((a42^d2), 6);
1541     b2 = ROL64((a23^d3), 25);
1542     b3 = ROL64((a04^d4), 8);
1543     a30 =   b0 ^((~b1)&  b2 );
1544     a11 =   b1 ^((~b2)&  b3 );
1545     a42 =   b2 ^((~b3)&  b4 );
1546     a23 =   b3 ^((~b4)&  b0 );
1547     a04 =   b4 ^((~b0)&  b1 );
1548 
1549     b1 = ROL64((a20^d0), 36);
1550     b2 = ROL64((a01^d1), 10);
1551     b3 = ROL64((a32^d2), 15);
1552     b4 = ROL64((a13^d3), 56);
1553     b0 = ROL64((a44^d4), 27);
1554     a20 =   b0 ^((~b1)&  b2 );
1555     a01 =   b1 ^((~b2)&  b3 );
1556     a32 =   b2 ^((~b3)&  b4 );
1557     a13 =   b3 ^((~b4)&  b0 );
1558     a44 =   b4 ^((~b0)&  b1 );
1559 
1560     b3 = ROL64((a10^d0), 41);
1561     b4 = ROL64((a41^d1), 2);
1562     b0 = ROL64((a22^d2), 62);
1563     b1 = ROL64((a03^d3), 55);
1564     b2 = ROL64((a34^d4), 39);
1565     a10 =   b0 ^((~b1)&  b2 );
1566     a41 =   b1 ^((~b2)&  b3 );
1567     a22 =   b2 ^((~b3)&  b4 );
1568     a03 =   b3 ^((~b4)&  b0 );
1569     a34 =   b4 ^((~b0)&  b1 );
1570 
1571     c0 = a00^a40^a30^a20^a10;
1572     c1 = a31^a21^a11^a01^a41;
1573     c2 = a12^a02^a42^a32^a22;
1574     c3 = a43^a33^a23^a13^a03;
1575     c4 = a24^a14^a04^a44^a34;
1576     d0 = c4^ROL64(c1, 1);
1577     d1 = c0^ROL64(c2, 1);
1578     d2 = c1^ROL64(c3, 1);
1579     d3 = c2^ROL64(c4, 1);
1580     d4 = c3^ROL64(c0, 1);
1581 
1582     b0 = (a00^d0);
1583     b1 = ROL64((a21^d1), 44);
1584     b2 = ROL64((a42^d2), 43);
1585     b3 = ROL64((a13^d3), 21);
1586     b4 = ROL64((a34^d4), 14);
1587     a00 =   b0 ^((~b1)&  b2 );
1588     a00 ^= RC[i+2];
1589     a21 =   b1 ^((~b2)&  b3 );
1590     a42 =   b2 ^((~b3)&  b4 );
1591     a13 =   b3 ^((~b4)&  b0 );
1592     a34 =   b4 ^((~b0)&  b1 );
1593 
1594     b2 = ROL64((a30^d0), 3);
1595     b3 = ROL64((a01^d1), 45);
1596     b4 = ROL64((a22^d2), 61);
1597     b0 = ROL64((a43^d3), 28);
1598     b1 = ROL64((a14^d4), 20);
1599     a30 =   b0 ^((~b1)&  b2 );
1600     a01 =   b1 ^((~b2)&  b3 );
1601     a22 =   b2 ^((~b3)&  b4 );
1602     a43 =   b3 ^((~b4)&  b0 );
1603     a14 =   b4 ^((~b0)&  b1 );
1604 
1605     b4 = ROL64((a10^d0), 18);
1606     b0 = ROL64((a31^d1), 1);
1607     b1 = ROL64((a02^d2), 6);
1608     b2 = ROL64((a23^d3), 25);
1609     b3 = ROL64((a44^d4), 8);
1610     a10 =   b0 ^((~b1)&  b2 );
1611     a31 =   b1 ^((~b2)&  b3 );
1612     a02 =   b2 ^((~b3)&  b4 );
1613     a23 =   b3 ^((~b4)&  b0 );
1614     a44 =   b4 ^((~b0)&  b1 );
1615 
1616     b1 = ROL64((a40^d0), 36);
1617     b2 = ROL64((a11^d1), 10);
1618     b3 = ROL64((a32^d2), 15);
1619     b4 = ROL64((a03^d3), 56);
1620     b0 = ROL64((a24^d4), 27);
1621     a40 =   b0 ^((~b1)&  b2 );
1622     a11 =   b1 ^((~b2)&  b3 );
1623     a32 =   b2 ^((~b3)&  b4 );
1624     a03 =   b3 ^((~b4)&  b0 );
1625     a24 =   b4 ^((~b0)&  b1 );
1626 
1627     b3 = ROL64((a20^d0), 41);
1628     b4 = ROL64((a41^d1), 2);
1629     b0 = ROL64((a12^d2), 62);
1630     b1 = ROL64((a33^d3), 55);
1631     b2 = ROL64((a04^d4), 39);
1632     a20 =   b0 ^((~b1)&  b2 );
1633     a41 =   b1 ^((~b2)&  b3 );
1634     a12 =   b2 ^((~b3)&  b4 );
1635     a33 =   b3 ^((~b4)&  b0 );
1636     a04 =   b4 ^((~b0)&  b1 );
1637 
1638     c0 = a00^a30^a10^a40^a20;
1639     c1 = a21^a01^a31^a11^a41;
1640     c2 = a42^a22^a02^a32^a12;
1641     c3 = a13^a43^a23^a03^a33;
1642     c4 = a34^a14^a44^a24^a04;
1643     d0 = c4^ROL64(c1, 1);
1644     d1 = c0^ROL64(c2, 1);
1645     d2 = c1^ROL64(c3, 1);
1646     d3 = c2^ROL64(c4, 1);
1647     d4 = c3^ROL64(c0, 1);
1648 
1649     b0 = (a00^d0);
1650     b1 = ROL64((a01^d1), 44);
1651     b2 = ROL64((a02^d2), 43);
1652     b3 = ROL64((a03^d3), 21);
1653     b4 = ROL64((a04^d4), 14);
1654     a00 =   b0 ^((~b1)&  b2 );
1655     a00 ^= RC[i+3];
1656     a01 =   b1 ^((~b2)&  b3 );
1657     a02 =   b2 ^((~b3)&  b4 );
1658     a03 =   b3 ^((~b4)&  b0 );
1659     a04 =   b4 ^((~b0)&  b1 );
1660 
1661     b2 = ROL64((a10^d0), 3);
1662     b3 = ROL64((a11^d1), 45);
1663     b4 = ROL64((a12^d2), 61);
1664     b0 = ROL64((a13^d3), 28);
1665     b1 = ROL64((a14^d4), 20);
1666     a10 =   b0 ^((~b1)&  b2 );
1667     a11 =   b1 ^((~b2)&  b3 );
1668     a12 =   b2 ^((~b3)&  b4 );
1669     a13 =   b3 ^((~b4)&  b0 );
1670     a14 =   b4 ^((~b0)&  b1 );
1671 
1672     b4 = ROL64((a20^d0), 18);
1673     b0 = ROL64((a21^d1), 1);
1674     b1 = ROL64((a22^d2), 6);
1675     b2 = ROL64((a23^d3), 25);
1676     b3 = ROL64((a24^d4), 8);
1677     a20 =   b0 ^((~b1)&  b2 );
1678     a21 =   b1 ^((~b2)&  b3 );
1679     a22 =   b2 ^((~b3)&  b4 );
1680     a23 =   b3 ^((~b4)&  b0 );
1681     a24 =   b4 ^((~b0)&  b1 );
1682 
1683     b1 = ROL64((a30^d0), 36);
1684     b2 = ROL64((a31^d1), 10);
1685     b3 = ROL64((a32^d2), 15);
1686     b4 = ROL64((a33^d3), 56);
1687     b0 = ROL64((a34^d4), 27);
1688     a30 =   b0 ^((~b1)&  b2 );
1689     a31 =   b1 ^((~b2)&  b3 );
1690     a32 =   b2 ^((~b3)&  b4 );
1691     a33 =   b3 ^((~b4)&  b0 );
1692     a34 =   b4 ^((~b0)&  b1 );
1693 
1694     b3 = ROL64((a40^d0), 41);
1695     b4 = ROL64((a41^d1), 2);
1696     b0 = ROL64((a42^d2), 62);
1697     b1 = ROL64((a43^d3), 55);
1698     b2 = ROL64((a44^d4), 39);
1699     a40 =   b0 ^((~b1)&  b2 );
1700     a41 =   b1 ^((~b2)&  b3 );
1701     a42 =   b2 ^((~b3)&  b4 );
1702     a43 =   b3 ^((~b4)&  b0 );
1703     a44 =   b4 ^((~b0)&  b1 );
1704   \}
1705 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a024aba96902e971c529231fc190eb2dd}} 
\index{shell.\+c@{shell.\+c}!line\+\_\+contains\+\_\+semicolon@{line\+\_\+contains\+\_\+semicolon}}
\index{line\+\_\+contains\+\_\+semicolon@{line\+\_\+contains\+\_\+semicolon}!shell.\+c@{shell.\+c}}
\subsubsection{line\+\_\+contains\+\_\+semicolon()}
{\footnotesize\ttfamily static int line\+\_\+contains\+\_\+semicolon (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z,  }\item[{int}]{N }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18212 of file shell.\+c.



Referenced by process\+\_\+input().


\begin{DoxyCode}
18212                                                         \{
18213   \textcolor{keywordtype}{int} i;
18214   \textcolor{keywordflow}{for}(i=0; i<N; i++)\{  \textcolor{keywordflow}{if}( z[i]==\textcolor{charliteral}{';'} ) \textcolor{keywordflow}{return} 1; \}
18215   \textcolor{keywordflow}{return} 0;
18216 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a5ec09164eaef2f04563ef1f1e4237905}} 
\index{shell.\+c@{shell.\+c}!line\+\_\+is\+\_\+command\+\_\+terminator@{line\+\_\+is\+\_\+command\+\_\+terminator}}
\index{line\+\_\+is\+\_\+command\+\_\+terminator@{line\+\_\+is\+\_\+command\+\_\+terminator}!shell.\+c@{shell.\+c}}
\subsubsection{line\+\_\+is\+\_\+command\+\_\+terminator()}
{\footnotesize\ttfamily static int line\+\_\+is\+\_\+command\+\_\+terminator (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Line }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18247 of file shell.\+c.



References \+\_\+all\+\_\+whitespace(), Is\+Space, and To\+Lower.



Referenced by process\+\_\+input().


\begin{DoxyCode}
18247                                                         \{
18248   \textcolor{keywordflow}{while}( IsSpace(zLine[0]) )\{ zLine++; \};
18249   \textcolor{keywordflow}{if}( zLine[0]==\textcolor{charliteral}{'/'} && _all_whitespace(&zLine[1]) )\{
18250     \textcolor{keywordflow}{return} 1;  \textcolor{comment}{/* Oracle */}
18251   \}
18252   \textcolor{keywordflow}{if}( ToLower(zLine[0])==\textcolor{charliteral}{'g'} && ToLower(zLine[1])==\textcolor{charliteral}{'o'}
18253          && _all_whitespace(&zLine[2]) )\{
18254     \textcolor{keywordflow}{return} 1;  \textcolor{comment}{/* SQL Server */}
18255   \}
18256   \textcolor{keywordflow}{return} 0;
18257 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a1df76818e31435c7931c2887ff412f1a}} 
\index{shell.\+c@{shell.\+c}!line\+\_\+is\+\_\+complete@{line\+\_\+is\+\_\+complete}}
\index{line\+\_\+is\+\_\+complete@{line\+\_\+is\+\_\+complete}!shell.\+c@{shell.\+c}}
\subsubsection{line\+\_\+is\+\_\+complete()}
{\footnotesize\ttfamily static int line\+\_\+is\+\_\+complete (\begin{DoxyParamCaption}\item[{char $\ast$}]{z\+Sql,  }\item[{int}]{n\+Sql }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18273 of file shell.\+c.



References sqlite3\+\_\+complete.



Referenced by process\+\_\+input().


\begin{DoxyCode}
18273                                                  \{
18274   \textcolor{keywordtype}{int} rc;
18275   \textcolor{keywordflow}{if}( zSql==0 ) \textcolor{keywordflow}{return} 1;
18276   zSql[nSql] = \textcolor{charliteral}{';'};
18277   zSql[nSql+1] = 0;
18278   rc = sqlite3_complete(zSql);
18279   zSql[nSql] = 0;
18280   \textcolor{keywordflow}{return} rc;
18281 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ac2f6e16d8f424eedf80e07c021ab1c0f}} 
\index{shell.\+c@{shell.\+c}!lint\+Dot\+Command@{lint\+Dot\+Command}}
\index{lint\+Dot\+Command@{lint\+Dot\+Command}!shell.\+c@{shell.\+c}}
\subsubsection{lint\+Dot\+Command()}
{\footnotesize\ttfamily static int lint\+Dot\+Command (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p\+State,  }\item[{char $\ast$$\ast$}]{az\+Arg,  }\item[{int}]{n\+Arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13996 of file shell.\+c.



References lint\+Fkey\+Indexes(), raw\+\_\+printf, sqlite3\+\_\+strnicmp, S\+Q\+L\+I\+T\+E\+\_\+\+E\+R\+R\+OR, strlen30(), and usage().



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
14000  \{
14001   \textcolor{keywordtype}{int} n;
14002   n = (nArg>=2 ? strlen30(azArg[1]) : 0);
14003   \textcolor{keywordflow}{if}( n<1 || sqlite3_strnicmp(azArg[1], \textcolor{stringliteral}{"fkey-indexes"}, n) ) \textcolor{keywordflow}{goto} usage;
14004   \textcolor{keywordflow}{return} lintFkeyIndexes(pState, azArg, nArg);
14005 
14006  usage:
14007   raw_printf(stderr, \textcolor{stringliteral}{"Usage %s sub-command ?switches...?\(\backslash\)n"}, azArg[0]);
14008   raw_printf(stderr, \textcolor{stringliteral}{"Where sub-commands are:\(\backslash\)n"});
14009   raw_printf(stderr, \textcolor{stringliteral}{"    fkey-indexes\(\backslash\)n"});
14010   \textcolor{keywordflow}{return} SQLITE_ERROR;
14011 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a84fb215c17aeff373af2262b1bb4042a}} 
\index{shell.\+c@{shell.\+c}!lint\+Fkey\+Indexes@{lint\+Fkey\+Indexes}}
\index{lint\+Fkey\+Indexes@{lint\+Fkey\+Indexes}!shell.\+c@{shell.\+c}}
\subsubsection{lint\+Fkey\+Indexes()}
{\footnotesize\ttfamily static int lint\+Fkey\+Indexes (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p\+State,  }\item[{char $\ast$$\ast$}]{az\+Arg,  }\item[{int}]{n\+Arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13820 of file shell.\+c.



References Shell\+State\+::db, Shell\+State\+::out, raw\+\_\+printf, shell\+Fkey\+Collate\+Clause(), sqlite3\+\_\+bind\+\_\+int, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+create\+\_\+function, sqlite3\+\_\+errmsg, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+step, sqlite3\+\_\+strglob, sqlite3\+\_\+stricmp, sqlite3\+\_\+strnicmp, S\+Q\+L\+I\+T\+E\+\_\+\+E\+R\+R\+OR, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+U\+T\+F8, and strlen30().



Referenced by lint\+Dot\+Command().


\begin{DoxyCode}
13824  \{
13825   sqlite3 *db = pState->db;       \textcolor{comment}{/* Database handle to query "main" db of */}
13826   FILE *out = pState->out;        \textcolor{comment}{/* Stream to write non-error output to */}
13827   \textcolor{keywordtype}{int} bVerbose = 0;               \textcolor{comment}{/* If -verbose is present */}
13828   \textcolor{keywordtype}{int} bGroupByParent = 0;         \textcolor{comment}{/* If -groupbyparent is present */}
13829   \textcolor{keywordtype}{int} i;                          \textcolor{comment}{/* To iterate through azArg[] */}
13830   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zIndent = \textcolor{stringliteral}{""};       \textcolor{comment}{/* How much to indent CREATE INDEX by */}
13831   \textcolor{keywordtype}{int} rc;                         \textcolor{comment}{/* Return code */}
13832   sqlite3_stmt *pSql = 0;         \textcolor{comment}{/* Compiled version of SQL statement below */}
13833 
13834   \textcolor{comment}{/*}
13835 \textcolor{comment}{  ** This SELECT statement returns one row for each foreign key constraint}
13836 \textcolor{comment}{  ** in the schema of the main database. The column values are:}
13837 \textcolor{comment}{  **}
13838 \textcolor{comment}{  ** 0. The text of an SQL statement similar to:}
13839 \textcolor{comment}{  **}
13840 \textcolor{comment}{  **      "EXPLAIN QUERY PLAN SELECT 1 FROM child\_table WHERE child\_key=?"}
13841 \textcolor{comment}{  **}
13842 \textcolor{comment}{  **    This SELECT is similar to the one that the foreign keys implementation}
13843 \textcolor{comment}{  **    needs to run internally on child tables. If there is an index that can}
13844 \textcolor{comment}{  **    be used to optimize this query, then it can also be used by the FK}
13845 \textcolor{comment}{  **    implementation to optimize DELETE or UPDATE statements on the parent}
13846 \textcolor{comment}{  **    table.}
13847 \textcolor{comment}{  **}
13848 \textcolor{comment}{  ** 1. A GLOB pattern suitable for sqlite3\_strglob(). If the plan output by}
13849 \textcolor{comment}{  **    the EXPLAIN QUERY PLAN command matches this pattern, then the schema}
13850 \textcolor{comment}{  **    contains an index that can be used to optimize the query.}
13851 \textcolor{comment}{  **}
13852 \textcolor{comment}{  ** 2. Human readable text that describes the child table and columns. e.g.}
13853 \textcolor{comment}{  **}
13854 \textcolor{comment}{  **       "child\_table(child\_key1, child\_key2)"}
13855 \textcolor{comment}{  **}
13856 \textcolor{comment}{  ** 3. Human readable text that describes the parent table and columns. e.g.}
13857 \textcolor{comment}{  **}
13858 \textcolor{comment}{  **       "parent\_table(parent\_key1, parent\_key2)"}
13859 \textcolor{comment}{  **}
13860 \textcolor{comment}{  ** 4. A full CREATE INDEX statement for an index that could be used to}
13861 \textcolor{comment}{  **    optimize DELETE or UPDATE statements on the parent table. e.g.}
13862 \textcolor{comment}{  **}
13863 \textcolor{comment}{  **       "CREATE INDEX child\_table\_child\_key ON child\_table(child\_key)"}
13864 \textcolor{comment}{  **}
13865 \textcolor{comment}{  ** 5. The name of the parent table.}
13866 \textcolor{comment}{  **}
13867 \textcolor{comment}{  ** These six values are used by the C logic below to generate the report.}
13868 \textcolor{comment}{  */}
13869   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql =
13870   \textcolor{stringliteral}{"SELECT "}
13871     \textcolor{stringliteral}{"     'EXPLAIN QUERY PLAN SELECT 1 FROM ' || quote(s.name) || ' WHERE '"}
13872     \textcolor{stringliteral}{"  || group\_concat(quote(s.name) || '.' || quote(f.[from]) || '=?' "}
13873     \textcolor{stringliteral}{"  || fkey\_collate\_clause("}
13874     \textcolor{stringliteral}{"       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),' AND ')"}
13875     \textcolor{stringliteral}{", "}
13876     \textcolor{stringliteral}{"     'SEARCH TABLE ' || s.name || ' USING COVERING INDEX*('"}
13877     \textcolor{stringliteral}{"  || group\_concat('*=?', ' AND ') || ')'"}
13878     \textcolor{stringliteral}{", "}
13879     \textcolor{stringliteral}{"     s.name  || '(' || group\_concat(f.[from],  ', ') || ')'"}
13880     \textcolor{stringliteral}{", "}
13881     \textcolor{stringliteral}{"     f.[table] || '(' || group\_concat(COALESCE(f.[to], p.[name])) || ')'"}
13882     \textcolor{stringliteral}{", "}
13883     \textcolor{stringliteral}{"     'CREATE INDEX ' || quote(s.name ||'\_'|| group\_concat(f.[from], '\_'))"}
13884     \textcolor{stringliteral}{"  || ' ON ' || quote(s.name) || '('"}
13885     \textcolor{stringliteral}{"  || group\_concat(quote(f.[from]) ||"}
13886     \textcolor{stringliteral}{"        fkey\_collate\_clause("}
13887     \textcolor{stringliteral}{"          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), ', ')"}
13888     \textcolor{stringliteral}{"  || ');'"}
13889     \textcolor{stringliteral}{", "}
13890     \textcolor{stringliteral}{"     f.[table] "}
13891     \textcolor{stringliteral}{"FROM sqlite\_master AS s, pragma\_foreign\_key\_list(s.name) AS f "}
13892     \textcolor{stringliteral}{"LEFT JOIN pragma\_table\_info AS p ON (pk-1=seq AND p.arg=f.[table]) "}
13893     \textcolor{stringliteral}{"GROUP BY s.name, f.id "}
13894     \textcolor{stringliteral}{"ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)"}
13895   ;
13896   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zGlobIPK = \textcolor{stringliteral}{"SEARCH TABLE * USING INTEGER PRIMARY KEY (rowid=?)"};
13897 
13898   \textcolor{keywordflow}{for}(i=2; i<nArg; i++)\{
13899     \textcolor{keywordtype}{int} n = strlen30(azArg[i]);
13900     \textcolor{keywordflow}{if}( n>1 && sqlite3_strnicmp(\textcolor{stringliteral}{"-verbose"}, azArg[i], n)==0 )\{
13901       bVerbose = 1;
13902     \}
13903     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( n>1 && sqlite3_strnicmp(\textcolor{stringliteral}{"-groupbyparent"}, azArg[i], n)==0 )\{
13904       bGroupByParent = 1;
13905       zIndent = \textcolor{stringliteral}{"    "};
13906     \}
13907     \textcolor{keywordflow}{else}\{
13908       raw_printf(stderr, \textcolor{stringliteral}{"Usage: %s %s ?-verbose? ?-groupbyparent?\(\backslash\)n"},
13909           azArg[0], azArg[1]
13910       );
13911       \textcolor{keywordflow}{return} SQLITE_ERROR;
13912     \}
13913   \}
13914 
13915   \textcolor{comment}{/* Register the fkey\_collate\_clause() SQL function */}
13916   rc = sqlite3_create_function(db, \textcolor{stringliteral}{"fkey\_collate\_clause"}, 4, SQLITE_UTF8,
13917       0, shellFkeyCollateClause, 0, 0
13918   );
13919 
13920 
13921   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
13922     rc = sqlite3_prepare_v2(db, zSql, -1, &pSql, 0);
13923   \}
13924   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
13925     sqlite3_bind_int(pSql, 1, bGroupByParent);
13926   \}
13927 
13928   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
13929     \textcolor{keywordtype}{int} rc2;
13930     \textcolor{keywordtype}{char} *zPrev = 0;
13931     \textcolor{keywordflow}{while}( SQLITE_ROW==sqlite3_step(pSql) )\{
13932       \textcolor{keywordtype}{int} res = -1;
13933       sqlite3_stmt *pExplain = 0;
13934       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zEQP = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSql, 0);
13935       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zGlob = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSql, 1);
13936       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zFrom = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSql, 2);
13937       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zTarget = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSql, 3);
13938       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCI = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSql, 4);
13939       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zParent = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSql, 5);
13940 
13941       rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);
13942       \textcolor{keywordflow}{if}( rc!=SQLITE_OK ) \textcolor{keywordflow}{break};
13943       \textcolor{keywordflow}{if}( SQLITE_ROW==sqlite3_step(pExplain) )\{
13944         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zPlan = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pExplain, 3);
13945         res = (
13946               0==sqlite3_strglob(zGlob, zPlan)
13947            || 0==sqlite3_strglob(zGlobIPK, zPlan)
13948         );
13949       \}
13950       rc = sqlite3_finalize(pExplain);
13951       \textcolor{keywordflow}{if}( rc!=SQLITE_OK ) \textcolor{keywordflow}{break};
13952 
13953       \textcolor{keywordflow}{if}( res<0 )\{
13954         raw_printf(stderr, \textcolor{stringliteral}{"Error: internal error"});
13955         \textcolor{keywordflow}{break};
13956       \}\textcolor{keywordflow}{else}\{
13957         \textcolor{keywordflow}{if}( bGroupByParent
13958         && (bVerbose || res==0)
13959         && (zPrev==0 || sqlite3_stricmp(zParent, zPrev))
13960         )\{
13961           raw_printf(out, \textcolor{stringliteral}{"-- Parent table %s\(\backslash\)n"}, zParent);
13962           sqlite3_free(zPrev);
13963           zPrev = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, zParent);
13964         \}
13965 
13966         \textcolor{keywordflow}{if}( res==0 )\{
13967           raw_printf(out, \textcolor{stringliteral}{"%s%s --> %s\(\backslash\)n"}, zIndent, zCI, zTarget);
13968         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( bVerbose )\{
13969           raw_printf(out, \textcolor{stringliteral}{"%s/* no extra indexes required for %s -> %s */\(\backslash\)n"},
13970               zIndent, zFrom, zTarget
13971           );
13972         \}
13973       \}
13974     \}
13975     sqlite3_free(zPrev);
13976 
13977     \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
13978       raw_printf(stderr, \textcolor{stringliteral}{"%s\(\backslash\)n"}, sqlite3_errmsg(db));
13979     \}
13980 
13981     rc2 = sqlite3_finalize(pSql);
13982     \textcolor{keywordflow}{if}( rc==SQLITE_OK && rc2!=SQLITE_OK )\{
13983       rc = rc2;
13984       raw_printf(stderr, \textcolor{stringliteral}{"%s\(\backslash\)n"}, sqlite3_errmsg(db));
13985     \}
13986   \}\textcolor{keywordflow}{else}\{
13987     raw_printf(stderr, \textcolor{stringliteral}{"%s\(\backslash\)n"}, sqlite3_errmsg(db));
13988   \}
13989 
13990   \textcolor{keywordflow}{return} rc;
13991 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad885bb5dca992fbc1e19f9a35b2e6590}} 
\index{shell.\+c@{shell.\+c}!local\+\_\+getline@{local\+\_\+getline}}
\index{local\+\_\+getline@{local\+\_\+getline}!shell.\+c@{shell.\+c}}
\subsubsection{local\+\_\+getline()}
{\footnotesize\ttfamily static char$\ast$ local\+\_\+getline (\begin{DoxyParamCaption}\item[{char $\ast$}]{z\+Line,  }\item[{F\+I\+LE $\ast$}]{in }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 584 of file shell.\+c.



References shell\+\_\+out\+\_\+of\+\_\+memory(), sqlite3\+\_\+free, and strlen30().



Referenced by one\+\_\+input\+\_\+line().


\begin{DoxyCode}
584                                                  \{
585   \textcolor{keywordtype}{int} nLine = zLine==0 ? 0 : 100;
586   \textcolor{keywordtype}{int} n = 0;
587 
588   \textcolor{keywordflow}{while}( 1 )\{
589     \textcolor{keywordflow}{if}( n+100>nLine )\{
590       nLine = nLine*2 + 100;
591       zLine = realloc(zLine, nLine);
592       \textcolor{keywordflow}{if}( zLine==0 ) shell_out_of_memory();
593     \}
594     \textcolor{keywordflow}{if}( fgets(&zLine[n], nLine - n, in)==0 )\{
595       \textcolor{keywordflow}{if}( n==0 )\{
596         free(zLine);
597         \textcolor{keywordflow}{return} 0;
598       \}
599       zLine[n] = 0;
600       \textcolor{keywordflow}{break};
601     \}
602     \textcolor{keywordflow}{while}( zLine[n] ) n++;
603     \textcolor{keywordflow}{if}( n>0 && zLine[n-1]==\textcolor{charliteral}{'\(\backslash\)n'} )\{
604       n--;
605       \textcolor{keywordflow}{if}( n>0 && zLine[n-1]==\textcolor{charliteral}{'\(\backslash\)r'} ) n--;
606       zLine[n] = 0;
607       \textcolor{keywordflow}{break};
608     \}
609   \}
610 \textcolor{preprocessor}{#if defined(\_WIN32) || defined(WIN32)}
611   \textcolor{comment}{/* For interactive input on Windows systems, translate the}
612 \textcolor{comment}{  ** multi-byte characterset characters into UTF-8. */}
613   \textcolor{keywordflow}{if}( stdin_is_interactive && in==stdin )\{
614     \textcolor{keywordtype}{char} *zTrans = sqlite3\_win32\_mbcs\_to\_utf8\_v2(zLine, 0);
615     \textcolor{keywordflow}{if}( zTrans )\{
616       \textcolor{keywordtype}{int} nTrans = strlen30(zTrans)+1;
617       \textcolor{keywordflow}{if}( nTrans>nLine )\{
618         zLine = realloc(zLine, nTrans);
619         \textcolor{keywordflow}{if}( zLine==0 ) shell_out_of_memory();
620       \}
621       memcpy(zLine, zTrans, nTrans);
622       sqlite3_free(zTrans);
623     \}
624   \}
625 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* defined(\_WIN32) || defined(WIN32) */}\textcolor{preprocessor}{}
626   \textcolor{keywordflow}{return} zLine;
627 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a6f313b008c50dbdd10869b61bc4a1cc7}} 
\index{shell.\+c@{shell.\+c}!ls\+Mode\+Func@{ls\+Mode\+Func}}
\index{ls\+Mode\+Func@{ls\+Mode\+Func}!shell.\+c@{shell.\+c}}
\subsubsection{ls\+Mode\+Func()}
{\footnotesize\ttfamily static void ls\+Mode\+Func (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{context,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2537 of file shell.\+c.



References sqlite3\+\_\+result\+\_\+text, sqlite3\+\_\+value\+\_\+int, and S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT.



Referenced by sqlite3\+\_\+fileio\+\_\+init().


\begin{DoxyCode}
2541  \{
2542   \textcolor{keywordtype}{int} i;
2543   \textcolor{keywordtype}{int} iMode = sqlite3_value_int(argv[0]);
2544   \textcolor{keywordtype}{char} z[16];
2545   (void)argc;
2546   \textcolor{keywordflow}{if}( S\_ISLNK(iMode) )\{
2547     z[0] = \textcolor{charliteral}{'l'};
2548   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( S\_ISREG(iMode) )\{
2549     z[0] = \textcolor{charliteral}{'-'};
2550   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( S\_ISDIR(iMode) )\{
2551     z[0] = \textcolor{charliteral}{'d'};
2552   \}\textcolor{keywordflow}{else}\{
2553     z[0] = \textcolor{charliteral}{'?'};
2554   \}
2555   \textcolor{keywordflow}{for}(i=0; i<3; i++)\{
2556     \textcolor{keywordtype}{int} m = (iMode >> ((2-i)*3));
2557     \textcolor{keywordtype}{char} *a = &z[1 + i*3];
2558     a[0] = (m & 0x4) ? \textcolor{charliteral}{'r'} : \textcolor{charliteral}{'-'};
2559     a[1] = (m & 0x2) ? \textcolor{charliteral}{'w'} : \textcolor{charliteral}{'-'};
2560     a[2] = (m & 0x1) ? \textcolor{charliteral}{'x'} : \textcolor{charliteral}{'-'};
2561   \}
2562   z[10] = \textcolor{charliteral}{'\(\backslash\)0'};
2563   sqlite3_result_text(context, z, -1, SQLITE_TRANSIENT);
2564 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ac931daf5abf20567dcdd053c22142b95}} 
\index{shell.\+c@{shell.\+c}!main@{main}}
\index{main@{main}!shell.\+c@{shell.\+c}}
\subsubsection{main()}
{\footnotesize\ttfamily int \textbf{ S\+Q\+L\+I\+T\+E\+\_\+\+C\+D\+E\+CL} main (\begin{DoxyParamCaption}\item[{int}]{argc,  }\item[{char $\ast$$\ast$}]{argv }\end{DoxyParamCaption})}



Definition at line 18665 of file shell.\+c.



References Shell\+State\+::auto\+E\+QP, A\+U\+T\+O\+E\+Q\+P\+\_\+full, A\+U\+T\+O\+E\+Q\+P\+\_\+on, clear\+Temp\+File(), close\+\_\+db(), cmdline\+\_\+option\+\_\+value(), Shell\+State\+::c\+Mode, Shell\+State\+::col\+Separator, main3\+::data, Shell\+State\+::db, do\+\_\+meta\+\_\+command(), Shell\+State\+::do\+Xdg\+Open, find\+\_\+home\+\_\+dir(), G\+E\+T\+P\+ID, Shell\+State\+::in, integer\+Value(), interrupt\+\_\+handler(), isatty(), main\+\_\+init(), Shell\+State\+::mode, M\+O\+D\+E\+\_\+\+Ascii, M\+O\+D\+E\+\_\+\+Column, M\+O\+D\+E\+\_\+\+Csv, M\+O\+D\+E\+\_\+\+Html, M\+O\+D\+E\+\_\+\+Line, M\+O\+D\+E\+\_\+\+List, M\+O\+D\+E\+\_\+\+Quote, Shell\+State\+::null\+Value, open\+\_\+db(), O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+Z\+I\+P\+F\+I\+LE, Shell\+State\+::open\+Flags, Shell\+State\+::open\+Mode, Shell\+State\+::out, output\+\_\+reset(), print\+Bold(), process\+\_\+input(), process\+\_\+sqliterc(), raw\+\_\+printf, Shell\+State\+::row\+Separator, Shell\+State\+::scanstats\+On, S\+E\+P\+\_\+\+Record, S\+E\+P\+\_\+\+Unit, session\+\_\+close\+\_\+all, set\+\_\+table\+\_\+name(), set\+Binary\+Mode, shell\+\_\+exec(), S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+ZE, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE, shell\+\_\+out\+\_\+of\+\_\+memory(), shell\+\_\+read\+\_\+history, shell\+\_\+stifle\+\_\+history, shell\+\_\+write\+\_\+history, Shell\+State\+::shell\+Flgs, Shell\+Set\+Flag, S\+H\+F\+L\+G\+\_\+\+Backslash, S\+H\+F\+L\+G\+\_\+\+Echo, S\+H\+F\+L\+G\+\_\+\+Lookaside, S\+H\+F\+L\+G\+\_\+\+Pagecache, Shell\+State\+::show\+Header, sqlite3\+\_\+appendvfs\+\_\+init(), sqlite3\+\_\+config(), sqlite3\+\_\+free, sqlite3\+\_\+initialize(), sqlite3\+\_\+libversion, sqlite3\+\_\+shutdown(), sqlite3\+\_\+snprintf, sqlite3\+\_\+sourceid, sqlite3\+\_\+vfs\+\_\+find, sqlite3\+\_\+vfs\+\_\+register, sqlite3\+Mem\+Trace\+Activate(), S\+Q\+L\+I\+T\+E\+\_\+\+C\+D\+E\+CL, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+H\+E\+AP, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+L\+O\+O\+K\+A\+S\+I\+DE, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+M\+M\+A\+P\+\_\+\+S\+I\+ZE, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+P\+A\+G\+E\+C\+A\+C\+HE, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+S\+O\+R\+T\+E\+R\+R\+E\+F\+\_\+\+S\+I\+ZE, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+N\+O\+F\+O\+L\+L\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+S\+O\+U\+R\+C\+E\+\_\+\+ID, Shell\+State\+::stats\+On, strlen30(), Shell\+State\+::sz\+Max, usage(), utf8\+\_\+printf, verify\+\_\+uninitialized(), Shell\+State\+::z\+Db\+Filename, and Shell\+State\+::z\+Free\+On\+Close.


\begin{DoxyCode}
18665                                             \{
18666 \textcolor{preprocessor}{#else}
18667 \textcolor{keywordtype}{int} SQLITE_CDECL wmain(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{wchar\_t} **wargv)\{
18668   \textcolor{keywordtype}{char} **argv;
18669 \textcolor{preprocessor}{#endif}
18670   \textcolor{keywordtype}{char} *zErrMsg = 0;
18671   ShellState data;
18672   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zInitFile = 0;
18673   \textcolor{keywordtype}{int} i;
18674   \textcolor{keywordtype}{int} rc = 0;
18675   \textcolor{keywordtype}{int} warnInmemoryDb = 0;
18676   \textcolor{keywordtype}{int} readStdin = 1;
18677   \textcolor{keywordtype}{int} nCmd = 0;
18678   \textcolor{keywordtype}{char} **azCmd = 0;
18679   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zVfs = 0;           \textcolor{comment}{/* Value of -vfs command-line option */}
18680 \textcolor{preprocessor}{#if !SQLITE\_SHELL\_IS\_UTF8}
18681   \textcolor{keywordtype}{char} **argvToFree = 0;
18682   \textcolor{keywordtype}{int} argcToFree = 0;
18683 \textcolor{preprocessor}{#endif}
18684 
18685   setBinaryMode(stdin, 0);
18686   setvbuf(stderr, 0, \_IONBF, 0); \textcolor{comment}{/* Make sure stderr is unbuffered */}
18687   stdin_is_interactive = isatty(0);
18688   stdout_is_console = isatty(1);
18689 
18690 \textcolor{preprocessor}{#if !defined(\_WIN32\_WCE)}
18691   \textcolor{keywordflow}{if}( getenv(\textcolor{stringliteral}{"SQLITE\_DEBUG\_BREAK"}) )\{
18692     \textcolor{keywordflow}{if}( isatty(0) && isatty(2) )\{
18693       fprintf(stderr,
18694           \textcolor{stringliteral}{"attach debugger to process %d and press any key to continue.\(\backslash\)n"},
18695           GETPID());
18696       fgetc(stdin);
18697     \}\textcolor{keywordflow}{else}\{
18698 \textcolor{preprocessor}{#if defined(\_WIN32) || defined(WIN32)}
18699       DebugBreak();
18700 \textcolor{preprocessor}{#elif defined(SIGTRAP)}
18701       \textcolor{keyword}{raise}(SIGTRAP);
18702 \textcolor{preprocessor}{#endif}
18703     \}
18704   \}
18705 \textcolor{preprocessor}{#endif}
18706 
18707 \textcolor{preprocessor}{#if USE\_SYSTEM\_SQLITE+0!=1}
18708   \textcolor{keywordflow}{if}( strncmp(sqlite3_sourceid(),SQLITE_SOURCE_ID,60)!=0 )\{
18709     utf8_printf(stderr, \textcolor{stringliteral}{"SQLite header and source version mismatch\(\backslash\)n%s\(\backslash\)n%s\(\backslash\)n"},
18710             sqlite3_sourceid(), SQLITE_SOURCE_ID);
18711     exit(1);
18712   \}
18713 \textcolor{preprocessor}{#endif}
18714   main_init(&data);
18715 
18716   \textcolor{comment}{/* On Windows, we must translate command-line arguments into UTF-8.}
18717 \textcolor{comment}{  ** The SQLite memory allocator subsystem has to be enabled in order to}
18718 \textcolor{comment}{  ** do this.  But we want to run an sqlite3\_shutdown() afterwards so that}
18719 \textcolor{comment}{  ** subsequent sqlite3\_config() calls will work.  So copy all results into}
18720 \textcolor{comment}{  ** memory that does not come from the SQLite memory allocator.}
18721 \textcolor{comment}{  */}
18722 \textcolor{preprocessor}{#if !SQLITE\_SHELL\_IS\_UTF8}
18723   sqlite3_initialize();
18724   argvToFree = malloc(\textcolor{keyword}{sizeof}(argv[0])*argc*2);
18725   argcToFree = argc;
18726   argv = argvToFree + argc;
18727   \textcolor{keywordflow}{if}( argv==0 ) shell_out_of_memory();
18728   \textcolor{keywordflow}{for}(i=0; i<argc; i++)\{
18729     \textcolor{keywordtype}{char} *z = sqlite3\_win32\_unicode\_to\_utf8(wargv[i]);
18730     \textcolor{keywordtype}{int} n;
18731     \textcolor{keywordflow}{if}( z==0 ) shell_out_of_memory();
18732     n = (int)strlen(z);
18733     argv[i] = malloc( n+1 );
18734     \textcolor{keywordflow}{if}( argv[i]==0 ) shell_out_of_memory();
18735     memcpy(argv[i], z, n+1);
18736     argvToFree[i] = argv[i];
18737     sqlite3_free(z);
18738   \}
18739   sqlite3_shutdown();
18740 \textcolor{preprocessor}{#endif}
18741 
18742   assert( argc>=1 && argv && argv[0] );
18743   Argv0 = argv[0];
18744 
18745   \textcolor{comment}{/* Make sure we have a valid signal handler early, before anything}
18746 \textcolor{comment}{  ** else is done.}
18747 \textcolor{comment}{  */}
18748 \textcolor{preprocessor}{#ifdef SIGINT}
18749   signal(SIGINT, interrupt_handler);
18750 \textcolor{preprocessor}{#elif (defined(\_WIN32) || defined(WIN32)) && !defined(\_WIN32\_WCE)}
18751   SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);
18752 \textcolor{preprocessor}{#endif}
18753 
18754 \textcolor{preprocessor}{#ifdef SQLITE\_SHELL\_DBNAME\_PROC}
18755   \{
18756     \textcolor{comment}{/* If the SQLITE\_SHELL\_DBNAME\_PROC macro is defined, then it is the name}
18757 \textcolor{comment}{    ** of a C-function that will provide the name of the database file.  Use}
18758 \textcolor{comment}{    ** this compile-time option to embed this shell program in larger}
18759 \textcolor{comment}{    ** applications. */}
18760     \textcolor{keyword}{extern} \textcolor{keywordtype}{void} SQLITE\_SHELL\_DBNAME\_PROC(\textcolor{keyword}{const} \textcolor{keywordtype}{char}**);
18761     SQLITE\_SHELL\_DBNAME\_PROC(&data.zDbFilename);
18762     warnInmemoryDb = 0;
18763   \}
18764 \textcolor{preprocessor}{#endif}
18765 
18766   \textcolor{comment}{/* Do an initial pass through the command-line argument to locate}
18767 \textcolor{comment}{  ** the name of the database file, the name of the initialization file,}
18768 \textcolor{comment}{  ** the size of the alternative malloc heap,}
18769 \textcolor{comment}{  ** and the first command to execute.}
18770 \textcolor{comment}{  */}
18771   verify_uninitialized();
18772   \textcolor{keywordflow}{for}(i=1; i<argc; i++)\{
18773     \textcolor{keywordtype}{char} *z;
18774     z = argv[i];
18775     \textcolor{keywordflow}{if}( z[0]!=\textcolor{charliteral}{'-'} )\{
18776       \textcolor{keywordflow}{if}( data.zDbFilename==0 )\{
18777         data.zDbFilename = z;
18778       \}\textcolor{keywordflow}{else}\{
18779         \textcolor{comment}{/* Excesss arguments are interpreted as SQL (or dot-commands) and}
18780 \textcolor{comment}{        ** mean that nothing is read from stdin */}
18781         readStdin = 0;
18782         nCmd++;
18783         azCmd = realloc(azCmd, \textcolor{keyword}{sizeof}(azCmd[0])*nCmd);
18784         \textcolor{keywordflow}{if}( azCmd==0 ) shell_out_of_memory();
18785         azCmd[nCmd-1] = z;
18786       \}
18787     \}
18788     \textcolor{keywordflow}{if}( z[1]==\textcolor{charliteral}{'-'} ) z++;
18789     \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-separator"})==0
18790      || strcmp(z,\textcolor{stringliteral}{"-nullvalue"})==0
18791      || strcmp(z,\textcolor{stringliteral}{"-newline"})==0
18792      || strcmp(z,\textcolor{stringliteral}{"-cmd"})==0
18793     )\{
18794       (void)cmdline_option_value(argc, argv, ++i);
18795     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-init"})==0 )\{
18796       zInitFile = cmdline_option_value(argc, argv, ++i);
18797     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-batch"})==0 )\{
18798       \textcolor{comment}{/* Need to check for batch mode here to so we can avoid printing}
18799 \textcolor{comment}{      ** informational messages (like from process\_sqliterc) before}
18800 \textcolor{comment}{      ** we do the actual processing of arguments later in a second pass.}
18801 \textcolor{comment}{      */}
18802       stdin_is_interactive = 0;
18803     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-heap"})==0 )\{
18804 \textcolor{preprocessor}{#if defined(SQLITE\_ENABLE\_MEMSYS3) || defined(SQLITE\_ENABLE\_MEMSYS5)}
18805       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSize;
18806       sqlite3_int64 szHeap;
18807 
18808       zSize = cmdline_option_value(argc, argv, ++i);
18809       szHeap = integerValue(zSize);
18810       \textcolor{keywordflow}{if}( szHeap>0x7fff0000 ) szHeap = 0x7fff0000;
18811       sqlite3_config(SQLITE_CONFIG_HEAP, malloc((\textcolor{keywordtype}{int})szHeap), (\textcolor{keywordtype}{int})szHeap, 64);
18812 \textcolor{preprocessor}{#else}
18813       (void)cmdline_option_value(argc, argv, ++i);
18814 \textcolor{preprocessor}{#endif}
18815     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-pagecache"})==0 )\{
18816       \textcolor{keywordtype}{int} n, sz;
18817       sz = (int)integerValue(cmdline_option_value(argc,argv,++i));
18818       \textcolor{keywordflow}{if}( sz>70000 ) sz = 70000;
18819       \textcolor{keywordflow}{if}( sz<0 ) sz = 0;
18820       n = (int)integerValue(cmdline_option_value(argc,argv,++i));
18821       sqlite3_config(SQLITE_CONFIG_PAGECACHE,
18822                     (n>0 && sz>0) ? malloc(n*sz) : 0, sz, n);
18823       data.shellFlgs |= SHFLG_Pagecache;
18824     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-lookaside"})==0 )\{
18825       \textcolor{keywordtype}{int} n, sz;
18826       sz = (int)integerValue(cmdline_option_value(argc,argv,++i));
18827       \textcolor{keywordflow}{if}( sz<0 ) sz = 0;
18828       n = (int)integerValue(cmdline_option_value(argc,argv,++i));
18829       \textcolor{keywordflow}{if}( n<0 ) n = 0;
18830       sqlite3_config(SQLITE_CONFIG_LOOKASIDE, sz, n);
18831       \textcolor{keywordflow}{if}( sz*n==0 ) data.shellFlgs &= ~SHFLG_Lookaside;
18832 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_VFSTRACE}
18833     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-vfstrace"})==0 )\{
18834       \textcolor{keyword}{extern} \textcolor{keywordtype}{int} vfstrace\_register(
18835          \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zTraceName,
18836          \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zOldVfsName,
18837          \textcolor{keywordtype}{int} (*xOut)(\textcolor{keyword}{const} \textcolor{keywordtype}{char}*,\textcolor{keywordtype}{void}*),
18838          \textcolor{keywordtype}{void} *pOutArg,
18839          \textcolor{keywordtype}{int} makeDefault
18840       );
18841       vfstrace\_register(\textcolor{stringliteral}{"trace"},0,(\textcolor{keywordtype}{int}(*)(\textcolor{keyword}{const} \textcolor{keywordtype}{char}*,\textcolor{keywordtype}{void}*))fputs,stderr,1);
18842 \textcolor{preprocessor}{#endif}
18843 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_MULTIPLEX}
18844     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-multiplex"})==0 )\{
18845       \textcolor{keyword}{extern} \textcolor{keywordtype}{int} sqlite3\_multiple\_initialize(\textcolor{keyword}{const} \textcolor{keywordtype}{char}*,\textcolor{keywordtype}{int});
18846       sqlite3\_multiplex\_initialize(0, 1);
18847 \textcolor{preprocessor}{#endif}
18848     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-mmap"})==0 )\{
18849       sqlite3_int64 sz = integerValue(cmdline_option_value(argc,argv,++i));
18850       sqlite3_config(SQLITE_CONFIG_MMAP_SIZE, sz, sz);
18851 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_SORTER\_REFERENCES}
18852     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-sorterref"})==0 )\{
18853       sqlite3_int64 sz = integerValue(cmdline_option_value(argc,argv,++i));
18854       sqlite3_config(SQLITE_CONFIG_SORTERREF_SIZE, (\textcolor{keywordtype}{int})sz);
18855 \textcolor{preprocessor}{#endif}
18856     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-vfs"})==0 )\{
18857       zVfs = cmdline_option_value(argc, argv, ++i);
18858 \textcolor{preprocessor}{#ifdef SQLITE\_HAVE\_ZLIB}
18859     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-zip"})==0 )\{
18860       data.openMode = SHELL_OPEN_ZIPFILE;
18861 \textcolor{preprocessor}{#endif}
18862     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-append"})==0 )\{
18863       data.openMode = SHELL_OPEN_APPENDVFS;
18864 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_DESERIALIZE}
18865     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-deserialize"})==0 )\{
18866       data.openMode = SHELL_OPEN_DESERIALIZE;
18867     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-maxsize"})==0 && i+1<argc )\{
18868       data.szMax = integerValue(argv[++i]);
18869 \textcolor{preprocessor}{#endif}
18870     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-readonly"})==0 )\{
18871       data.openMode = SHELL_OPEN_READONLY;
18872     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-nofollow"})==0 )\{
18873       data.openFlags = SQLITE_OPEN_NOFOLLOW;
18874 \textcolor{preprocessor}{#if !defined(SQLITE\_OMIT\_VIRTUALTABLE) && defined(SQLITE\_HAVE\_ZLIB)}
18875     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strncmp(z, \textcolor{stringliteral}{"-A"},2)==0 )\{
18876       \textcolor{comment}{/* All remaining command-line arguments are passed to the ".archive"}
18877 \textcolor{comment}{      ** command, so ignore them */}
18878       \textcolor{keywordflow}{break};
18879 \textcolor{preprocessor}{#endif}
18880     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z, \textcolor{stringliteral}{"-memtrace"})==0 )\{
18881       sqlite3MemTraceActivate(stderr);
18882     \}
18883   \}
18884   verify_uninitialized();
18885 
18886 
18887 \textcolor{preprocessor}{#ifdef SQLITE\_SHELL\_INIT\_PROC}
18888   \{
18889     \textcolor{comment}{/* If the SQLITE\_SHELL\_INIT\_PROC macro is defined, then it is the name}
18890 \textcolor{comment}{    ** of a C-function that will perform initialization actions on SQLite that}
18891 \textcolor{comment}{    ** occur just before or after sqlite3\_initialize(). Use this compile-time}
18892 \textcolor{comment}{    ** option to embed this shell program in larger applications. */}
18893     \textcolor{keyword}{extern} \textcolor{keywordtype}{void} SQLITE\_SHELL\_INIT\_PROC(\textcolor{keywordtype}{void});
18894     SQLITE\_SHELL\_INIT\_PROC();
18895   \}
18896 \textcolor{preprocessor}{#else}
18897   \textcolor{comment}{/* All the sqlite3\_config() calls have now been made. So it is safe}
18898 \textcolor{comment}{  ** to call sqlite3\_initialize() and process any command line -vfs option. */}
18899   sqlite3_initialize();
18900 \textcolor{preprocessor}{#endif}
18901 
18902   \textcolor{keywordflow}{if}( zVfs )\{
18903     sqlite3_vfs *pVfs = sqlite3_vfs_find(zVfs);
18904     \textcolor{keywordflow}{if}( pVfs )\{
18905       sqlite3_vfs_register(pVfs, 1);
18906     \}\textcolor{keywordflow}{else}\{
18907       utf8_printf(stderr, \textcolor{stringliteral}{"no such VFS: \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, argv[i]);
18908       exit(1);
18909     \}
18910   \}
18911 
18912   \textcolor{keywordflow}{if}( data.zDbFilename==0 )\{
18913 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_MEMORYDB}
18914     data.zDbFilename = \textcolor{stringliteral}{":memory:"};
18915     warnInmemoryDb = argc==1;
18916 \textcolor{preprocessor}{#else}
18917     utf8_printf(stderr,\textcolor{stringliteral}{"%s: Error: no database filename specified\(\backslash\)n"}, Argv0);
18918     \textcolor{keywordflow}{return} 1;
18919 \textcolor{preprocessor}{#endif}
18920   \}
18921   data.out = stdout;
18922   sqlite3_appendvfs_init(0,0,0);
18923 
18924   \textcolor{comment}{/* Go ahead and open the database file if it already exists.  If the}
18925 \textcolor{comment}{  ** file does not exist, delay opening it.  This prevents empty database}
18926 \textcolor{comment}{  ** files from being created if a user mistypes the database name argument}
18927 \textcolor{comment}{  ** to the sqlite command-line tool.}
18928 \textcolor{comment}{  */}
18929   \textcolor{keywordflow}{if}( access(data.zDbFilename, 0)==0 )\{
18930     open_db(&data, 0);
18931   \}
18932 
18933   \textcolor{comment}{/* Process the initialization file if there is one.  If no -init option}
18934 \textcolor{comment}{  ** is given on the command line, look for a file named ~/.sqliterc and}
18935 \textcolor{comment}{  ** try to process it.}
18936 \textcolor{comment}{  */}
18937   process_sqliterc(&data,zInitFile);
18938 
18939   \textcolor{comment}{/* Make a second pass through the command-line argument and set}
18940 \textcolor{comment}{  ** options.  This second pass is delayed until after the initialization}
18941 \textcolor{comment}{  ** file is processed so that the command-line arguments will override}
18942 \textcolor{comment}{  ** settings in the initialization file.}
18943 \textcolor{comment}{  */}
18944   \textcolor{keywordflow}{for}(i=1; i<argc; i++)\{
18945     \textcolor{keywordtype}{char} *z = argv[i];
18946     \textcolor{keywordflow}{if}( z[0]!=\textcolor{charliteral}{'-'} ) \textcolor{keywordflow}{continue};
18947     \textcolor{keywordflow}{if}( z[1]==\textcolor{charliteral}{'-'} )\{ z++; \}
18948     \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-init"})==0 )\{
18949       i++;
18950     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-html"})==0 )\{
18951       data.mode = MODE_Html;
18952     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-list"})==0 )\{
18953       data.mode = MODE_List;
18954     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-quote"})==0 )\{
18955       data.mode = MODE_Quote;
18956     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-line"})==0 )\{
18957       data.mode = MODE_Line;
18958     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-column"})==0 )\{
18959       data.mode = MODE_Column;
18960     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-csv"})==0 )\{
18961       data.mode = MODE_Csv;
18962       memcpy(data.colSeparator,\textcolor{stringliteral}{","},2);
18963 \textcolor{preprocessor}{#ifdef SQLITE\_HAVE\_ZLIB}
18964     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-zip"})==0 )\{
18965       data.openMode = SHELL_OPEN_ZIPFILE;
18966 \textcolor{preprocessor}{#endif}
18967     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-append"})==0 )\{
18968       data.openMode = SHELL_OPEN_APPENDVFS;
18969 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_DESERIALIZE}
18970     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-deserialize"})==0 )\{
18971       data.openMode = SHELL_OPEN_DESERIALIZE;
18972     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-maxsize"})==0 && i+1<argc )\{
18973       data.szMax = integerValue(argv[++i]);
18974 \textcolor{preprocessor}{#endif}
18975     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-readonly"})==0 )\{
18976       data.openMode = SHELL_OPEN_READONLY;
18977     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-nofollow"})==0 )\{
18978       data.openFlags |= SQLITE_OPEN_NOFOLLOW;
18979     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-ascii"})==0 )\{
18980       data.mode = MODE_Ascii;
18981       sqlite3_snprintf(\textcolor{keyword}{sizeof}(data.colSeparator), data.colSeparator,
18982                        SEP_Unit);
18983       sqlite3_snprintf(\textcolor{keyword}{sizeof}(data.rowSeparator), data.rowSeparator,
18984                        SEP_Record);
18985     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-separator"})==0 )\{
18986       sqlite3_snprintf(\textcolor{keyword}{sizeof}(data.colSeparator), data.colSeparator,
18987                        \textcolor{stringliteral}{"%s"},cmdline_option_value(argc,argv,++i));
18988     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-newline"})==0 )\{
18989       sqlite3_snprintf(\textcolor{keyword}{sizeof}(data.rowSeparator), data.rowSeparator,
18990                        \textcolor{stringliteral}{"%s"},cmdline_option_value(argc,argv,++i));
18991     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-nullvalue"})==0 )\{
18992       sqlite3_snprintf(\textcolor{keyword}{sizeof}(data.nullValue), data.nullValue,
18993                        \textcolor{stringliteral}{"%s"},cmdline_option_value(argc,argv,++i));
18994     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-header"})==0 )\{
18995       data.showHeader = 1;
18996     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-noheader"})==0 )\{
18997       data.showHeader = 0;
18998     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-echo"})==0 )\{
18999       ShellSetFlag(&data, SHFLG_Echo);
19000     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-eqp"})==0 )\{
19001       data.autoEQP = AUTOEQP_on;
19002     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-eqpfull"})==0 )\{
19003       data.autoEQP = AUTOEQP_full;
19004     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-stats"})==0 )\{
19005       data.statsOn = 1;
19006     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-scanstats"})==0 )\{
19007       data.scanstatsOn = 1;
19008     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-backslash"})==0 )\{
19009       \textcolor{comment}{/* Undocumented command-line option: -backslash}
19010 \textcolor{comment}{      ** Causes C-style backslash escapes to be evaluated in SQL statements}
19011 \textcolor{comment}{      ** prior to sending the SQL into SQLite.  Useful for injecting}
19012 \textcolor{comment}{      ** crazy bytes in the middle of SQL statements for testing and debugging.}
19013 \textcolor{comment}{      */}
19014       ShellSetFlag(&data, SHFLG_Backslash);
19015     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-bail"})==0 )\{
19016       bail_on_error = 1;
19017     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-version"})==0 )\{
19018       printf(\textcolor{stringliteral}{"%s %s\(\backslash\)n"}, sqlite3_libversion(), sqlite3_sourceid());
19019       \textcolor{keywordflow}{return} 0;
19020     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-interactive"})==0 )\{
19021       stdin_is_interactive = 1;
19022     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-batch"})==0 )\{
19023       stdin_is_interactive = 0;
19024     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-heap"})==0 )\{
19025       i++;
19026     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-pagecache"})==0 )\{
19027       i+=2;
19028     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-lookaside"})==0 )\{
19029       i+=2;
19030     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-mmap"})==0 )\{
19031       i++;
19032     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-memtrace"})==0 )\{
19033       i++;
19034 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_SORTER\_REFERENCES}
19035     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-sorterref"})==0 )\{
19036       i++;
19037 \textcolor{preprocessor}{#endif}
19038     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-vfs"})==0 )\{
19039       i++;
19040 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_VFSTRACE}
19041     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-vfstrace"})==0 )\{
19042       i++;
19043 \textcolor{preprocessor}{#endif}
19044 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_MULTIPLEX}
19045     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-multiplex"})==0 )\{
19046       i++;
19047 \textcolor{preprocessor}{#endif}
19048     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-help"})==0 )\{
19049       usage(1);
19050     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(z,\textcolor{stringliteral}{"-cmd"})==0 )\{
19051       \textcolor{comment}{/* Run commands that follow -cmd first and separately from commands}
19052 \textcolor{comment}{      ** that simply appear on the command-line.  This seems goofy.  It would}
19053 \textcolor{comment}{      ** be better if all commands ran in the order that they appear.  But}
19054 \textcolor{comment}{      ** we retain the goofy behavior for historical compatibility. */}
19055       \textcolor{keywordflow}{if}( i==argc-1 ) \textcolor{keywordflow}{break};
19056       z = cmdline_option_value(argc,argv,++i);
19057       \textcolor{keywordflow}{if}( z[0]==\textcolor{charliteral}{'.'} )\{
19058         rc = do_meta_command(z, &data);
19059         \textcolor{keywordflow}{if}( rc && bail_on_error ) \textcolor{keywordflow}{return} rc==2 ? 0 : rc;
19060       \}\textcolor{keywordflow}{else}\{
19061         open_db(&data, 0);
19062         rc = shell_exec(&data, z, &zErrMsg);
19063         \textcolor{keywordflow}{if}( zErrMsg!=0 )\{
19064           utf8_printf(stderr,\textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, zErrMsg);
19065           \textcolor{keywordflow}{if}( bail_on_error ) \textcolor{keywordflow}{return} rc!=0 ? rc : 1;
19066         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( rc!=0 )\{
19067           utf8_printf(stderr,\textcolor{stringliteral}{"Error: unable to process SQL \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, z);
19068           \textcolor{keywordflow}{if}( bail_on_error ) \textcolor{keywordflow}{return} rc;
19069         \}
19070       \}
19071 \textcolor{preprocessor}{#if !defined(SQLITE\_OMIT\_VIRTUALTABLE) && defined(SQLITE\_HAVE\_ZLIB)}
19072     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strncmp(z, \textcolor{stringliteral}{"-A"}, 2)==0 )\{
19073       \textcolor{keywordflow}{if}( nCmd>0 )\{
19074         utf8_printf(stderr, \textcolor{stringliteral}{"Error: cannot mix regular SQL or dot-commands"}
19075                             \textcolor{stringliteral}{" with \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, z);
19076         \textcolor{keywordflow}{return} 1;
19077       \}
19078       open_db(&data, OPEN_DB_ZIPFILE);
19079       \textcolor{keywordflow}{if}( z[2] )\{
19080         argv[i] = &z[2];
19081         arDotCommand(&data, 1, argv+(i-1), argc-(i-1));
19082       \}\textcolor{keywordflow}{else}\{
19083         arDotCommand(&data, 1, argv+i, argc-i);
19084       \}
19085       readStdin = 0;
19086       \textcolor{keywordflow}{break};
19087 \textcolor{preprocessor}{#endif}
19088     \}\textcolor{keywordflow}{else}\{
19089       utf8_printf(stderr,\textcolor{stringliteral}{"%s: Error: unknown option: %s\(\backslash\)n"}, Argv0, z);
19090       raw_printf(stderr,\textcolor{stringliteral}{"Use -help for a list of options.\(\backslash\)n"});
19091       \textcolor{keywordflow}{return} 1;
19092     \}
19093     data.cMode = data.mode;
19094   \}
19095 
19096   \textcolor{keywordflow}{if}( !readStdin )\{
19097     \textcolor{comment}{/* Run all arguments that do not begin with '-' as if they were separate}
19098 \textcolor{comment}{    ** command-line inputs, except for the argToSkip argument which contains}
19099 \textcolor{comment}{    ** the database filename.}
19100 \textcolor{comment}{    */}
19101     \textcolor{keywordflow}{for}(i=0; i<nCmd; i++)\{
19102       \textcolor{keywordflow}{if}( azCmd[i][0]==\textcolor{charliteral}{'.'} )\{
19103         rc = do_meta_command(azCmd[i], &data);
19104         \textcolor{keywordflow}{if}( rc ) \textcolor{keywordflow}{return} rc==2 ? 0 : rc;
19105       \}\textcolor{keywordflow}{else}\{
19106         open_db(&data, 0);
19107         rc = shell_exec(&data, azCmd[i], &zErrMsg);
19108         \textcolor{keywordflow}{if}( zErrMsg!=0 )\{
19109           utf8_printf(stderr,\textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, zErrMsg);
19110           \textcolor{keywordflow}{return} rc!=0 ? rc : 1;
19111         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( rc!=0 )\{
19112           utf8_printf(stderr,\textcolor{stringliteral}{"Error: unable to process SQL: %s\(\backslash\)n"}, azCmd[i]);
19113           \textcolor{keywordflow}{return} rc;
19114         \}
19115       \}
19116     \}
19117     free(azCmd);
19118   \}\textcolor{keywordflow}{else}\{
19119     \textcolor{comment}{/* Run commands received from standard input}
19120 \textcolor{comment}{    */}
19121     \textcolor{keywordflow}{if}( stdin_is_interactive )\{
19122       \textcolor{keywordtype}{char} *zHome;
19123       \textcolor{keywordtype}{char} *zHistory;
19124       \textcolor{keywordtype}{int} nHistory;
19125       printf(
19126         \textcolor{stringliteral}{"SQLite version %s %.19s\(\backslash\)n"} \textcolor{comment}{/*extra-version-info*/}
19127         \textcolor{stringliteral}{"Enter \(\backslash\)".help\(\backslash\)" for usage hints.\(\backslash\)n"},
19128         sqlite3_libversion(), sqlite3_sourceid()
19129       );
19130       \textcolor{keywordflow}{if}( warnInmemoryDb )\{
19131         printf(\textcolor{stringliteral}{"Connected to a "});
19132         printBold(\textcolor{stringliteral}{"transient in-memory database"});
19133         printf(\textcolor{stringliteral}{".\(\backslash\)nUse \(\backslash\)".open FILENAME\(\backslash\)" to reopen on a "}
19134                \textcolor{stringliteral}{"persistent database.\(\backslash\)n"});
19135       \}
19136       zHistory = getenv(\textcolor{stringliteral}{"SQLITE\_HISTORY"});
19137       \textcolor{keywordflow}{if}( zHistory )\{
19138         zHistory = strdup(zHistory);
19139       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( (zHome = find_home_dir(0))!=0 )\{
19140         nHistory = strlen30(zHome) + 20;
19141         \textcolor{keywordflow}{if}( (zHistory = malloc(nHistory))!=0 )\{
19142           sqlite3_snprintf(nHistory, zHistory,\textcolor{stringliteral}{"%s/.sqlite\_history"}, zHome);
19143         \}
19144       \}
19145       \textcolor{keywordflow}{if}( zHistory )\{ shell_read_history(zHistory); \}
19146 \textcolor{preprocessor}{#if HAVE\_READLINE || HAVE\_EDITLINE}
19147       rl\_attempted\_completion\_function = readline\_completion;
19148 \textcolor{preprocessor}{#elif HAVE\_LINENOISE}
19149       linenoiseSetCompletionCallback(linenoise\_completion);
19150 \textcolor{preprocessor}{#endif}
19151       data.in = 0;
19152       rc = process_input(&data);
19153       \textcolor{keywordflow}{if}( zHistory )\{
19154         shell_stifle_history(2000);
19155         shell_write_history(zHistory);
19156         free(zHistory);
19157       \}
19158     \}\textcolor{keywordflow}{else}\{
19159       data.in = stdin;
19160       rc = process_input(&data);
19161     \}
19162   \}
19163   set_table_name(&data, 0);
19164   \textcolor{keywordflow}{if}( data.db )\{
19165     session_close_all(&data);
19166     close_db(data.db);
19167   \}
19168   sqlite3_free(data.zFreeOnClose);
19169   find_home_dir(1);
19170   output_reset(&data);
19171   data.doXdgOpen = 0;
19172   clearTempFile(&data);
19173 \textcolor{preprocessor}{#if !SQLITE\_SHELL\_IS\_UTF8}
19174   \textcolor{keywordflow}{for}(i=0; i<argcToFree; i++) free(argvToFree[i]);
19175   free(argvToFree);
19176 \textcolor{preprocessor}{#endif}
19177   \textcolor{comment}{/* Clear the global data structure so that valgrind will detect memory}
19178 \textcolor{comment}{  ** leaks */}
19179   memset(&data, 0, \textcolor{keyword}{sizeof}(data));
19180   \textcolor{keywordflow}{return} rc;
19181 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a7384081333f19a3e9a0ed167efeca6af}} 
\index{shell.\+c@{shell.\+c}!main\+\_\+init@{main\+\_\+init}}
\index{main\+\_\+init@{main\+\_\+init}!shell.\+c@{shell.\+c}}
\subsubsection{main\+\_\+init()}
{\footnotesize\ttfamily static void main\+\_\+init (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18607 of file shell.\+c.



References Shell\+State\+::auto\+Explain, Shell\+State\+::c\+Mode, Shell\+State\+::col\+Separator, Shell\+State\+::mode, M\+O\+D\+E\+\_\+\+List, Shell\+State\+::normal\+Mode, print\+Bold(), Shell\+State\+::row\+Separator, S\+E\+P\+\_\+\+Column, S\+E\+P\+\_\+\+Row, Shell\+State\+::shell\+Flgs, shell\+Log(), S\+H\+F\+L\+G\+\_\+\+Lookaside, Shell\+State\+::show\+Header, sqlite3\+\_\+config(), sqlite3\+\_\+snprintf, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+L\+OG, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+M\+U\+L\+T\+I\+T\+H\+R\+E\+AD, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+U\+RI, and verify\+\_\+uninitialized().



Referenced by main().


\begin{DoxyCode}
18607                                         \{
18608   memset(data, 0, \textcolor{keyword}{sizeof}(*data));
18609   data->normalMode = data->cMode = data->mode = MODE_List;
18610   data->autoExplain = 1;
18611   memcpy(data->colSeparator,SEP_Column, 2);
18612   memcpy(data->rowSeparator,SEP_Row, 2);
18613   data->showHeader = 0;
18614   data->shellFlgs = SHFLG_Lookaside;
18615   verify_uninitialized();
18616   sqlite3_config(SQLITE_CONFIG_URI, 1);
18617   sqlite3_config(SQLITE_CONFIG_LOG, shellLog, data);
18618   sqlite3_config(SQLITE_CONFIG_MULTITHREAD);
18619   sqlite3_snprintf(\textcolor{keyword}{sizeof}(mainPrompt), mainPrompt,\textcolor{stringliteral}{"sqlite> "});
18620   sqlite3_snprintf(\textcolor{keyword}{sizeof}(continuePrompt), continuePrompt,\textcolor{stringliteral}{"   ...> "});
18621 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a6e314bdf95720609135e34b2215392b7}} 
\index{shell.\+c@{shell.\+c}!make\+Directory@{make\+Directory}}
\index{make\+Directory@{make\+Directory}!shell.\+c@{shell.\+c}}
\subsubsection{make\+Directory()}
{\footnotesize\ttfamily static int make\+Directory (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+File }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2335 of file shell.\+c.



References file\+Stat(), sqlite3\+\_\+free, sqlite3\+\_\+mprintf, S\+Q\+L\+I\+T\+E\+\_\+\+E\+R\+R\+OR, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by writefile\+Func().


\begin{DoxyCode}
2337  \{
2338   \textcolor{keywordtype}{char} *zCopy = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, zFile);
2339   \textcolor{keywordtype}{int} rc = SQLITE_OK;
2340 
2341   \textcolor{keywordflow}{if}( zCopy==0 )\{
2342     rc = SQLITE_NOMEM;
2343   \}\textcolor{keywordflow}{else}\{
2344     \textcolor{keywordtype}{int} nCopy = (int)strlen(zCopy);
2345     \textcolor{keywordtype}{int} i = 1;
2346 
2347     \textcolor{keywordflow}{while}( rc==SQLITE_OK )\{
2348       \textcolor{keyword}{struct }stat sStat;
2349       \textcolor{keywordtype}{int} rc2;
2350 
2351       \textcolor{keywordflow}{for}(; zCopy[i]!=\textcolor{charliteral}{'/'} && i<nCopy; i++);
2352       \textcolor{keywordflow}{if}( i==nCopy ) \textcolor{keywordflow}{break};
2353       zCopy[i] = \textcolor{charliteral}{'\(\backslash\)0'};
2354 
2355       rc2 = fileStat(zCopy, &sStat);
2356       \textcolor{keywordflow}{if}( rc2!=0 )\{
2357         \textcolor{keywordflow}{if}( mkdir(zCopy, 0777) ) rc = SQLITE_ERROR;
2358       \}\textcolor{keywordflow}{else}\{
2359         \textcolor{keywordflow}{if}( !S\_ISDIR(sStat.st\_mode) ) rc = SQLITE_ERROR;
2360       \}
2361       zCopy[i] = \textcolor{charliteral}{'/'};
2362       i++;
2363     \}
2364 
2365     sqlite3_free(zCopy);
2366   \}
2367 
2368   \textcolor{keywordflow}{return} rc;
2369 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a204acb4d070ebd6cb66d192c42687a09}} 
\index{shell.\+c@{shell.\+c}!memtrace\+Free@{memtrace\+Free}}
\index{memtrace\+Free@{memtrace\+Free}!shell.\+c@{shell.\+c}}
\subsubsection{memtrace\+Free()}
{\footnotesize\ttfamily static void memtrace\+Free (\begin{DoxyParamCaption}\item[{void $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4145 of file shell.\+c.



References sqlite3\+\_\+mem\+\_\+methods\+::x\+Free, and sqlite3\+\_\+mem\+\_\+methods\+::x\+Size.



Referenced by memtrace\+Realloc().


\begin{DoxyCode}
4145                                  \{
4146   \textcolor{keywordflow}{if}( p==0 ) \textcolor{keywordflow}{return};
4147   \textcolor{keywordflow}{if}( memtraceOut )\{
4148     fprintf(memtraceOut, \textcolor{stringliteral}{"MEMTRACE: free %d bytes\(\backslash\)n"}, memtraceBase.xSize(p));
4149   \}
4150   memtraceBase.xFree(p);
4151 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a636bf20aab0893f2f8ad37033d643316}} 
\index{shell.\+c@{shell.\+c}!memtrace\+Init@{memtrace\+Init}}
\index{memtrace\+Init@{memtrace\+Init}!shell.\+c@{shell.\+c}}
\subsubsection{memtrace\+Init()}
{\footnotesize\ttfamily static int memtrace\+Init (\begin{DoxyParamCaption}\item[{void $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4170 of file shell.\+c.



References sqlite3\+\_\+mem\+\_\+methods\+::x\+Init.


\begin{DoxyCode}
4170                                 \{
4171   \textcolor{keywordflow}{return} memtraceBase.xInit(p);
4172 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aef6d794e6859e658df74bbedbc0005a3}} 
\index{shell.\+c@{shell.\+c}!memtrace\+Malloc@{memtrace\+Malloc}}
\index{memtrace\+Malloc@{memtrace\+Malloc}!shell.\+c@{shell.\+c}}
\subsubsection{memtrace\+Malloc()}
{\footnotesize\ttfamily static void$\ast$ memtrace\+Malloc (\begin{DoxyParamCaption}\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4138 of file shell.\+c.



References sqlite3\+\_\+mem\+\_\+methods\+::x\+Malloc, and sqlite3\+\_\+mem\+\_\+methods\+::x\+Roundup.



Referenced by memtrace\+Realloc().


\begin{DoxyCode}
4138                                   \{
4139   \textcolor{keywordflow}{if}( memtraceOut )\{
4140     fprintf(memtraceOut, \textcolor{stringliteral}{"MEMTRACE: allocate %d bytes\(\backslash\)n"}, 
4141             memtraceBase.xRoundup(n));
4142   \}
4143   \textcolor{keywordflow}{return} memtraceBase.xMalloc(n);
4144 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a1be0e06a237207ecd756f9577dd32acc}} 
\index{shell.\+c@{shell.\+c}!memtrace\+Realloc@{memtrace\+Realloc}}
\index{memtrace\+Realloc@{memtrace\+Realloc}!shell.\+c@{shell.\+c}}
\subsubsection{memtrace\+Realloc()}
{\footnotesize\ttfamily static void$\ast$ memtrace\+Realloc (\begin{DoxyParamCaption}\item[{void $\ast$}]{p,  }\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4152 of file shell.\+c.



References memtrace\+Free(), memtrace\+Malloc(), sqlite3\+\_\+mem\+\_\+methods\+::x\+Realloc, sqlite3\+\_\+mem\+\_\+methods\+::x\+Roundup, and sqlite3\+\_\+mem\+\_\+methods\+::x\+Size.


\begin{DoxyCode}
4152                                             \{
4153   \textcolor{keywordflow}{if}( p==0 ) \textcolor{keywordflow}{return} memtraceMalloc(n);
4154   \textcolor{keywordflow}{if}( n==0 )\{
4155     memtraceFree(p);
4156     \textcolor{keywordflow}{return} 0;
4157   \}
4158   \textcolor{keywordflow}{if}( memtraceOut )\{
4159     fprintf(memtraceOut, \textcolor{stringliteral}{"MEMTRACE: resize %d -> %d bytes\(\backslash\)n"},
4160             memtraceBase.xSize(p), memtraceBase.xRoundup(n));
4161   \}
4162   \textcolor{keywordflow}{return} memtraceBase.xRealloc(p, n);
4163 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad30b59a7f4465b2d723803e252bc1f3e}} 
\index{shell.\+c@{shell.\+c}!memtrace\+Roundup@{memtrace\+Roundup}}
\index{memtrace\+Roundup@{memtrace\+Roundup}!shell.\+c@{shell.\+c}}
\subsubsection{memtrace\+Roundup()}
{\footnotesize\ttfamily static int memtrace\+Roundup (\begin{DoxyParamCaption}\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4167 of file shell.\+c.



References sqlite3\+\_\+mem\+\_\+methods\+::x\+Roundup.


\begin{DoxyCode}
4167                                  \{
4168   \textcolor{keywordflow}{return} memtraceBase.xRoundup(n);
4169 \}
\end{DoxyCode}
\mbox{\label{shell_8c_af2db2290b1a7a3632942e50b3f4cb7b9}} 
\index{shell.\+c@{shell.\+c}!memtrace\+Shutdown@{memtrace\+Shutdown}}
\index{memtrace\+Shutdown@{memtrace\+Shutdown}!shell.\+c@{shell.\+c}}
\subsubsection{memtrace\+Shutdown()}
{\footnotesize\ttfamily static void memtrace\+Shutdown (\begin{DoxyParamCaption}\item[{void $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4173 of file shell.\+c.



References sqlite3\+\_\+mem\+\_\+methods\+::x\+Shutdown.


\begin{DoxyCode}
4173                                      \{
4174   memtraceBase.xShutdown(p);
4175 \}
\end{DoxyCode}
\mbox{\label{shell_8c_abe2741d2490f6ffc6cfa349778eaa470}} 
\index{shell.\+c@{shell.\+c}!memtrace\+Size@{memtrace\+Size}}
\index{memtrace\+Size@{memtrace\+Size}!shell.\+c@{shell.\+c}}
\subsubsection{memtrace\+Size()}
{\footnotesize\ttfamily static int memtrace\+Size (\begin{DoxyParamCaption}\item[{void $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4164 of file shell.\+c.



References sqlite3\+\_\+mem\+\_\+methods\+::x\+Size.


\begin{DoxyCode}
4164                                 \{
4165   \textcolor{keywordflow}{return} memtraceBase.xSize(p);
4166 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a572d9f277580de26bdca881270e914fc}} 
\index{shell.\+c@{shell.\+c}!new\+Temp\+File@{new\+Temp\+File}}
\index{new\+Temp\+File@{new\+Temp\+File}!shell.\+c@{shell.\+c}}
\subsubsection{new\+Temp\+File()}
{\footnotesize\ttfamily static void new\+Temp\+File (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{const char $\ast$}]{z\+Suffix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13743 of file shell.\+c.



References clear\+Temp\+File(), Shell\+State\+::db, raw\+\_\+printf, sqlite3\+\_\+file\+\_\+control, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+randomness, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+T\+E\+M\+P\+F\+I\+L\+E\+N\+A\+ME, and Shell\+State\+::z\+Temp\+File.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13743                                                            \{
13744   clearTempFile(p);
13745   sqlite3_free(p->zTempFile);
13746   p->zTempFile = 0;
13747   \textcolor{keywordflow}{if}( p->db )\{
13748     sqlite3_file_control(p->db, 0, SQLITE_FCNTL_TEMPFILENAME, &p->zTempFile);
13749   \}
13750   \textcolor{keywordflow}{if}( p->zTempFile==0 )\{
13751     sqlite3_uint64 r;
13752     sqlite3_randomness(\textcolor{keyword}{sizeof}(r), &r);
13753     p->zTempFile = sqlite3_mprintf(\textcolor{stringliteral}{"temp%llx.%s"}, r, zSuffix);
13754   \}\textcolor{keywordflow}{else}\{
13755     p->zTempFile = sqlite3_mprintf(\textcolor{stringliteral}{"%z.%s"}, p->zTempFile, zSuffix);
13756   \}
13757   \textcolor{keywordflow}{if}( p->zTempFile==0 )\{
13758     raw_printf(stderr, \textcolor{stringliteral}{"out of memory\(\backslash\)n"});
13759     exit(1);
13760   \}
13761 \}
\end{DoxyCode}
\mbox{\label{shell_8c_acda6c882963376e11ebad6d9804614ca}} 
\index{shell.\+c@{shell.\+c}!one\+\_\+input\+\_\+line@{one\+\_\+input\+\_\+line}}
\index{one\+\_\+input\+\_\+line@{one\+\_\+input\+\_\+line}!shell.\+c@{shell.\+c}}
\subsubsection{one\+\_\+input\+\_\+line()}
{\footnotesize\ttfamily static char$\ast$ one\+\_\+input\+\_\+line (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{in,  }\item[{char $\ast$}]{z\+Prior,  }\item[{int}]{is\+Continuation }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 643 of file shell.\+c.



References continue\+Prompt, local\+\_\+getline(), and main\+Prompt.



Referenced by process\+\_\+input().


\begin{DoxyCode}
643                                                                        \{
644   \textcolor{keywordtype}{char} *zPrompt;
645   \textcolor{keywordtype}{char} *zResult;
646   \textcolor{keywordflow}{if}( in!=0 )\{
647     zResult = local_getline(zPrior, in);
648   \}\textcolor{keywordflow}{else}\{
649     zPrompt = isContinuation ? continuePrompt : mainPrompt;
650 \textcolor{preprocessor}{#if SHELL\_USE\_LOCAL\_GETLINE}
651     printf(\textcolor{stringliteral}{"%s"}, zPrompt);
652     fflush(stdout);
653     zResult = local_getline(zPrior, stdin);
654 \textcolor{preprocessor}{#else}
655     free(zPrior);
656     zResult = shell\_readline(zPrompt);
657     \textcolor{keywordflow}{if}( zResult && *zResult ) shell\_add\_history(zResult);
658 \textcolor{preprocessor}{#endif}
659   \}
660   \textcolor{keywordflow}{return} zResult;
661 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a4fa9fee46326d8f4abe7c9ea12b0d614}} 
\index{shell.\+c@{shell.\+c}!open\+\_\+db@{open\+\_\+db}}
\index{open\+\_\+db@{open\+\_\+db}!shell.\+c@{shell.\+c}}
\subsubsection{open\+\_\+db()}
{\footnotesize\ttfamily static void open\+\_\+db (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{int}]{open\+Flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12687 of file shell.\+c.



References Shell\+State\+::db, deduce\+Database\+Type(), edit\+Func(), O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+K\+E\+E\+P\+A\+L\+I\+VE, O\+P\+E\+N\+\_\+\+D\+B\+\_\+\+Z\+I\+P\+F\+I\+LE, Shell\+State\+::open\+Flags, Shell\+State\+::open\+Mode, read\+File(), S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+ZE, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+H\+E\+X\+DB, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+N\+O\+R\+M\+AL, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+U\+N\+S\+P\+EC, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE, shell\+Add\+Schema\+Name(), shell\+Escape\+Crnl(), shell\+Id\+Quote(), shell\+Int32(), shell\+Module\+Schema(), shell\+Puts\+Func(), sqlite3\+\_\+completion\+\_\+init(), sqlite3\+\_\+create\+\_\+function, sqlite3\+\_\+deserialize(), sqlite3\+\_\+enable\+\_\+load\+\_\+extension(), sqlite3\+\_\+errcode, sqlite3\+\_\+errmsg, sqlite3\+\_\+exec, sqlite3\+\_\+file\+\_\+control, sqlite3\+\_\+fileio\+\_\+init(), sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+open, sqlite3\+\_\+open\+\_\+v2, sqlite3\+\_\+shathree\+\_\+init(), S\+Q\+L\+I\+T\+E\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+F\+R\+E\+E\+O\+N\+C\+L\+O\+SE, S\+Q\+L\+I\+T\+E\+\_\+\+D\+E\+S\+E\+R\+I\+A\+L\+I\+Z\+E\+\_\+\+R\+E\+S\+I\+Z\+E\+A\+B\+LE, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+S\+I\+Z\+E\+\_\+\+L\+I\+M\+IT, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+C\+R\+E\+A\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+W\+R\+I\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+U\+T\+F8, Shell\+State\+::sz\+Max, utf8\+\_\+printf, and Shell\+State\+::z\+Db\+Filename.



Referenced by do\+\_\+meta\+\_\+command(), main(), run\+One\+Sql\+Line(), and shell\+\_\+dbinfo\+\_\+command().


\begin{DoxyCode}
12687                                                  \{
12688   \textcolor{keywordflow}{if}( p->db==0 )\{
12689     \textcolor{keywordflow}{if}( p->openMode==SHELL_OPEN_UNSPEC )\{
12690       \textcolor{keywordflow}{if}( p->zDbFilename==0 || p->zDbFilename[0]==0 )\{
12691         p->openMode = SHELL_OPEN_NORMAL;
12692       \}\textcolor{keywordflow}{else}\{
12693         p->openMode = (u8)deduceDatabaseType(p->zDbFilename, 
12694                              (openFlags & OPEN_DB_ZIPFILE)!=0);
12695       \}
12696     \}
12697     \textcolor{keywordflow}{switch}( p->openMode )\{
12698       \textcolor{keywordflow}{case} SHELL_OPEN_APPENDVFS: \{
12699         sqlite3_open_v2(p->zDbFilename, &p->db, 
12700            SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|p->openFlags, \textcolor{stringliteral}{"apndvfs"});
12701         \textcolor{keywordflow}{break};
12702       \}
12703       \textcolor{keywordflow}{case} SHELL_OPEN_HEXDB:
12704       \textcolor{keywordflow}{case} SHELL_OPEN_DESERIALIZE: \{
12705         sqlite3_open(0, &p->db);
12706         \textcolor{keywordflow}{break};
12707       \}
12708       \textcolor{keywordflow}{case} SHELL_OPEN_ZIPFILE: \{
12709         sqlite3_open(\textcolor{stringliteral}{":memory:"}, &p->db);
12710         \textcolor{keywordflow}{break};
12711       \}
12712       \textcolor{keywordflow}{case} SHELL_OPEN_READONLY: \{
12713         sqlite3_open_v2(p->zDbFilename, &p->db,
12714             SQLITE_OPEN_READONLY|p->openFlags, 0);
12715         \textcolor{keywordflow}{break};
12716       \}
12717       \textcolor{keywordflow}{case} SHELL_OPEN_UNSPEC:
12718       \textcolor{keywordflow}{case} SHELL_OPEN_NORMAL: \{
12719         sqlite3_open_v2(p->zDbFilename, &p->db,
12720            SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|p->openFlags, 0);
12721         \textcolor{keywordflow}{break};
12722       \}
12723     \}
12724     globalDb = p->db;
12725     \textcolor{keywordflow}{if}( p->db==0 || SQLITE_OK!=sqlite3_errcode(p->db) )\{
12726       utf8_printf(stderr,\textcolor{stringliteral}{"Error: unable to open database \(\backslash\)"%s\(\backslash\)": %s\(\backslash\)n"},
12727           p->zDbFilename, sqlite3_errmsg(p->db));
12728       \textcolor{keywordflow}{if}( openFlags & OPEN_DB_KEEPALIVE )\{
12729         sqlite3_open(\textcolor{stringliteral}{":memory:"}, &p->db);
12730         \textcolor{keywordflow}{return};
12731       \}
12732       exit(1);
12733     \}
12734 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_LOAD\_EXTENSION}
12735     sqlite3_enable_load_extension(p->db, 1);
12736 \textcolor{preprocessor}{#endif}
12737     sqlite3_fileio_init(p->db, 0, 0);
12738     sqlite3_shathree_init(p->db, 0, 0);
12739     sqlite3_completion_init(p->db, 0, 0);
12740 \textcolor{preprocessor}{#if !defined(SQLITE\_OMIT\_VIRTUALTABLE) && defined(SQLITE\_ENABLE\_DBPAGE\_VTAB)}
12741     sqlite3\_dbdata\_init(p->db, 0, 0);
12742 \textcolor{preprocessor}{#endif}
12743 \textcolor{preprocessor}{#ifdef SQLITE\_HAVE\_ZLIB}
12744     sqlite3\_zipfile\_init(p->db, 0, 0);
12745     sqlite3\_sqlar\_init(p->db, 0, 0);
12746 \textcolor{preprocessor}{#endif}
12747     sqlite3_create_function(p->db, \textcolor{stringliteral}{"shell\_add\_schema"}, 3, SQLITE_UTF8, 0,
12748                             shellAddSchemaName, 0, 0);
12749     sqlite3_create_function(p->db, \textcolor{stringliteral}{"shell\_module\_schema"}, 1, SQLITE_UTF8, 0,
12750                             shellModuleSchema, 0, 0);
12751     sqlite3_create_function(p->db, \textcolor{stringliteral}{"shell\_putsnl"}, 1, SQLITE_UTF8, p,
12752                             shellPutsFunc, 0, 0);
12753     sqlite3_create_function(p->db, \textcolor{stringliteral}{"shell\_escape\_crnl"}, 1, SQLITE_UTF8, 0,
12754                             shellEscapeCrnl, 0, 0);
12755     sqlite3_create_function(p->db, \textcolor{stringliteral}{"shell\_int32"}, 2, SQLITE_UTF8, 0,
12756                             shellInt32, 0, 0);
12757     sqlite3_create_function(p->db, \textcolor{stringliteral}{"shell\_idquote"}, 1, SQLITE_UTF8, 0,
12758                             shellIdQuote, 0, 0);
12759 \textcolor{preprocessor}{#ifndef SQLITE\_NOHAVE\_SYSTEM}
12760     sqlite3_create_function(p->db, \textcolor{stringliteral}{"edit"}, 1, SQLITE_UTF8, 0,
12761                             editFunc, 0, 0);
12762     sqlite3_create_function(p->db, \textcolor{stringliteral}{"edit"}, 2, SQLITE_UTF8, 0,
12763                             editFunc, 0, 0);
12764 \textcolor{preprocessor}{#endif}
12765     \textcolor{keywordflow}{if}( p->openMode==SHELL_OPEN_ZIPFILE )\{
12766       \textcolor{keywordtype}{char} *zSql = sqlite3_mprintf(
12767          \textcolor{stringliteral}{"CREATE VIRTUAL TABLE zip USING zipfile(%Q);"}, p->zDbFilename);
12768       sqlite3_exec(p->db, zSql, 0, 0, 0);
12769       sqlite3_free(zSql);
12770     \}
12771 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_DESERIALIZE}
12772     \textcolor{keywordflow}{else}
12773     \textcolor{keywordflow}{if}( p->openMode==SHELL_OPEN_DESERIALIZE || p->openMode==SHELL_OPEN_HEXDB )\{
12774       \textcolor{keywordtype}{int} rc;
12775       \textcolor{keywordtype}{int} nData = 0;
12776       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *aData;
12777       \textcolor{keywordflow}{if}( p->openMode==SHELL_OPEN_DESERIALIZE )\{
12778         aData = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)readFile(p->zDbFilename, &nData);
12779       \}\textcolor{keywordflow}{else}\{
12780         aData = readHexDb(p, &nData);
12781         \textcolor{keywordflow}{if}( aData==0 )\{
12782           \textcolor{keywordflow}{return};
12783         \}
12784       \}
12785       rc = sqlite3_deserialize(p->db, \textcolor{stringliteral}{"main"}, aData, nData, nData,
12786                    SQLITE_DESERIALIZE_RESIZEABLE |
12787                    SQLITE_DESERIALIZE_FREEONCLOSE);
12788       \textcolor{keywordflow}{if}( rc )\{
12789         utf8_printf(stderr, \textcolor{stringliteral}{"Error: sqlite3\_deserialize() returns %d\(\backslash\)n"}, rc);
12790       \}
12791       \textcolor{keywordflow}{if}( p->szMax>0 )\{
12792         sqlite3_file_control(p->db, \textcolor{stringliteral}{"main"}, SQLITE_FCNTL_SIZE_LIMIT, &p->szMax);
12793       \}
12794     \}
12795 \textcolor{preprocessor}{#endif}
12796   \}
12797 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a327e6349e2f8f454ebf3e87bdc09cf91}} 
\index{shell.\+c@{shell.\+c}!option\+Match@{option\+Match}}
\index{option\+Match@{option\+Match}!shell.\+c@{shell.\+c}}
\subsubsection{option\+Match()}
{\footnotesize\ttfamily static int option\+Match (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Str,  }\item[{const char $\ast$}]{z\+Opt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13706 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13706                                                           \{
13707   \textcolor{keywordflow}{if}( zStr[0]!=\textcolor{charliteral}{'-'} ) \textcolor{keywordflow}{return} 0;
13708   zStr++;
13709   \textcolor{keywordflow}{if}( zStr[0]==\textcolor{charliteral}{'-'} ) zStr++;
13710   \textcolor{keywordflow}{return} strcmp(zStr, zOpt)==0;
13711 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a0066403d43d9c458e2875f1c49eecafe}} 
\index{shell.\+c@{shell.\+c}!output\+\_\+c\+\_\+string@{output\+\_\+c\+\_\+string}}
\index{output\+\_\+c\+\_\+string@{output\+\_\+c\+\_\+string}!shell.\+c@{shell.\+c}}
\subsubsection{output\+\_\+c\+\_\+string()}
{\footnotesize\ttfamily static void output\+\_\+c\+\_\+string (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{out,  }\item[{const char $\ast$}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10051 of file shell.\+c.



References raw\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command(), shell\+\_\+callback(), and shell\+Auth().


\begin{DoxyCode}
10051                                                      \{
10052   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} c;
10053   fputc(\textcolor{charliteral}{'"'}, out);
10054   \textcolor{keywordflow}{while}( (c = *(z++))!=0 )\{
10055     \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} )\{
10056       fputc(c, out);
10057       fputc(c, out);
10058     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'"'} )\{
10059       fputc(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}, out);
10060       fputc(\textcolor{charliteral}{'"'}, out);
10061     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)t'} )\{
10062       fputc(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}, out);
10063       fputc(\textcolor{charliteral}{'t'}, out);
10064     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)n'} )\{
10065       fputc(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}, out);
10066       fputc(\textcolor{charliteral}{'n'}, out);
10067     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)r'} )\{
10068       fputc(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}, out);
10069       fputc(\textcolor{charliteral}{'r'}, out);
10070     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( !isprint(c&0xff) )\{
10071       raw_printf(out, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)%03o"}, c&0xff);
10072     \}\textcolor{keywordflow}{else}\{
10073       fputc(c, out);
10074     \}
10075   \}
10076   fputc(\textcolor{charliteral}{'"'}, out);
10077 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a4db413f63a5632af9c92b150cf4b5c4a}} 
\index{shell.\+c@{shell.\+c}!output\+\_\+csv@{output\+\_\+csv}}
\index{output\+\_\+csv@{output\+\_\+csv}!shell.\+c@{shell.\+c}}
\subsubsection{output\+\_\+csv()}
{\footnotesize\ttfamily static void output\+\_\+csv (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{const char $\ast$}]{z,  }\item[{int}]{b\+Sep }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10143 of file shell.\+c.



References Shell\+State\+::col\+Separator, Shell\+State\+::null\+Value, Shell\+State\+::out, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, strlen30(), and utf8\+\_\+printf.



Referenced by shell\+\_\+callback().


\begin{DoxyCode}
10143                                                               \{
10144   FILE *out = p->out;
10145   \textcolor{keywordflow}{if}( z==0 )\{
10146     utf8_printf(out,\textcolor{stringliteral}{"%s"},p->nullValue);
10147   \}\textcolor{keywordflow}{else}\{
10148     \textcolor{keywordtype}{int} i;
10149     \textcolor{keywordtype}{int} nSep = strlen30(p->colSeparator);
10150     \textcolor{keywordflow}{for}(i=0; z[i]; i++)\{
10151       \textcolor{keywordflow}{if}( needCsvQuote[((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)z)[i]]
10152          || (z[i]==p->colSeparator[0] &&
10153              (nSep==1 || memcmp(z, p->colSeparator, nSep)==0)) )\{
10154         i = 0;
10155         \textcolor{keywordflow}{break};
10156       \}
10157     \}
10158     \textcolor{keywordflow}{if}( i==0 )\{
10159       \textcolor{keywordtype}{char} *zQuoted = sqlite3_mprintf(\textcolor{stringliteral}{"\(\backslash\)"%w\(\backslash\)""}, z);
10160       utf8_printf(out, \textcolor{stringliteral}{"%s"}, zQuoted);
10161       sqlite3_free(zQuoted);
10162     \}\textcolor{keywordflow}{else}\{
10163       utf8_printf(out, \textcolor{stringliteral}{"%s"}, z);
10164     \}
10165   \}
10166   \textcolor{keywordflow}{if}( bSep )\{
10167     utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->colSeparator);
10168   \}
10169 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a98b86e91ed3a90f2e133bb4f1ca1dc48}} 
\index{shell.\+c@{shell.\+c}!output\+\_\+file\+\_\+close@{output\+\_\+file\+\_\+close}}
\index{output\+\_\+file\+\_\+close@{output\+\_\+file\+\_\+close}!shell.\+c@{shell.\+c}}
\subsubsection{output\+\_\+file\+\_\+close()}
{\footnotesize\ttfamily static void output\+\_\+file\+\_\+close (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12971 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and output\+\_\+reset().


\begin{DoxyCode}
12971                                       \{
12972   \textcolor{keywordflow}{if}( f && f!=stdout && f!=stderr ) fclose(f);
12973 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae2bf10a6227c0adcb75f2ef8c5cd7adb}} 
\index{shell.\+c@{shell.\+c}!output\+\_\+file\+\_\+open@{output\+\_\+file\+\_\+open}}
\index{output\+\_\+file\+\_\+open@{output\+\_\+file\+\_\+open}!shell.\+c@{shell.\+c}}
\subsubsection{output\+\_\+file\+\_\+open()}
{\footnotesize\ttfamily static F\+I\+LE$\ast$ output\+\_\+file\+\_\+open (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+File,  }\item[{int}]{b\+Text\+Mode }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12980 of file shell.\+c.



References utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
12980                                                                \{
12981   FILE *f;
12982   \textcolor{keywordflow}{if}( strcmp(zFile,\textcolor{stringliteral}{"stdout"})==0 )\{
12983     f = stdout;
12984   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(zFile, \textcolor{stringliteral}{"stderr"})==0 )\{
12985     f = stderr;
12986   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(zFile, \textcolor{stringliteral}{"off"})==0 )\{
12987     f = 0;
12988   \}\textcolor{keywordflow}{else}\{
12989     f = fopen(zFile, bTextMode ? \textcolor{stringliteral}{"w"} : \textcolor{stringliteral}{"wb"});
12990     \textcolor{keywordflow}{if}( f==0 )\{
12991       utf8_printf(stderr, \textcolor{stringliteral}{"Error: cannot open \(\backslash\)"%s\(\backslash\)"\(\backslash\)n"}, zFile);
12992     \}
12993   \}
12994   \textcolor{keywordflow}{return} f;
12995 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a7a515ef4910c67b925e05eaf715055bf}} 
\index{shell.\+c@{shell.\+c}!output\+\_\+hex\+\_\+blob@{output\+\_\+hex\+\_\+blob}}
\index{output\+\_\+hex\+\_\+blob@{output\+\_\+hex\+\_\+blob}!shell.\+c@{shell.\+c}}
\subsubsection{output\+\_\+hex\+\_\+blob()}
{\footnotesize\ttfamily static void output\+\_\+hex\+\_\+blob (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{out,  }\item[{const void $\ast$}]{p\+Blob,  }\item[{int}]{n\+Blob }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 9917 of file shell.\+c.



References raw\+\_\+printf.



Referenced by shell\+\_\+callback().


\begin{DoxyCode}
9917                                                                     \{
9918   \textcolor{keywordtype}{int} i;
9919   \textcolor{keywordtype}{char} *zBlob = (\textcolor{keywordtype}{char} *)pBlob;
9920   raw_printf(out,\textcolor{stringliteral}{"X'"});
9921   \textcolor{keywordflow}{for}(i=0; i<nBlob; i++)\{ raw_printf(out,\textcolor{stringliteral}{"%02x"},zBlob[i]&0xff); \}
9922   raw_printf(out,\textcolor{stringliteral}{"'"});
9923 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a80e241f59dd2151638cf12a0e02cfad3}} 
\index{shell.\+c@{shell.\+c}!output\+\_\+html\+\_\+string@{output\+\_\+html\+\_\+string}}
\index{output\+\_\+html\+\_\+string@{output\+\_\+html\+\_\+string}!shell.\+c@{shell.\+c}}
\subsubsection{output\+\_\+html\+\_\+string()}
{\footnotesize\ttfamily static void output\+\_\+html\+\_\+string (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{out,  }\item[{const char $\ast$}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10083 of file shell.\+c.



References raw\+\_\+printf, and utf8\+\_\+printf.



Referenced by shell\+\_\+callback().


\begin{DoxyCode}
10083                                                         \{
10084   \textcolor{keywordtype}{int} i;
10085   \textcolor{keywordflow}{if}( z==0 ) z = \textcolor{stringliteral}{""};
10086   \textcolor{keywordflow}{while}( *z )\{
10087     \textcolor{keywordflow}{for}(i=0;   z[i]
10088             && z[i]!=\textcolor{charliteral}{'<'}
10089             && z[i]!=\textcolor{charliteral}{'&'}
10090             && z[i]!=\textcolor{charliteral}{'>'}
10091             && z[i]!=\textcolor{charliteral}{'\(\backslash\)"'}
10092             && z[i]!=\textcolor{charliteral}{'\(\backslash\)''};
10093         i++)\{\}
10094     \textcolor{keywordflow}{if}( i>0 )\{
10095       utf8_printf(out,\textcolor{stringliteral}{"%.*s"},i,z);
10096     \}
10097     \textcolor{keywordflow}{if}( z[i]==\textcolor{charliteral}{'<'} )\{
10098       raw_printf(out,\textcolor{stringliteral}{"&lt;"});
10099     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( z[i]==\textcolor{charliteral}{'&'} )\{
10100       raw_printf(out,\textcolor{stringliteral}{"&amp;"});
10101     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( z[i]==\textcolor{charliteral}{'>'} )\{
10102       raw_printf(out,\textcolor{stringliteral}{"&gt;"});
10103     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( z[i]==\textcolor{charliteral}{'\(\backslash\)"'} )\{
10104       raw_printf(out,\textcolor{stringliteral}{"&quot;"});
10105     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( z[i]==\textcolor{charliteral}{'\(\backslash\)''} )\{
10106       raw_printf(out,\textcolor{stringliteral}{"&#39;"});
10107     \}\textcolor{keywordflow}{else}\{
10108       \textcolor{keywordflow}{break};
10109     \}
10110     z += i + 1;
10111   \}
10112 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a67850984b8c824154c650456effe6660}} 
\index{shell.\+c@{shell.\+c}!output\+\_\+quoted\+\_\+escaped\+\_\+string@{output\+\_\+quoted\+\_\+escaped\+\_\+string}}
\index{output\+\_\+quoted\+\_\+escaped\+\_\+string@{output\+\_\+quoted\+\_\+escaped\+\_\+string}!shell.\+c@{shell.\+c}}
\subsubsection{output\+\_\+quoted\+\_\+escaped\+\_\+string()}
{\footnotesize\ttfamily static void output\+\_\+quoted\+\_\+escaped\+\_\+string (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{out,  }\item[{const char $\ast$}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 9990 of file shell.\+c.



References raw\+\_\+printf, set\+Binary\+Mode, set\+Text\+Mode, unused\+\_\+string(), and utf8\+\_\+printf.



Referenced by shell\+\_\+callback().


\begin{DoxyCode}
9990                                                                   \{
9991   \textcolor{keywordtype}{int} i;
9992   \textcolor{keywordtype}{char} c;
9993   setBinaryMode(out, 1);
9994   \textcolor{keywordflow}{for}(i=0; (c = z[i])!=0 && c!=\textcolor{charliteral}{'\(\backslash\)''} && c!=\textcolor{charliteral}{'\(\backslash\)n'} && c!=\textcolor{charliteral}{'\(\backslash\)r'}; i++)\{\}
9995   \textcolor{keywordflow}{if}( c==0 )\{
9996     utf8_printf(out,\textcolor{stringliteral}{"'%s'"},z);
9997   \}\textcolor{keywordflow}{else}\{
9998     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zNL = 0;
9999     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCR = 0;
10000     \textcolor{keywordtype}{int} nNL = 0;
10001     \textcolor{keywordtype}{int} nCR = 0;
10002     \textcolor{keywordtype}{char} zBuf1[20], zBuf2[20];
10003     \textcolor{keywordflow}{for}(i=0; z[i]; i++)\{
10004       \textcolor{keywordflow}{if}( z[i]==\textcolor{charliteral}{'\(\backslash\)n'} ) nNL++;
10005       \textcolor{keywordflow}{if}( z[i]==\textcolor{charliteral}{'\(\backslash\)r'} ) nCR++;
10006     \}
10007     \textcolor{keywordflow}{if}( nNL )\{
10008       raw_printf(out, \textcolor{stringliteral}{"replace("});
10009       zNL = unused_string(z, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)n"}, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)012"}, zBuf1);
10010     \}
10011     \textcolor{keywordflow}{if}( nCR )\{
10012       raw_printf(out, \textcolor{stringliteral}{"replace("});
10013       zCR = unused_string(z, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)r"}, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)015"}, zBuf2);
10014     \}
10015     raw_printf(out, \textcolor{stringliteral}{"'"});
10016     \textcolor{keywordflow}{while}( *z )\{
10017       \textcolor{keywordflow}{for}(i=0; (c = z[i])!=0 && c!=\textcolor{charliteral}{'\(\backslash\)n'} && c!=\textcolor{charliteral}{'\(\backslash\)r'} && c!=\textcolor{charliteral}{'\(\backslash\)''}; i++)\{\}
10018       \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)''} ) i++;
10019       \textcolor{keywordflow}{if}( i )\{
10020         utf8_printf(out, \textcolor{stringliteral}{"%.*s"}, i, z);
10021         z += i;
10022       \}
10023       \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)''} )\{
10024         raw_printf(out, \textcolor{stringliteral}{"'"});
10025         \textcolor{keywordflow}{continue};
10026       \}
10027       \textcolor{keywordflow}{if}( c==0 )\{
10028         \textcolor{keywordflow}{break};
10029       \}
10030       z++;
10031       \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)n'} )\{
10032         raw_printf(out, \textcolor{stringliteral}{"%s"}, zNL);
10033         \textcolor{keywordflow}{continue};
10034       \}
10035       raw_printf(out, \textcolor{stringliteral}{"%s"}, zCR);
10036     \}
10037     raw_printf(out, \textcolor{stringliteral}{"'"});
10038     \textcolor{keywordflow}{if}( nCR )\{
10039       raw_printf(out, \textcolor{stringliteral}{",'%s',char(13))"}, zCR);
10040     \}
10041     \textcolor{keywordflow}{if}( nNL )\{
10042       raw_printf(out, \textcolor{stringliteral}{",'%s',char(10))"}, zNL);
10043     \}
10044   \}
10045   setTextMode(out, 1);
10046 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a6efc1022affd9c40de83685309745420}} 
\index{shell.\+c@{shell.\+c}!output\+\_\+quoted\+\_\+string@{output\+\_\+quoted\+\_\+string}}
\index{output\+\_\+quoted\+\_\+string@{output\+\_\+quoted\+\_\+string}!shell.\+c@{shell.\+c}}
\subsubsection{output\+\_\+quoted\+\_\+string()}
{\footnotesize\ttfamily static void output\+\_\+quoted\+\_\+string (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{out,  }\item[{const char $\ast$}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 9951 of file shell.\+c.



References raw\+\_\+printf, set\+Binary\+Mode, set\+Text\+Mode, and utf8\+\_\+printf.



Referenced by shell\+\_\+callback().


\begin{DoxyCode}
9951                                                           \{
9952   \textcolor{keywordtype}{int} i;
9953   \textcolor{keywordtype}{char} c;
9954   setBinaryMode(out, 1);
9955   \textcolor{keywordflow}{for}(i=0; (c = z[i])!=0 && c!=\textcolor{charliteral}{'\(\backslash\)''}; i++)\{\}
9956   \textcolor{keywordflow}{if}( c==0 )\{
9957     utf8_printf(out,\textcolor{stringliteral}{"'%s'"},z);
9958   \}\textcolor{keywordflow}{else}\{
9959     raw_printf(out, \textcolor{stringliteral}{"'"});
9960     \textcolor{keywordflow}{while}( *z )\{
9961       \textcolor{keywordflow}{for}(i=0; (c = z[i])!=0 && c!=\textcolor{charliteral}{'\(\backslash\)''}; i++)\{\}
9962       \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)''} ) i++;
9963       \textcolor{keywordflow}{if}( i )\{
9964         utf8_printf(out, \textcolor{stringliteral}{"%.*s"}, i, z);
9965         z += i;
9966       \}
9967       \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)''} )\{
9968         raw_printf(out, \textcolor{stringliteral}{"'"});
9969         \textcolor{keywordflow}{continue};
9970       \}
9971       \textcolor{keywordflow}{if}( c==0 )\{
9972         \textcolor{keywordflow}{break};
9973       \}
9974       z++;
9975     \}
9976     raw_printf(out, \textcolor{stringliteral}{"'"});
9977   \}
9978   setTextMode(out, 1);
9979 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae30c22d2f1a44510b7f92acdf6af3787}} 
\index{shell.\+c@{shell.\+c}!output\+\_\+reset@{output\+\_\+reset}}
\index{output\+\_\+reset@{output\+\_\+reset}!shell.\+c@{shell.\+c}}
\subsubsection{output\+\_\+reset()}
{\footnotesize\ttfamily static void output\+\_\+reset (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13436 of file shell.\+c.



References Shell\+State\+::do\+Xdg\+Open, Shell\+State\+::out, Shell\+State\+::outfile, output\+\_\+file\+\_\+close(), output\+Mode\+Pop(), pclose(), sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+sleep, utf8\+\_\+printf, and Shell\+State\+::z\+Temp\+File.



Referenced by do\+\_\+meta\+\_\+command(), main(), and process\+\_\+input().


\begin{DoxyCode}
13436                                        \{
13437   \textcolor{keywordflow}{if}( p->outfile[0]==\textcolor{charliteral}{'|'} )\{
13438 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_POPEN}
13439     pclose(p->out);
13440 \textcolor{preprocessor}{#endif}
13441   \}\textcolor{keywordflow}{else}\{
13442     output_file_close(p->out);
13443 \textcolor{preprocessor}{#ifndef SQLITE\_NOHAVE\_SYSTEM}
13444     \textcolor{keywordflow}{if}( p->doXdgOpen )\{
13445       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zXdgOpenCmd =
13446 \textcolor{preprocessor}{#if defined(\_WIN32)}
13447       \textcolor{stringliteral}{"start"};
13448 \textcolor{preprocessor}{#elif defined(\_\_APPLE\_\_)}
13449       \textcolor{stringliteral}{"open"};
13450 \textcolor{preprocessor}{#else}
13451       \textcolor{stringliteral}{"xdg-open"};
13452 \textcolor{preprocessor}{#endif}
13453       \textcolor{keywordtype}{char} *zCmd;
13454       zCmd = sqlite3_mprintf(\textcolor{stringliteral}{"%s %s"}, zXdgOpenCmd, p->zTempFile);
13455       \textcolor{keywordflow}{if}( system(zCmd) )\{
13456         utf8_printf(stderr, \textcolor{stringliteral}{"Failed: [%s]\(\backslash\)n"}, zCmd);
13457       \}
13458       sqlite3_free(zCmd);
13459       outputModePop(p);
13460       p->doXdgOpen = 0;
13461       sqlite3_sleep(100);
13462     \}
13463 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* !defined(SQLITE\_NOHAVE\_SYSTEM) */}\textcolor{preprocessor}{}
13464   \}
13465   p->outfile[0] = 0;
13466   p->out = stdout;
13467 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aa1b087821d84ec63c54502352c823570}} 
\index{shell.\+c@{shell.\+c}!output\+Mode\+Pop@{output\+Mode\+Pop}}
\index{output\+Mode\+Pop@{output\+Mode\+Pop}!shell.\+c@{shell.\+c}}
\subsubsection{output\+Mode\+Pop()}
{\footnotesize\ttfamily static void output\+Mode\+Pop (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 9908 of file shell.\+c.



References Shell\+State\+::col\+Separator, Shell\+State\+::col\+Sep\+Prior, Shell\+State\+::mode, Shell\+State\+::mode\+Prior, Shell\+State\+::row\+Separator, and Shell\+State\+::row\+Sep\+Prior.



Referenced by output\+\_\+reset().


\begin{DoxyCode}
9908                                         \{
9909   p->mode = p->modePrior;
9910   memcpy(p->colSeparator, p->colSepPrior, \textcolor{keyword}{sizeof}(p->colSeparator));
9911   memcpy(p->rowSeparator, p->rowSepPrior, \textcolor{keyword}{sizeof}(p->rowSeparator));
9912 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aa71ffff46e3f3f92ac09ca805f6b374d}} 
\index{shell.\+c@{shell.\+c}!output\+Mode\+Push@{output\+Mode\+Push}}
\index{output\+Mode\+Push@{output\+Mode\+Push}!shell.\+c@{shell.\+c}}
\subsubsection{output\+Mode\+Push()}
{\footnotesize\ttfamily static void output\+Mode\+Push (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 9903 of file shell.\+c.



References Shell\+State\+::col\+Separator, Shell\+State\+::col\+Sep\+Prior, Shell\+State\+::mode, Shell\+State\+::mode\+Prior, Shell\+State\+::row\+Separator, and Shell\+State\+::row\+Sep\+Prior.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
9903                                          \{
9904   p->modePrior = p->mode;
9905   memcpy(p->colSepPrior, p->colSeparator, \textcolor{keyword}{sizeof}(p->colSeparator));
9906   memcpy(p->rowSepPrior, p->rowSeparator, \textcolor{keyword}{sizeof}(p->rowSeparator));
9907 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a92e41b535f1505676ed8cbe5896606d5}} 
\index{shell.\+c@{shell.\+c}!pclose@{pclose}}
\index{pclose@{pclose}!shell.\+c@{shell.\+c}}
\subsubsection{pclose()}
{\footnotesize\ttfamily int pclose (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{ }\end{DoxyParamCaption})}



Referenced by do\+\_\+meta\+\_\+command(), and output\+\_\+reset().

\mbox{\label{shell_8c_a31dd4384020447c7d99d0e4aace6f17a}} 
\index{shell.\+c@{shell.\+c}!popen@{popen}}
\index{popen@{popen}!shell.\+c@{shell.\+c}}
\subsubsection{popen()}
{\footnotesize\ttfamily F\+I\+LE$\ast$ popen (\begin{DoxyParamCaption}\item[{const char $\ast$}]{,  }\item[{const char $\ast$}]{ }\end{DoxyParamCaption})}



Referenced by do\+\_\+meta\+\_\+command().

\mbox{\label{shell_8c_a1bc8b58e0c5660484be3051960f0679f}} 
\index{shell.\+c@{shell.\+c}!print\+Bold@{print\+Bold}}
\index{print\+Bold@{print\+Bold}!shell.\+c@{shell.\+c}}
\subsubsection{print\+Bold()}
{\footnotesize\ttfamily static void print\+Bold (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Text }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18638 of file shell.\+c.



Referenced by main(), and main\+\_\+init().


\begin{DoxyCode}
18638                                         \{
18639   printf(\textcolor{stringliteral}{"\(\backslash\)033[1m%s\(\backslash\)033[0m"}, zText);
18640 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a96d6c10c1340958833b19667f4996c39}} 
\index{shell.\+c@{shell.\+c}!print\+Schema\+Line@{print\+Schema\+Line}}
\index{print\+Schema\+Line@{print\+Schema\+Line}!shell.\+c@{shell.\+c}}
\subsubsection{print\+Schema\+Line()}
{\footnotesize\ttfamily static void print\+Schema\+Line (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{out,  }\item[{const char $\ast$}]{z,  }\item[{const char $\ast$}]{z\+Tail }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10249 of file shell.\+c.



References sqlite3\+\_\+strglob, and utf8\+\_\+printf.



Referenced by dump\+\_\+callback(), print\+Schema\+Line\+N(), and shell\+\_\+callback().


\begin{DoxyCode}
10249                                                                         \{
10250   \textcolor{keywordflow}{if}( z==0 ) \textcolor{keywordflow}{return};
10251   \textcolor{keywordflow}{if}( zTail==0 ) \textcolor{keywordflow}{return};
10252   \textcolor{keywordflow}{if}( sqlite3_strglob(\textcolor{stringliteral}{"CREATE TABLE ['\(\backslash\)"]*"}, z)==0 )\{
10253     utf8_printf(out, \textcolor{stringliteral}{"CREATE TABLE IF NOT EXISTS %s%s"}, z+13, zTail);
10254   \}\textcolor{keywordflow}{else}\{
10255     utf8_printf(out, \textcolor{stringliteral}{"%s%s"}, z, zTail);
10256   \}
10257 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad7face87c9137eab1187a3cde07e46ce}} 
\index{shell.\+c@{shell.\+c}!print\+Schema\+LineN@{print\+Schema\+LineN}}
\index{print\+Schema\+LineN@{print\+Schema\+LineN}!shell.\+c@{shell.\+c}}
\subsubsection{print\+Schema\+Line\+N()}
{\footnotesize\ttfamily static void print\+Schema\+LineN (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{out,  }\item[{char $\ast$}]{z,  }\item[{int}]{n,  }\item[{const char $\ast$}]{z\+Tail }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10258 of file shell.\+c.



References print\+Schema\+Line().



Referenced by shell\+\_\+callback().


\begin{DoxyCode}
10258                                                                           \{
10259   \textcolor{keywordtype}{char} c = z[n];
10260   z[n] = 0;
10261   printSchemaLine(out, z, zTail);
10262   z[n] = c;
10263 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a1e60e524f9468a30a99cfd5af95b68d8}} 
\index{shell.\+c@{shell.\+c}!process\+\_\+input@{process\+\_\+input}}
\index{process\+\_\+input@{process\+\_\+input}!shell.\+c@{shell.\+c}}
\subsubsection{process\+\_\+input()}
{\footnotesize\ttfamily static int process\+\_\+input (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18329 of file shell.\+c.



References \+\_\+all\+\_\+whitespace(), clear\+Temp\+File(), do\+\_\+meta\+\_\+command(), Shell\+State\+::in, Is\+Space, line\+\_\+contains\+\_\+semicolon(), line\+\_\+is\+\_\+command\+\_\+terminator(), line\+\_\+is\+\_\+complete(), Shell\+State\+::lineno, one\+\_\+input\+\_\+line(), Shell\+State\+::out, Shell\+State\+::out\+Count, output\+\_\+reset(), run\+One\+Sql\+Line(), shell\+\_\+out\+\_\+of\+\_\+memory(), Shell\+Has\+Flag, S\+H\+F\+L\+G\+\_\+\+Echo, sqlite3\+\_\+complete, and strlen30().



Referenced by do\+\_\+meta\+\_\+command(), main(), process\+\_\+sqliterc(), and show\+Help().


\begin{DoxyCode}
18329                                        \{
18330   \textcolor{keywordtype}{char} *zLine = 0;          \textcolor{comment}{/* A single input line */}
18331   \textcolor{keywordtype}{char} *zSql = 0;           \textcolor{comment}{/* Accumulated SQL text */}
18332   \textcolor{keywordtype}{int} nLine;                \textcolor{comment}{/* Length of current line */}
18333   \textcolor{keywordtype}{int} nSql = 0;             \textcolor{comment}{/* Bytes of zSql[] used */}
18334   \textcolor{keywordtype}{int} nAlloc = 0;           \textcolor{comment}{/* Allocated zSql[] space */}
18335   \textcolor{keywordtype}{int} nSqlPrior = 0;        \textcolor{comment}{/* Bytes of zSql[] used by prior line */}
18336   \textcolor{keywordtype}{int} rc;                   \textcolor{comment}{/* Error code */}
18337   \textcolor{keywordtype}{int} errCnt = 0;           \textcolor{comment}{/* Number of errors seen */}
18338   \textcolor{keywordtype}{int} startline = 0;        \textcolor{comment}{/* Line number for start of current input */}
18339 
18340   p->lineno = 0;
18341   \textcolor{keywordflow}{while}( errCnt==0 || !bail_on_error || (p->in==0 && stdin_is_interactive) )\{
18342     fflush(p->out);
18343     zLine = one_input_line(p->in, zLine, nSql>0);
18344     \textcolor{keywordflow}{if}( zLine==0 )\{
18345       \textcolor{comment}{/* End of input */}
18346       \textcolor{keywordflow}{if}( p->in==0 && stdin_is_interactive ) printf(\textcolor{stringliteral}{"\(\backslash\)n"});
18347       \textcolor{keywordflow}{break};
18348     \}
18349     \textcolor{keywordflow}{if}( seenInterrupt )\{
18350       \textcolor{keywordflow}{if}( p->in!=0 ) \textcolor{keywordflow}{break};
18351       seenInterrupt = 0;
18352     \}
18353     p->lineno++;
18354     \textcolor{keywordflow}{if}( nSql==0 && _all_whitespace(zLine) )\{
18355       \textcolor{keywordflow}{if}( ShellHasFlag(p, SHFLG_Echo) ) printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, zLine);
18356       \textcolor{keywordflow}{continue};
18357     \}
18358     \textcolor{keywordflow}{if}( zLine && (zLine[0]==\textcolor{charliteral}{'.'} || zLine[0]==\textcolor{charliteral}{'#'}) && nSql==0 )\{
18359       \textcolor{keywordflow}{if}( ShellHasFlag(p, SHFLG_Echo) ) printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, zLine);
18360       \textcolor{keywordflow}{if}( zLine[0]==\textcolor{charliteral}{'.'} )\{
18361         rc = do_meta_command(zLine, p);
18362         \textcolor{keywordflow}{if}( rc==2 )\{ \textcolor{comment}{/* exit requested */}
18363           \textcolor{keywordflow}{break};
18364         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( rc )\{
18365           errCnt++;
18366         \}
18367       \}
18368       \textcolor{keywordflow}{continue};
18369     \}
18370     \textcolor{keywordflow}{if}( line_is_command_terminator(zLine) && line_is_complete(zSql, nSql) )\{
18371       memcpy(zLine,\textcolor{stringliteral}{";"},2);
18372     \}
18373     nLine = strlen30(zLine);
18374     \textcolor{keywordflow}{if}( nSql+nLine+2>=nAlloc )\{
18375       nAlloc = nSql+nLine+100;
18376       zSql = realloc(zSql, nAlloc);
18377       \textcolor{keywordflow}{if}( zSql==0 ) shell_out_of_memory();
18378     \}
18379     nSqlPrior = nSql;
18380     \textcolor{keywordflow}{if}( nSql==0 )\{
18381       \textcolor{keywordtype}{int} i;
18382       \textcolor{keywordflow}{for}(i=0; zLine[i] && IsSpace(zLine[i]); i++)\{\}
18383       assert( nAlloc>0 && zSql!=0 );
18384       memcpy(zSql, zLine+i, nLine+1-i);
18385       startline = p->lineno;
18386       nSql = nLine-i;
18387     \}\textcolor{keywordflow}{else}\{
18388       zSql[nSql++] = \textcolor{charliteral}{'\(\backslash\)n'};
18389       memcpy(zSql+nSql, zLine, nLine+1);
18390       nSql += nLine;
18391     \}
18392     \textcolor{keywordflow}{if}( nSql && line_contains_semicolon(&zSql[nSqlPrior], nSql-nSqlPrior)
18393                 && sqlite3_complete(zSql) )\{
18394       errCnt += runOneSqlLine(p, zSql, p->in, startline);
18395       nSql = 0;
18396       \textcolor{keywordflow}{if}( p->outCount )\{
18397         output_reset(p);
18398         p->outCount = 0;
18399       \}\textcolor{keywordflow}{else}\{
18400         clearTempFile(p);
18401       \}
18402     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( nSql && _all_whitespace(zSql) )\{
18403       \textcolor{keywordflow}{if}( ShellHasFlag(p, SHFLG_Echo) ) printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, zSql);
18404       nSql = 0;
18405     \}
18406   \}
18407   \textcolor{keywordflow}{if}( nSql && !_all_whitespace(zSql) )\{
18408     errCnt += runOneSqlLine(p, zSql, p->in, startline);
18409   \}
18410   free(zSql);
18411   free(zLine);
18412   \textcolor{keywordflow}{return} errCnt>0;
18413 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a121d06853a2e10f82487dd74adcb8525}} 
\index{shell.\+c@{shell.\+c}!process\+\_\+sqliterc@{process\+\_\+sqliterc}}
\index{process\+\_\+sqliterc@{process\+\_\+sqliterc}!shell.\+c@{shell.\+c}}
\subsubsection{process\+\_\+sqliterc()}
{\footnotesize\ttfamily static void process\+\_\+sqliterc (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{const char $\ast$}]{sqliterc\+\_\+override }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18490 of file shell.\+c.



References find\+\_\+home\+\_\+dir(), Shell\+State\+::in, Shell\+State\+::lineno, process\+\_\+input(), raw\+\_\+printf, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, and utf8\+\_\+printf.



Referenced by main().


\begin{DoxyCode}
18493  \{
18494   \textcolor{keywordtype}{char} *home\_dir = NULL;
18495   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *sqliterc = sqliterc\_override;
18496   \textcolor{keywordtype}{char} *zBuf = 0;
18497   FILE *inSaved = p->in;
18498   \textcolor{keywordtype}{int} savedLineno = p->lineno;
18499 
18500   \textcolor{keywordflow}{if} (sqliterc == NULL) \{
18501     home\_dir = find_home_dir(0);
18502     \textcolor{keywordflow}{if}( home\_dir==0 )\{
18503       raw_printf(stderr, \textcolor{stringliteral}{"-- warning: cannot find home directory;"}
18504                       \textcolor{stringliteral}{" cannot read ~/.sqliterc\(\backslash\)n"});
18505       \textcolor{keywordflow}{return};
18506     \}
18507     zBuf = sqlite3_mprintf(\textcolor{stringliteral}{"%s/.sqliterc"},home\_dir);
18508     sqliterc = zBuf;
18509   \}
18510   p->in = fopen(sqliterc,\textcolor{stringliteral}{"rb"});
18511   \textcolor{keywordflow}{if}( p->in )\{
18512     \textcolor{keywordflow}{if}( stdin_is_interactive )\{
18513       utf8_printf(stderr,\textcolor{stringliteral}{"-- Loading resources from %s\(\backslash\)n"},sqliterc);
18514     \}
18515     process_input(p);
18516     fclose(p->in);
18517   \}
18518   p->in = inSaved;
18519   p->lineno = savedLineno;
18520   sqlite3_free(zBuf);
18521 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a0826ed98ceaf96b01e82fe41631e4494}} 
\index{shell.\+c@{shell.\+c}!progress\+\_\+handler@{progress\+\_\+handler}}
\index{progress\+\_\+handler@{progress\+\_\+handler}!shell.\+c@{shell.\+c}}
\subsubsection{progress\+\_\+handler()}
{\footnotesize\ttfamily static int progress\+\_\+handler (\begin{DoxyParamCaption}\item[{void $\ast$}]{p\+Client\+Data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10372 of file shell.\+c.



References Shell\+State\+::flg\+Progress, Shell\+State\+::mx\+Progress, Shell\+State\+::n\+Progress, Shell\+State\+::out, raw\+\_\+printf, S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+O\+N\+CE, S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+Q\+U\+I\+ET, and S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+R\+E\+S\+ET.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
10372                                                \{
10373   ShellState *p = (ShellState*)pClientData;
10374   p->nProgress++;
10375   \textcolor{keywordflow}{if}( p->nProgress>=p->mxProgress && p->mxProgress>0 )\{
10376     raw_printf(p->out, \textcolor{stringliteral}{"Progress limit reached (%u)\(\backslash\)n"}, p->nProgress);
10377     \textcolor{keywordflow}{if}( p->flgProgress & SHELL_PROGRESS_RESET ) p->nProgress = 0;
10378     \textcolor{keywordflow}{if}( p->flgProgress & SHELL_PROGRESS_ONCE ) p->mxProgress = 0;
10379     \textcolor{keywordflow}{return} 1;
10380   \}
10381   \textcolor{keywordflow}{if}( (p->flgProgress & SHELL_PROGRESS_QUIET)==0 )\{
10382     raw_printf(p->out, \textcolor{stringliteral}{"Progress %u\(\backslash\)n"}, p->nProgress);
10383   \}
10384   \textcolor{keywordflow}{return} 0;
10385 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a3e6f3ac65471b3673ac075e2a92c3a49}} 
\index{shell.\+c@{shell.\+c}!quote\+Char@{quote\+Char}}
\index{quote\+Char@{quote\+Char}!shell.\+c@{shell.\+c}}
\subsubsection{quote\+Char()}
{\footnotesize\ttfamily static char quote\+Char (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 794 of file shell.\+c.



References sqlite3\+\_\+keyword\+\_\+check.



Referenced by do\+\_\+meta\+\_\+command(), dump\+\_\+callback(), set\+\_\+table\+\_\+name(), shell\+\_\+callback(), shell\+Add\+Schema\+Name(), and shell\+Fake\+Schema().


\begin{DoxyCode}
794                                         \{
795   \textcolor{keywordtype}{int} i;
796   \textcolor{keywordflow}{if}( !isalpha((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char})zName[0]) && zName[0]!=\textcolor{charliteral}{'\_'} ) \textcolor{keywordflow}{return} \textcolor{charliteral}{'"'};
797   \textcolor{keywordflow}{for}(i=0; zName[i]; i++)\{
798     \textcolor{keywordflow}{if}( !isalnum((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char})zName[i]) && zName[i]!=\textcolor{charliteral}{'\_'} ) \textcolor{keywordflow}{return} \textcolor{charliteral}{'"'};
799   \}
800   \textcolor{keywordflow}{return} sqlite3_keyword_check(zName, i) ? \textcolor{charliteral}{'"'} : 0;
801 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a8964d295ec8deb7f396168e5ee4cf4a4}} 
\index{shell.\+c@{shell.\+c}!read\+File@{read\+File}}
\index{read\+File@{read\+File}!shell.\+c@{shell.\+c}}
\subsubsection{read\+File()}
{\footnotesize\ttfamily static char$\ast$ read\+File (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Name,  }\item[{int $\ast$}]{pn\+Byte }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12328 of file shell.\+c.



References session\+\_\+close\+\_\+all, sqlite3\+\_\+free, and sqlite3\+\_\+malloc64.



Referenced by do\+\_\+meta\+\_\+command(), and open\+\_\+db().


\begin{DoxyCode}
12328                                                      \{
12329   FILE *in = fopen(zName, \textcolor{stringliteral}{"rb"});
12330   \textcolor{keywordtype}{long} nIn;
12331   \textcolor{keywordtype}{size\_t} nRead;
12332   \textcolor{keywordtype}{char} *pBuf;
12333   \textcolor{keywordflow}{if}( in==0 ) \textcolor{keywordflow}{return} 0;
12334   fseek(in, 0, SEEK\_END);
12335   nIn = ftell(in);
12336   rewind(in);
12337   pBuf = sqlite3_malloc64( nIn+1 );
12338   \textcolor{keywordflow}{if}( pBuf==0 )\{ fclose(in); \textcolor{keywordflow}{return} 0; \}
12339   nRead = fread(pBuf, nIn, 1, in);
12340   fclose(in);
12341   \textcolor{keywordflow}{if}( nRead!=1 )\{
12342     sqlite3_free(pBuf);
12343     \textcolor{keywordflow}{return} 0;
12344   \}
12345   pBuf[nIn] = 0;
12346   \textcolor{keywordflow}{if}( pnByte ) *pnByte = nIn;
12347   \textcolor{keywordflow}{return} pBuf;
12348 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a15793439af47119edab12f99b0ed8a57}} 
\index{shell.\+c@{shell.\+c}!read\+File\+Contents@{read\+File\+Contents}}
\index{read\+File\+Contents@{read\+File\+Contents}!shell.\+c@{shell.\+c}}
\subsubsection{read\+File\+Contents()}
{\footnotesize\ttfamily static void read\+File\+Contents (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{ctx,  }\item[{const char $\ast$}]{z\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2165 of file shell.\+c.



References sqlite3\+\_\+context\+\_\+db\+\_\+handle, sqlite3\+\_\+free, sqlite3\+\_\+limit, sqlite3\+\_\+malloc64, sqlite3\+\_\+result\+\_\+blob64, sqlite3\+\_\+result\+\_\+error\+\_\+code, sqlite3\+\_\+result\+\_\+error\+\_\+nomem, S\+Q\+L\+I\+T\+E\+\_\+\+I\+O\+E\+RR, S\+Q\+L\+I\+T\+E\+\_\+\+L\+I\+M\+I\+T\+\_\+\+L\+E\+N\+G\+TH, and S\+Q\+L\+I\+T\+E\+\_\+\+T\+O\+O\+B\+IG.



Referenced by fsdir\+Column(), and readfile\+Func().


\begin{DoxyCode}
2165                                                                      \{
2166   FILE *in;
2167   sqlite3_int64 nIn;
2168   \textcolor{keywordtype}{void} *pBuf;
2169   sqlite3 *db;
2170   \textcolor{keywordtype}{int} mxBlob;
2171 
2172   in = fopen(zName, \textcolor{stringliteral}{"rb"});
2173   \textcolor{keywordflow}{if}( in==0 )\{
2174     \textcolor{comment}{/* File does not exist or is unreadable. Leave the result set to NULL. */}
2175     \textcolor{keywordflow}{return};
2176   \}
2177   fseek(in, 0, SEEK\_END);
2178   nIn = ftell(in);
2179   rewind(in);
2180   db = sqlite3_context_db_handle(ctx);
2181   mxBlob = sqlite3_limit(db, SQLITE_LIMIT_LENGTH, -1);
2182   \textcolor{keywordflow}{if}( nIn>mxBlob )\{
2183     sqlite3_result_error_code(ctx, SQLITE_TOOBIG);
2184     fclose(in);
2185     \textcolor{keywordflow}{return};
2186   \}
2187   pBuf = sqlite3_malloc64( nIn ? nIn : 1 );
2188   \textcolor{keywordflow}{if}( pBuf==0 )\{
2189     sqlite3_result_error_nomem(ctx);
2190     fclose(in);
2191     \textcolor{keywordflow}{return};
2192   \}
2193   \textcolor{keywordflow}{if}( nIn==(sqlite3_int64)fread(pBuf, 1, (\textcolor{keywordtype}{size\_t})nIn, in) )\{
2194     sqlite3_result_blob64(ctx, pBuf, nIn, sqlite3_free);
2195   \}\textcolor{keywordflow}{else}\{
2196     sqlite3_result_error_code(ctx, SQLITE_IOERR);
2197     sqlite3_free(pBuf);
2198   \}
2199   fclose(in);
2200 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a55e9c691f5db117b63ac1f8912663eaa}} 
\index{shell.\+c@{shell.\+c}!readfile\+Func@{readfile\+Func}}
\index{readfile\+Func@{readfile\+Func}!shell.\+c@{shell.\+c}}
\subsubsection{readfile\+Func()}
{\footnotesize\ttfamily static void readfile\+Func (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{context,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2207 of file shell.\+c.



References read\+File\+Contents(), sqlite3\+\_\+value\+\_\+text, and z\+Name.



Referenced by sqlite3\+\_\+fileio\+\_\+init().


\begin{DoxyCode}
2211  \{
2212   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zName;
2213   (void)(argc);  \textcolor{comment}{/* Unused parameter */}
2214   zName = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(argv[0]);
2215   \textcolor{keywordflow}{if}( zName==0 ) \textcolor{keywordflow}{return};
2216   readFileContents(context, zName);
2217 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a42f12cc7304b47cf727c489099c47b64}} 
\index{shell.\+c@{shell.\+c}!resolve\+\_\+backslashes@{resolve\+\_\+backslashes}}
\index{resolve\+\_\+backslashes@{resolve\+\_\+backslashes}!shell.\+c@{shell.\+c}}
\subsubsection{resolve\+\_\+backslashes()}
{\footnotesize\ttfamily static void resolve\+\_\+backslashes (\begin{DoxyParamCaption}\item[{char $\ast$}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12890 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command(), and run\+One\+Sql\+Line().


\begin{DoxyCode}
12890                                         \{
12891   \textcolor{keywordtype}{int} i, j;
12892   \textcolor{keywordtype}{char} c;
12893   \textcolor{keywordflow}{while}( *z && *z!=\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} ) z++;
12894   \textcolor{keywordflow}{for}(i=j=0; (c = z[i])!=0; i++, j++)\{
12895     \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} && z[i+1]!=0 )\{
12896       c = z[++i];
12897       \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'a'} )\{
12898         c = \textcolor{charliteral}{'\(\backslash\)a'};
12899       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'b'} )\{
12900         c = \textcolor{charliteral}{'\(\backslash\)b'};
12901       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'t'} )\{
12902         c = \textcolor{charliteral}{'\(\backslash\)t'};
12903       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'n'} )\{
12904         c = \textcolor{charliteral}{'\(\backslash\)n'};
12905       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'v'} )\{
12906         c = \textcolor{charliteral}{'\(\backslash\)v'};
12907       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'f'} )\{
12908         c = \textcolor{charliteral}{'\(\backslash\)f'};
12909       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'r'} )\{
12910         c = \textcolor{charliteral}{'\(\backslash\)r'};
12911       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'"'} )\{
12912         c = \textcolor{charliteral}{'"'};
12913       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)''} )\{
12914         c = \textcolor{charliteral}{'\(\backslash\)''};
12915       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} )\{
12916         c = \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'};
12917       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c>=\textcolor{charliteral}{'0'} && c<=\textcolor{charliteral}{'7'} )\{
12918         c -= \textcolor{charliteral}{'0'};
12919         \textcolor{keywordflow}{if}( z[i+1]>=\textcolor{charliteral}{'0'} && z[i+1]<=\textcolor{charliteral}{'7'} )\{
12920           i++;
12921           c = (c<<3) + z[i] - \textcolor{charliteral}{'0'};
12922           \textcolor{keywordflow}{if}( z[i+1]>=\textcolor{charliteral}{'0'} && z[i+1]<=\textcolor{charliteral}{'7'} )\{
12923             i++;
12924             c = (c<<3) + z[i] - \textcolor{charliteral}{'0'};
12925           \}
12926         \}
12927       \}
12928     \}
12929     z[j] = c;
12930   \}
12931   \textcolor{keywordflow}{if}( j<i ) z[j] = 0;
12932 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a716d20d1a034ab08a67f7b53fc812453}} 
\index{shell.\+c@{shell.\+c}!restore\+\_\+debug\+\_\+trace\+\_\+modes@{restore\+\_\+debug\+\_\+trace\+\_\+modes}}
\index{restore\+\_\+debug\+\_\+trace\+\_\+modes@{restore\+\_\+debug\+\_\+trace\+\_\+modes}!shell.\+c@{shell.\+c}}
\subsubsection{restore\+\_\+debug\+\_\+trace\+\_\+modes()}
{\footnotesize\ttfamily static void restore\+\_\+debug\+\_\+trace\+\_\+modes (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11317 of file shell.\+c.



Referenced by shell\+\_\+exec().


\begin{DoxyCode}
11317                                            \{
11318 \textcolor{preprocessor}{#if defined(SQLITE\_DEBUG) && defined(SQLITE\_ENABLE\_SELECTTRACE)}
11319   sqlite3SelectTrace = savedSelectTrace;
11320 \textcolor{preprocessor}{#endif}
11321 \textcolor{preprocessor}{#if defined(SQLITE\_DEBUG) && defined(SQLITE\_ENABLE\_WHERETRACE)}
11322   sqlite3WhereTrace = savedWhereTrace;
11323 \textcolor{preprocessor}{#endif}
11324 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad779d0d1b64b032187a57c9106ca82fb}} 
\index{shell.\+c@{shell.\+c}!run\+\_\+schema\+\_\+dump\+\_\+query@{run\+\_\+schema\+\_\+dump\+\_\+query}}
\index{run\+\_\+schema\+\_\+dump\+\_\+query@{run\+\_\+schema\+\_\+dump\+\_\+query}!shell.\+c@{shell.\+c}}
\subsubsection{run\+\_\+schema\+\_\+dump\+\_\+query()}
{\footnotesize\ttfamily static int run\+\_\+schema\+\_\+dump\+\_\+query (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{const char $\ast$}]{z\+Query }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11991 of file shell.\+c.



References Shell\+State\+::db, dump\+\_\+callback(), Shell\+State\+::out, raw\+\_\+printf, sqlite3\+\_\+exec, sqlite3\+\_\+free, sqlite3\+\_\+snprintf, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+R\+R\+U\+PT, strlen30(), and utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
11994  \{
11995   \textcolor{keywordtype}{int} rc;
11996   \textcolor{keywordtype}{char} *zErr = 0;
11997   rc = sqlite3_exec(p->db, zQuery, dump_callback, p, &zErr);
11998   \textcolor{keywordflow}{if}( rc==SQLITE_CORRUPT )\{
11999     \textcolor{keywordtype}{char} *zQ2;
12000     \textcolor{keywordtype}{int} len = strlen30(zQuery);
12001     raw_printf(p->out, \textcolor{stringliteral}{"/****** CORRUPTION ERROR *******/\(\backslash\)n"});
12002     \textcolor{keywordflow}{if}( zErr )\{
12003       utf8_printf(p->out, \textcolor{stringliteral}{"/****** %s ******/\(\backslash\)n"}, zErr);
12004       sqlite3_free(zErr);
12005       zErr = 0;
12006     \}
12007     zQ2 = malloc( len+100 );
12008     \textcolor{keywordflow}{if}( zQ2==0 ) \textcolor{keywordflow}{return} rc;
12009     sqlite3_snprintf(len+100, zQ2, \textcolor{stringliteral}{"%s ORDER BY rowid DESC"}, zQuery);
12010     rc = sqlite3_exec(p->db, zQ2, dump_callback, p, &zErr);
12011     \textcolor{keywordflow}{if}( rc )\{
12012       utf8_printf(p->out, \textcolor{stringliteral}{"/****** ERROR: %s ******/\(\backslash\)n"}, zErr);
12013     \}\textcolor{keywordflow}{else}\{
12014       rc = SQLITE_CORRUPT;
12015     \}
12016     sqlite3_free(zErr);
12017     free(zQ2);
12018   \}
12019   \textcolor{keywordflow}{return} rc;
12020 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a395d87704bd3168df6b6347d84579e58}} 
\index{shell.\+c@{shell.\+c}!run\+\_\+table\+\_\+dump\+\_\+query@{run\+\_\+table\+\_\+dump\+\_\+query}}
\index{run\+\_\+table\+\_\+dump\+\_\+query@{run\+\_\+table\+\_\+dump\+\_\+query}!shell.\+c@{shell.\+c}}
\subsubsection{run\+\_\+table\+\_\+dump\+\_\+query()}
{\footnotesize\ttfamily static int run\+\_\+table\+\_\+dump\+\_\+query (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{const char $\ast$}]{z\+Select,  }\item[{const char $\ast$}]{z\+First\+Row }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10872 of file shell.\+c.



References Shell\+State\+::db, Shell\+State\+::n\+Err, Shell\+State\+::out, raw\+\_\+printf, sqlite3\+\_\+column\+\_\+count, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+errmsg, sqlite3\+\_\+finalize, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+R\+R\+U\+PT, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, and utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
10876  \{
10877   sqlite3_stmt *pSelect;
10878   \textcolor{keywordtype}{int} rc;
10879   \textcolor{keywordtype}{int} nResult;
10880   \textcolor{keywordtype}{int} i;
10881   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z;
10882   rc = sqlite3_prepare_v2(p->db, zSelect, -1, &pSelect, 0);
10883   \textcolor{keywordflow}{if}( rc!=SQLITE_OK || !pSelect )\{
10884     utf8_printf(p->out, \textcolor{stringliteral}{"/**** ERROR: (%d) %s *****/\(\backslash\)n"}, rc,
10885                 sqlite3_errmsg(p->db));
10886     \textcolor{keywordflow}{if}( (rc&0xff)!=SQLITE_CORRUPT ) p->nErr++;
10887     \textcolor{keywordflow}{return} rc;
10888   \}
10889   rc = sqlite3_step(pSelect);
10890   nResult = sqlite3_column_count(pSelect);
10891   \textcolor{keywordflow}{while}( rc==SQLITE_ROW )\{
10892     \textcolor{keywordflow}{if}( zFirstRow )\{
10893       utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, zFirstRow);
10894       zFirstRow = 0;
10895     \}
10896     z = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSelect, 0);
10897     utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, z);
10898     \textcolor{keywordflow}{for}(i=1; i<nResult; i++)\{
10899       utf8_printf(p->out, \textcolor{stringliteral}{",%s"}, sqlite3_column_text(pSelect, i));
10900     \}
10901     \textcolor{keywordflow}{if}( z==0 ) z = \textcolor{stringliteral}{""};
10902     \textcolor{keywordflow}{while}( z[0] && (z[0]!=\textcolor{charliteral}{'-'} || z[1]!=\textcolor{charliteral}{'-'}) ) z++;
10903     \textcolor{keywordflow}{if}( z[0] )\{
10904       raw_printf(p->out, \textcolor{stringliteral}{"\(\backslash\)n;\(\backslash\)n"});
10905     \}\textcolor{keywordflow}{else}\{
10906       raw_printf(p->out, \textcolor{stringliteral}{";\(\backslash\)n"});
10907     \}
10908     rc = sqlite3_step(pSelect);
10909   \}
10910   rc = sqlite3_finalize(pSelect);
10911   \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
10912     utf8_printf(p->out, \textcolor{stringliteral}{"/**** ERROR: (%d) %s *****/\(\backslash\)n"}, rc,
10913                 sqlite3_errmsg(p->db));
10914     \textcolor{keywordflow}{if}( (rc&0xff)!=SQLITE_CORRUPT ) p->nErr++;
10915   \}
10916   \textcolor{keywordflow}{return} rc;
10917 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad8935106a498f906f5667d205623dfa3}} 
\index{shell.\+c@{shell.\+c}!run\+One\+Sql\+Line@{run\+One\+Sql\+Line}}
\index{run\+One\+Sql\+Line@{run\+One\+Sql\+Line}!shell.\+c@{shell.\+c}}
\subsubsection{run\+One\+Sql\+Line()}
{\footnotesize\ttfamily static int run\+One\+Sql\+Line (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{char $\ast$}]{z\+Sql,  }\item[{F\+I\+LE $\ast$}]{in,  }\item[{int}]{startline }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18286 of file shell.\+c.



References B\+E\+G\+I\+N\+\_\+\+T\+I\+M\+ER, Shell\+State\+::db, E\+N\+D\+\_\+\+T\+I\+M\+ER, Shell\+State\+::flg\+Progress, Shell\+State\+::n\+Progress, open\+\_\+db(), Shell\+State\+::out, raw\+\_\+printf, resolve\+\_\+backslashes(), shell\+\_\+exec(), S\+H\+E\+L\+L\+\_\+\+P\+R\+O\+G\+R\+E\+S\+S\+\_\+\+R\+E\+S\+ET, Shell\+Has\+Flag, S\+H\+F\+L\+G\+\_\+\+Backslash, S\+H\+F\+L\+G\+\_\+\+Count\+Changes, sqlite3\+\_\+changes, sqlite3\+\_\+errmsg, sqlite3\+\_\+free, sqlite3\+\_\+snprintf, sqlite3\+\_\+total\+\_\+changes, and utf8\+\_\+printf.



Referenced by process\+\_\+input().


\begin{DoxyCode}
18286                                                                             \{
18287   \textcolor{keywordtype}{int} rc;
18288   \textcolor{keywordtype}{char} *zErrMsg = 0;
18289 
18290   open_db(p, 0);
18291   \textcolor{keywordflow}{if}( ShellHasFlag(p,SHFLG_Backslash) ) resolve_backslashes(zSql);
18292   \textcolor{keywordflow}{if}( p->flgProgress & SHELL_PROGRESS_RESET ) p->nProgress = 0;
18293   BEGIN_TIMER;
18294   rc = shell_exec(p, zSql, &zErrMsg);
18295   END_TIMER;
18296   \textcolor{keywordflow}{if}( rc || zErrMsg )\{
18297     \textcolor{keywordtype}{char} zPrefix[100];
18298     \textcolor{keywordflow}{if}( in!=0 || !stdin_is_interactive )\{
18299       sqlite3_snprintf(\textcolor{keyword}{sizeof}(zPrefix), zPrefix,
18300                        \textcolor{stringliteral}{"Error: near line %d:"}, startline);
18301     \}\textcolor{keywordflow}{else}\{
18302       sqlite3_snprintf(\textcolor{keyword}{sizeof}(zPrefix), zPrefix, \textcolor{stringliteral}{"Error:"});
18303     \}
18304     \textcolor{keywordflow}{if}( zErrMsg!=0 )\{
18305       utf8_printf(stderr, \textcolor{stringliteral}{"%s %s\(\backslash\)n"}, zPrefix, zErrMsg);
18306       sqlite3_free(zErrMsg);
18307       zErrMsg = 0;
18308     \}\textcolor{keywordflow}{else}\{
18309       utf8_printf(stderr, \textcolor{stringliteral}{"%s %s\(\backslash\)n"}, zPrefix, sqlite3_errmsg(p->db));
18310     \}
18311     \textcolor{keywordflow}{return} 1;
18312   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( ShellHasFlag(p, SHFLG_CountChanges) )\{
18313     raw_printf(p->out, \textcolor{stringliteral}{"changes: %3d   total\_changes: %d\(\backslash\)n"},
18314             sqlite3_changes(p->db), sqlite3_total_changes(p->db));
18315   \}
18316   \textcolor{keywordflow}{return} 0;
18317 \}
\end{DoxyCode}
\mbox{\label{shell_8c_af89d15c485bf460944d13d9e0984c327}} 
\index{shell.\+c@{shell.\+c}!save\+\_\+err\+\_\+msg@{save\+\_\+err\+\_\+msg}}
\index{save\+\_\+err\+\_\+msg@{save\+\_\+err\+\_\+msg}!shell.\+c@{shell.\+c}}
\subsubsection{save\+\_\+err\+\_\+msg()}
{\footnotesize\ttfamily static char$\ast$ save\+\_\+err\+\_\+msg (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10922 of file shell.\+c.



References Array\+Size, sqlite3\+\_\+errmsg, sqlite3\+\_\+malloc64, sqlite3\+\_\+snprintf, strlen30(), and utf8\+\_\+printf.



Referenced by shell\+\_\+exec().


\begin{DoxyCode}
10924  \{
10925   \textcolor{keywordtype}{int} nErrMsg = 1+strlen30(sqlite3_errmsg(db));
10926   \textcolor{keywordtype}{char} *zErrMsg = sqlite3_malloc64(nErrMsg);
10927   \textcolor{keywordflow}{if}( zErrMsg )\{
10928     memcpy(zErrMsg, sqlite3_errmsg(db), nErrMsg);
10929   \}
10930   \textcolor{keywordflow}{return} zErrMsg;
10931 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad2a08f83f795b3fae1fea7594eaeed4f}} 
\index{shell.\+c@{shell.\+c}!set\+\_\+table\+\_\+name@{set\+\_\+table\+\_\+name}}
\index{set\+\_\+table\+\_\+name@{set\+\_\+table\+\_\+name}!shell.\+c@{shell.\+c}}
\subsubsection{set\+\_\+table\+\_\+name()}
{\footnotesize\ttfamily static void set\+\_\+table\+\_\+name (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{const char $\ast$}]{z\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10836 of file shell.\+c.



References quote\+Char(), shell\+\_\+out\+\_\+of\+\_\+memory(), strlen30(), and Shell\+State\+::z\+Dest\+Table.



Referenced by do\+\_\+meta\+\_\+command(), and main().


\begin{DoxyCode}
10836                                                             \{
10837   \textcolor{keywordtype}{int} i, n;
10838   \textcolor{keywordtype}{char} cQuote;
10839   \textcolor{keywordtype}{char} *z;
10840 
10841   \textcolor{keywordflow}{if}( p->zDestTable )\{
10842     free(p->zDestTable);
10843     p->zDestTable = 0;
10844   \}
10845   \textcolor{keywordflow}{if}( zName==0 ) \textcolor{keywordflow}{return};
10846   cQuote = quoteChar(zName);
10847   n = strlen30(zName);
10848   \textcolor{keywordflow}{if}( cQuote ) n += n+2;
10849   z = p->zDestTable = malloc( n+1 );
10850   \textcolor{keywordflow}{if}( z==0 ) shell_out_of_memory();
10851   n = 0;
10852   \textcolor{keywordflow}{if}( cQuote ) z[n++] = cQuote;
10853   \textcolor{keywordflow}{for}(i=0; zName[i]; i++)\{
10854     z[n++] = zName[i];
10855     \textcolor{keywordflow}{if}( zName[i]==cQuote ) z[n++] = cQuote;
10856   \}
10857   \textcolor{keywordflow}{if}( cQuote ) z[n++] = cQuote;
10858   z[n] = 0;
10859 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a91d7989547f497aee7376bbd7faf3d84}} 
\index{shell.\+c@{shell.\+c}!set\+Or\+Clear\+Flag@{set\+Or\+Clear\+Flag}}
\index{set\+Or\+Clear\+Flag@{set\+Or\+Clear\+Flag}!shell.\+c@{shell.\+c}}
\subsubsection{set\+Or\+Clear\+Flag()}
{\footnotesize\ttfamily static void set\+Or\+Clear\+Flag (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{unsigned}]{m\+Flag,  }\item[{const char $\ast$}]{z\+Arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12960 of file shell.\+c.



References boolean\+Value(), Shell\+Clear\+Flag, and Shell\+Set\+Flag.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
12960                                                                            \{
12961   \textcolor{keywordflow}{if}( booleanValue(zArg) )\{
12962     ShellSetFlag(p, mFlag);
12963   \}\textcolor{keywordflow}{else}\{
12964     ShellClearFlag(p, mFlag);
12965   \}
12966 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a6a2ec33936522fb0586250dc61747ec3}} 
\index{shell.\+c@{shell.\+c}!S\+H\+A3\+Final@{S\+H\+A3\+Final}}
\index{S\+H\+A3\+Final@{S\+H\+A3\+Final}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+A3\+Final()}
{\footnotesize\ttfamily static unsigned char$\ast$ S\+H\+A3\+Final (\begin{DoxyParamCaption}\item[{\textbf{ S\+H\+A3\+Context} $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 1780 of file shell.\+c.



References S\+H\+A3\+Context\+::ix\+Mask, S\+H\+A3\+Context\+::n\+Loaded, S\+H\+A3\+Context\+::n\+Rate, S\+H\+A3\+Update(), S\+H\+A3\+Context\+::u, and S\+H\+A3\+Context\+::x.



Referenced by sha3\+Func(), and sha3\+Query\+Func().


\begin{DoxyCode}
1780                                                \{
1781   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;
1782   \textcolor{keywordflow}{if}( p->nLoaded==p->nRate-1 )\{
1783     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c1 = 0x86;
1784     SHA3Update(p, &c1, 1);
1785   \}\textcolor{keywordflow}{else}\{
1786     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c2 = 0x06;
1787     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} c3 = 0x80;
1788     SHA3Update(p, &c2, 1);
1789     p->nLoaded = p->nRate - 1;
1790     SHA3Update(p, &c3, 1);
1791   \}
1792   \textcolor{keywordflow}{for}(i=0; i<p->nRate; i++)\{
1793     p->u.x[i+p->nRate] = p->u.x[i^p->ixMask];
1794   \}
1795   \textcolor{keywordflow}{return} &p->u.x[p->nRate];
1796 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a51833bed43d580b8380a1e1bec8eb700}} 
\index{shell.\+c@{shell.\+c}!sha3\+Func@{sha3\+Func}}
\index{sha3\+Func@{sha3\+Func}!shell.\+c@{shell.\+c}}
\subsubsection{sha3\+Func()}
{\footnotesize\ttfamily static void sha3\+Func (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{context,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 1809 of file shell.\+c.



References e\+Type, S\+H\+A3\+Final(), S\+H\+A3\+Init(), S\+H\+A3\+Update(), sqlite3\+\_\+result\+\_\+blob, sqlite3\+\_\+result\+\_\+error, sqlite3\+\_\+value\+\_\+blob, sqlite3\+\_\+value\+\_\+bytes, sqlite3\+\_\+value\+\_\+int, sqlite3\+\_\+value\+\_\+text, sqlite3\+\_\+value\+\_\+type, S\+Q\+L\+I\+T\+E\+\_\+\+B\+L\+OB, S\+Q\+L\+I\+T\+E\+\_\+\+N\+U\+LL, and S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT.



Referenced by sqlite3\+\_\+shathree\+\_\+init().


\begin{DoxyCode}
1813  \{
1814   SHA3Context cx;
1815   \textcolor{keywordtype}{int} eType = sqlite3_value_type(argv[0]);
1816   \textcolor{keywordtype}{int} nByte = sqlite3_value_bytes(argv[0]);
1817   \textcolor{keywordtype}{int} iSize;
1818   \textcolor{keywordflow}{if}( argc==1 )\{
1819     iSize = 256;
1820   \}\textcolor{keywordflow}{else}\{
1821     iSize = sqlite3_value_int(argv[1]);
1822     \textcolor{keywordflow}{if}( iSize!=224 && iSize!=256 && iSize!=384 && iSize!=512 )\{
1823       sqlite3_result_error(context, \textcolor{stringliteral}{"SHA3 size should be one of: 224 256 "}
1824                                     \textcolor{stringliteral}{"384 512"}, -1);
1825       \textcolor{keywordflow}{return};
1826     \}
1827   \}
1828   \textcolor{keywordflow}{if}( eType==SQLITE_NULL ) \textcolor{keywordflow}{return};
1829   SHA3Init(&cx, iSize);
1830   \textcolor{keywordflow}{if}( eType==SQLITE_BLOB )\{
1831     SHA3Update(&cx, sqlite3_value_blob(argv[0]), nByte);
1832   \}\textcolor{keywordflow}{else}\{
1833     SHA3Update(&cx, sqlite3_value_text(argv[0]), nByte);
1834   \}
1835   sqlite3_result_blob(context, SHA3Final(&cx), iSize/8, SQLITE_TRANSIENT);
1836 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab24e75838b12ecca73c5791792e41a70}} 
\index{shell.\+c@{shell.\+c}!S\+H\+A3\+Init@{S\+H\+A3\+Init}}
\index{S\+H\+A3\+Init@{S\+H\+A3\+Init}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+A3\+Init()}
{\footnotesize\ttfamily static void S\+H\+A3\+Init (\begin{DoxyParamCaption}\item[{\textbf{ S\+H\+A3\+Context} $\ast$}]{p,  }\item[{int}]{i\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 1712 of file shell.\+c.



References S\+H\+A3\+Context\+::ix\+Mask, and S\+H\+A3\+Context\+::n\+Rate.



Referenced by sha3\+Func(), and sha3\+Query\+Func().


\begin{DoxyCode}
1712                                                \{
1713   memset(p, 0, \textcolor{keyword}{sizeof}(*p));
1714   \textcolor{keywordflow}{if}( iSize>=128 && iSize<=512 )\{
1715     p->nRate = (1600 - ((iSize + 31)&~31)*2)/8;
1716   \}\textcolor{keywordflow}{else}\{
1717     p->nRate = (1600 - 2*256)/8;
1718   \}
1719 \textcolor{preprocessor}{#if SHA3\_BYTEORDER==1234}
1720   \textcolor{comment}{/* Known to be little-endian at compile-time. No-op */}
1721 \textcolor{preprocessor}{#elif SHA3\_BYTEORDER==4321}
1722   p->ixMask = 7;  \textcolor{comment}{/* Big-endian */}
1723 \textcolor{preprocessor}{#else}
1724   \{
1725     \textcolor{keyword}{static} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} one = 1;
1726     \textcolor{keywordflow}{if}( 1==*(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)&one )\{
1727       \textcolor{comment}{/* Little endian.  No byte swapping. */}
1728       p->ixMask = 0;
1729     \}\textcolor{keywordflow}{else}\{
1730       \textcolor{comment}{/* Big endian.  Byte swap. */}
1731       p->ixMask = 7;
1732     \}
1733   \}
1734 \textcolor{preprocessor}{#endif}
1735 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a45605123477af036a543563ae898a111}} 
\index{shell.\+c@{shell.\+c}!sha3\+Query\+Func@{sha3\+Query\+Func}}
\index{sha3\+Query\+Func@{sha3\+Query\+Func}!shell.\+c@{shell.\+c}}
\subsubsection{sha3\+Query\+Func()}
{\footnotesize\ttfamily static void sha3\+Query\+Func (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{context,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 1888 of file shell.\+c.



References hash\+\_\+step\+\_\+vformat(), S\+H\+A3\+Final(), S\+H\+A3\+Init(), S\+H\+A3\+Update(), sqlite3\+\_\+column\+\_\+blob, sqlite3\+\_\+column\+\_\+bytes, sqlite3\+\_\+column\+\_\+count, sqlite3\+\_\+column\+\_\+double, sqlite3\+\_\+column\+\_\+int64, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+column\+\_\+type, sqlite3\+\_\+context\+\_\+db\+\_\+handle, sqlite3\+\_\+errmsg, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+result\+\_\+blob, sqlite3\+\_\+result\+\_\+error, sqlite3\+\_\+sql, sqlite3\+\_\+step, sqlite3\+\_\+stmt\+\_\+readonly, sqlite3\+\_\+value\+\_\+int, sqlite3\+\_\+value\+\_\+text, S\+Q\+L\+I\+T\+E\+\_\+\+B\+L\+OB, S\+Q\+L\+I\+T\+E\+\_\+\+F\+L\+O\+AT, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+T\+E\+G\+ER, S\+Q\+L\+I\+T\+E\+\_\+\+N\+U\+LL, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+XT, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT, and time\+\_\+test\+::x.



Referenced by sqlite3\+\_\+shathree\+\_\+init().


\begin{DoxyCode}
1892  \{
1893   sqlite3 *db = sqlite3_context_db_handle(context);
1894   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(argv[0]);
1895   sqlite3_stmt *pStmt = 0;
1896   \textcolor{keywordtype}{int} nCol;                   \textcolor{comment}{/* Number of columns in the result set */}
1897   \textcolor{keywordtype}{int} i;                      \textcolor{comment}{/* Loop counter */}
1898   \textcolor{keywordtype}{int} rc;
1899   \textcolor{keywordtype}{int} n;
1900   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z;
1901   SHA3Context cx;
1902   \textcolor{keywordtype}{int} iSize;
1903 
1904   \textcolor{keywordflow}{if}( argc==1 )\{
1905     iSize = 256;
1906   \}\textcolor{keywordflow}{else}\{
1907     iSize = sqlite3_value_int(argv[1]);
1908     \textcolor{keywordflow}{if}( iSize!=224 && iSize!=256 && iSize!=384 && iSize!=512 )\{
1909       sqlite3_result_error(context, \textcolor{stringliteral}{"SHA3 size should be one of: 224 256 "}
1910                                     \textcolor{stringliteral}{"384 512"}, -1);
1911       \textcolor{keywordflow}{return};
1912     \}
1913   \}
1914   \textcolor{keywordflow}{if}( zSql==0 ) \textcolor{keywordflow}{return};
1915   SHA3Init(&cx, iSize);
1916   \textcolor{keywordflow}{while}( zSql[0] )\{
1917     rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zSql);
1918     \textcolor{keywordflow}{if}( rc )\{
1919       \textcolor{keywordtype}{char} *zMsg = sqlite3_mprintf(\textcolor{stringliteral}{"error SQL statement [%s]: %s"},
1920                                    zSql, sqlite3_errmsg(db));
1921       sqlite3_finalize(pStmt);
1922       sqlite3_result_error(context, zMsg, -1);
1923       sqlite3_free(zMsg);
1924       \textcolor{keywordflow}{return};
1925     \}
1926     \textcolor{keywordflow}{if}( !sqlite3_stmt_readonly(pStmt) )\{
1927       \textcolor{keywordtype}{char} *zMsg = sqlite3_mprintf(\textcolor{stringliteral}{"non-query: [%s]"}, sqlite3_sql(pStmt));
1928       sqlite3_finalize(pStmt);
1929       sqlite3_result_error(context, zMsg, -1);
1930       sqlite3_free(zMsg);
1931       \textcolor{keywordflow}{return};
1932     \}
1933     nCol = sqlite3_column_count(pStmt);
1934     z = sqlite3_sql(pStmt);
1935     n = (int)strlen(z);
1936     hash_step_vformat(&cx,\textcolor{stringliteral}{"S%d:"},n);
1937     SHA3Update(&cx,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)z,n);
1938 
1939     \textcolor{comment}{/* Compute a hash over the result of the query */}
1940     \textcolor{keywordflow}{while}( SQLITE_ROW==sqlite3_step(pStmt) )\{
1941       SHA3Update(&cx,(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"R"},1);
1942       \textcolor{keywordflow}{for}(i=0; i<nCol; i++)\{
1943         \textcolor{keywordflow}{switch}( sqlite3_column_type(pStmt,i) )\{
1944           \textcolor{keywordflow}{case} SQLITE_NULL: \{
1945             SHA3Update(&cx, (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)\textcolor{stringliteral}{"N"},1);
1946             \textcolor{keywordflow}{break};
1947           \}
1948           \textcolor{keywordflow}{case} SQLITE_INTEGER: \{
1949             sqlite3_uint64 u;
1950             \textcolor{keywordtype}{int} j;
1951             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} x[9];
1952             sqlite3_int64 v = sqlite3_column_int64(pStmt,i);
1953             memcpy(&u, &v, 8);
1954             \textcolor{keywordflow}{for}(j=8; j>=1; j--)\{
1955               x[j] = u & 0xff;
1956               u >>= 8;
1957             \}
1958             x[0] = \textcolor{charliteral}{'I'};
1959             SHA3Update(&cx, x, 9);
1960             \textcolor{keywordflow}{break};
1961           \}
1962           \textcolor{keywordflow}{case} SQLITE_FLOAT: \{
1963             sqlite3_uint64 u;
1964             \textcolor{keywordtype}{int} j;
1965             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} x[9];
1966             \textcolor{keywordtype}{double} r = sqlite3_column_double(pStmt,i);
1967             memcpy(&u, &r, 8);
1968             \textcolor{keywordflow}{for}(j=8; j>=1; j--)\{
1969               x[j] = u & 0xff;
1970               u >>= 8;
1971             \}
1972             x[0] = \textcolor{charliteral}{'F'};
1973             SHA3Update(&cx,x,9);
1974             \textcolor{keywordflow}{break};
1975           \}
1976           \textcolor{keywordflow}{case} SQLITE_TEXT: \{
1977             \textcolor{keywordtype}{int} n2 = sqlite3_column_bytes(pStmt, i);
1978             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *z2 = sqlite3_column_text(pStmt, i);
1979             hash_step_vformat(&cx,\textcolor{stringliteral}{"T%d:"},n2);
1980             SHA3Update(&cx, z2, n2);
1981             \textcolor{keywordflow}{break};
1982           \}
1983           \textcolor{keywordflow}{case} SQLITE_BLOB: \{
1984             \textcolor{keywordtype}{int} n2 = sqlite3_column_bytes(pStmt, i);
1985             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *z2 = sqlite3_column_blob(pStmt, i);
1986             hash_step_vformat(&cx,\textcolor{stringliteral}{"B%d:"},n2);
1987             SHA3Update(&cx, z2, n2);
1988             \textcolor{keywordflow}{break};
1989           \}
1990         \}
1991       \}
1992     \}
1993     sqlite3_finalize(pStmt);
1994   \}
1995   sqlite3_result_blob(context, SHA3Final(&cx), iSize/8, SQLITE_TRANSIENT);
1996 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a6e14fd9c3aafb2b219a686641c2ea9b4}} 
\index{shell.\+c@{shell.\+c}!S\+H\+A3\+Update@{S\+H\+A3\+Update}}
\index{S\+H\+A3\+Update@{S\+H\+A3\+Update}!shell.\+c@{shell.\+c}}
\subsubsection{S\+H\+A3\+Update()}
{\footnotesize\ttfamily static void S\+H\+A3\+Update (\begin{DoxyParamCaption}\item[{\textbf{ S\+H\+A3\+Context} $\ast$}]{p,  }\item[{const unsigned char $\ast$}]{a\+Data,  }\item[{unsigned int}]{n\+Data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 1741 of file shell.\+c.



References S\+H\+A3\+Context\+::ix\+Mask, Keccak\+F1600\+Step(), S\+H\+A3\+Context\+::n\+Loaded, S\+H\+A3\+Context\+::n\+Rate, S\+H\+A3\+Context\+::s, S\+H\+A3\+Context\+::u, and S\+H\+A3\+Context\+::x.



Referenced by hash\+\_\+step\+\_\+vformat(), S\+H\+A3\+Final(), sha3\+Func(), and sha3\+Query\+Func().


\begin{DoxyCode}
1745  \{
1746   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0;
1747 \textcolor{preprocessor}{#if SHA3\_BYTEORDER==1234}
1748   \textcolor{keywordflow}{if}( (p->nLoaded % 8)==0 && ((aData - (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)0)&7)==0 )\{
1749     \textcolor{keywordflow}{for}(; i+7<nData; i+=8)\{
1750       p->u.s[p->nLoaded/8] ^= *(u64*)&aData[i];
1751       p->nLoaded += 8;
1752       \textcolor{keywordflow}{if}( p->nLoaded>=p->nRate )\{
1753         KeccakF1600Step(p);
1754         p->nLoaded = 0;
1755       \}
1756     \}
1757   \}
1758 \textcolor{preprocessor}{#endif}
1759   \textcolor{keywordflow}{for}(; i<nData; i++)\{
1760 \textcolor{preprocessor}{#if SHA3\_BYTEORDER==1234}
1761     p->u.x[p->nLoaded] ^= aData[i];
1762 \textcolor{preprocessor}{#elif SHA3\_BYTEORDER==4321}
1763     p->u.x[p->nLoaded^0x07] ^= aData[i];
1764 \textcolor{preprocessor}{#else}
1765     p->u.x[p->nLoaded^p->ixMask] ^= aData[i];
1766 \textcolor{preprocessor}{#endif}
1767     p->nLoaded++;
1768     \textcolor{keywordflow}{if}( p->nLoaded==p->nRate )\{
1769       KeccakF1600Step(p);
1770       p->nLoaded = 0;
1771     \}
1772   \}
1773 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab7f3ddba1172313cbb23a09f1cb48edd}} 
\index{shell.\+c@{shell.\+c}!shell\+\_\+callback@{shell\+\_\+callback}}
\index{shell\+\_\+callback@{shell\+\_\+callback}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+\_\+callback()}
{\footnotesize\ttfamily static int shell\+\_\+callback (\begin{DoxyParamCaption}\item[{void $\ast$}]{p\+Arg,  }\item[{int}]{n\+Arg,  }\item[{char $\ast$$\ast$}]{az\+Arg,  }\item[{char $\ast$$\ast$}]{az\+Col,  }\item[{int $\ast$}]{ai\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10392 of file shell.\+c.



References Shell\+State\+::actual\+Width, Shell\+State\+::ai\+Indent, Array\+Size, Shell\+State\+::c\+Mode, Shell\+State\+::cnt, Shell\+State\+::col\+Separator, Shell\+State\+::col\+Width, eqp\+\_\+append(), Shell\+State\+::i\+Indent, is\+Number(), Is\+Space, M\+O\+D\+E\+\_\+\+Ascii, M\+O\+D\+E\+\_\+\+Column, M\+O\+D\+E\+\_\+\+Csv, M\+O\+D\+E\+\_\+\+E\+QP, M\+O\+D\+E\+\_\+\+Explain, M\+O\+D\+E\+\_\+\+Html, M\+O\+D\+E\+\_\+\+Insert, M\+O\+D\+E\+\_\+\+Line, M\+O\+D\+E\+\_\+\+List, M\+O\+D\+E\+\_\+\+Pretty, M\+O\+D\+E\+\_\+\+Quote, M\+O\+D\+E\+\_\+\+Semi, M\+O\+D\+E\+\_\+\+Tcl, Shell\+State\+::n\+Indent, Shell\+State\+::null\+Value, Shell\+State\+::out, output\+\_\+c\+\_\+string(), output\+\_\+csv(), output\+\_\+hex\+\_\+blob(), output\+\_\+html\+\_\+string(), output\+\_\+quoted\+\_\+escaped\+\_\+string(), output\+\_\+quoted\+\_\+string(), print\+Schema\+Line(), print\+Schema\+Line\+N(), Shell\+State\+::p\+Stmt, quote\+Char(), raw\+\_\+printf, Shell\+State\+::row\+Separator, S\+E\+P\+\_\+\+Row, set\+Binary\+Mode, set\+Text\+Mode, Shell\+Has\+Flag, S\+H\+F\+L\+G\+\_\+\+Newlines, Shell\+State\+::show\+Header, sqlite3\+\_\+column\+\_\+blob, sqlite3\+\_\+column\+\_\+bytes, sqlite3\+\_\+column\+\_\+double, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+snprintf, sqlite3\+\_\+strlike, S\+Q\+L\+I\+T\+E\+\_\+\+B\+L\+OB, S\+Q\+L\+I\+T\+E\+\_\+\+F\+L\+O\+AT, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+T\+E\+G\+ER, S\+Q\+L\+I\+T\+E\+\_\+\+N\+U\+LL, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+XT, strlen30(), strlen\+Char(), utf8\+\_\+printf, utf8\+\_\+width\+\_\+print(), ws\+To\+Eol(), and Shell\+State\+::z\+Dest\+Table.



Referenced by callback(), and exec\+\_\+prepared\+\_\+stmt().


\begin{DoxyCode}
10398  \{
10399   \textcolor{keywordtype}{int} i;
10400   ShellState *p = (ShellState*)pArg;
10401 
10402   \textcolor{keywordflow}{if}( azArg==0 ) \textcolor{keywordflow}{return} 0;
10403   \textcolor{keywordflow}{switch}( p->cMode )\{
10404     \textcolor{keywordflow}{case} MODE_Line: \{
10405       \textcolor{keywordtype}{int} w = 5;
10406       \textcolor{keywordflow}{if}( azArg==0 ) \textcolor{keywordflow}{break};
10407       \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10408         \textcolor{keywordtype}{int} len = strlen30(azCol[i] ? azCol[i] : \textcolor{stringliteral}{""});
10409         \textcolor{keywordflow}{if}( len>w ) w = len;
10410       \}
10411       \textcolor{keywordflow}{if}( p->cnt++>0 ) utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->rowSeparator);
10412       \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10413         utf8_printf(p->out,\textcolor{stringliteral}{"%*s = %s%s"}, w, azCol[i],
10414                 azArg[i] ? azArg[i] : p->nullValue, p->rowSeparator);
10415       \}
10416       \textcolor{keywordflow}{break};
10417     \}
10418     \textcolor{keywordflow}{case} MODE_Explain:
10419     \textcolor{keywordflow}{case} MODE_Column: \{
10420       \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} aExplainWidths[] = \{4, 13, 4, 4, 4, 13, 2, 13\};
10421       \textcolor{keyword}{const} \textcolor{keywordtype}{int} *colWidth;
10422       \textcolor{keywordtype}{int} showHdr;
10423       \textcolor{keywordtype}{char} *rowSep;
10424       \textcolor{keywordtype}{int} nWidth;
10425       \textcolor{keywordflow}{if}( p->cMode==MODE_Column )\{
10426         colWidth = p->colWidth;
10427         nWidth = ArraySize(p->colWidth);
10428         showHdr = p->showHeader;
10429         rowSep = p->rowSeparator;
10430       \}\textcolor{keywordflow}{else}\{
10431         colWidth = aExplainWidths;
10432         nWidth = ArraySize(aExplainWidths);
10433         showHdr = 1;
10434         rowSep = SEP_Row;
10435       \}
10436       \textcolor{keywordflow}{if}( p->cnt++==0 )\{
10437         \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10438           \textcolor{keywordtype}{int} w, n;
10439           \textcolor{keywordflow}{if}( i<nWidth )\{
10440             w = colWidth[i];
10441           \}\textcolor{keywordflow}{else}\{
10442             w = 0;
10443           \}
10444           \textcolor{keywordflow}{if}( w==0 )\{
10445             w = strlenChar(azCol[i] ? azCol[i] : \textcolor{stringliteral}{""});
10446             \textcolor{keywordflow}{if}( w<10 ) w = 10;
10447             n = strlenChar(azArg && azArg[i] ? azArg[i] : p->nullValue);
10448             \textcolor{keywordflow}{if}( w<n ) w = n;
10449           \}
10450           \textcolor{keywordflow}{if}( i<ArraySize(p->actualWidth) )\{
10451             p->actualWidth[i] = w;
10452           \}
10453           \textcolor{keywordflow}{if}( showHdr )\{
10454             utf8_width_print(p->out, w, azCol[i]);
10455             utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, i==nArg-1 ? rowSep : \textcolor{stringliteral}{"  "});
10456           \}
10457         \}
10458         \textcolor{keywordflow}{if}( showHdr )\{
10459           \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10460             \textcolor{keywordtype}{int} w;
10461             \textcolor{keywordflow}{if}( i<ArraySize(p->actualWidth) )\{
10462                w = p->actualWidth[i];
10463                \textcolor{keywordflow}{if}( w<0 ) w = -w;
10464             \}\textcolor{keywordflow}{else}\{
10465                w = 10;
10466             \}
10467             utf8_printf(p->out,\textcolor{stringliteral}{"%-*.*s%s"},w,w,
10468                    \textcolor{stringliteral}{"----------------------------------------------------------"}
10469                    \textcolor{stringliteral}{"----------------------------------------------------------"},
10470                     i==nArg-1 ? rowSep : \textcolor{stringliteral}{"  "});
10471           \}
10472         \}
10473       \}
10474       \textcolor{keywordflow}{if}( azArg==0 ) \textcolor{keywordflow}{break};
10475       \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10476         \textcolor{keywordtype}{int} w;
10477         \textcolor{keywordflow}{if}( i<ArraySize(p->actualWidth) )\{
10478            w = p->actualWidth[i];
10479         \}\textcolor{keywordflow}{else}\{
10480            w = 10;
10481         \}
10482         \textcolor{keywordflow}{if}( p->cMode==MODE_Explain && azArg[i] && strlenChar(azArg[i])>w )\{
10483           w = strlenChar(azArg[i]);
10484         \}
10485         \textcolor{keywordflow}{if}( i==1 && p->aiIndent && p->pStmt )\{
10486           \textcolor{keywordflow}{if}( p->iIndent<p->nIndent )\{
10487             utf8_printf(p->out, \textcolor{stringliteral}{"%*.s"}, p->aiIndent[p->iIndent], \textcolor{stringliteral}{""});
10488           \}
10489           p->iIndent++;
10490         \}
10491         utf8_width_print(p->out, w, azArg[i] ? azArg[i] : p->nullValue);
10492         utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, i==nArg-1 ? rowSep : \textcolor{stringliteral}{"  "});
10493       \}
10494       \textcolor{keywordflow}{break};
10495     \}
10496     \textcolor{keywordflow}{case} MODE_Semi: \{   \textcolor{comment}{/* .schema and .fullschema output */}
10497       printSchemaLine(p->out, azArg[0], \textcolor{stringliteral}{";\(\backslash\)n"});
10498       \textcolor{keywordflow}{break};
10499     \}
10500     \textcolor{keywordflow}{case} MODE_Pretty: \{  \textcolor{comment}{/* .schema and .fullschema with --indent */}
10501       \textcolor{keywordtype}{char} *z;
10502       \textcolor{keywordtype}{int} j;
10503       \textcolor{keywordtype}{int} nParen = 0;
10504       \textcolor{keywordtype}{char} cEnd = 0;
10505       \textcolor{keywordtype}{char} c;
10506       \textcolor{keywordtype}{int} nLine = 0;
10507       assert( nArg==1 );
10508       \textcolor{keywordflow}{if}( azArg[0]==0 ) \textcolor{keywordflow}{break};
10509       \textcolor{keywordflow}{if}( sqlite3_strlike(\textcolor{stringliteral}{"CREATE VIEW%"}, azArg[0], 0)==0
10510        || sqlite3_strlike(\textcolor{stringliteral}{"CREATE TRIG%"}, azArg[0], 0)==0
10511       )\{
10512         utf8_printf(p->out, \textcolor{stringliteral}{"%s;\(\backslash\)n"}, azArg[0]);
10513         \textcolor{keywordflow}{break};
10514       \}
10515       z = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, azArg[0]);
10516       j = 0;
10517       \textcolor{keywordflow}{for}(i=0; IsSpace(z[i]); i++)\{\}
10518       \textcolor{keywordflow}{for}(; (c = z[i])!=0; i++)\{
10519         \textcolor{keywordflow}{if}( IsSpace(c) )\{
10520           \textcolor{keywordflow}{if}( z[j-1]==\textcolor{charliteral}{'\(\backslash\)r'} ) z[j-1] = \textcolor{charliteral}{'\(\backslash\)n'};
10521           \textcolor{keywordflow}{if}( IsSpace(z[j-1]) || z[j-1]==\textcolor{charliteral}{'('} ) \textcolor{keywordflow}{continue};
10522         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( (c==\textcolor{charliteral}{'('} || c==\textcolor{charliteral}{')'}) && j>0 && IsSpace(z[j-1]) )\{
10523           j--;
10524         \}
10525         z[j++] = c;
10526       \}
10527       \textcolor{keywordflow}{while}( j>0 && IsSpace(z[j-1]) )\{ j--; \}
10528       z[j] = 0;
10529       \textcolor{keywordflow}{if}( strlen30(z)>=79 )\{
10530         \textcolor{keywordflow}{for}(i=j=0; (c = z[i])!=0; i++)\{ \textcolor{comment}{/* Copy from z[i] back to z[j] */}
10531           \textcolor{keywordflow}{if}( c==cEnd )\{
10532             cEnd = 0;
10533           \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'"'} || c==\textcolor{charliteral}{'\(\backslash\)''} || c==\textcolor{charliteral}{'`'} )\{
10534             cEnd = c;
10535           \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'['} )\{
10536             cEnd = \textcolor{charliteral}{']'};
10537           \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'-'} && z[i+1]==\textcolor{charliteral}{'-'} )\{
10538             cEnd = \textcolor{charliteral}{'\(\backslash\)n'};
10539           \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'('} )\{
10540             nParen++;
10541           \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{')'} )\{
10542             nParen--;
10543             \textcolor{keywordflow}{if}( nLine>0 && nParen==0 && j>0 )\{
10544               printSchemaLineN(p->out, z, j, \textcolor{stringliteral}{"\(\backslash\)n"});
10545               j = 0;
10546             \}
10547           \}
10548           z[j++] = c;
10549           \textcolor{keywordflow}{if}( nParen==1 && cEnd==0
10550            && (c==\textcolor{charliteral}{'('} || c==\textcolor{charliteral}{'\(\backslash\)n'} || (c==\textcolor{charliteral}{','} && !wsToEol(z+i+1)))
10551           )\{
10552             \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'\(\backslash\)n'} ) j--;
10553             printSchemaLineN(p->out, z, j, \textcolor{stringliteral}{"\(\backslash\)n  "});
10554             j = 0;
10555             nLine++;
10556             \textcolor{keywordflow}{while}( IsSpace(z[i+1]) )\{ i++; \}
10557           \}
10558         \}
10559         z[j] = 0;
10560       \}
10561       printSchemaLine(p->out, z, \textcolor{stringliteral}{";\(\backslash\)n"});
10562       sqlite3_free(z);
10563       \textcolor{keywordflow}{break};
10564     \}
10565     \textcolor{keywordflow}{case} MODE_List: \{
10566       \textcolor{keywordflow}{if}( p->cnt++==0 && p->showHeader )\{
10567         \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10568           utf8_printf(p->out,\textcolor{stringliteral}{"%s%s"},azCol[i],
10569                   i==nArg-1 ? p->rowSeparator : p->colSeparator);
10570         \}
10571       \}
10572       \textcolor{keywordflow}{if}( azArg==0 ) \textcolor{keywordflow}{break};
10573       \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10574         \textcolor{keywordtype}{char} *z = azArg[i];
10575         \textcolor{keywordflow}{if}( z==0 ) z = p->nullValue;
10576         utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, z);
10577         \textcolor{keywordflow}{if}( i<nArg-1 )\{
10578           utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->colSeparator);
10579         \}\textcolor{keywordflow}{else}\{
10580           utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->rowSeparator);
10581         \}
10582       \}
10583       \textcolor{keywordflow}{break};
10584     \}
10585     \textcolor{keywordflow}{case} MODE_Html: \{
10586       \textcolor{keywordflow}{if}( p->cnt++==0 && p->showHeader )\{
10587         raw_printf(p->out,\textcolor{stringliteral}{"<TR>"});
10588         \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10589           raw_printf(p->out,\textcolor{stringliteral}{"<TH>"});
10590           output_html_string(p->out, azCol[i]);
10591           raw_printf(p->out,\textcolor{stringliteral}{"</TH>\(\backslash\)n"});
10592         \}
10593         raw_printf(p->out,\textcolor{stringliteral}{"</TR>\(\backslash\)n"});
10594       \}
10595       \textcolor{keywordflow}{if}( azArg==0 ) \textcolor{keywordflow}{break};
10596       raw_printf(p->out,\textcolor{stringliteral}{"<TR>"});
10597       \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10598         raw_printf(p->out,\textcolor{stringliteral}{"<TD>"});
10599         output_html_string(p->out, azArg[i] ? azArg[i] : p->nullValue);
10600         raw_printf(p->out,\textcolor{stringliteral}{"</TD>\(\backslash\)n"});
10601       \}
10602       raw_printf(p->out,\textcolor{stringliteral}{"</TR>\(\backslash\)n"});
10603       \textcolor{keywordflow}{break};
10604     \}
10605     \textcolor{keywordflow}{case} MODE_Tcl: \{
10606       \textcolor{keywordflow}{if}( p->cnt++==0 && p->showHeader )\{
10607         \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10608           output_c_string(p->out,azCol[i] ? azCol[i] : \textcolor{stringliteral}{""});
10609           \textcolor{keywordflow}{if}(i<nArg-1) utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->colSeparator);
10610         \}
10611         utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->rowSeparator);
10612       \}
10613       \textcolor{keywordflow}{if}( azArg==0 ) \textcolor{keywordflow}{break};
10614       \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10615         output_c_string(p->out, azArg[i] ? azArg[i] : p->nullValue);
10616         \textcolor{keywordflow}{if}(i<nArg-1) utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->colSeparator);
10617       \}
10618       utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->rowSeparator);
10619       \textcolor{keywordflow}{break};
10620     \}
10621     \textcolor{keywordflow}{case} MODE_Csv: \{
10622       setBinaryMode(p->out, 1);
10623       \textcolor{keywordflow}{if}( p->cnt++==0 && p->showHeader )\{
10624         \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10625           output_csv(p, azCol[i] ? azCol[i] : \textcolor{stringliteral}{""}, i<nArg-1);
10626         \}
10627         utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->rowSeparator);
10628       \}
10629       \textcolor{keywordflow}{if}( nArg>0 )\{
10630         \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10631           output_csv(p, azArg[i], i<nArg-1);
10632         \}
10633         utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->rowSeparator);
10634       \}
10635       setTextMode(p->out, 1);
10636       \textcolor{keywordflow}{break};
10637     \}
10638     \textcolor{keywordflow}{case} MODE_Insert: \{
10639       \textcolor{keywordflow}{if}( azArg==0 ) \textcolor{keywordflow}{break};
10640       utf8_printf(p->out,\textcolor{stringliteral}{"INSERT INTO %s"},p->zDestTable);
10641       \textcolor{keywordflow}{if}( p->showHeader )\{
10642         raw_printf(p->out,\textcolor{stringliteral}{"("});
10643         \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10644           \textcolor{keywordflow}{if}( i>0 ) raw_printf(p->out, \textcolor{stringliteral}{","});
10645           \textcolor{keywordflow}{if}( quoteChar(azCol[i]) )\{
10646             \textcolor{keywordtype}{char} *z = sqlite3_mprintf(\textcolor{stringliteral}{"\(\backslash\)"%w\(\backslash\)""}, azCol[i]);
10647             utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, z);
10648             sqlite3_free(z);
10649           \}\textcolor{keywordflow}{else}\{
10650             raw_printf(p->out, \textcolor{stringliteral}{"%s"}, azCol[i]);
10651           \}
10652         \}
10653         raw_printf(p->out,\textcolor{stringliteral}{")"});
10654       \}
10655       p->cnt++;
10656       \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10657         raw_printf(p->out, i>0 ? \textcolor{stringliteral}{","} : \textcolor{stringliteral}{" VALUES("});
10658         \textcolor{keywordflow}{if}( (azArg[i]==0) || (aiType && aiType[i]==SQLITE_NULL) )\{
10659           utf8_printf(p->out,\textcolor{stringliteral}{"NULL"});
10660         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( aiType && aiType[i]==SQLITE_TEXT )\{
10661           \textcolor{keywordflow}{if}( ShellHasFlag(p, SHFLG_Newlines) )\{
10662             output_quoted_string(p->out, azArg[i]);
10663           \}\textcolor{keywordflow}{else}\{
10664             output_quoted_escaped_string(p->out, azArg[i]);
10665           \}
10666         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( aiType && aiType[i]==SQLITE_INTEGER )\{
10667           utf8_printf(p->out,\textcolor{stringliteral}{"%s"}, azArg[i]);
10668         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( aiType && aiType[i]==SQLITE_FLOAT )\{
10669           \textcolor{keywordtype}{char} z[50];
10670           \textcolor{keywordtype}{double} r = sqlite3_column_double(p->pStmt, i);
10671           sqlite3_uint64 ur;
10672           memcpy(&ur,&r,\textcolor{keyword}{sizeof}(r));
10673           \textcolor{keywordflow}{if}( ur==0x7ff0000000000000LL )\{
10674             raw_printf(p->out, \textcolor{stringliteral}{"1e999"});
10675           \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( ur==0xfff0000000000000LL )\{
10676             raw_printf(p->out, \textcolor{stringliteral}{"-1e999"});
10677           \}\textcolor{keywordflow}{else}\{
10678             sqlite3_snprintf(50,z,\textcolor{stringliteral}{"%!.20g"}, r);
10679             raw_printf(p->out, \textcolor{stringliteral}{"%s"}, z);
10680           \}
10681         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( aiType && aiType[i]==SQLITE_BLOB && p->pStmt )\{
10682           \textcolor{keyword}{const} \textcolor{keywordtype}{void} *pBlob = sqlite3_column_blob(p->pStmt, i);
10683           \textcolor{keywordtype}{int} nBlob = sqlite3_column_bytes(p->pStmt, i);
10684           output_hex_blob(p->out, pBlob, nBlob);
10685         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( isNumber(azArg[i], 0) )\{
10686           utf8_printf(p->out,\textcolor{stringliteral}{"%s"}, azArg[i]);
10687         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( ShellHasFlag(p, SHFLG_Newlines) )\{
10688           output_quoted_string(p->out, azArg[i]);
10689         \}\textcolor{keywordflow}{else}\{
10690           output_quoted_escaped_string(p->out, azArg[i]);
10691         \}
10692       \}
10693       raw_printf(p->out,\textcolor{stringliteral}{");\(\backslash\)n"});
10694       \textcolor{keywordflow}{break};
10695     \}
10696     \textcolor{keywordflow}{case} MODE_Quote: \{
10697       \textcolor{keywordflow}{if}( azArg==0 ) \textcolor{keywordflow}{break};
10698       \textcolor{keywordflow}{if}( p->cnt==0 && p->showHeader )\{
10699         \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10700           \textcolor{keywordflow}{if}( i>0 ) raw_printf(p->out, \textcolor{stringliteral}{","});
10701           output_quoted_string(p->out, azCol[i]);
10702         \}
10703         raw_printf(p->out,\textcolor{stringliteral}{"\(\backslash\)n"});
10704       \}
10705       p->cnt++;
10706       \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10707         \textcolor{keywordflow}{if}( i>0 ) raw_printf(p->out, \textcolor{stringliteral}{","});
10708         \textcolor{keywordflow}{if}( (azArg[i]==0) || (aiType && aiType[i]==SQLITE_NULL) )\{
10709           utf8_printf(p->out,\textcolor{stringliteral}{"NULL"});
10710         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( aiType && aiType[i]==SQLITE_TEXT )\{
10711           output_quoted_string(p->out, azArg[i]);
10712         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( aiType && aiType[i]==SQLITE_INTEGER )\{
10713           utf8_printf(p->out,\textcolor{stringliteral}{"%s"}, azArg[i]);
10714         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( aiType && aiType[i]==SQLITE_FLOAT )\{
10715           \textcolor{keywordtype}{char} z[50];
10716           \textcolor{keywordtype}{double} r = sqlite3_column_double(p->pStmt, i);
10717           sqlite3_snprintf(50,z,\textcolor{stringliteral}{"%!.20g"}, r);
10718           raw_printf(p->out, \textcolor{stringliteral}{"%s"}, z);
10719         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( aiType && aiType[i]==SQLITE_BLOB && p->pStmt )\{
10720           \textcolor{keyword}{const} \textcolor{keywordtype}{void} *pBlob = sqlite3_column_blob(p->pStmt, i);
10721           \textcolor{keywordtype}{int} nBlob = sqlite3_column_bytes(p->pStmt, i);
10722           output_hex_blob(p->out, pBlob, nBlob);
10723         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( isNumber(azArg[i], 0) )\{
10724           utf8_printf(p->out,\textcolor{stringliteral}{"%s"}, azArg[i]);
10725         \}\textcolor{keywordflow}{else}\{
10726           output_quoted_string(p->out, azArg[i]);
10727         \}
10728       \}
10729       raw_printf(p->out,\textcolor{stringliteral}{"\(\backslash\)n"});
10730       \textcolor{keywordflow}{break};
10731     \}
10732     \textcolor{keywordflow}{case} MODE_Ascii: \{
10733       \textcolor{keywordflow}{if}( p->cnt++==0 && p->showHeader )\{
10734         \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10735           \textcolor{keywordflow}{if}( i>0 ) utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->colSeparator);
10736           utf8_printf(p->out,\textcolor{stringliteral}{"%s"},azCol[i] ? azCol[i] : \textcolor{stringliteral}{""});
10737         \}
10738         utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->rowSeparator);
10739       \}
10740       \textcolor{keywordflow}{if}( azArg==0 ) \textcolor{keywordflow}{break};
10741       \textcolor{keywordflow}{for}(i=0; i<nArg; i++)\{
10742         \textcolor{keywordflow}{if}( i>0 ) utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->colSeparator);
10743         utf8_printf(p->out,\textcolor{stringliteral}{"%s"},azArg[i] ? azArg[i] : p->nullValue);
10744       \}
10745       utf8_printf(p->out, \textcolor{stringliteral}{"%s"}, p->rowSeparator);
10746       \textcolor{keywordflow}{break};
10747     \}
10748     \textcolor{keywordflow}{case} MODE_EQP: \{
10749       eqp_append(p, atoi(azArg[0]), atoi(azArg[1]), azArg[3]);
10750       \textcolor{keywordflow}{break};
10751     \}
10752   \}
10753   \textcolor{keywordflow}{return} 0;
10754 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae14540c85a0c98d51e624a74a054cd50}} 
\index{shell.\+c@{shell.\+c}!shell\+\_\+dbinfo\+\_\+command@{shell\+\_\+dbinfo\+\_\+command}}
\index{shell\+\_\+dbinfo\+\_\+command@{shell\+\_\+dbinfo\+\_\+command}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+\_\+dbinfo\+\_\+command()}
{\footnotesize\ttfamily static int shell\+\_\+dbinfo\+\_\+command (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{int}]{n\+Arg,  }\item[{char $\ast$$\ast$}]{az\+Arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13498 of file shell.\+c.



References Array\+Size, Shell\+State\+::db, db\+\_\+int(), get2byte\+Int(), get4byte\+Int(), open\+\_\+db(), Shell\+State\+::out, raw\+\_\+printf, sqlite3\+\_\+bind\+\_\+text, sqlite3\+\_\+column\+\_\+blob, sqlite3\+\_\+column\+\_\+bytes, sqlite3\+\_\+compileoption\+\_\+used, sqlite3\+\_\+errmsg, sqlite3\+\_\+file\+\_\+control, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+F\+C\+N\+T\+L\+\_\+\+D\+A\+T\+A\+\_\+\+V\+E\+R\+S\+I\+ON, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+IC, utf8\+\_\+printf, and z\+Name.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13498                                                                       \{
13499   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }\{ \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zName; \textcolor{keywordtype}{int} ofst; \} aField[] = \{
13500      \{ \textcolor{stringliteral}{"file change counter:"},  24  \},
13501      \{ \textcolor{stringliteral}{"database page count:"},  28  \},
13502      \{ \textcolor{stringliteral}{"freelist page count:"},  36  \},
13503      \{ \textcolor{stringliteral}{"schema cookie:"},        40  \},
13504      \{ \textcolor{stringliteral}{"schema format:"},        44  \},
13505      \{ \textcolor{stringliteral}{"default cache size:"},   48  \},
13506      \{ \textcolor{stringliteral}{"autovacuum top root:"},  52  \},
13507      \{ \textcolor{stringliteral}{"incremental vacuum:"},   64  \},
13508      \{ \textcolor{stringliteral}{"text encoding:"},        56  \},
13509      \{ \textcolor{stringliteral}{"user version:"},         60  \},
13510      \{ \textcolor{stringliteral}{"application id:"},       68  \},
13511      \{ \textcolor{stringliteral}{"software version:"},     96  \},
13512   \};
13513   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{struct }\{ \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zName; \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql; \} aQuery[] = \{
13514      \{ \textcolor{stringliteral}{"number of tables:"},
13515        \textcolor{stringliteral}{"SELECT count(*) FROM %s WHERE type='table'"} \},
13516      \{ \textcolor{stringliteral}{"number of indexes:"},
13517        \textcolor{stringliteral}{"SELECT count(*) FROM %s WHERE type='index'"} \},
13518      \{ \textcolor{stringliteral}{"number of triggers:"},
13519        \textcolor{stringliteral}{"SELECT count(*) FROM %s WHERE type='trigger'"} \},
13520      \{ \textcolor{stringliteral}{"number of views:"},
13521        \textcolor{stringliteral}{"SELECT count(*) FROM %s WHERE type='view'"} \},
13522      \{ \textcolor{stringliteral}{"schema size:"},
13523        \textcolor{stringliteral}{"SELECT total(length(sql)) FROM %s"} \},
13524   \};
13525   \textcolor{keywordtype}{int} i, rc;
13526   \textcolor{keywordtype}{unsigned} iDataVersion;
13527   \textcolor{keywordtype}{char} *zSchemaTab;
13528   \textcolor{keywordtype}{char} *zDb = nArg>=2 ? azArg[1] : \textcolor{stringliteral}{"main"};
13529   sqlite3_stmt *pStmt = 0;
13530   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} aHdr[100];
13531   open_db(p, 0);
13532   \textcolor{keywordflow}{if}( p->db==0 ) \textcolor{keywordflow}{return} 1;
13533   rc = sqlite3_prepare_v2(p->db,
13534              \textcolor{stringliteral}{"SELECT data FROM sqlite\_dbpage(?1) WHERE pgno=1"},
13535              -1, &pStmt, 0);
13536   \textcolor{keywordflow}{if}( rc )\{
13537     \textcolor{keywordflow}{if}( !sqlite3_compileoption_used(\textcolor{stringliteral}{"ENABLE\_DBPAGE\_VTAB"}) )\{
13538       utf8_printf(stderr, \textcolor{stringliteral}{"the \(\backslash\)".dbinfo\(\backslash\)" command requires the "}
13539                           \textcolor{stringliteral}{"-DSQLITE\_ENABLE\_DBPAGE\_VTAB compile-time options\(\backslash\)n"});
13540     \}\textcolor{keywordflow}{else}\{
13541       utf8_printf(stderr, \textcolor{stringliteral}{"error: %s\(\backslash\)n"}, sqlite3_errmsg(p->db));
13542     \}
13543     sqlite3_finalize(pStmt);
13544     \textcolor{keywordflow}{return} 1;
13545   \}
13546   sqlite3_bind_text(pStmt, 1, zDb, -1, SQLITE_STATIC);
13547   \textcolor{keywordflow}{if}( sqlite3_step(pStmt)==SQLITE_ROW
13548    && sqlite3_column_bytes(pStmt,0)>100
13549   )\{
13550     memcpy(aHdr, sqlite3_column_blob(pStmt,0), 100);
13551     sqlite3_finalize(pStmt);
13552   \}\textcolor{keywordflow}{else}\{
13553     raw_printf(stderr, \textcolor{stringliteral}{"unable to read database header\(\backslash\)n"});
13554     sqlite3_finalize(pStmt);
13555     \textcolor{keywordflow}{return} 1;
13556   \}
13557   i = get2byteInt(aHdr+16);
13558   \textcolor{keywordflow}{if}( i==1 ) i = 65536;
13559   utf8_printf(p->out, \textcolor{stringliteral}{"%-20s %d\(\backslash\)n"}, \textcolor{stringliteral}{"database page size:"}, i);
13560   utf8_printf(p->out, \textcolor{stringliteral}{"%-20s %d\(\backslash\)n"}, \textcolor{stringliteral}{"write format:"}, aHdr[18]);
13561   utf8_printf(p->out, \textcolor{stringliteral}{"%-20s %d\(\backslash\)n"}, \textcolor{stringliteral}{"read format:"}, aHdr[19]);
13562   utf8_printf(p->out, \textcolor{stringliteral}{"%-20s %d\(\backslash\)n"}, \textcolor{stringliteral}{"reserved bytes:"}, aHdr[20]);
13563   \textcolor{keywordflow}{for}(i=0; i<ArraySize(aField); i++)\{
13564     \textcolor{keywordtype}{int} ofst = aField[i].ofst;
13565     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} val = get4byteInt(aHdr + ofst);
13566     utf8_printf(p->out, \textcolor{stringliteral}{"%-20s %u"}, aField[i].zName, val);
13567     \textcolor{keywordflow}{switch}( ofst )\{
13568       \textcolor{keywordflow}{case} 56: \{
13569         \textcolor{keywordflow}{if}( val==1 ) raw_printf(p->out, \textcolor{stringliteral}{" (utf8)"});
13570         \textcolor{keywordflow}{if}( val==2 ) raw_printf(p->out, \textcolor{stringliteral}{" (utf16le)"});
13571         \textcolor{keywordflow}{if}( val==3 ) raw_printf(p->out, \textcolor{stringliteral}{" (utf16be)"});
13572       \}
13573     \}
13574     raw_printf(p->out, \textcolor{stringliteral}{"\(\backslash\)n"});
13575   \}
13576   \textcolor{keywordflow}{if}( zDb==0 )\{
13577     zSchemaTab = sqlite3_mprintf(\textcolor{stringliteral}{"main.sqlite\_master"});
13578   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( strcmp(zDb,\textcolor{stringliteral}{"temp"})==0 )\{
13579     zSchemaTab = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"sqlite\_temp\_master"});
13580   \}\textcolor{keywordflow}{else}\{
13581     zSchemaTab = sqlite3_mprintf(\textcolor{stringliteral}{"\(\backslash\)"%w\(\backslash\)".sqlite\_master"}, zDb);
13582   \}
13583   \textcolor{keywordflow}{for}(i=0; i<ArraySize(aQuery); i++)\{
13584     \textcolor{keywordtype}{char} *zSql = sqlite3_mprintf(aQuery[i].zSql, zSchemaTab);
13585     \textcolor{keywordtype}{int} val = db_int(p, zSql);
13586     sqlite3_free(zSql);
13587     utf8_printf(p->out, \textcolor{stringliteral}{"%-20s %d\(\backslash\)n"}, aQuery[i].zName, val);
13588   \}
13589   sqlite3_free(zSchemaTab);
13590   sqlite3_file_control(p->db, zDb, SQLITE_FCNTL_DATA_VERSION, &iDataVersion);
13591   utf8_printf(p->out, \textcolor{stringliteral}{"%-20s %u\(\backslash\)n"}, \textcolor{stringliteral}{"data version"}, iDataVersion);
13592   \textcolor{keywordflow}{return} 0;
13593 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a39652642fc40eef086a84ef2e55b5f6d}} 
\index{shell.\+c@{shell.\+c}!shell\+\_\+exec@{shell\+\_\+exec}}
\index{shell\+\_\+exec@{shell\+\_\+exec}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+\_\+exec()}
{\footnotesize\ttfamily static int shell\+\_\+exec (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p\+Arg,  }\item[{const char $\ast$}]{z\+Sql,  }\item[{char $\ast$$\ast$}]{pz\+Err\+Msg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11590 of file shell.\+c.



References Shell\+State\+::auto\+E\+QP, A\+U\+T\+O\+E\+Q\+P\+\_\+full, A\+U\+T\+O\+E\+Q\+P\+\_\+trigger, Shell\+State\+::auto\+Explain, bind\+\_\+prepared\+\_\+stmt(), Shell\+State\+::c\+Mode, Shell\+State\+::cnt, Shell\+State\+::db, disable\+\_\+debug\+\_\+trace\+\_\+modes(), display\+\_\+scanstats(), display\+\_\+stats(), eqp\+\_\+append(), eqp\+\_\+render(), exec\+\_\+prepared\+\_\+stmt(), Shell\+State\+::expert, expert\+Finish(), expert\+Handle\+S\+Q\+L(), explain\+\_\+data\+\_\+delete(), explain\+\_\+data\+\_\+prepare(), Is\+Space, Shell\+State\+::mode, M\+O\+D\+E\+\_\+\+E\+QP, M\+O\+D\+E\+\_\+\+Explain, Shell\+State\+::out, Expert\+Info\+::p\+Expert, Shell\+State\+::p\+Stmt, restore\+\_\+debug\+\_\+trace\+\_\+modes(), save\+\_\+err\+\_\+msg(), Shell\+State\+::scanstats\+On, Shell\+Has\+Flag, S\+H\+F\+L\+G\+\_\+\+Echo, sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+db\+\_\+config, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+sql, sqlite3\+\_\+step, sqlite3\+\_\+stmt\+\_\+isexplain, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+T\+R\+I\+G\+G\+E\+R\+\_\+\+E\+QP, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, Shell\+State\+::stats\+On, and utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command(), dump\+\_\+callback(), main(), and run\+One\+Sql\+Line().


\begin{DoxyCode}
11594  \{
11595   sqlite3_stmt *pStmt = NULL;     \textcolor{comment}{/* Statement to execute. */}
11596   \textcolor{keywordtype}{int} rc = SQLITE_OK;             \textcolor{comment}{/* Return Code */}
11597   \textcolor{keywordtype}{int} rc2;
11598   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zLeftover;          \textcolor{comment}{/* Tail of unprocessed SQL */}
11599   sqlite3 *db = pArg->db;
11600 
11601   \textcolor{keywordflow}{if}( pzErrMsg )\{
11602     *pzErrMsg = NULL;
11603   \}
11604 
11605 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_VIRTUALTABLE}
11606   \textcolor{keywordflow}{if}( pArg->expert.pExpert )\{
11607     rc = expertHandleSQL(pArg, zSql, pzErrMsg);
11608     \textcolor{keywordflow}{return} expertFinish(pArg, (rc!=SQLITE_OK), pzErrMsg);
11609   \}
11610 \textcolor{preprocessor}{#endif}
11611 
11612   \textcolor{keywordflow}{while}( zSql[0] && (SQLITE_OK == rc) )\{
11613     \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zStmtSql;
11614     rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
11615     \textcolor{keywordflow}{if}( SQLITE_OK != rc )\{
11616       \textcolor{keywordflow}{if}( pzErrMsg )\{
11617         *pzErrMsg = save_err_msg(db);
11618       \}
11619     \}\textcolor{keywordflow}{else}\{
11620       \textcolor{keywordflow}{if}( !pStmt )\{
11621         \textcolor{comment}{/* this happens for a comment or white-space */}
11622         zSql = zLeftover;
11623         \textcolor{keywordflow}{while}( IsSpace(zSql[0]) ) zSql++;
11624         \textcolor{keywordflow}{continue};
11625       \}
11626       zStmtSql = sqlite3_sql(pStmt);
11627       \textcolor{keywordflow}{if}( zStmtSql==0 ) zStmtSql = \textcolor{stringliteral}{""};
11628       \textcolor{keywordflow}{while}( IsSpace(zStmtSql[0]) ) zStmtSql++;
11629 
11630       \textcolor{comment}{/* save off the prepared statment handle and reset row count */}
11631       \textcolor{keywordflow}{if}( pArg )\{
11632         pArg->pStmt = pStmt;
11633         pArg->cnt = 0;
11634       \}
11635 
11636       \textcolor{comment}{/* echo the sql statement if echo on */}
11637       \textcolor{keywordflow}{if}( pArg && ShellHasFlag(pArg, SHFLG_Echo) )\{
11638         utf8_printf(pArg->out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, zStmtSql ? zStmtSql : zSql);
11639       \}
11640 
11641       \textcolor{comment}{/* Show the EXPLAIN QUERY PLAN if .eqp is on */}
11642       \textcolor{keywordflow}{if}( pArg && pArg->autoEQP && sqlite3_stmt_isexplain(pStmt)==0 )\{
11643         sqlite3_stmt *pExplain;
11644         \textcolor{keywordtype}{char} *zEQP;
11645         \textcolor{keywordtype}{int} triggerEQP = 0;
11646         disable_debug_trace_modes();
11647         sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, -1, &triggerEQP);
11648         \textcolor{keywordflow}{if}( pArg->autoEQP>=AUTOEQP_trigger )\{
11649           sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, 1, 0);
11650         \}
11651         zEQP = sqlite3_mprintf(\textcolor{stringliteral}{"EXPLAIN QUERY PLAN %s"}, zStmtSql);
11652         rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);
11653         \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
11654           \textcolor{keywordflow}{while}( sqlite3_step(pExplain)==SQLITE_ROW )\{
11655             \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zEQPLine = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pExplain,3);
11656             \textcolor{keywordtype}{int} iEqpId = sqlite3_column_int(pExplain, 0);
11657             \textcolor{keywordtype}{int} iParentId = sqlite3_column_int(pExplain, 1);
11658             \textcolor{keywordflow}{if}( zEQPLine[0]==\textcolor{charliteral}{'-'} ) eqp_render(pArg);
11659             eqp_append(pArg, iEqpId, iParentId, zEQPLine);
11660           \}
11661           eqp_render(pArg);
11662         \}
11663         sqlite3_finalize(pExplain);
11664         sqlite3_free(zEQP);
11665         \textcolor{keywordflow}{if}( pArg->autoEQP>=AUTOEQP_full )\{
11666           \textcolor{comment}{/* Also do an EXPLAIN for ".eqp full" mode */}
11667           zEQP = sqlite3_mprintf(\textcolor{stringliteral}{"EXPLAIN %s"}, zStmtSql);
11668           rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);
11669           \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
11670             pArg->cMode = MODE_Explain;
11671             explain_data_prepare(pArg, pExplain);
11672             exec_prepared_stmt(pArg, pExplain);
11673             explain_data_delete(pArg);
11674           \}
11675           sqlite3_finalize(pExplain);
11676           sqlite3_free(zEQP);
11677         \}
11678         \textcolor{keywordflow}{if}( pArg->autoEQP>=AUTOEQP_trigger && triggerEQP==0 )\{
11679           sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, 0, 0);
11680           \textcolor{comment}{/* Reprepare pStmt before reactiving trace modes */}
11681           sqlite3_finalize(pStmt);
11682           sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
11683           \textcolor{keywordflow}{if}( pArg ) pArg->pStmt = pStmt;
11684         \}
11685         restore_debug_trace_modes();
11686       \}
11687 
11688       \textcolor{keywordflow}{if}( pArg )\{
11689         pArg->cMode = pArg->mode;
11690         \textcolor{keywordflow}{if}( pArg->autoExplain )\{
11691           \textcolor{keywordflow}{if}( sqlite3_stmt_isexplain(pStmt)==1 )\{
11692             pArg->cMode = MODE_Explain;
11693           \}
11694           \textcolor{keywordflow}{if}( sqlite3_stmt_isexplain(pStmt)==2 )\{
11695             pArg->cMode = MODE_EQP;
11696           \}
11697         \}
11698 
11699         \textcolor{comment}{/* If the shell is currently in ".explain" mode, gather the extra}
11700 \textcolor{comment}{        ** data required to add indents to the output.*/}
11701         \textcolor{keywordflow}{if}( pArg->cMode==MODE_Explain )\{
11702           explain_data_prepare(pArg, pStmt);
11703         \}
11704       \}
11705 
11706       bind_prepared_stmt(pArg, pStmt);
11707       exec_prepared_stmt(pArg, pStmt);
11708       explain_data_delete(pArg);
11709       eqp_render(pArg);
11710 
11711       \textcolor{comment}{/* print usage stats if stats on */}
11712       \textcolor{keywordflow}{if}( pArg && pArg->statsOn )\{
11713         display_stats(db, pArg, 0);
11714       \}
11715 
11716       \textcolor{comment}{/* print loop-counters if required */}
11717       \textcolor{keywordflow}{if}( pArg && pArg->scanstatsOn )\{
11718         display_scanstats(db, pArg);
11719       \}
11720 
11721       \textcolor{comment}{/* Finalize the statement just executed. If this fails, save a}
11722 \textcolor{comment}{      ** copy of the error message. Otherwise, set zSql to point to the}
11723 \textcolor{comment}{      ** next statement to execute. */}
11724       rc2 = sqlite3_finalize(pStmt);
11725       \textcolor{keywordflow}{if}( rc!=SQLITE_NOMEM ) rc = rc2;
11726       \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
11727         zSql = zLeftover;
11728         \textcolor{keywordflow}{while}( IsSpace(zSql[0]) ) zSql++;
11729       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( pzErrMsg )\{
11730         *pzErrMsg = save_err_msg(db);
11731       \}
11732 
11733       \textcolor{comment}{/* clear saved stmt handle */}
11734       \textcolor{keywordflow}{if}( pArg )\{
11735         pArg->pStmt = NULL;
11736       \}
11737     \}
11738   \} \textcolor{comment}{/* end while */}
11739 
11740   \textcolor{keywordflow}{return} rc;
11741 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad9cec55c094e808a15451bc1255e002e}} 
\index{shell.\+c@{shell.\+c}!shell\+\_\+out\+\_\+of\+\_\+memory@{shell\+\_\+out\+\_\+of\+\_\+memory}}
\index{shell\+\_\+out\+\_\+of\+\_\+memory@{shell\+\_\+out\+\_\+of\+\_\+memory}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+\_\+out\+\_\+of\+\_\+memory()}
{\footnotesize\ttfamily static void shell\+\_\+out\+\_\+of\+\_\+memory (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 464 of file shell.\+c.



References raw\+\_\+printf, sqlite3\+\_\+free, sqlite3\+\_\+vmprintf, S\+Q\+L\+I\+T\+E\+\_\+\+C\+D\+E\+CL, and utf8\+\_\+printf.



Referenced by append\+Text(), do\+\_\+meta\+\_\+command(), eqp\+\_\+append(), explain\+\_\+data\+\_\+prepare(), import\+\_\+append\+\_\+char(), local\+\_\+getline(), main(), process\+\_\+input(), set\+\_\+table\+\_\+name(), table\+Column\+List(), and try\+To\+Clone\+Data().


\begin{DoxyCode}
464                                      \{
465   raw_printf(stderr,\textcolor{stringliteral}{"Error: out of memory\(\backslash\)n"});
466   exit(1);
467 \}
\end{DoxyCode}
\mbox{\label{shell_8c_acc3c7edf16cc54d011aa272f91fc9b44}} 
\index{shell.\+c@{shell.\+c}!shell\+Add\+Schema\+Name@{shell\+Add\+Schema\+Name}}
\index{shell\+Add\+Schema\+Name@{shell\+Add\+Schema\+Name}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Add\+Schema\+Name()}
{\footnotesize\ttfamily static void shell\+Add\+Schema\+Name (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{p\+Ctx,  }\item[{int}]{n\+Val,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{ap\+Val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 889 of file shell.\+c.



References a\+Prefix, quote\+Char(), shell\+Fake\+Schema(), sqlite3\+\_\+context\+\_\+db\+\_\+handle, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+result\+\_\+text, sqlite3\+\_\+result\+\_\+value, sqlite3\+\_\+stricmp, sqlite3\+\_\+value\+\_\+text, strlen30(), U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER, and z\+Name.



Referenced by open\+\_\+db().


\begin{DoxyCode}
893  \{
894   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *aPrefix[] = \{
895      \textcolor{stringliteral}{"TABLE"},
896      \textcolor{stringliteral}{"INDEX"},
897      \textcolor{stringliteral}{"UNIQUE INDEX"},
898      \textcolor{stringliteral}{"VIEW"},
899      \textcolor{stringliteral}{"TRIGGER"},
900      \textcolor{stringliteral}{"VIRTUAL TABLE"}
901   \};
902   \textcolor{keywordtype}{int} i = 0;
903   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zIn = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(apVal[0]);
904   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSchema = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(apVal[1]);
905   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zName = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(apVal[2]);
906   sqlite3 *db = sqlite3_context_db_handle(pCtx);
907   UNUSED_PARAMETER(nVal);
908   \textcolor{keywordflow}{if}( zIn!=0 && strncmp(zIn, \textcolor{stringliteral}{"CREATE "}, 7)==0 )\{
909     \textcolor{keywordflow}{for}(i=0; i<(int)(\textcolor{keyword}{sizeof}(aPrefix)/\textcolor{keyword}{sizeof}(aPrefix[0])); i++)\{
910       \textcolor{keywordtype}{int} n = strlen30(aPrefix[i]);
911       \textcolor{keywordflow}{if}( strncmp(zIn+7, aPrefix[i], n)==0 && zIn[n+7]==\textcolor{charliteral}{' '} )\{
912         \textcolor{keywordtype}{char} *z = 0;
913         \textcolor{keywordtype}{char} *zFake = 0;
914         \textcolor{keywordflow}{if}( zSchema )\{
915           \textcolor{keywordtype}{char} cQuote = quoteChar(zSchema);
916           \textcolor{keywordflow}{if}( cQuote && sqlite3_stricmp(zSchema,\textcolor{stringliteral}{"temp"})!=0 )\{
917             z = sqlite3_mprintf(\textcolor{stringliteral}{"%.*s \(\backslash\)"%w\(\backslash\)".%s"}, n+7, zIn, zSchema, zIn+n+8);
918           \}\textcolor{keywordflow}{else}\{
919             z = sqlite3_mprintf(\textcolor{stringliteral}{"%.*s %s.%s"}, n+7, zIn, zSchema, zIn+n+8);
920           \}
921         \}
922         \textcolor{keywordflow}{if}( zName
923          && aPrefix[i][0]==\textcolor{charliteral}{'V'}
924          && (zFake = shellFakeSchema(db, zSchema, zName))!=0
925         )\{
926           \textcolor{keywordflow}{if}( z==0 )\{
927             z = sqlite3_mprintf(\textcolor{stringliteral}{"%s\(\backslash\)n/* %s */"}, zIn, zFake);
928           \}\textcolor{keywordflow}{else}\{
929             z = sqlite3_mprintf(\textcolor{stringliteral}{"%z\(\backslash\)n/* %s */"}, z, zFake);
930           \}
931           free(zFake);
932         \}
933         \textcolor{keywordflow}{if}( z )\{
934           sqlite3_result_text(pCtx, z, -1, sqlite3_free);
935           \textcolor{keywordflow}{return};
936         \}
937       \}
938     \}
939   \}
940   sqlite3_result_value(pCtx, apVal[0]);
941 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ac32934502c80588db3db6280d817d86e}} 
\index{shell.\+c@{shell.\+c}!shell\+Auth@{shell\+Auth}}
\index{shell\+Auth@{shell\+Auth}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Auth()}
{\footnotesize\ttfamily static int shell\+Auth (\begin{DoxyParamCaption}\item[{void $\ast$}]{p\+Client\+Data,  }\item[{int}]{op,  }\item[{const char $\ast$}]{z\+A1,  }\item[{const char $\ast$}]{z\+A2,  }\item[{const char $\ast$}]{z\+A3,  }\item[{const char $\ast$}]{z\+A4 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10201 of file shell.\+c.



References Shell\+State\+::out, output\+\_\+c\+\_\+string(), raw\+\_\+printf, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
10208  \{
10209   ShellState *p = (ShellState*)pClientData;
10210   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{char} *azAction[] = \{ 0,
10211      \textcolor{stringliteral}{"CREATE\_INDEX"},         \textcolor{stringliteral}{"CREATE\_TABLE"},         \textcolor{stringliteral}{"CREATE\_TEMP\_INDEX"},
10212      \textcolor{stringliteral}{"CREATE\_TEMP\_TABLE"},    \textcolor{stringliteral}{"CREATE\_TEMP\_TRIGGER"},  \textcolor{stringliteral}{"CREATE\_TEMP\_VIEW"},
10213      \textcolor{stringliteral}{"CREATE\_TRIGGER"},       \textcolor{stringliteral}{"CREATE\_VIEW"},          \textcolor{stringliteral}{"DELETE"},
10214      \textcolor{stringliteral}{"DROP\_INDEX"},           \textcolor{stringliteral}{"DROP\_TABLE"},           \textcolor{stringliteral}{"DROP\_TEMP\_INDEX"},
10215      \textcolor{stringliteral}{"DROP\_TEMP\_TABLE"},      \textcolor{stringliteral}{"DROP\_TEMP\_TRIGGER"},    \textcolor{stringliteral}{"DROP\_TEMP\_VIEW"},
10216      \textcolor{stringliteral}{"DROP\_TRIGGER"},         \textcolor{stringliteral}{"DROP\_VIEW"},            \textcolor{stringliteral}{"INSERT"},
10217      \textcolor{stringliteral}{"PRAGMA"},               \textcolor{stringliteral}{"READ"},                 \textcolor{stringliteral}{"SELECT"},
10218      \textcolor{stringliteral}{"TRANSACTION"},          \textcolor{stringliteral}{"UPDATE"},               \textcolor{stringliteral}{"ATTACH"},
10219      \textcolor{stringliteral}{"DETACH"},               \textcolor{stringliteral}{"ALTER\_TABLE"},          \textcolor{stringliteral}{"REINDEX"},
10220      \textcolor{stringliteral}{"ANALYZE"},              \textcolor{stringliteral}{"CREATE\_VTABLE"},        \textcolor{stringliteral}{"DROP\_VTABLE"},
10221      \textcolor{stringliteral}{"FUNCTION"},             \textcolor{stringliteral}{"SAVEPOINT"},            \textcolor{stringliteral}{"RECURSIVE"}
10222   \};
10223   \textcolor{keywordtype}{int} i;
10224   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *az[4];
10225   az[0] = zA1;
10226   az[1] = zA2;
10227   az[2] = zA3;
10228   az[3] = zA4;
10229   utf8_printf(p->out, \textcolor{stringliteral}{"authorizer: %s"}, azAction[op]);
10230   \textcolor{keywordflow}{for}(i=0; i<4; i++)\{
10231     raw_printf(p->out, \textcolor{stringliteral}{" "});
10232     \textcolor{keywordflow}{if}( az[i] )\{
10233       output_c_string(p->out, az[i]);
10234     \}\textcolor{keywordflow}{else}\{
10235       raw_printf(p->out, \textcolor{stringliteral}{"NULL"});
10236     \}
10237   \}
10238   raw_printf(p->out, \textcolor{stringliteral}{"\(\backslash\)n"});
10239   \textcolor{keywordflow}{return} SQLITE_OK;
10240 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a0f7da77f9231d57dfbd903726e52599d}} 
\index{shell.\+c@{shell.\+c}!shell\+Database\+Error@{shell\+Database\+Error}}
\index{shell\+Database\+Error@{shell\+Database\+Error}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Database\+Error()}
{\footnotesize\ttfamily static int shell\+Database\+Error (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13598 of file shell.\+c.



References sqlite3\+\_\+errmsg, and utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13598                                           \{
13599   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zErr = sqlite3_errmsg(db);
13600   utf8_printf(stderr, \textcolor{stringliteral}{"Error: %s\(\backslash\)n"}, zErr);
13601   \textcolor{keywordflow}{return} 1;
13602 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae947adfb82ce715b82e7c3456cedb59d}} 
\index{shell.\+c@{shell.\+c}!shell\+Delete\+File@{shell\+Delete\+File}}
\index{shell\+Delete\+File@{shell\+Delete\+File}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Delete\+File()}
{\footnotesize\ttfamily int shell\+Delete\+File (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Filename }\end{DoxyParamCaption})}



Definition at line 13716 of file shell.\+c.



References sqlite3\+\_\+free.



Referenced by clear\+Temp\+File(), and do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13716                                           \{
13717   \textcolor{keywordtype}{int} rc;
13718 \textcolor{preprocessor}{#ifdef \_WIN32}
13719   \textcolor{keywordtype}{wchar\_t} *z = sqlite3\_win32\_utf8\_to\_unicode(zFilename);
13720   rc = \_wunlink(z);
13721   sqlite3_free(z);
13722 \textcolor{preprocessor}{#else}
13723   rc = unlink(zFilename);
13724 \textcolor{preprocessor}{#endif}
13725   \textcolor{keywordflow}{return} rc;
13726 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a1feeb4254c9d8aec63ad810297e0312d}} 
\index{shell.\+c@{shell.\+c}!shell\+Escape\+Crnl@{shell\+Escape\+Crnl}}
\index{shell\+Escape\+Crnl@{shell\+Escape\+Crnl}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Escape\+Crnl()}
{\footnotesize\ttfamily static void shell\+Escape\+Crnl (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{context,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12592 of file shell.\+c.



References sqlite3\+\_\+free, sqlite3\+\_\+malloc64, sqlite3\+\_\+result\+\_\+error\+\_\+nomem, sqlite3\+\_\+result\+\_\+text, sqlite3\+\_\+result\+\_\+value, sqlite3\+\_\+value\+\_\+bytes, sqlite3\+\_\+value\+\_\+text, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT, U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER, and unused\+\_\+string().



Referenced by open\+\_\+db().


\begin{DoxyCode}
12596  \{
12597   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zText = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(argv[0]);
12598   UNUSED_PARAMETER(argc);
12599   \textcolor{keywordflow}{if}( zText[0]==\textcolor{charliteral}{'\(\backslash\)''} )\{
12600     \textcolor{keywordtype}{int} nText = sqlite3_value_bytes(argv[0]);
12601     \textcolor{keywordtype}{int} i;
12602     \textcolor{keywordtype}{char} zBuf1[20];
12603     \textcolor{keywordtype}{char} zBuf2[20];
12604     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zNL = 0;
12605     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCR = 0;
12606     \textcolor{keywordtype}{int} nCR = 0;
12607     \textcolor{keywordtype}{int} nNL = 0;
12608 
12609     \textcolor{keywordflow}{for}(i=0; zText[i]; i++)\{
12610       \textcolor{keywordflow}{if}( zNL==0 && zText[i]==\textcolor{charliteral}{'\(\backslash\)n'} )\{
12611         zNL = unused_string(zText, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)n"}, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)012"}, zBuf1);
12612         nNL = (int)strlen(zNL);
12613       \}
12614       \textcolor{keywordflow}{if}( zCR==0 && zText[i]==\textcolor{charliteral}{'\(\backslash\)r'} )\{
12615         zCR = unused_string(zText, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)r"}, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)015"}, zBuf2);
12616         nCR = (int)strlen(zCR);
12617       \}
12618     \}
12619 
12620     \textcolor{keywordflow}{if}( zNL || zCR )\{
12621       \textcolor{keywordtype}{int} iOut = 0;
12622       i64 nMax = (nNL > nCR) ? nNL : nCR;
12623       i64 nAlloc = nMax * nText + (nMax+64)*2;
12624       \textcolor{keywordtype}{char} *zOut = (\textcolor{keywordtype}{char}*)sqlite3_malloc64(nAlloc);
12625       \textcolor{keywordflow}{if}( zOut==0 )\{
12626         sqlite3_result_error_nomem(context);
12627         \textcolor{keywordflow}{return};
12628       \}
12629 
12630       \textcolor{keywordflow}{if}( zNL && zCR )\{
12631         memcpy(&zOut[iOut], \textcolor{stringliteral}{"replace(replace("}, 16);
12632         iOut += 16;
12633       \}\textcolor{keywordflow}{else}\{
12634         memcpy(&zOut[iOut], \textcolor{stringliteral}{"replace("}, 8);
12635         iOut += 8;
12636       \}
12637       \textcolor{keywordflow}{for}(i=0; zText[i]; i++)\{
12638         \textcolor{keywordflow}{if}( zText[i]==\textcolor{charliteral}{'\(\backslash\)n'} )\{
12639           memcpy(&zOut[iOut], zNL, nNL);
12640           iOut += nNL;
12641         \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( zText[i]==\textcolor{charliteral}{'\(\backslash\)r'} )\{
12642           memcpy(&zOut[iOut], zCR, nCR);
12643           iOut += nCR;
12644         \}\textcolor{keywordflow}{else}\{
12645           zOut[iOut] = zText[i];
12646           iOut++;
12647         \}
12648       \}
12649 
12650       \textcolor{keywordflow}{if}( zNL )\{
12651         memcpy(&zOut[iOut], \textcolor{stringliteral}{",'"}, 2); iOut += 2;
12652         memcpy(&zOut[iOut], zNL, nNL); iOut += nNL;
12653         memcpy(&zOut[iOut], \textcolor{stringliteral}{"', char(10))"}, 12); iOut += 12;
12654       \}
12655       \textcolor{keywordflow}{if}( zCR )\{
12656         memcpy(&zOut[iOut], \textcolor{stringliteral}{",'"}, 2); iOut += 2;
12657         memcpy(&zOut[iOut], zCR, nCR); iOut += nCR;
12658         memcpy(&zOut[iOut], \textcolor{stringliteral}{"', char(13))"}, 12); iOut += 12;
12659       \}
12660 
12661       sqlite3_result_text(context, zOut, iOut, SQLITE_TRANSIENT);
12662       sqlite3_free(zOut);
12663       \textcolor{keywordflow}{return};
12664     \}
12665   \}
12666 
12667   sqlite3_result_value(context, argv[0]);
12668 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ad231d3e23ccc186d0a0176147c695954}} 
\index{shell.\+c@{shell.\+c}!shell\+Fake\+Schema@{shell\+Fake\+Schema}}
\index{shell\+Fake\+Schema@{shell\+Fake\+Schema}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Fake\+Schema()}
{\footnotesize\ttfamily static char$\ast$ shell\+Fake\+Schema (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{const char $\ast$}]{z\+Schema,  }\item[{const char $\ast$}]{z\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 807 of file shell.\+c.



References append\+Text(), free\+Text(), init\+Text(), quote\+Char(), sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+step, sqlite3\+\_\+stricmp, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, and Shell\+Text\+::z.



Referenced by shell\+Add\+Schema\+Name(), and shell\+Module\+Schema().


\begin{DoxyCode}
811  \{
812   sqlite3_stmt *pStmt = 0;
813   \textcolor{keywordtype}{char} *zSql;
814   ShellText s;
815   \textcolor{keywordtype}{char} cQuote;
816   \textcolor{keywordtype}{char} *zDiv = \textcolor{stringliteral}{"("};
817   \textcolor{keywordtype}{int} nRow = 0;
818 
819   zSql = sqlite3_mprintf(\textcolor{stringliteral}{"PRAGMA \(\backslash\)"%w\(\backslash\)".table\_info=%Q;"},
820                          zSchema ? zSchema : \textcolor{stringliteral}{"main"}, zName);
821   sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
822   sqlite3_free(zSql);
823   initText(&s);
824   \textcolor{keywordflow}{if}( zSchema )\{
825     cQuote = quoteChar(zSchema);
826     \textcolor{keywordflow}{if}( cQuote && sqlite3_stricmp(zSchema,\textcolor{stringliteral}{"temp"})==0 ) cQuote = 0;
827     appendText(&s, zSchema, cQuote);
828     appendText(&s, \textcolor{stringliteral}{"."}, 0);
829   \}
830   cQuote = quoteChar(zName);
831   appendText(&s, zName, cQuote);
832   \textcolor{keywordflow}{while}( sqlite3_step(pStmt)==SQLITE_ROW )\{
833     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zCol = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pStmt, 1);
834     nRow++;
835     appendText(&s, zDiv, 0);
836     zDiv = \textcolor{stringliteral}{","};
837     cQuote = quoteChar(zCol);
838     appendText(&s, zCol, cQuote);
839   \}
840   appendText(&s, \textcolor{stringliteral}{")"}, 0);
841   sqlite3_finalize(pStmt);
842   \textcolor{keywordflow}{if}( nRow==0 )\{
843     freeText(&s);
844     s.z = 0;
845   \}
846   \textcolor{keywordflow}{return} s.z;
847 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a9529d82405386872127fd03aa871063d}} 
\index{shell.\+c@{shell.\+c}!shell\+Finalize@{shell\+Finalize}}
\index{shell\+Finalize@{shell\+Finalize}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Finalize()}
{\footnotesize\ttfamily void shell\+Finalize (\begin{DoxyParamCaption}\item[{int $\ast$}]{p\+Rc,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$}]{p\+Stmt }\end{DoxyParamCaption})}



Definition at line 14068 of file shell.\+c.



References raw\+\_\+printf, sqlite3\+\_\+db\+\_\+handle, sqlite3\+\_\+errmsg, sqlite3\+\_\+finalize, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by shell\+Reset().


\begin{DoxyCode}
14071  \{
14072   \textcolor{keywordflow}{if}( pStmt )\{
14073     sqlite3 *db = sqlite3_db_handle(pStmt);
14074     \textcolor{keywordtype}{int} rc = sqlite3_finalize(pStmt);
14075     \textcolor{keywordflow}{if}( *pRc==SQLITE_OK )\{
14076       \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
14077         raw_printf(stderr, \textcolor{stringliteral}{"SQL error: %s\(\backslash\)n"}, sqlite3_errmsg(db));
14078       \}
14079       *pRc = rc;
14080     \}
14081   \}
14082 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab58b75d6f4760b9352046b71749bcbc4}} 
\index{shell.\+c@{shell.\+c}!shell\+Fkey\+Collate\+Clause@{shell\+Fkey\+Collate\+Clause}}
\index{shell\+Fkey\+Collate\+Clause@{shell\+Fkey\+Collate\+Clause}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Fkey\+Collate\+Clause()}
{\footnotesize\ttfamily static void shell\+Fkey\+Collate\+Clause (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{p\+Ctx,  }\item[{int}]{n\+Val,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{ap\+Val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13779 of file shell.\+c.



References sqlite3\+\_\+context\+\_\+db\+\_\+handle, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+result\+\_\+text, sqlite3\+\_\+stricmp, sqlite3\+\_\+table\+\_\+column\+\_\+metadata, sqlite3\+\_\+value\+\_\+text, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+IC, and S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT.



Referenced by lint\+Fkey\+Indexes().


\begin{DoxyCode}
13783  \{
13784   sqlite3 *db = sqlite3_context_db_handle(pCtx);
13785   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zParent;
13786   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zParentCol;
13787   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zParentSeq;
13788   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zChild;
13789   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zChildCol;
13790   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zChildSeq = 0;  \textcolor{comment}{/* Initialize to avoid false-positive warning */}
13791   \textcolor{keywordtype}{int} rc;
13792 
13793   assert( nVal==4 );
13794   zParent = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(apVal[0]);
13795   zParentCol = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(apVal[1]);
13796   zChild = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(apVal[2]);
13797   zChildCol = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(apVal[3]);
13798 
13799   sqlite3_result_text(pCtx, \textcolor{stringliteral}{""}, -1, SQLITE_STATIC);
13800   rc = sqlite3_table_column_metadata(
13801       db, \textcolor{stringliteral}{"main"}, zParent, zParentCol, 0, &zParentSeq, 0, 0, 0
13802   );
13803   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
13804     rc = sqlite3_table_column_metadata(
13805         db, \textcolor{stringliteral}{"main"}, zChild, zChildCol, 0, &zChildSeq, 0, 0, 0
13806     );
13807   \}
13808 
13809   \textcolor{keywordflow}{if}( rc==SQLITE_OK && sqlite3_stricmp(zParentSeq, zChildSeq) )\{
13810     \textcolor{keywordtype}{char} *z = sqlite3_mprintf(\textcolor{stringliteral}{" COLLATE %s"}, zParentSeq);
13811     sqlite3_result_text(pCtx, z, -1, SQLITE_TRANSIENT);
13812     sqlite3_free(z);
13813   \}
13814 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a3d115699c065cff140172babe7e75ad5}} 
\index{shell.\+c@{shell.\+c}!shell\+Id\+Quote@{shell\+Id\+Quote}}
\index{shell\+Id\+Quote@{shell\+Id\+Quote}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Id\+Quote()}
{\footnotesize\ttfamily static void shell\+Id\+Quote (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{context,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12566 of file shell.\+c.



References sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+result\+\_\+text, sqlite3\+\_\+value\+\_\+text, and U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER.



Referenced by open\+\_\+db(), and shell\+Reset().


\begin{DoxyCode}
12570  \{
12571   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zName = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(argv[0]);
12572   UNUSED_PARAMETER(argc);
12573   \textcolor{keywordflow}{if}( zName )\{
12574     \textcolor{keywordtype}{char} *z = sqlite3_mprintf(\textcolor{stringliteral}{"\(\backslash\)"%w\(\backslash\)""}, zName);
12575     sqlite3_result_text(context, z, -1, sqlite3_free);
12576   \}
12577 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a5619fd1ae7a844bff224c7eb6d75ac95}} 
\index{shell.\+c@{shell.\+c}!shell\+Int32@{shell\+Int32}}
\index{shell\+Int32@{shell\+Int32}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Int32()}
{\footnotesize\ttfamily static void shell\+Int32 (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{context,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12538 of file shell.\+c.



References sqlite3\+\_\+result\+\_\+int64, sqlite3\+\_\+value\+\_\+blob, sqlite3\+\_\+value\+\_\+bytes, sqlite3\+\_\+value\+\_\+int, and U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER.



Referenced by open\+\_\+db().


\begin{DoxyCode}
12542  \{
12543   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *pBlob;
12544   \textcolor{keywordtype}{int} nBlob;
12545   \textcolor{keywordtype}{int} iInt;
12546 
12547   UNUSED_PARAMETER(argc);
12548   nBlob = sqlite3_value_bytes(argv[0]);
12549   pBlob = (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)sqlite3_value_blob(argv[0]);
12550   iInt = sqlite3_value_int(argv[1]);
12551 
12552   \textcolor{keywordflow}{if}( iInt>=0 && (iInt+1)*4<=nBlob )\{
12553     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *a = &pBlob[iInt*4];
12554     sqlite3_int64 iVal = ((sqlite3_int64)a[0]<<24)
12555                        + ((sqlite3_int64)a[1]<<16)
12556                        + ((sqlite3_int64)a[2]<< 8)
12557                        + ((sqlite3_int64)a[3]<< 0);
12558     sqlite3_result_int64(context, iVal);
12559   \}
12560 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a03e505391bc400d65a03ebddaae4b423}} 
\index{shell.\+c@{shell.\+c}!shell\+Log@{shell\+Log}}
\index{shell\+Log@{shell\+Log}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Log()}
{\footnotesize\ttfamily static void shell\+Log (\begin{DoxyParamCaption}\item[{void $\ast$}]{p\+Arg,  }\item[{int}]{i\+Err\+Code,  }\item[{const char $\ast$}]{z\+Msg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 9732 of file shell.\+c.



References Shell\+State\+::p\+Log, and utf8\+\_\+printf.



Referenced by main\+\_\+init().


\begin{DoxyCode}
9732                                                                 \{
9733   ShellState *p = (ShellState*)pArg;
9734   \textcolor{keywordflow}{if}( p->pLog==0 ) \textcolor{keywordflow}{return};
9735   utf8_printf(p->pLog, \textcolor{stringliteral}{"(%d) %s\(\backslash\)n"}, iErrCode, zMsg);
9736   fflush(p->pLog);
9737 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ae13eab0dca2ee6a9930dacb51698438f}} 
\index{shell.\+c@{shell.\+c}!shell\+Module\+Schema@{shell\+Module\+Schema}}
\index{shell\+Module\+Schema@{shell\+Module\+Schema}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Module\+Schema()}
{\footnotesize\ttfamily static void shell\+Module\+Schema (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{p\+Ctx,  }\item[{int}]{n\+Val,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{ap\+Val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 855 of file shell.\+c.



References shell\+Fake\+Schema(), sqlite3\+\_\+context\+\_\+db\+\_\+handle, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+result\+\_\+text, sqlite3\+\_\+value\+\_\+text, U\+N\+U\+S\+E\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER, and z\+Name.



Referenced by open\+\_\+db().


\begin{DoxyCode}
859  \{
860   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zName = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(apVal[0]);
861   \textcolor{keywordtype}{char} *zFake = shellFakeSchema(sqlite3_context_db_handle(pCtx), 0, zName);
862   UNUSED_PARAMETER(nVal);
863   \textcolor{keywordflow}{if}( zFake )\{
864     sqlite3_result_text(pCtx, sqlite3_mprintf(\textcolor{stringliteral}{"/* %s */"}, zFake),
865                         -1, sqlite3_free);
866     free(zFake);
867   \}
868 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aeadfeeaea3f9a5f18fcae5950278dce6}} 
\index{shell.\+c@{shell.\+c}!shell\+Prepare@{shell\+Prepare}}
\index{shell\+Prepare@{shell\+Prepare}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Prepare()}
{\footnotesize\ttfamily static void shell\+Prepare (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{int $\ast$}]{p\+Rc,  }\item[{const char $\ast$}]{z\+Sql,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$$\ast$}]{pp\+Stmt }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 14014 of file shell.\+c.



References raw\+\_\+printf, sqlite3\+\_\+errcode, sqlite3\+\_\+errmsg, sqlite3\+\_\+prepare\+\_\+v2, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by shell\+Prepare\+Printf(), and shell\+Reset().


\begin{DoxyCode}
14019  \{
14020   *ppStmt = 0;
14021   \textcolor{keywordflow}{if}( *pRc==SQLITE_OK )\{
14022     \textcolor{keywordtype}{int} rc = sqlite3_prepare_v2(db, zSql, -1, ppStmt, 0);
14023     \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
14024       raw_printf(stderr, \textcolor{stringliteral}{"sql error: %s (%d)\(\backslash\)n"}, 
14025           sqlite3_errmsg(db), sqlite3_errcode(db)
14026       );
14027       *pRc = rc;
14028     \}
14029   \}
14030 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a663f774f376c9a87d3776780e23eff15}} 
\index{shell.\+c@{shell.\+c}!shell\+Prepare\+Printf@{shell\+Prepare\+Printf}}
\index{shell\+Prepare\+Printf@{shell\+Prepare\+Printf}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Prepare\+Printf()}
{\footnotesize\ttfamily void shell\+Prepare\+Printf (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{int $\ast$}]{p\+Rc,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$$\ast$}]{pp\+Stmt,  }\item[{const char $\ast$}]{z\+Fmt,  }\item[{}]{... }\end{DoxyParamCaption})}



Definition at line 14039 of file shell.\+c.



References shell\+Prepare(), sqlite3\+\_\+free, sqlite3\+\_\+vmprintf, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by shell\+Reset().


\begin{DoxyCode}
14045  \{
14046   *ppStmt = 0;
14047   \textcolor{keywordflow}{if}( *pRc==SQLITE_OK )\{
14048     va\_list ap;
14049     \textcolor{keywordtype}{char} *z;
14050     va\_start(ap, zFmt);
14051     z = sqlite3_vmprintf(zFmt, ap);
14052     va\_end(ap);
14053     \textcolor{keywordflow}{if}( z==0 )\{
14054       *pRc = SQLITE_NOMEM;
14055     \}\textcolor{keywordflow}{else}\{
14056       shellPrepare(db, pRc, z, ppStmt);
14057       sqlite3_free(z);
14058     \}
14059   \}
14060 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a60643de33e20accfa49b11fd3630172a}} 
\index{shell.\+c@{shell.\+c}!shell\+Puts\+Func@{shell\+Puts\+Func}}
\index{shell\+Puts\+Func@{shell\+Puts\+Func}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Puts\+Func()}
{\footnotesize\ttfamily static void shell\+Puts\+Func (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{p\+Ctx,  }\item[{int}]{n\+Val,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{ap\+Val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 9745 of file shell.\+c.



References Shell\+State\+::out, sqlite3\+\_\+result\+\_\+value, sqlite3\+\_\+user\+\_\+data, sqlite3\+\_\+value\+\_\+text, and utf8\+\_\+printf.



Referenced by open\+\_\+db(), and shell\+Reset().


\begin{DoxyCode}
9749  \{
9750   ShellState *p = (ShellState*)sqlite3_user_data(pCtx);
9751   (void)nVal;
9752   utf8_printf(p->out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, sqlite3_value_text(apVal[0]));
9753   sqlite3_result_value(pCtx, apVal[0]);
9754 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a463b17126de60f0595b9bec9067baca8}} 
\index{shell.\+c@{shell.\+c}!shell\+Reset@{shell\+Reset}}
\index{shell\+Reset@{shell\+Reset}!shell.\+c@{shell.\+c}}
\subsubsection{shell\+Reset()}
{\footnotesize\ttfamily void shell\+Reset (\begin{DoxyParamCaption}\item[{int $\ast$}]{p\+Rc,  }\item[{\textbf{ sqlite3\+\_\+stmt} $\ast$}]{p\+Stmt }\end{DoxyParamCaption})}



Definition at line 14090 of file shell.\+c.



References close\+\_\+db(), Shell\+State\+::db, deduce\+Database\+Type(), Shell\+State\+::open\+Mode, Shell\+State\+::out, raw\+\_\+printf, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+A\+P\+P\+E\+N\+D\+V\+FS, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+U\+N\+S\+P\+EC, S\+H\+E\+L\+L\+\_\+\+O\+P\+E\+N\+\_\+\+Z\+I\+P\+F\+I\+LE, shell\+Finalize(), shell\+Id\+Quote(), shell\+Prepare(), shell\+Prepare\+Printf(), shell\+Puts\+Func(), show\+Help(), sqlite3\+\_\+bind\+\_\+int, sqlite3\+\_\+bind\+\_\+parameter\+\_\+index, sqlite3\+\_\+bind\+\_\+text, sqlite3\+\_\+close, sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+create\+\_\+function, sqlite3\+\_\+db\+\_\+handle, sqlite3\+\_\+errmsg, sqlite3\+\_\+exec, sqlite3\+\_\+fileio\+\_\+init(), sqlite3\+\_\+free, sqlite3\+\_\+malloc64, sqlite3\+\_\+mprintf, sqlite3\+\_\+open, sqlite3\+\_\+open\+\_\+v2, sqlite3\+\_\+randomness, sqlite3\+\_\+reset, sqlite3\+\_\+snprintf, sqlite3\+\_\+sql, sqlite3\+\_\+step, sqlite3\+\_\+stricmp, sqlite3\+\_\+strnicmp, sqlite3\+\_\+table\+\_\+column\+\_\+metadata, sqlite3\+\_\+vmprintf, S\+Q\+L\+I\+T\+E\+\_\+\+E\+R\+R\+OR, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+C\+R\+E\+A\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+O\+N\+LY, S\+Q\+L\+I\+T\+E\+\_\+\+O\+P\+E\+N\+\_\+\+R\+E\+A\+D\+W\+R\+I\+TE, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+IC, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT, S\+Q\+L\+I\+T\+E\+\_\+\+U\+T\+F8, strlen30(), and utf8\+\_\+printf.


\begin{DoxyCode}
14093  \{
14094   \textcolor{keywordtype}{int} rc = sqlite3_reset(pStmt);
14095   \textcolor{keywordflow}{if}( *pRc==SQLITE_OK )\{
14096     \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
14097       sqlite3 *db = sqlite3_db_handle(pStmt);
14098       raw_printf(stderr, \textcolor{stringliteral}{"SQL error: %s\(\backslash\)n"}, sqlite3_errmsg(db));
14099     \}
14100     *pRc = rc;
14101   \}
14102 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a3f1925de1da6ad4f21ee0e5e53940066}} 
\index{shell.\+c@{shell.\+c}!show\+Help@{show\+Help}}
\index{show\+Help@{show\+Help}!shell.\+c@{shell.\+c}}
\subsubsection{show\+Help()}
{\footnotesize\ttfamily static int show\+Help (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{out,  }\item[{const char $\ast$}]{z\+Pattern }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12250 of file shell.\+c.



References Array\+Size, az\+Help, process\+\_\+input(), sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+strglob, sqlite3\+\_\+strlike, and utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command(), and shell\+Reset().


\begin{DoxyCode}
12250                                                     \{
12251   \textcolor{keywordtype}{int} i = 0;
12252   \textcolor{keywordtype}{int} j = 0;
12253   \textcolor{keywordtype}{int} n = 0;
12254   \textcolor{keywordtype}{char} *zPat;
12255   \textcolor{keywordflow}{if}( zPattern==0
12256    || zPattern[0]==\textcolor{charliteral}{'0'}
12257    || strcmp(zPattern,\textcolor{stringliteral}{"-a"})==0
12258    || strcmp(zPattern,\textcolor{stringliteral}{"-all"})==0
12259   )\{
12260     \textcolor{comment}{/* Show all commands, but only one line per command */}
12261     \textcolor{keywordflow}{if}( zPattern==0 ) zPattern = \textcolor{stringliteral}{""};
12262     \textcolor{keywordflow}{for}(i=0; i<ArraySize(azHelp); i++)\{
12263       \textcolor{keywordflow}{if}( azHelp[i][0]==\textcolor{charliteral}{'.'} || zPattern[0] )\{
12264         utf8_printf(out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, azHelp[i]);
12265         n++;
12266       \}
12267     \}
12268   \}\textcolor{keywordflow}{else}\{
12269     \textcolor{comment}{/* Look for commands that for which zPattern is an exact prefix */}
12270     zPat = sqlite3_mprintf(\textcolor{stringliteral}{".%s*"}, zPattern);
12271     \textcolor{keywordflow}{for}(i=0; i<ArraySize(azHelp); i++)\{
12272       \textcolor{keywordflow}{if}( sqlite3_strglob(zPat, azHelp[i])==0 )\{
12273         utf8_printf(out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, azHelp[i]);
12274         j = i+1;
12275         n++;
12276       \}
12277     \}
12278     sqlite3_free(zPat);
12279     \textcolor{keywordflow}{if}( n )\{
12280       \textcolor{keywordflow}{if}( n==1 )\{
12281         \textcolor{comment}{/* when zPattern is a prefix of exactly one command, then include the}
12282 \textcolor{comment}{        ** details of that command, which should begin at offset j */}
12283         \textcolor{keywordflow}{while}( j<ArraySize(azHelp)-1 && azHelp[j][0]!=\textcolor{charliteral}{'.'} )\{
12284           utf8_printf(out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, azHelp[j]);
12285           j++;
12286         \}
12287       \}
12288       \textcolor{keywordflow}{return} n;
12289     \}
12290     \textcolor{comment}{/* Look for commands that contain zPattern anywhere.  Show the complete}
12291 \textcolor{comment}{    ** text of all commands that match. */}
12292     zPat = sqlite3_mprintf(\textcolor{stringliteral}{"%%%s%%"}, zPattern);
12293     \textcolor{keywordflow}{for}(i=0; i<ArraySize(azHelp); i++)\{
12294       \textcolor{keywordflow}{if}( azHelp[i][0]==\textcolor{charliteral}{'.'} ) j = i;
12295       \textcolor{keywordflow}{if}( sqlite3_strlike(zPat, azHelp[i], 0)==0 )\{
12296         utf8_printf(out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, azHelp[j]);
12297         \textcolor{keywordflow}{while}( j<ArraySize(azHelp)-1 && azHelp[j+1][0]!=\textcolor{charliteral}{'.'} )\{
12298           j++;
12299           utf8_printf(out, \textcolor{stringliteral}{"%s\(\backslash\)n"}, azHelp[j]);
12300         \}
12301         i = j;
12302         n++;
12303       \}
12304     \}
12305     sqlite3_free(zPat);
12306   \}
12307   \textcolor{keywordflow}{return} n;
12308 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a9873c4df7146a3b0164de84dd17404b0}} 
\index{shell.\+c@{shell.\+c}!sql\+\_\+trace\+\_\+callback@{sql\+\_\+trace\+\_\+callback}}
\index{sql\+\_\+trace\+\_\+callback@{sql\+\_\+trace\+\_\+callback}!shell.\+c@{shell.\+c}}
\subsubsection{sql\+\_\+trace\+\_\+callback()}
{\footnotesize\ttfamily static int sql\+\_\+trace\+\_\+callback (\begin{DoxyParamCaption}\item[{unsigned}]{m\+Type,  }\item[{void $\ast$}]{p\+Arg,  }\item[{void $\ast$}]{pP,  }\item[{void $\ast$}]{pX }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13001 of file shell.\+c.



References Shell\+State\+::e\+Trace\+Type, S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+E\+X\+P\+A\+N\+D\+ED, S\+H\+E\+L\+L\+\_\+\+T\+R\+A\+C\+E\+\_\+\+N\+O\+R\+M\+A\+L\+I\+Z\+ED, sqlite3\+\_\+expanded\+\_\+sql, sqlite3\+\_\+normalized\+\_\+sql, sqlite3\+\_\+sql, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+C\+E\+\_\+\+C\+L\+O\+SE, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+C\+E\+\_\+\+P\+R\+O\+F\+I\+LE, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+C\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+C\+E\+\_\+\+S\+T\+MT, strlen30(), Shell\+State\+::trace\+Out, and utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13006  \{
13007   ShellState *p = (ShellState*)pArg;
13008   sqlite3_stmt *pStmt;
13009   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql;
13010   \textcolor{keywordtype}{int} nSql;
13011   \textcolor{keywordflow}{if}( p->traceOut==0 ) \textcolor{keywordflow}{return} 0;
13012   \textcolor{keywordflow}{if}( mType==SQLITE_TRACE_CLOSE )\{
13013     utf8_printf(p->traceOut, \textcolor{stringliteral}{"-- closing database connection\(\backslash\)n"});
13014     \textcolor{keywordflow}{return} 0;
13015   \}
13016   \textcolor{keywordflow}{if}( mType!=SQLITE_TRACE_ROW && ((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)pX)[0]==\textcolor{charliteral}{'-'} )\{
13017     zSql = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)pX;
13018   \}\textcolor{keywordflow}{else}\{
13019     pStmt = (sqlite3_stmt*)pP;
13020     \textcolor{keywordflow}{switch}( p->eTraceType )\{
13021       \textcolor{keywordflow}{case} SHELL_TRACE_EXPANDED: \{
13022         zSql = sqlite3_expanded_sql(pStmt);
13023         \textcolor{keywordflow}{break};
13024       \}
13025 \textcolor{preprocessor}{#ifdef SQLITE\_ENABLE\_NORMALIZE}
13026       \textcolor{keywordflow}{case} SHELL_TRACE_NORMALIZED: \{
13027         zSql = sqlite3_normalized_sql(pStmt);
13028         \textcolor{keywordflow}{break};
13029       \}
13030 \textcolor{preprocessor}{#endif}
13031       \textcolor{keywordflow}{default}: \{
13032         zSql = sqlite3_sql(pStmt);
13033         \textcolor{keywordflow}{break};
13034       \}
13035     \}
13036   \}
13037   \textcolor{keywordflow}{if}( zSql==0 ) \textcolor{keywordflow}{return} 0;
13038   nSql = strlen30(zSql);
13039   \textcolor{keywordflow}{while}( nSql>0 && zSql[nSql-1]==\textcolor{charliteral}{';'} )\{ nSql--; \}
13040   \textcolor{keywordflow}{switch}( mType )\{
13041     \textcolor{keywordflow}{case} SQLITE_TRACE_ROW:
13042     \textcolor{keywordflow}{case} SQLITE_TRACE_STMT: \{
13043       utf8_printf(p->traceOut, \textcolor{stringliteral}{"%.*s;\(\backslash\)n"}, nSql, zSql);
13044       \textcolor{keywordflow}{break};
13045     \}
13046     \textcolor{keywordflow}{case} SQLITE_TRACE_PROFILE: \{
13047       sqlite3_int64 nNanosec = *(sqlite3_int64*)pX;
13048       utf8_printf(p->traceOut, \textcolor{stringliteral}{"%.*s; -- %lld ns\(\backslash\)n"}, nSql, zSql, nNanosec);
13049       \textcolor{keywordflow}{break};
13050     \}
13051   \}
13052   \textcolor{keywordflow}{return} 0;
13053 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a5f9ccd65f04ab4f6d4fbfa0ffd76b02a}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+\_\+appendvfs\+\_\+init@{sqlite3\+\_\+appendvfs\+\_\+init}}
\index{sqlite3\+\_\+appendvfs\+\_\+init@{sqlite3\+\_\+appendvfs\+\_\+init}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+\_\+appendvfs\+\_\+init()}
{\footnotesize\ttfamily int sqlite3\+\_\+appendvfs\+\_\+init (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{char $\ast$$\ast$}]{pz\+Err\+Msg,  }\item[{const \textbf{ sqlite3\+\_\+api\+\_\+routines} $\ast$}]{p\+Api }\end{DoxyParamCaption})}



Definition at line 4080 of file shell.\+c.



References sqlite3\+\_\+vfs\+::i\+Version, sqlite3\+\_\+vfs\+::p\+App\+Data, sqlite3\+\_\+auto\+\_\+extension, sqlite3\+\_\+vfs\+\_\+find, sqlite3\+\_\+vfs\+\_\+register, S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+O\+K\+\_\+\+L\+O\+A\+D\+\_\+\+P\+E\+R\+M\+A\+N\+E\+N\+T\+LY, and sqlite3\+\_\+vfs\+::sz\+Os\+File.



Referenced by main().


\begin{DoxyCode}
4084  \{
4085   \textcolor{keywordtype}{int} rc = SQLITE_OK;
4086   sqlite3_vfs *pOrig;
4087   SQLITE_EXTENSION_INIT2(pApi);
4088   (void)pzErrMsg;
4089   (void)db;
4090   pOrig = sqlite3_vfs_find(0);
4091   apnd_vfs.iVersion = pOrig->iVersion;
4092   apnd_vfs.pAppData = pOrig;
4093   apnd_vfs.szOsFile = pOrig->szOsFile + \textcolor{keyword}{sizeof}(ApndFile);
4094   rc = sqlite3_vfs_register(&apnd_vfs, 0);
4095 \textcolor{preprocessor}{#ifdef APPENDVFS\_TEST}
4096   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
4097     rc = sqlite3_auto_extension((\textcolor{keywordtype}{void}(*)(\textcolor{keywordtype}{void}))apndvfsRegister);
4098   \}
4099 \textcolor{preprocessor}{#endif}
4100   \textcolor{keywordflow}{if}( rc==SQLITE_OK ) rc = SQLITE_OK_LOAD_PERMANENTLY;
4101   \textcolor{keywordflow}{return} rc;
4102 \}
\end{DoxyCode}
\mbox{\label{shell_8c_abe13f95f7293ae4f318bae2cd75090bc}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+\_\+completion\+\_\+init@{sqlite3\+\_\+completion\+\_\+init}}
\index{sqlite3\+\_\+completion\+\_\+init@{sqlite3\+\_\+completion\+\_\+init}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+\_\+completion\+\_\+init()}
{\footnotesize\ttfamily int sqlite3\+\_\+completion\+\_\+init (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{char $\ast$$\ast$}]{pz\+Err\+Msg,  }\item[{const \textbf{ sqlite3\+\_\+api\+\_\+routines} $\ast$}]{p\+Api }\end{DoxyParamCaption})}



Definition at line 3522 of file shell.\+c.



References sqlite3\+Completion\+Vtab\+Init(), S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1, S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by open\+\_\+db().


\begin{DoxyCode}
3526  \{
3527   \textcolor{keywordtype}{int} rc = SQLITE_OK;
3528   SQLITE_EXTENSION_INIT2(pApi);
3529   (void)(pzErrMsg);  \textcolor{comment}{/* Unused parameter */}
3530 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_VIRTUALTABLE}
3531   rc = sqlite3CompletionVtabInit(db);
3532 \textcolor{preprocessor}{#endif}
3533   \textcolor{keywordflow}{return} rc;
3534 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a515a70fba5c3ad73b282d31942eb7aff}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+\_\+expert\+\_\+analyze@{sqlite3\+\_\+expert\+\_\+analyze}}
\index{sqlite3\+\_\+expert\+\_\+analyze@{sqlite3\+\_\+expert\+\_\+analyze}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+\_\+expert\+\_\+analyze()}
{\footnotesize\ttfamily int sqlite3\+\_\+expert\+\_\+analyze (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})}



Definition at line 8569 of file shell.\+c.



References sqlite3expert\+::b\+Run, sqlite3expert\+::h\+Idx, idx\+Append\+Text(), idx\+Create\+Candidates(), idx\+Find\+Indexes(), idx\+Populate\+Stat1(), idx\+Process\+Triggers(), Idx\+Hash\+::p\+First, Idx\+Hash\+Entry\+::p\+Next, S\+Q\+L\+I\+T\+E\+\_\+\+OK, sqlite3expert\+::z\+Candidates, Idx\+Hash\+Entry\+::z\+Val, and Idx\+Hash\+Entry\+::z\+Val2.



Referenced by expert\+Finish().


\begin{DoxyCode}
8569                                                           \{
8570   \textcolor{keywordtype}{int} rc;
8571   IdxHashEntry *pEntry;
8572 
8573   \textcolor{comment}{/* Do trigger processing to collect any extra IdxScan structures */}
8574   rc = idxProcessTriggers(p, pzErr);
8575 
8576   \textcolor{comment}{/* Create candidate indexes within the in-memory database file */}
8577   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8578     rc = idxCreateCandidates(p);
8579   \}
8580 
8581   \textcolor{comment}{/* Generate the stat1 data */}
8582   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8583     rc = idxPopulateStat1(p, pzErr);
8584   \}
8585 
8586   \textcolor{comment}{/* Formulate the EXPERT\_REPORT\_CANDIDATES text */}
8587   \textcolor{keywordflow}{for}(pEntry=p->hIdx.pFirst; pEntry; pEntry=pEntry->pNext)\{
8588     p->zCandidates = idxAppendText(&rc, p->zCandidates, 
8589         \textcolor{stringliteral}{"%s;%s%s\(\backslash\)n"}, pEntry->zVal, 
8590         pEntry->zVal2 ? \textcolor{stringliteral}{" -- stat1: "} : \textcolor{stringliteral}{""}, pEntry->zVal2
8591     );
8592   \}
8593 
8594   \textcolor{comment}{/* Figure out which of the candidate indexes are preferred by the query}
8595 \textcolor{comment}{  ** planner and report the results to the user.  */}
8596   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8597     rc = idxFindIndexes(p, pzErr);
8598   \}
8599 
8600   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8601     p->bRun = 1;
8602   \}
8603   \textcolor{keywordflow}{return} rc;
8604 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a484948ebd850385f0b32b3f89c03089e}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+\_\+expert\+\_\+config@{sqlite3\+\_\+expert\+\_\+config}}
\index{sqlite3\+\_\+expert\+\_\+config@{sqlite3\+\_\+expert\+\_\+config}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+\_\+expert\+\_\+config()}
{\footnotesize\ttfamily int sqlite3\+\_\+expert\+\_\+config (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{int}]{op,  }\item[{}]{... }\end{DoxyParamCaption})}



Definition at line 8500 of file shell.\+c.



References E\+X\+P\+E\+R\+T\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+S\+A\+M\+P\+LE, sqlite3expert\+::i\+Sample, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+T\+F\+O\+U\+ND, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by expert\+Dot\+Command().


\begin{DoxyCode}
8500                                                         \{
8501   \textcolor{keywordtype}{int} rc = SQLITE_OK;
8502   va\_list ap;
8503   va\_start(ap, op);
8504   \textcolor{keywordflow}{switch}( op )\{
8505     \textcolor{keywordflow}{case} EXPERT_CONFIG_SAMPLE: \{
8506       \textcolor{keywordtype}{int} iVal = va\_arg(ap, \textcolor{keywordtype}{int});
8507       \textcolor{keywordflow}{if}( iVal<0 ) iVal = 0;
8508       \textcolor{keywordflow}{if}( iVal>100 ) iVal = 100;
8509       p->iSample = iVal;
8510       \textcolor{keywordflow}{break};
8511     \}
8512     \textcolor{keywordflow}{default}:
8513       rc = SQLITE_NOTFOUND;
8514       \textcolor{keywordflow}{break};
8515   \}
8516 
8517   va\_end(ap);
8518   \textcolor{keywordflow}{return} rc;
8519 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a277541ee4f73b7a6da52bdbaec2d309d}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+\_\+expert\+\_\+count@{sqlite3\+\_\+expert\+\_\+count}}
\index{sqlite3\+\_\+expert\+\_\+count@{sqlite3\+\_\+expert\+\_\+count}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+\_\+expert\+\_\+count()}
{\footnotesize\ttfamily int sqlite3\+\_\+expert\+\_\+count (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p }\end{DoxyParamCaption})}



Definition at line 8610 of file shell.\+c.



References Idx\+Statement\+::i\+Id, and sqlite3expert\+::p\+Statement.



Referenced by expert\+Finish().


\begin{DoxyCode}
8610                                           \{
8611   \textcolor{keywordtype}{int} nRet = 0;
8612   \textcolor{keywordflow}{if}( p->pStatement ) nRet = p->pStatement->iId+1;
8613   \textcolor{keywordflow}{return} nRet;
8614 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a8fb9b42d4dacb06efe2beeb5dd4d4788}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+\_\+expert\+\_\+destroy@{sqlite3\+\_\+expert\+\_\+destroy}}
\index{sqlite3\+\_\+expert\+\_\+destroy@{sqlite3\+\_\+expert\+\_\+destroy}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+\_\+expert\+\_\+destroy()}
{\footnotesize\ttfamily void sqlite3\+\_\+expert\+\_\+destroy (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p }\end{DoxyParamCaption})}



Definition at line 8645 of file shell.\+c.



References sqlite3\+\_\+index\+\_\+info\+::a\+Constraint, sqlite3\+\_\+index\+\_\+info\+::a\+Constraint\+Usage, sqlite3\+\_\+index\+\_\+info\+::a\+Order\+By, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+constraint\+\_\+usage\+::argv\+Index, sqlite3expert\+::dbm, sqlite3expert\+::dbv, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+orderby\+::desc, sqlite3\+\_\+index\+\_\+info\+::estimated\+Cost, sqlite3\+\_\+index\+\_\+info\+::estimated\+Rows, e\+Type, sqlite3expert\+::h\+Idx, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+orderby\+::i\+Column, idx\+Hash\+Clear(), sqlite3\+\_\+index\+\_\+info\+::idx\+Num, idx\+Scan\+Free(), idx\+Statement\+Free(), idx\+Table\+Free(), idx\+Write\+Free(), sqlite3\+\_\+index\+\_\+info\+::n\+Constraint, sqlite3\+\_\+index\+\_\+info\+::n\+Order\+By, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+constraint\+\_\+usage\+::omit, sqlite3\+\_\+index\+\_\+info\+::order\+By\+Consumed, sqlite3expert\+::p\+Scan, sqlite3expert\+::p\+Statement, sqlite3expert\+::p\+Table, sqlite3\+\_\+vtab\+\_\+cursor\+::p\+Vtab, sqlite3expert\+::p\+Write, sqlite3\+\_\+bind\+\_\+int64, sqlite3\+\_\+bind\+\_\+text, sqlite3\+\_\+close, sqlite3\+\_\+column\+\_\+blob, sqlite3\+\_\+column\+\_\+bytes, sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+create\+\_\+module, sqlite3\+\_\+declare\+\_\+vtab, sqlite3\+\_\+errmsg, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+malloc64, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+reset, sqlite3\+\_\+result\+\_\+blob, sqlite3\+\_\+result\+\_\+double, sqlite3\+\_\+result\+\_\+int, sqlite3\+\_\+result\+\_\+int64, sqlite3\+\_\+result\+\_\+null, sqlite3\+\_\+result\+\_\+text, sqlite3\+\_\+step, sqlite3\+\_\+value\+\_\+int, sqlite3\+\_\+value\+\_\+text, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+NT, S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1, S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+N\+T\+\_\+\+EQ, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT, X, sqlite3expert\+::z\+Candidates, and z\+Name.



Referenced by expert\+Finish(), and sqlite3\+\_\+expert\+\_\+new().


\begin{DoxyCode}
8645                                              \{
8646   \textcolor{keywordflow}{if}( p )\{
8647     sqlite3_close(p->dbm);
8648     sqlite3_close(p->dbv);
8649     idxScanFree(p->pScan, 0);
8650     idxStatementFree(p->pStatement, 0);
8651     idxTableFree(p->pTable);
8652     idxWriteFree(p->pWrite);
8653     idxHashClear(&p->hIdx);
8654     sqlite3_free(p->zCandidates);
8655     sqlite3_free(p);
8656   \}
8657 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a4347c06d5e9138bac192582dd98ed7fd}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+\_\+expert\+\_\+new@{sqlite3\+\_\+expert\+\_\+new}}
\index{sqlite3\+\_\+expert\+\_\+new@{sqlite3\+\_\+expert\+\_\+new}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+\_\+expert\+\_\+new()}
{\footnotesize\ttfamily \textbf{ sqlite3expert} $\ast$ sqlite3\+\_\+expert\+\_\+new (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})}



Definition at line 8439 of file shell.\+c.



References sqlite3expert\+::db, sqlite3expert\+::dbm, sqlite3expert\+::dbv, idx\+Auth\+Callback(), idx\+Create\+Vtab\+Schema(), idx\+Finalize(), idx\+Malloc(), idx\+Printf\+Prepare\+Stmt(), sqlite3expert\+::i\+Sample, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+db\+\_\+config, sqlite3\+\_\+exec, sqlite3\+\_\+expert\+\_\+destroy(), sqlite3\+\_\+open, sqlite3\+\_\+set\+\_\+authorizer, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+D\+B\+C\+O\+N\+F\+I\+G\+\_\+\+T\+R\+I\+G\+G\+E\+R\+\_\+\+E\+QP, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW.



Referenced by expert\+Dot\+Command().


\begin{DoxyCode}
8439                                                                \{
8440   \textcolor{keywordtype}{int} rc = SQLITE_OK;
8441   sqlite3expert *pNew;
8442 
8443   pNew = (sqlite3expert*)idxMalloc(&rc, \textcolor{keyword}{sizeof}(sqlite3expert));
8444 
8445   \textcolor{comment}{/* Open two in-memory databases to work with. The "vtab database" (dbv)}
8446 \textcolor{comment}{  ** will contain a virtual table corresponding to each real table in}
8447 \textcolor{comment}{  ** the user database schema, and a copy of each view. It is used to}
8448 \textcolor{comment}{  ** collect information regarding the WHERE, ORDER BY and other clauses}
8449 \textcolor{comment}{  ** of the user's query.}
8450 \textcolor{comment}{  */}
8451   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8452     pNew->db = db;
8453     pNew->iSample = 100;
8454     rc = sqlite3_open(\textcolor{stringliteral}{":memory:"}, &pNew->dbv);
8455   \}
8456   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8457     rc = sqlite3_open(\textcolor{stringliteral}{":memory:"}, &pNew->dbm);
8458     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8459       sqlite3_db_config(pNew->dbm, SQLITE_DBCONFIG_TRIGGER_EQP, 1, (\textcolor{keywordtype}{int}*)0);
8460     \}
8461   \}
8462   
8463 
8464   \textcolor{comment}{/* Copy the entire schema of database [db] into [dbm]. */}
8465   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8466     sqlite3_stmt *pSql;
8467     rc = idxPrintfPrepareStmt(pNew->db, &pSql, pzErrmsg, 
8468         \textcolor{stringliteral}{"SELECT sql FROM sqlite\_master WHERE name NOT LIKE 'sqlite\_%%'"}
8469         \textcolor{stringliteral}{" AND sql NOT LIKE 'CREATE VIRTUAL %%'"}
8470     );
8471     \textcolor{keywordflow}{while}( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) )\{
8472       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zSql = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pSql, 0);
8473       rc = sqlite3_exec(pNew->dbm, zSql, 0, 0, pzErrmsg);
8474     \}
8475     idxFinalize(&rc, pSql);
8476   \}
8477 
8478   \textcolor{comment}{/* Create the vtab schema */}
8479   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8480     rc = idxCreateVtabSchema(pNew, pzErrmsg);
8481   \}
8482 
8483   \textcolor{comment}{/* Register the auth callback with dbv */}
8484   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8485     sqlite3_set_authorizer(pNew->dbv, idxAuthCallback, (\textcolor{keywordtype}{void}*)pNew);
8486   \}
8487 
8488   \textcolor{comment}{/* If an error has occurred, free the new object and reutrn NULL. Otherwise,}
8489 \textcolor{comment}{  ** return the new sqlite3expert handle.  */}
8490   \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
8491     sqlite3_expert_destroy(pNew);
8492     pNew = 0;
8493   \}
8494   \textcolor{keywordflow}{return} pNew;
8495 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a58cfcd0075b6a9a8f1efecc482ab1fba}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+\_\+expert\+\_\+report@{sqlite3\+\_\+expert\+\_\+report}}
\index{sqlite3\+\_\+expert\+\_\+report@{sqlite3\+\_\+expert\+\_\+report}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+\_\+expert\+\_\+report()}
{\footnotesize\ttfamily const char $\ast$ sqlite3\+\_\+expert\+\_\+report (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{int}]{i\+Stmt,  }\item[{int}]{e\+Report }\end{DoxyParamCaption})}



Definition at line 8619 of file shell.\+c.



References sqlite3expert\+::b\+Run, E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+C\+A\+N\+D\+I\+D\+A\+T\+ES, E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+I\+N\+D\+E\+X\+ES, E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+P\+L\+AN, E\+X\+P\+E\+R\+T\+\_\+\+R\+E\+P\+O\+R\+T\+\_\+\+S\+QL, Idx\+Statement\+::i\+Id, Idx\+Statement\+::p\+Next, sqlite3expert\+::p\+Statement, sqlite3expert\+::z\+Candidates, Idx\+Statement\+::z\+E\+QP, Idx\+Statement\+::z\+Idx, and Idx\+Statement\+::z\+Sql.



Referenced by expert\+Finish().


\begin{DoxyCode}
8619                                                                            \{
8620   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zRet = 0;
8621   IdxStatement *pStmt;
8622 
8623   \textcolor{keywordflow}{if}( p->bRun==0 ) \textcolor{keywordflow}{return} 0;
8624   \textcolor{keywordflow}{for}(pStmt=p->pStatement; pStmt && pStmt->iId!=iStmt; pStmt=pStmt->pNext);
8625   \textcolor{keywordflow}{switch}( eReport )\{
8626     \textcolor{keywordflow}{case} EXPERT_REPORT_SQL:
8627       \textcolor{keywordflow}{if}( pStmt ) zRet = pStmt->zSql;
8628       \textcolor{keywordflow}{break};
8629     \textcolor{keywordflow}{case} EXPERT_REPORT_INDEXES:
8630       \textcolor{keywordflow}{if}( pStmt ) zRet = pStmt->zIdx;
8631       \textcolor{keywordflow}{break};
8632     \textcolor{keywordflow}{case} EXPERT_REPORT_PLAN:
8633       \textcolor{keywordflow}{if}( pStmt ) zRet = pStmt->zEQP;
8634       \textcolor{keywordflow}{break};
8635     \textcolor{keywordflow}{case} EXPERT_REPORT_CANDIDATES:
8636       zRet = p->zCandidates;
8637       \textcolor{keywordflow}{break};
8638   \}
8639   \textcolor{keywordflow}{return} zRet;
8640 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aee3263e579c54c44539fc14dde760b05}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+\_\+expert\+\_\+sql@{sqlite3\+\_\+expert\+\_\+sql}}
\index{sqlite3\+\_\+expert\+\_\+sql@{sqlite3\+\_\+expert\+\_\+sql}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+\_\+expert\+\_\+sql()}
{\footnotesize\ttfamily int sqlite3\+\_\+expert\+\_\+sql (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3expert} $\ast$}]{p,  }\item[{const char $\ast$}]{z\+Sql,  }\item[{char $\ast$$\ast$}]{pz\+Err }\end{DoxyParamCaption})}



Definition at line 8524 of file shell.\+c.



References sqlite3expert\+::b\+Run, sqlite3expert\+::dbv, idx\+Database\+Error(), idx\+Malloc(), idx\+Scan\+Free(), idx\+Statement\+Free(), Idx\+Statement\+::i\+Id, Idx\+Statement\+::p\+Next, sqlite3expert\+::p\+Scan, sqlite3expert\+::p\+Statement, sqlite3\+\_\+finalize, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+sql, S\+Q\+L\+I\+T\+E\+\_\+\+M\+I\+S\+U\+SE, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+T\+R\+L\+EN, and Idx\+Statement\+::z\+Sql.



Referenced by expert\+Handle\+S\+Q\+L().


\begin{DoxyCode}
8528  \{
8529   IdxScan *pScanOrig = p->pScan;
8530   IdxStatement *pStmtOrig = p->pStatement;
8531   \textcolor{keywordtype}{int} rc = SQLITE_OK;
8532   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zStmt = zSql;
8533 
8534   \textcolor{keywordflow}{if}( p->bRun ) \textcolor{keywordflow}{return} SQLITE_MISUSE;
8535 
8536   \textcolor{keywordflow}{while}( rc==SQLITE_OK && zStmt && zStmt[0] )\{
8537     sqlite3_stmt *pStmt = 0;
8538     rc = sqlite3_prepare_v2(p->dbv, zStmt, -1, &pStmt, &zStmt);
8539     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8540       \textcolor{keywordflow}{if}( pStmt )\{
8541         IdxStatement *pNew;
8542         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z = sqlite3_sql(pStmt);
8543         \textcolor{keywordtype}{int} n = STRLEN(z);
8544         pNew = (IdxStatement*)idxMalloc(&rc, \textcolor{keyword}{sizeof}(IdxStatement) + n+1);
8545         \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
8546           pNew->zSql = (\textcolor{keywordtype}{char}*)&pNew[1];
8547           memcpy(pNew->zSql, z, n+1);
8548           pNew->pNext = p->pStatement;
8549           \textcolor{keywordflow}{if}( p->pStatement ) pNew->iId = p->pStatement->iId+1;
8550           p->pStatement = pNew;
8551         \}
8552         sqlite3_finalize(pStmt);
8553       \}
8554     \}\textcolor{keywordflow}{else}\{
8555       idxDatabaseError(p->dbv, pzErr);
8556     \}
8557   \}
8558 
8559   \textcolor{keywordflow}{if}( rc!=SQLITE_OK )\{
8560     idxScanFree(p->pScan, pScanOrig);
8561     idxStatementFree(p->pStatement, pStmtOrig);
8562     p->pScan = pScanOrig;
8563     p->pStatement = pStmtOrig;
8564   \}
8565 
8566   \textcolor{keywordflow}{return} rc;
8567 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a796bd781716c0cd114f460c66ee39e1d}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+\_\+fileio\+\_\+init@{sqlite3\+\_\+fileio\+\_\+init}}
\index{sqlite3\+\_\+fileio\+\_\+init@{sqlite3\+\_\+fileio\+\_\+init}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+\_\+fileio\+\_\+init()}
{\footnotesize\ttfamily int sqlite3\+\_\+fileio\+\_\+init (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{char $\ast$$\ast$}]{pz\+Err\+Msg,  }\item[{const \textbf{ sqlite3\+\_\+api\+\_\+routines} $\ast$}]{p\+Api }\end{DoxyParamCaption})}



Definition at line 3006 of file shell.\+c.



References fsdir\+Register(), ls\+Mode\+Func(), readfile\+Func(), sqlite3\+\_\+create\+\_\+function, S\+Q\+L\+I\+T\+E\+\_\+\+D\+I\+R\+E\+C\+T\+O\+N\+LY, S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1, S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+U\+T\+F8, and writefile\+Func().



Referenced by open\+\_\+db(), and shell\+Reset().


\begin{DoxyCode}
3010  \{
3011   \textcolor{keywordtype}{int} rc = SQLITE_OK;
3012   SQLITE_EXTENSION_INIT2(pApi);
3013   (void)pzErrMsg;  \textcolor{comment}{/* Unused parameter */}
3014   rc = sqlite3_create_function(db, \textcolor{stringliteral}{"readfile"}, 1, 
3015                                SQLITE_UTF8|SQLITE_DIRECTONLY, 0,
3016                                readfileFunc, 0, 0);
3017   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
3018     rc = sqlite3_create_function(db, \textcolor{stringliteral}{"writefile"}, -1,
3019                                  SQLITE_UTF8|SQLITE_DIRECTONLY, 0,
3020                                  writefileFunc, 0, 0);
3021   \}
3022   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
3023     rc = sqlite3_create_function(db, \textcolor{stringliteral}{"lsmode"}, 1, SQLITE_UTF8, 0,
3024                                  lsModeFunc, 0, 0);
3025   \}
3026   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
3027     rc = fsdirRegister(db);
3028   \}
3029   \textcolor{keywordflow}{return} rc;
3030 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a81f604b1ca3c2a65d392abb47ac4cff2}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+\_\+shathree\+\_\+init@{sqlite3\+\_\+shathree\+\_\+init}}
\index{sqlite3\+\_\+shathree\+\_\+init@{sqlite3\+\_\+shathree\+\_\+init}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+\_\+shathree\+\_\+init()}
{\footnotesize\ttfamily int sqlite3\+\_\+shathree\+\_\+init (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db,  }\item[{char $\ast$$\ast$}]{pz\+Err\+Msg,  }\item[{const \textbf{ sqlite3\+\_\+api\+\_\+routines} $\ast$}]{p\+Api }\end{DoxyParamCaption})}



Definition at line 2002 of file shell.\+c.



References sha3\+Func(), sha3\+Query\+Func(), sqlite3\+\_\+create\+\_\+function, S\+Q\+L\+I\+T\+E\+\_\+\+D\+E\+T\+E\+R\+M\+I\+N\+I\+S\+T\+IC, S\+Q\+L\+I\+T\+E\+\_\+\+D\+I\+R\+E\+C\+T\+O\+N\+LY, S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1, S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+N\+O\+C\+U\+O\+US, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and S\+Q\+L\+I\+T\+E\+\_\+\+U\+T\+F8.



Referenced by open\+\_\+db().


\begin{DoxyCode}
2006  \{
2007   \textcolor{keywordtype}{int} rc = SQLITE_OK;
2008   SQLITE_EXTENSION_INIT2(pApi);
2009   (void)pzErrMsg;  \textcolor{comment}{/* Unused parameter */}
2010   rc = sqlite3_create_function(db, \textcolor{stringliteral}{"sha3"}, 1,
2011                       SQLITE_UTF8 | SQLITE_INNOCUOUS | SQLITE_DETERMINISTIC,
2012                       0, sha3Func, 0, 0);
2013   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
2014     rc = sqlite3_create_function(db, \textcolor{stringliteral}{"sha3"}, 2,
2015                       SQLITE_UTF8 | SQLITE_INNOCUOUS | SQLITE_DETERMINISTIC,
2016                       0, sha3Func, 0, 0);
2017   \}
2018   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
2019     rc = sqlite3_create_function(db, \textcolor{stringliteral}{"sha3\_query"}, 1,
2020                       SQLITE_UTF8 | SQLITE_DIRECTONLY,
2021                       0, sha3QueryFunc, 0, 0);
2022   \}
2023   \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
2024     rc = sqlite3_create_function(db, \textcolor{stringliteral}{"sha3\_query"}, 2,
2025                       SQLITE_UTF8 | SQLITE_DIRECTONLY,
2026                       0, sha3QueryFunc, 0, 0);
2027   \}
2028   \textcolor{keywordflow}{return} rc;
2029 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a1435582714ae499a0c959340ef96c2a3}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+Completion\+Vtab\+Init@{sqlite3\+Completion\+Vtab\+Init}}
\index{sqlite3\+Completion\+Vtab\+Init@{sqlite3\+Completion\+Vtab\+Init}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+Completion\+Vtab\+Init()}
{\footnotesize\ttfamily int sqlite3\+Completion\+Vtab\+Init (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db }\end{DoxyParamCaption})}



Definition at line 3511 of file shell.\+c.



References sqlite3\+\_\+create\+\_\+module, and S\+Q\+L\+I\+T\+E\+\_\+\+OK.



Referenced by sqlite3\+\_\+completion\+\_\+init().


\begin{DoxyCode}
3511                                           \{
3512   \textcolor{keywordtype}{int} rc = SQLITE_OK;
3513 \textcolor{preprocessor}{#ifndef SQLITE\_OMIT\_VIRTUALTABLE}
3514   rc = sqlite3_create_module(db, \textcolor{stringliteral}{"completion"}, &completionModule, 0);
3515 \textcolor{preprocessor}{#endif}
3516   \textcolor{keywordflow}{return} rc;
3517 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aac109a05fd053ec0ac1bd71c91578a76}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+Mem\+Trace\+Activate@{sqlite3\+Mem\+Trace\+Activate}}
\index{sqlite3\+Mem\+Trace\+Activate@{sqlite3\+Mem\+Trace\+Activate}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+Mem\+Trace\+Activate()}
{\footnotesize\ttfamily int sqlite3\+Mem\+Trace\+Activate (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{out }\end{DoxyParamCaption})}



Definition at line 4190 of file shell.\+c.



References sqlite3\+\_\+config(), S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+G\+E\+T\+M\+A\+L\+L\+OC, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+M\+A\+L\+L\+OC, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and sqlite3\+\_\+mem\+\_\+methods\+::x\+Malloc.



Referenced by main().


\begin{DoxyCode}
4190                                       \{
4191   \textcolor{keywordtype}{int} rc = SQLITE_OK;
4192   \textcolor{keywordflow}{if}( memtraceBase.xMalloc==0 )\{
4193     rc = sqlite3_config(SQLITE_CONFIG_GETMALLOC, &memtraceBase);
4194     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
4195       rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &ersaztMethods);
4196     \}
4197   \}
4198   memtraceOut = out;
4199   \textcolor{keywordflow}{return} rc;
4200 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a79daca3800046e8ae61b83ad411980eb}} 
\index{shell.\+c@{shell.\+c}!sqlite3\+Mem\+Trace\+Deactivate@{sqlite3\+Mem\+Trace\+Deactivate}}
\index{sqlite3\+Mem\+Trace\+Deactivate@{sqlite3\+Mem\+Trace\+Deactivate}!shell.\+c@{shell.\+c}}
\subsubsection{sqlite3\+Mem\+Trace\+Deactivate()}
{\footnotesize\ttfamily int sqlite3\+Mem\+Trace\+Deactivate (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Definition at line 4203 of file shell.\+c.



References sqlite3\+\_\+index\+\_\+info\+::a\+Constraint, sqlite3\+\_\+index\+\_\+info\+::a\+Constraint\+Usage, A\+L\+W\+A\+YS, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+constraint\+\_\+usage\+::argv\+Index, main3\+::cur, list\+\_\+test\+::E, sqlite3\+\_\+index\+\_\+info\+::estimated\+Cost, sqlite3\+\_\+index\+\_\+info\+::idx\+Num, sqlite3\+\_\+vfs\+::i\+Version, M\+IN, sqlite3\+\_\+index\+\_\+info\+::n\+Constraint, n\+Name, sqlite3\+\_\+index\+\_\+info\+::sqlite3\+\_\+index\+\_\+constraint\+\_\+usage\+::omit, sqlite3\+\_\+vtab\+\_\+cursor\+::p\+Vtab, sqlite3\+\_\+aggregate\+\_\+context, sqlite3\+\_\+config(), sqlite3\+\_\+create\+\_\+function, sqlite3\+\_\+create\+\_\+module, sqlite3\+\_\+declare\+\_\+vtab, sqlite3\+\_\+free, sqlite3\+\_\+malloc, sqlite3\+\_\+malloc64, sqlite3\+\_\+mprintf, sqlite3\+\_\+overload\+\_\+function, sqlite3\+\_\+realloc64, sqlite3\+\_\+result\+\_\+blob, sqlite3\+\_\+result\+\_\+error, sqlite3\+\_\+result\+\_\+error\+\_\+code, sqlite3\+\_\+result\+\_\+error\+\_\+nomem, sqlite3\+\_\+result\+\_\+int, sqlite3\+\_\+result\+\_\+int64, sqlite3\+\_\+result\+\_\+text, sqlite3\+\_\+result\+\_\+value, sqlite3\+\_\+stricmp, sqlite3\+\_\+user\+\_\+data, sqlite3\+\_\+value\+\_\+blob, sqlite3\+\_\+value\+\_\+bytes, sqlite3\+\_\+value\+\_\+int, sqlite3\+\_\+value\+\_\+int64, sqlite3\+\_\+value\+\_\+text, sqlite3\+\_\+value\+\_\+type, sqlite3\+\_\+vfs\+\_\+find, sqlite3\+\_\+vmprintf, sqlite3\+\_\+vtab\+\_\+config, sqlite3\+\_\+vtab\+\_\+nochange, sqlite3\+\_\+vtab\+\_\+on\+\_\+conflict, S\+Q\+L\+I\+T\+E\+\_\+\+B\+L\+OB, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+F\+I\+G\+\_\+\+M\+A\+L\+L\+OC, S\+Q\+L\+I\+T\+E\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+NT, S\+Q\+L\+I\+T\+E\+\_\+\+E\+R\+R\+OR, S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T1, S\+Q\+L\+I\+T\+E\+\_\+\+E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+I\+N\+I\+T2, S\+Q\+L\+I\+T\+E\+\_\+\+I\+G\+N\+O\+RE, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+C\+O\+N\+S\+T\+R\+A\+I\+N\+T\+\_\+\+EQ, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+N\+O\+C\+U\+O\+US, S\+Q\+L\+I\+T\+E\+\_\+\+N\+O\+M\+EM, S\+Q\+L\+I\+T\+E\+\_\+\+N\+U\+LL, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+E\+P\+L\+A\+CE, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+IC, S\+Q\+L\+I\+T\+E\+\_\+\+T\+R\+A\+N\+S\+I\+E\+NT, S\+Q\+L\+I\+T\+E\+\_\+\+U\+T\+F8, S\+Q\+L\+I\+T\+E\+\_\+\+V\+T\+A\+B\+\_\+\+D\+I\+R\+E\+C\+T\+O\+N\+LY, sqlite3\+\_\+vfs\+::x\+Current\+Time, sqlite3\+\_\+vfs\+::x\+Current\+Time\+Int64, sqlite3\+\_\+mem\+\_\+methods\+::x\+Malloc, and z\+Name.


\begin{DoxyCode}
4203                                    \{
4204   \textcolor{keywordtype}{int} rc = SQLITE_OK;
4205   \textcolor{keywordflow}{if}( memtraceBase.xMalloc!=0 )\{
4206     rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &memtraceBase);
4207     \textcolor{keywordflow}{if}( rc==SQLITE_OK )\{
4208       memset(&memtraceBase, 0, \textcolor{keyword}{sizeof}(memtraceBase));
4209     \}
4210   \}
4211   memtraceOut = 0;
4212   \textcolor{keywordflow}{return} rc;
4213 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a327490f2055e211f2c98f96795f9edab}} 
\index{shell.\+c@{shell.\+c}!str\+\_\+in\+\_\+array@{str\+\_\+in\+\_\+array}}
\index{str\+\_\+in\+\_\+array@{str\+\_\+in\+\_\+array}!shell.\+c@{shell.\+c}}
\subsubsection{str\+\_\+in\+\_\+array()}
{\footnotesize\ttfamily static int str\+\_\+in\+\_\+array (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Str,  }\item[{const char $\ast$$\ast$}]{az\+Array }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11180 of file shell.\+c.



Referenced by explain\+\_\+data\+\_\+prepare().


\begin{DoxyCode}
11180                                                                \{
11181   \textcolor{keywordtype}{int} i;
11182   \textcolor{keywordflow}{for}(i=0; azArray[i]; i++)\{
11183     \textcolor{keywordflow}{if}( 0==strcmp(zStr, azArray[i]) ) \textcolor{keywordflow}{return} 1;
11184   \}
11185   \textcolor{keywordflow}{return} 0;
11186 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a3dfa9c08ff026e7589f87f53025362a9}} 
\index{shell.\+c@{shell.\+c}!strlen30@{strlen30}}
\index{strlen30@{strlen30}!shell.\+c@{shell.\+c}}
\subsubsection{strlen30()}
{\footnotesize\ttfamily static int strlen30 (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 557 of file shell.\+c.



Referenced by append\+Text(), close\+\_\+db(), do\+\_\+meta\+\_\+command(), eqp\+\_\+append(), eqp\+\_\+render\+\_\+level(), expert\+Dot\+Command(), find\+\_\+home\+\_\+dir(), lint\+Dot\+Command(), lint\+Fkey\+Indexes(), local\+\_\+getline(), main(), output\+\_\+csv(), process\+\_\+input(), run\+\_\+schema\+\_\+dump\+\_\+query(), save\+\_\+err\+\_\+msg(), set\+\_\+table\+\_\+name(), shell\+\_\+callback(), shell\+Add\+Schema\+Name(), shell\+Reset(), sql\+\_\+trace\+\_\+callback(), and try\+To\+Clone\+Data().


\begin{DoxyCode}
557                                   \{
558   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z2 = z;
559   \textcolor{keywordflow}{while}( *z2 )\{ z2++; \}
560   \textcolor{keywordflow}{return} 0x3fffffff & (int)(z2 - z);
561 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a8ec28c0a03b4a6f6ed9c4e5ae1816bf5}} 
\index{shell.\+c@{shell.\+c}!strlen\+Char@{strlen\+Char}}
\index{strlen\+Char@{strlen\+Char}!shell.\+c@{shell.\+c}}
\subsubsection{strlen\+Char()}
{\footnotesize\ttfamily static int strlen\+Char (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 567 of file shell.\+c.



Referenced by shell\+\_\+callback().


\begin{DoxyCode}
567                                     \{
568   \textcolor{keywordtype}{int} n = 0;
569   \textcolor{keywordflow}{while}( *z )\{
570     \textcolor{keywordflow}{if}( (0xc0&*(z++))!=0x80 ) n++;
571   \}
572   \textcolor{keywordflow}{return} n;
573 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a172c14fec2cda1b73711eee3a3f325e4}} 
\index{shell.\+c@{shell.\+c}!table\+Column\+List@{table\+Column\+List}}
\index{table\+Column\+List@{table\+Column\+List}!shell.\+c@{shell.\+c}}
\subsubsection{table\+Column\+List()}
{\footnotesize\ttfamily static char$\ast$$\ast$ table\+Column\+List (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{const char $\ast$}]{z\+Tab }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11768 of file shell.\+c.



References Shell\+State\+::db, free\+Column\+List(), shell\+\_\+out\+\_\+of\+\_\+memory(), Shell\+Has\+Flag, S\+H\+F\+L\+G\+\_\+\+Preserve\+Rowid, sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+realloc, sqlite3\+\_\+step, sqlite3\+\_\+stricmp, sqlite3\+\_\+table\+\_\+column\+\_\+metadata, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW.



Referenced by dump\+\_\+callback().


\begin{DoxyCode}
11768                                                               \{
11769   \textcolor{keywordtype}{char} **azCol = 0;
11770   sqlite3_stmt *pStmt;
11771   \textcolor{keywordtype}{char} *zSql;
11772   \textcolor{keywordtype}{int} nCol = 0;
11773   \textcolor{keywordtype}{int} nAlloc = 0;
11774   \textcolor{keywordtype}{int} nPK = 0;       \textcolor{comment}{/* Number of PRIMARY KEY columns seen */}
11775   \textcolor{keywordtype}{int} isIPK = 0;     \textcolor{comment}{/* True if one PRIMARY KEY column of type INTEGER */}
11776   \textcolor{keywordtype}{int} preserveRowid = ShellHasFlag(p, SHFLG_PreserveRowid);
11777   \textcolor{keywordtype}{int} rc;
11778 
11779   zSql = sqlite3_mprintf(\textcolor{stringliteral}{"PRAGMA table\_info=%Q"}, zTab);
11780   rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
11781   sqlite3_free(zSql);
11782   \textcolor{keywordflow}{if}( rc ) \textcolor{keywordflow}{return} 0;
11783   \textcolor{keywordflow}{while}( sqlite3_step(pStmt)==SQLITE_ROW )\{
11784     \textcolor{keywordflow}{if}( nCol>=nAlloc-2 )\{
11785       nAlloc = nAlloc*2 + nCol + 10;
11786       azCol = sqlite3_realloc(azCol, nAlloc*\textcolor{keyword}{sizeof}(azCol[0]));
11787       \textcolor{keywordflow}{if}( azCol==0 ) shell_out_of_memory();
11788     \}
11789     azCol[++nCol] = sqlite3_mprintf(\textcolor{stringliteral}{"%s"}, sqlite3_column_text(pStmt, 1));
11790     \textcolor{keywordflow}{if}( sqlite3_column_int(pStmt, 5) )\{
11791       nPK++;
11792       \textcolor{keywordflow}{if}( nPK==1
11793        && sqlite3_stricmp((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pStmt,2),
11794                           \textcolor{stringliteral}{"INTEGER"})==0
11795       )\{
11796         isIPK = 1;
11797       \}\textcolor{keywordflow}{else}\{
11798         isIPK = 0;
11799       \}
11800     \}
11801   \}
11802   sqlite3_finalize(pStmt);
11803   \textcolor{keywordflow}{if}( azCol==0 ) \textcolor{keywordflow}{return} 0;
11804   azCol[0] = 0;
11805   azCol[nCol+1] = 0;
11806 
11807   \textcolor{comment}{/* The decision of whether or not a rowid really needs to be preserved}
11808 \textcolor{comment}{  ** is tricky.  We never need to preserve a rowid for a WITHOUT ROWID table}
11809 \textcolor{comment}{  ** or a table with an INTEGER PRIMARY KEY.  We are unable to preserve}
11810 \textcolor{comment}{  ** rowids on tables where the rowid is inaccessible because there are other}
11811 \textcolor{comment}{  ** columns in the table named "rowid", "\_rowid\_", and "oid".}
11812 \textcolor{comment}{  */}
11813   \textcolor{keywordflow}{if}( preserveRowid && isIPK )\{
11814     \textcolor{comment}{/* If a single PRIMARY KEY column with type INTEGER was seen, then it}
11815 \textcolor{comment}{    ** might be an alise for the ROWID.  But it might also be a WITHOUT ROWID}
11816 \textcolor{comment}{    ** table or a INTEGER PRIMARY KEY DESC column, neither of which are}
11817 \textcolor{comment}{    ** ROWID aliases.  To distinguish these cases, check to see if}
11818 \textcolor{comment}{    ** there is a "pk" entry in "PRAGMA index\_list".  There will be}
11819 \textcolor{comment}{    ** no "pk" index if the PRIMARY KEY really is an alias for the ROWID.}
11820 \textcolor{comment}{    */}
11821     zSql = sqlite3_mprintf(\textcolor{stringliteral}{"SELECT 1 FROM pragma\_index\_list(%Q)"}
11822                            \textcolor{stringliteral}{" WHERE origin='pk'"}, zTab);
11823     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);
11824     sqlite3_free(zSql);
11825     \textcolor{keywordflow}{if}( rc )\{
11826       freeColumnList(azCol);
11827       \textcolor{keywordflow}{return} 0;
11828     \}
11829     rc = sqlite3_step(pStmt);
11830     sqlite3_finalize(pStmt);
11831     preserveRowid = rc==SQLITE_ROW;
11832   \}
11833   \textcolor{keywordflow}{if}( preserveRowid )\{
11834     \textcolor{comment}{/* Only preserve the rowid if we can find a name to use for the}
11835 \textcolor{comment}{    ** rowid */}
11836     \textcolor{keyword}{static} \textcolor{keywordtype}{char} *azRowid[] = \{ \textcolor{stringliteral}{"rowid"}, \textcolor{stringliteral}{"\_rowid\_"}, \textcolor{stringliteral}{"oid"} \};
11837     \textcolor{keywordtype}{int} i, j;
11838     \textcolor{keywordflow}{for}(j=0; j<3; j++)\{
11839       \textcolor{keywordflow}{for}(i=1; i<=nCol; i++)\{
11840         \textcolor{keywordflow}{if}( sqlite3_stricmp(azRowid[j],azCol[i])==0 ) \textcolor{keywordflow}{break};
11841       \}
11842       \textcolor{keywordflow}{if}( i>nCol )\{
11843         \textcolor{comment}{/* At this point, we know that azRowid[j] is not the name of any}
11844 \textcolor{comment}{        ** ordinary column in the table.  Verify that azRowid[j] is a valid}
11845 \textcolor{comment}{        ** name for the rowid before adding it to azCol[0].  WITHOUT ROWID}
11846 \textcolor{comment}{        ** tables will fail this last check */}
11847         rc = sqlite3_table_column_metadata(p->db,0,zTab,azRowid[j],0,0,0,0,0);
11848         \textcolor{keywordflow}{if}( rc==SQLITE_OK ) azCol[0] = azRowid[j];
11849         \textcolor{keywordflow}{break};
11850       \}
11851     \}
11852   \}
11853   \textcolor{keywordflow}{return} azCol;
11854 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a193e6fd0053e54b9fdca07b9e54a7b67}} 
\index{shell.\+c@{shell.\+c}!test\+\_\+breakpoint@{test\+\_\+breakpoint}}
\index{test\+\_\+breakpoint@{test\+\_\+breakpoint}!shell.\+c@{shell.\+c}}
\subsubsection{test\+\_\+breakpoint()}
{\footnotesize\ttfamily static void test\+\_\+breakpoint (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13060 of file shell.\+c.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13060                                  \{
13061   \textcolor{keyword}{static} \textcolor{keywordtype}{int} nCall = 0;
13062   nCall++;
13063 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a68e4fb01c82b670913b08690694978ac}} 
\index{shell.\+c@{shell.\+c}!testcase\+\_\+glob@{testcase\+\_\+glob}}
\index{testcase\+\_\+glob@{testcase\+\_\+glob}!shell.\+c@{shell.\+c}}
\subsubsection{testcase\+\_\+glob()}
{\footnotesize\ttfamily static int testcase\+\_\+glob (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z\+Glob,  }\item[{const char $\ast$}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13627 of file shell.\+c.



References Is\+Digit, and Is\+Space.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13627                                                           \{
13628   \textcolor{keywordtype}{int} c, c2;
13629   \textcolor{keywordtype}{int} invert;
13630   \textcolor{keywordtype}{int} seen;
13631 
13632   \textcolor{keywordflow}{while}( (c = (*(zGlob++)))!=0 )\{
13633     \textcolor{keywordflow}{if}( IsSpace(c) )\{
13634       \textcolor{keywordflow}{if}( !IsSpace(*z) ) \textcolor{keywordflow}{return} 0;
13635       \textcolor{keywordflow}{while}( IsSpace(*zGlob) ) zGlob++;
13636       \textcolor{keywordflow}{while}( IsSpace(*z) ) z++;
13637     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'*'} )\{
13638       \textcolor{keywordflow}{while}( (c=(*(zGlob++))) == \textcolor{charliteral}{'*'} || c==\textcolor{charliteral}{'?'} )\{
13639         \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'?'} && (*(z++))==0 ) \textcolor{keywordflow}{return} 0;
13640       \}
13641       \textcolor{keywordflow}{if}( c==0 )\{
13642         \textcolor{keywordflow}{return} 1;
13643       \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'['} )\{
13644         \textcolor{keywordflow}{while}( *z && testcase_glob(zGlob-1,z)==0 )\{
13645           z++;
13646         \}
13647         \textcolor{keywordflow}{return} (*z)!=0;
13648       \}
13649       \textcolor{keywordflow}{while}( (c2 = (*(z++)))!=0 )\{
13650         \textcolor{keywordflow}{while}( c2!=c )\{
13651           c2 = *(z++);
13652           \textcolor{keywordflow}{if}( c2==0 ) \textcolor{keywordflow}{return} 0;
13653         \}
13654         \textcolor{keywordflow}{if}( testcase_glob(zGlob,z) ) \textcolor{keywordflow}{return} 1;
13655       \}
13656       \textcolor{keywordflow}{return} 0;
13657     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'?'} )\{
13658       \textcolor{keywordflow}{if}( (*(z++))==0 ) \textcolor{keywordflow}{return} 0;
13659     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'['} )\{
13660       \textcolor{keywordtype}{int} prior\_c = 0;
13661       seen = 0;
13662       invert = 0;
13663       c = *(z++);
13664       \textcolor{keywordflow}{if}( c==0 ) \textcolor{keywordflow}{return} 0;
13665       c2 = *(zGlob++);
13666       \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'^'} )\{
13667         invert = 1;
13668         c2 = *(zGlob++);
13669       \}
13670       \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{']'} )\{
13671         \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{']'} ) seen = 1;
13672         c2 = *(zGlob++);
13673       \}
13674       \textcolor{keywordflow}{while}( c2 && c2!=\textcolor{charliteral}{']'} )\{
13675         \textcolor{keywordflow}{if}( c2==\textcolor{charliteral}{'-'} && zGlob[0]!=\textcolor{charliteral}{']'} && zGlob[0]!=0 && prior\_c>0 )\{
13676           c2 = *(zGlob++);
13677           \textcolor{keywordflow}{if}( c>=prior\_c && c<=c2 ) seen = 1;
13678           prior\_c = 0;
13679         \}\textcolor{keywordflow}{else}\{
13680           \textcolor{keywordflow}{if}( c==c2 )\{
13681             seen = 1;
13682           \}
13683           prior\_c = c2;
13684         \}
13685         c2 = *(zGlob++);
13686       \}
13687       \textcolor{keywordflow}{if}( c2==0 || (seen ^ invert)==0 ) \textcolor{keywordflow}{return} 0;
13688     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( c==\textcolor{charliteral}{'#'} )\{
13689       \textcolor{keywordflow}{if}( (z[0]==\textcolor{charliteral}{'-'} || z[0]==\textcolor{charliteral}{'+'}) && IsDigit(z[1]) ) z++;
13690       \textcolor{keywordflow}{if}( !IsDigit(z[0]) ) \textcolor{keywordflow}{return} 0;
13691       z++;
13692       \textcolor{keywordflow}{while}( IsDigit(z[0]) )\{ z++; \}
13693     \}\textcolor{keywordflow}{else}\{
13694       \textcolor{keywordflow}{if}( c!=(*(z++)) ) \textcolor{keywordflow}{return} 0;
13695     \}
13696   \}
13697   \textcolor{keywordflow}{while}( IsSpace(*z) )\{ z++; \}
13698   \textcolor{keywordflow}{return} *z==0;
13699 \}
\end{DoxyCode}
\mbox{\label{shell_8c_ab8148977e2401f39f00969bfce1fc1a3}} 
\index{shell.\+c@{shell.\+c}!time\+Diff@{time\+Diff}}
\index{time\+Diff@{time\+Diff}!shell.\+c@{shell.\+c}}
\subsubsection{time\+Diff()}
{\footnotesize\ttfamily static double time\+Diff (\begin{DoxyParamCaption}\item[{struct timeval $\ast$}]{p\+Start,  }\item[{struct timeval $\ast$}]{p\+End }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 270 of file shell.\+c.



Referenced by end\+Timer().


\begin{DoxyCode}
270                                                                     \{
271   \textcolor{keywordflow}{return} (pEnd->tv\_usec - pStart->tv\_usec)*0.000001 +
272          (double)(pEnd->tv\_sec - pStart->tv\_sec);
273 \}
\end{DoxyCode}
\mbox{\label{shell_8c_afac1717bd07a36ea4500b65db1afa30d}} 
\index{shell.\+c@{shell.\+c}!time\+Of\+Day@{time\+Of\+Day}}
\index{time\+Of\+Day@{time\+Of\+Day}!shell.\+c@{shell.\+c}}
\subsubsection{time\+Of\+Day()}
{\footnotesize\ttfamily static \textbf{ sqlite3\+\_\+int64} time\+Of\+Day (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 228 of file shell.\+c.



References sqlite3\+\_\+vfs\+::i\+Version, sqlite3\+\_\+vfs\+\_\+find, sqlite3\+\_\+vfs\+::x\+Current\+Time, and sqlite3\+\_\+vfs\+::x\+Current\+Time\+Int64.



Referenced by begin\+Timer(), and end\+Timer().


\begin{DoxyCode}
228                                     \{
229   \textcolor{keyword}{static} sqlite3_vfs *clockVfs = 0;
230   sqlite3_int64 t;
231   \textcolor{keywordflow}{if}( clockVfs==0 ) clockVfs = sqlite3_vfs_find(0);
232   \textcolor{keywordflow}{if}( clockVfs->iVersion>=2 && clockVfs->xCurrentTimeInt64!=0 )\{
233     clockVfs->xCurrentTimeInt64(clockVfs, &t);
234   \}\textcolor{keywordflow}{else}\{
235     \textcolor{keywordtype}{double} r;
236     clockVfs->xCurrentTime(clockVfs, &r);
237     t = (sqlite3_int64)(r*86400000.0);
238   \}
239   \textcolor{keywordflow}{return} t;
240 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a86ee25abe4a10448e63d8cdf253ee77f}} 
\index{shell.\+c@{shell.\+c}!toggle\+Select\+Order@{toggle\+Select\+Order}}
\index{toggle\+Select\+Order@{toggle\+Select\+Order}!shell.\+c@{shell.\+c}}
\subsubsection{toggle\+Select\+Order()}
{\footnotesize\ttfamily static void toggle\+Select\+Order (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3} $\ast$}]{db }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 11859 of file shell.\+c.



References sqlite3\+\_\+column\+\_\+int, sqlite3\+\_\+exec, sqlite3\+\_\+finalize, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+snprintf, sqlite3\+\_\+step, and S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW.



Referenced by dump\+\_\+callback().


\begin{DoxyCode}
11859                                           \{
11860   sqlite3_stmt *pStmt = 0;
11861   \textcolor{keywordtype}{int} iSetting = 0;
11862   \textcolor{keywordtype}{char} zStmt[100];
11863   sqlite3_prepare_v2(db, \textcolor{stringliteral}{"PRAGMA reverse\_unordered\_selects"}, -1, &pStmt, 0);
11864   \textcolor{keywordflow}{if}( sqlite3_step(pStmt)==SQLITE_ROW )\{
11865     iSetting = sqlite3_column_int(pStmt, 0);
11866   \}
11867   sqlite3_finalize(pStmt);
11868   sqlite3_snprintf(\textcolor{keyword}{sizeof}(zStmt), zStmt,
11869        \textcolor{stringliteral}{"PRAGMA reverse\_unordered\_selects(%d)"}, !iSetting);
11870   sqlite3_exec(db, zStmt, 0, 0, 0);
11871 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a8cb297124b954d24bbe8b9d476670477}} 
\index{shell.\+c@{shell.\+c}!try\+To\+Clone@{try\+To\+Clone}}
\index{try\+To\+Clone@{try\+To\+Clone}!shell.\+c@{shell.\+c}}
\subsubsection{try\+To\+Clone()}
{\footnotesize\ttfamily static void try\+To\+Clone (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{const char $\ast$}]{z\+New\+Db }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13407 of file shell.\+c.



References close\+\_\+db(), Shell\+State\+::db, sqlite3\+\_\+errmsg, sqlite3\+\_\+exec, sqlite3\+\_\+open, try\+To\+Clone\+Data(), try\+To\+Clone\+Schema(), and utf8\+\_\+printf.



Referenced by do\+\_\+meta\+\_\+command().


\begin{DoxyCode}
13407                                                          \{
13408   \textcolor{keywordtype}{int} rc;
13409   sqlite3 *newDb = 0;
13410   \textcolor{keywordflow}{if}( access(zNewDb,0)==0 )\{
13411     utf8_printf(stderr, \textcolor{stringliteral}{"File \(\backslash\)"%s\(\backslash\)" already exists.\(\backslash\)n"}, zNewDb);
13412     \textcolor{keywordflow}{return};
13413   \}
13414   rc = sqlite3_open(zNewDb, &newDb);
13415   \textcolor{keywordflow}{if}( rc )\{
13416     utf8_printf(stderr, \textcolor{stringliteral}{"Cannot create output database: %s\(\backslash\)n"},
13417             sqlite3_errmsg(newDb));
13418   \}\textcolor{keywordflow}{else}\{
13419     sqlite3_exec(p->db, \textcolor{stringliteral}{"PRAGMA writable\_schema=ON;"}, 0, 0, 0);
13420     sqlite3_exec(newDb, \textcolor{stringliteral}{"BEGIN EXCLUSIVE;"}, 0, 0, 0);
13421     tryToCloneSchema(p, newDb, \textcolor{stringliteral}{"type='table'"}, tryToCloneData);
13422     tryToCloneSchema(p, newDb, \textcolor{stringliteral}{"type!='table'"}, 0);
13423     sqlite3_exec(newDb, \textcolor{stringliteral}{"COMMIT;"}, 0, 0, 0);
13424     sqlite3_exec(p->db, \textcolor{stringliteral}{"PRAGMA writable\_schema=OFF;"}, 0, 0, 0);
13425   \}
13426   close_db(newDb);
13427 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a14c803cf051a75019368656e18875163}} 
\index{shell.\+c@{shell.\+c}!try\+To\+Clone\+Data@{try\+To\+Clone\+Data}}
\index{try\+To\+Clone\+Data@{try\+To\+Clone\+Data}!shell.\+c@{shell.\+c}}
\subsubsection{try\+To\+Clone\+Data()}
{\footnotesize\ttfamily static void try\+To\+Clone\+Data (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{\textbf{ sqlite3} $\ast$}]{new\+Db,  }\item[{const char $\ast$}]{z\+Table }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13222 of file shell.\+c.



References Shell\+State\+::db, shell\+\_\+out\+\_\+of\+\_\+memory(), sqlite3\+\_\+bind\+\_\+blob, sqlite3\+\_\+bind\+\_\+double, sqlite3\+\_\+bind\+\_\+int64, sqlite3\+\_\+bind\+\_\+null, sqlite3\+\_\+bind\+\_\+text, sqlite3\+\_\+column\+\_\+blob, sqlite3\+\_\+column\+\_\+bytes, sqlite3\+\_\+column\+\_\+count, sqlite3\+\_\+column\+\_\+double, sqlite3\+\_\+column\+\_\+int64, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+column\+\_\+type, sqlite3\+\_\+errmsg, sqlite3\+\_\+extended\+\_\+errcode, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+malloc64, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+reset, sqlite3\+\_\+snprintf, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+B\+L\+OB, S\+Q\+L\+I\+T\+E\+\_\+\+D\+O\+NE, S\+Q\+L\+I\+T\+E\+\_\+\+F\+L\+O\+AT, S\+Q\+L\+I\+T\+E\+\_\+\+I\+N\+T\+E\+G\+ER, S\+Q\+L\+I\+T\+E\+\_\+\+N\+U\+LL, S\+Q\+L\+I\+T\+E\+\_\+\+OK, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, S\+Q\+L\+I\+T\+E\+\_\+\+S\+T\+A\+T\+IC, S\+Q\+L\+I\+T\+E\+\_\+\+T\+E\+XT, strlen30(), and utf8\+\_\+printf.



Referenced by try\+To\+Clone().


\begin{DoxyCode}
13226  \{
13227   sqlite3_stmt *pQuery = 0;
13228   sqlite3_stmt *pInsert = 0;
13229   \textcolor{keywordtype}{char} *zQuery = 0;
13230   \textcolor{keywordtype}{char} *zInsert = 0;
13231   \textcolor{keywordtype}{int} rc;
13232   \textcolor{keywordtype}{int} i, j, n;
13233   \textcolor{keywordtype}{int} nTable = strlen30(zTable);
13234   \textcolor{keywordtype}{int} k = 0;
13235   \textcolor{keywordtype}{int} cnt = 0;
13236   \textcolor{keyword}{const} \textcolor{keywordtype}{int} spinRate = 10000;
13237 
13238   zQuery = sqlite3_mprintf(\textcolor{stringliteral}{"SELECT * FROM \(\backslash\)"%w\(\backslash\)""}, zTable);
13239   rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
13240   \textcolor{keywordflow}{if}( rc )\{
13241     utf8_printf(stderr, \textcolor{stringliteral}{"Error %d: %s on [%s]\(\backslash\)n"},
13242             sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),
13243             zQuery);
13244     \textcolor{keywordflow}{goto} end\_data\_xfer;
13245   \}
13246   n = sqlite3_column_count(pQuery);
13247   zInsert = sqlite3_malloc64(200 + nTable + n*3);
13248   \textcolor{keywordflow}{if}( zInsert==0 ) shell_out_of_memory();
13249   sqlite3_snprintf(200+nTable,zInsert,
13250                    \textcolor{stringliteral}{"INSERT OR IGNORE INTO \(\backslash\)"%s\(\backslash\)" VALUES(?"}, zTable);
13251   i = strlen30(zInsert);
13252   \textcolor{keywordflow}{for}(j=1; j<n; j++)\{
13253     memcpy(zInsert+i, \textcolor{stringliteral}{",?"}, 2);
13254     i += 2;
13255   \}
13256   memcpy(zInsert+i, \textcolor{stringliteral}{");"}, 3);
13257   rc = sqlite3_prepare_v2(newDb, zInsert, -1, &pInsert, 0);
13258   \textcolor{keywordflow}{if}( rc )\{
13259     utf8_printf(stderr, \textcolor{stringliteral}{"Error %d: %s on [%s]\(\backslash\)n"},
13260             sqlite3_extended_errcode(newDb), sqlite3_errmsg(newDb),
13261             zQuery);
13262     \textcolor{keywordflow}{goto} end\_data\_xfer;
13263   \}
13264   \textcolor{keywordflow}{for}(k=0; k<2; k++)\{
13265     \textcolor{keywordflow}{while}( (rc = sqlite3_step(pQuery))==SQLITE_ROW )\{
13266       \textcolor{keywordflow}{for}(i=0; i<n; i++)\{
13267         \textcolor{keywordflow}{switch}( sqlite3_column_type(pQuery, i) )\{
13268           \textcolor{keywordflow}{case} SQLITE_NULL: \{
13269             sqlite3_bind_null(pInsert, i+1);
13270             \textcolor{keywordflow}{break};
13271           \}
13272           \textcolor{keywordflow}{case} SQLITE_INTEGER: \{
13273             sqlite3_bind_int64(pInsert, i+1, sqlite3_column_int64(pQuery,i));
13274             \textcolor{keywordflow}{break};
13275           \}
13276           \textcolor{keywordflow}{case} SQLITE_FLOAT: \{
13277             sqlite3_bind_double(pInsert, i+1, sqlite3_column_double(pQuery,i));
13278             \textcolor{keywordflow}{break};
13279           \}
13280           \textcolor{keywordflow}{case} SQLITE_TEXT: \{
13281             sqlite3_bind_text(pInsert, i+1,
13282                              (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_column_text(pQuery,i),
13283                              -1, SQLITE_STATIC);
13284             \textcolor{keywordflow}{break};
13285           \}
13286           \textcolor{keywordflow}{case} SQLITE_BLOB: \{
13287             sqlite3_bind_blob(pInsert, i+1, sqlite3_column_blob(pQuery,i),
13288                                             sqlite3_column_bytes(pQuery,i),
13289                                             SQLITE_STATIC);
13290             \textcolor{keywordflow}{break};
13291           \}
13292         \}
13293       \} \textcolor{comment}{/* End for */}
13294       rc = sqlite3_step(pInsert);
13295       \textcolor{keywordflow}{if}( rc!=SQLITE_OK && rc!=SQLITE_ROW && rc!=SQLITE_DONE )\{
13296         utf8_printf(stderr, \textcolor{stringliteral}{"Error %d: %s\(\backslash\)n"}, sqlite3_extended_errcode(newDb),
13297                         sqlite3_errmsg(newDb));
13298       \}
13299       sqlite3_reset(pInsert);
13300       cnt++;
13301       \textcolor{keywordflow}{if}( (cnt%spinRate)==0 )\{
13302         printf(\textcolor{stringliteral}{"%c\(\backslash\)b"}, \textcolor{stringliteral}{"|/-\(\backslash\)\(\backslash\)"}[(cnt/spinRate)%4]);
13303         fflush(stdout);
13304       \}
13305     \} \textcolor{comment}{/* End while */}
13306     \textcolor{keywordflow}{if}( rc==SQLITE_DONE ) \textcolor{keywordflow}{break};
13307     sqlite3_finalize(pQuery);
13308     sqlite3_free(zQuery);
13309     zQuery = sqlite3_mprintf(\textcolor{stringliteral}{"SELECT * FROM \(\backslash\)"%w\(\backslash\)" ORDER BY rowid DESC;"},
13310                              zTable);
13311     rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
13312     \textcolor{keywordflow}{if}( rc )\{
13313       utf8_printf(stderr, \textcolor{stringliteral}{"Warning: cannot step \(\backslash\)"%s\(\backslash\)" backwards"}, zTable);
13314       \textcolor{keywordflow}{break};
13315     \}
13316   \} \textcolor{comment}{/* End for(k=0...) */}
13317 
13318 end\_data\_xfer:
13319   sqlite3_finalize(pQuery);
13320   sqlite3_finalize(pInsert);
13321   sqlite3_free(zQuery);
13322   sqlite3_free(zInsert);
13323 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aa6b478ad8bf363608c24e73f313b5d5d}} 
\index{shell.\+c@{shell.\+c}!try\+To\+Clone\+Schema@{try\+To\+Clone\+Schema}}
\index{try\+To\+Clone\+Schema@{try\+To\+Clone\+Schema}!shell.\+c@{shell.\+c}}
\subsubsection{try\+To\+Clone\+Schema()}
{\footnotesize\ttfamily static void try\+To\+Clone\+Schema (\begin{DoxyParamCaption}\item[{\textbf{ Shell\+State} $\ast$}]{p,  }\item[{\textbf{ sqlite3} $\ast$}]{new\+Db,  }\item[{const char $\ast$}]{z\+Where,  }\item[{void($\ast$)(\textbf{ Shell\+State} $\ast$, \textbf{ sqlite3} $\ast$, const char $\ast$)}]{x\+For\+Each }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 13332 of file shell.\+c.



References Shell\+State\+::db, sqlite3\+\_\+column\+\_\+text, sqlite3\+\_\+errmsg, sqlite3\+\_\+exec, sqlite3\+\_\+extended\+\_\+errcode, sqlite3\+\_\+finalize, sqlite3\+\_\+free, sqlite3\+\_\+mprintf, sqlite3\+\_\+prepare\+\_\+v2, sqlite3\+\_\+step, S\+Q\+L\+I\+T\+E\+\_\+\+D\+O\+NE, S\+Q\+L\+I\+T\+E\+\_\+\+R\+OW, utf8\+\_\+printf, and z\+Name.



Referenced by try\+To\+Clone().


\begin{DoxyCode}
13337  \{
13338   sqlite3_stmt *pQuery = 0;
13339   \textcolor{keywordtype}{char} *zQuery = 0;
13340   \textcolor{keywordtype}{int} rc;
13341   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zName;
13342   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *zSql;
13343   \textcolor{keywordtype}{char} *zErrMsg = 0;
13344 
13345   zQuery = sqlite3_mprintf(\textcolor{stringliteral}{"SELECT name, sql FROM sqlite\_master"}
13346                            \textcolor{stringliteral}{" WHERE %s"}, zWhere);
13347   rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
13348   \textcolor{keywordflow}{if}( rc )\{
13349     utf8_printf(stderr, \textcolor{stringliteral}{"Error: (%d) %s on [%s]\(\backslash\)n"},
13350                     sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),
13351                     zQuery);
13352     \textcolor{keywordflow}{goto} end\_schema\_xfer;
13353   \}
13354   \textcolor{keywordflow}{while}( (rc = sqlite3_step(pQuery))==SQLITE_ROW )\{
13355     zName = sqlite3_column_text(pQuery, 0);
13356     zSql = sqlite3_column_text(pQuery, 1);
13357     printf(\textcolor{stringliteral}{"%s... "}, zName); fflush(stdout);
13358     sqlite3_exec(newDb, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)zSql, 0, 0, &zErrMsg);
13359     \textcolor{keywordflow}{if}( zErrMsg )\{
13360       utf8_printf(stderr, \textcolor{stringliteral}{"Error: %s\(\backslash\)nSQL: [%s]\(\backslash\)n"}, zErrMsg, zSql);
13361       sqlite3_free(zErrMsg);
13362       zErrMsg = 0;
13363     \}
13364     \textcolor{keywordflow}{if}( xForEach )\{
13365       xForEach(p, newDb, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)zName);
13366     \}
13367     printf(\textcolor{stringliteral}{"done\(\backslash\)n"});
13368   \}
13369   \textcolor{keywordflow}{if}( rc!=SQLITE_DONE )\{
13370     sqlite3_finalize(pQuery);
13371     sqlite3_free(zQuery);
13372     zQuery = sqlite3_mprintf(\textcolor{stringliteral}{"SELECT name, sql FROM sqlite\_master"}
13373                              \textcolor{stringliteral}{" WHERE %s ORDER BY rowid DESC"}, zWhere);
13374     rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);
13375     \textcolor{keywordflow}{if}( rc )\{
13376       utf8_printf(stderr, \textcolor{stringliteral}{"Error: (%d) %s on [%s]\(\backslash\)n"},
13377                       sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),
13378                       zQuery);
13379       \textcolor{keywordflow}{goto} end\_schema\_xfer;
13380     \}
13381     \textcolor{keywordflow}{while}( (rc = sqlite3_step(pQuery))==SQLITE_ROW )\{
13382       zName = sqlite3_column_text(pQuery, 0);
13383       zSql = sqlite3_column_text(pQuery, 1);
13384       printf(\textcolor{stringliteral}{"%s... "}, zName); fflush(stdout);
13385       sqlite3_exec(newDb, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)zSql, 0, 0, &zErrMsg);
13386       \textcolor{keywordflow}{if}( zErrMsg )\{
13387         utf8_printf(stderr, \textcolor{stringliteral}{"Error: %s\(\backslash\)nSQL: [%s]\(\backslash\)n"}, zErrMsg, zSql);
13388         sqlite3_free(zErrMsg);
13389         zErrMsg = 0;
13390       \}
13391       \textcolor{keywordflow}{if}( xForEach )\{
13392         xForEach(p, newDb, (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)zName);
13393       \}
13394       printf(\textcolor{stringliteral}{"done\(\backslash\)n"});
13395     \}
13396   \}
13397 end\_schema\_xfer:
13398   sqlite3_finalize(pQuery);
13399   sqlite3_free(zQuery);
13400 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a6bed5328eb3162df938b0bf2d9244008}} 
\index{shell.\+c@{shell.\+c}!unused\+\_\+string@{unused\+\_\+string}}
\index{unused\+\_\+string@{unused\+\_\+string}!shell.\+c@{shell.\+c}}
\subsubsection{unused\+\_\+string()}
{\footnotesize\ttfamily static const char$\ast$ unused\+\_\+string (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z,  }\item[{const char $\ast$}]{zA,  }\item[{const char $\ast$}]{zB,  }\item[{char $\ast$}]{z\+Buf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 9932 of file shell.\+c.



References sqlite3\+\_\+snprintf.



Referenced by output\+\_\+quoted\+\_\+escaped\+\_\+string(), and shell\+Escape\+Crnl().


\begin{DoxyCode}
9936  \{
9937   \textcolor{keywordtype}{unsigned} i = 0;
9938   \textcolor{keywordflow}{if}( strstr(z, zA)==0 ) \textcolor{keywordflow}{return} zA;
9939   \textcolor{keywordflow}{if}( strstr(z, zB)==0 ) \textcolor{keywordflow}{return} zB;
9940   \textcolor{keywordflow}{do}\{
9941     sqlite3_snprintf(20,zBuf,\textcolor{stringliteral}{"(%s%u)"}, zA, i++);
9942   \}\textcolor{keywordflow}{while}( strstr(z,zBuf)!=0 );
9943   \textcolor{keywordflow}{return} zBuf;
9944 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a6dbffcc6971ac9cafac343d7cd422a4e}} 
\index{shell.\+c@{shell.\+c}!usage@{usage}}
\index{usage@{usage}!shell.\+c@{shell.\+c}}
\subsubsection{usage()}
{\footnotesize\ttfamily static void usage (\begin{DoxyParamCaption}\item[{int}]{show\+Detail }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18580 of file shell.\+c.



References raw\+\_\+printf, and utf8\+\_\+printf.



Referenced by lint\+Dot\+Command(), and main().


\begin{DoxyCode}
18580                                  \{
18581   utf8_printf(stderr,
18582       \textcolor{stringliteral}{"Usage: %s [OPTIONS] FILENAME [SQL]\(\backslash\)n"}
18583       \textcolor{stringliteral}{"FILENAME is the name of an SQLite database. A new database is created\(\backslash\)n"}
18584       \textcolor{stringliteral}{"if the file does not previously exist.\(\backslash\)n"}, Argv0);
18585   \textcolor{keywordflow}{if}( showDetail )\{
18586     utf8_printf(stderr, \textcolor{stringliteral}{"OPTIONS include:\(\backslash\)n%s"}, zOptions);
18587   \}\textcolor{keywordflow}{else}\{
18588     raw_printf(stderr, \textcolor{stringliteral}{"Use the -help option for additional information\(\backslash\)n"});
18589   \}
18590   exit(1);
18591 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aef6d0ea8e8f66d02b649900aae12eeb8}} 
\index{shell.\+c@{shell.\+c}!utf8\+\_\+width\+\_\+print@{utf8\+\_\+width\+\_\+print}}
\index{utf8\+\_\+width\+\_\+print@{utf8\+\_\+width\+\_\+print}!shell.\+c@{shell.\+c}}
\subsubsection{utf8\+\_\+width\+\_\+print()}
{\footnotesize\ttfamily static void utf8\+\_\+width\+\_\+print (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{p\+Out,  }\item[{int}]{w,  }\item[{const char $\ast$}]{z\+Utf }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 501 of file shell.\+c.



References utf8\+\_\+printf.



Referenced by shell\+\_\+callback().


\begin{DoxyCode}
501                                                                  \{
502   \textcolor{keywordtype}{int} i;
503   \textcolor{keywordtype}{int} n;
504   \textcolor{keywordtype}{int} aw = w<0 ? -w : w;
505   \textcolor{keywordtype}{char} zBuf[1000];
506   \textcolor{keywordflow}{if}( aw>(\textcolor{keywordtype}{int})\textcolor{keyword}{sizeof}(zBuf)/3 ) aw = (int)\textcolor{keyword}{sizeof}(zBuf)/3;
507   \textcolor{keywordflow}{for}(i=n=0; zUtf[i]; i++)\{
508     \textcolor{keywordflow}{if}( (zUtf[i]&0xc0)!=0x80 )\{
509       n++;
510       \textcolor{keywordflow}{if}( n==aw )\{
511         \textcolor{keywordflow}{do}\{ i++; \}\textcolor{keywordflow}{while}( (zUtf[i]&0xc0)==0x80 );
512         \textcolor{keywordflow}{break};
513       \}
514     \}
515   \}
516   \textcolor{keywordflow}{if}( n>=aw )\{
517     utf8_printf(pOut, \textcolor{stringliteral}{"%.*s"}, i, zUtf);
518   \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( w<0 )\{
519     utf8_printf(pOut, \textcolor{stringliteral}{"%*s%s"}, aw-n, \textcolor{stringliteral}{""}, zUtf);
520   \}\textcolor{keywordflow}{else}\{
521     utf8_printf(pOut, \textcolor{stringliteral}{"%s%*s"}, zUtf, aw-n, \textcolor{stringliteral}{""});
522   \}
523 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a417c44aa8922f5c7c0a2f904a3ef93ef}} 
\index{shell.\+c@{shell.\+c}!verify\+\_\+uninitialized@{verify\+\_\+uninitialized}}
\index{verify\+\_\+uninitialized@{verify\+\_\+uninitialized}!shell.\+c@{shell.\+c}}
\subsubsection{verify\+\_\+uninitialized()}
{\footnotesize\ttfamily static void verify\+\_\+uninitialized (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18597 of file shell.\+c.



References sqlite3\+\_\+config(), S\+Q\+L\+I\+T\+E\+\_\+\+M\+I\+S\+U\+SE, and utf8\+\_\+printf.



Referenced by main(), and main\+\_\+init().


\begin{DoxyCode}
18597                                       \{
18598   \textcolor{keywordflow}{if}( sqlite3_config(-1)==SQLITE_MISUSE )\{
18599     utf8_printf(stdout, \textcolor{stringliteral}{"WARNING: attempt to configure SQLite after"}
18600                         \textcolor{stringliteral}{" initialization.\(\backslash\)n"});
18601   \}
18602 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a6c6e4132d386987f7993da8b744dca55}} 
\index{shell.\+c@{shell.\+c}!write\+File@{write\+File}}
\index{write\+File@{write\+File}!shell.\+c@{shell.\+c}}
\subsubsection{write\+File()}
{\footnotesize\ttfamily static int write\+File (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{p\+Ctx,  }\item[{const char $\ast$}]{z\+File,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$}]{p\+Data,  }\item[{mode\+\_\+t}]{mode,  }\item[{\textbf{ sqlite3\+\_\+int64}}]{mtime }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2375 of file shell.\+c.



References file\+Stat(), sqlite3\+\_\+free, sqlite3\+\_\+result\+\_\+int64, sqlite3\+\_\+value\+\_\+blob, sqlite3\+\_\+value\+\_\+bytes, and sqlite3\+\_\+value\+\_\+text.



Referenced by writefile\+Func().


\begin{DoxyCode}
2381  \{
2382 \textcolor{preprocessor}{#if !defined(\_WIN32) && !defined(WIN32)}
2383   \textcolor{keywordflow}{if}( S\_ISLNK(mode) )\{
2384     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zTo = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(pData);
2385     \textcolor{keywordflow}{if}( symlink(zTo, zFile)<0 ) \textcolor{keywordflow}{return} 1;
2386   \}\textcolor{keywordflow}{else}
2387 \textcolor{preprocessor}{#endif}
2388   \{
2389     \textcolor{keywordflow}{if}( S\_ISDIR(mode) )\{
2390       \textcolor{keywordflow}{if}( mkdir(zFile, mode) )\{
2391         \textcolor{comment}{/* The mkdir() call to create the directory failed. This might not}
2392 \textcolor{comment}{        ** be an error though - if there is already a directory at the same}
2393 \textcolor{comment}{        ** path and either the permissions already match or can be changed}
2394 \textcolor{comment}{        ** to do so using chmod(), it is not an error.  */}
2395         \textcolor{keyword}{struct }stat sStat;
2396         \textcolor{keywordflow}{if}( errno!=EEXIST
2397          || 0!=fileStat(zFile, &sStat)
2398          || !S\_ISDIR(sStat.st\_mode)
2399          || ((sStat.st\_mode&0777)!=(mode&0777) && 0!=chmod(zFile, mode&0777))
2400         )\{
2401           \textcolor{keywordflow}{return} 1;
2402         \}
2403       \}
2404     \}\textcolor{keywordflow}{else}\{
2405       sqlite3_int64 nWrite = 0;
2406       \textcolor{keyword}{const} \textcolor{keywordtype}{char} *z;
2407       \textcolor{keywordtype}{int} rc = 0;
2408       FILE *out = fopen(zFile, \textcolor{stringliteral}{"wb"});
2409       \textcolor{keywordflow}{if}( out==0 ) \textcolor{keywordflow}{return} 1;
2410       z = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_blob(pData);
2411       \textcolor{keywordflow}{if}( z )\{
2412         sqlite3_int64 n = fwrite(z, 1, sqlite3_value_bytes(pData), out);
2413         nWrite = sqlite3_value_bytes(pData);
2414         \textcolor{keywordflow}{if}( nWrite!=n )\{
2415           rc = 1;
2416         \}
2417       \}
2418       fclose(out);
2419       \textcolor{keywordflow}{if}( rc==0 && mode && chmod(zFile, mode & 0777) )\{
2420         rc = 1;
2421       \}
2422       \textcolor{keywordflow}{if}( rc ) \textcolor{keywordflow}{return} 2;
2423       sqlite3_result_int64(pCtx, nWrite);
2424     \}
2425   \}
2426 
2427   \textcolor{keywordflow}{if}( mtime>=0 )\{
2428 \textcolor{preprocessor}{#if defined(\_WIN32)}
2429     \textcolor{comment}{/* Windows */}
2430     FILETIME lastAccess;
2431     FILETIME lastWrite;
2432     SYSTEMTIME currentTime;
2433     LONGLONG intervals;
2434     HANDLE hFile;
2435     LPWSTR zUnicodeName;
2436     \textcolor{keyword}{extern} LPWSTR sqlite3\_win32\_utf8\_to\_unicode(\textcolor{keyword}{const} \textcolor{keywordtype}{char}*);
2437 
2438     GetSystemTime(&currentTime);
2439     SystemTimeToFileTime(&currentTime, &lastAccess);
2440     intervals = Int32x32To64(mtime, 10000000) + 116444736000000000;
2441     lastWrite.dwLowDateTime = (DWORD)intervals;
2442     lastWrite.dwHighDateTime = intervals >> 32;
2443     zUnicodeName = sqlite3\_win32\_utf8\_to\_unicode(zFile);
2444     \textcolor{keywordflow}{if}( zUnicodeName==0 )\{
2445       \textcolor{keywordflow}{return} 1;
2446     \}
2447     hFile = CreateFileW(
2448       zUnicodeName, FILE\_WRITE\_ATTRIBUTES, 0, NULL, OPEN\_EXISTING,
2449       FILE\_FLAG\_BACKUP\_SEMANTICS, NULL
2450     );
2451     sqlite3_free(zUnicodeName);
2452     \textcolor{keywordflow}{if}( hFile!=INVALID\_HANDLE\_VALUE )\{
2453       BOOL bResult = SetFileTime(hFile, NULL, &lastAccess, &lastWrite);
2454       CloseHandle(hFile);
2455       \textcolor{keywordflow}{return} !bResult;
2456     \}\textcolor{keywordflow}{else}\{
2457       \textcolor{keywordflow}{return} 1;
2458     \}
2459 \textcolor{preprocessor}{#elif defined(AT\_FDCWD) && 0 }\textcolor{comment}{/* utimensat() is not universally available */}\textcolor{preprocessor}{}
2460     \textcolor{comment}{/* Recent unix */}
2461     \textcolor{keyword}{struct }timespec times[2];
2462     times[0].tv\_nsec = times[1].tv\_nsec = 0;
2463     times[0].tv\_sec = time(0);
2464     times[1].tv\_sec = mtime;
2465     \textcolor{keywordflow}{if}( utimensat(AT\_FDCWD, zFile, times, AT\_SYMLINK\_NOFOLLOW) )\{
2466       \textcolor{keywordflow}{return} 1;
2467     \}
2468 \textcolor{preprocessor}{#else}
2469     \textcolor{comment}{/* Legacy unix */}
2470     \textcolor{keyword}{struct }timeval times[2];
2471     times[0].tv\_usec = times[1].tv\_usec = 0;
2472     times[0].tv\_sec = time(0);
2473     times[1].tv\_sec = mtime;
2474     \textcolor{keywordflow}{if}( utimes(zFile, times) )\{
2475       \textcolor{keywordflow}{return} 1;
2476     \}
2477 \textcolor{preprocessor}{#endif}
2478   \}
2479 
2480   \textcolor{keywordflow}{return} 0;
2481 \}
\end{DoxyCode}
\mbox{\label{shell_8c_a11e5af10ab390682cf8fce9a534da02c}} 
\index{shell.\+c@{shell.\+c}!writefile\+Func@{writefile\+Func}}
\index{writefile\+Func@{writefile\+Func}!shell.\+c@{shell.\+c}}
\subsubsection{writefile\+Func()}
{\footnotesize\ttfamily static void writefile\+Func (\begin{DoxyParamCaption}\item[{\textbf{ sqlite3\+\_\+context} $\ast$}]{context,  }\item[{int}]{argc,  }\item[{\textbf{ sqlite3\+\_\+value} $\ast$$\ast$}]{argv }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 2487 of file shell.\+c.



References ctx\+Error\+Msg(), make\+Directory(), sqlite3\+\_\+result\+\_\+error, sqlite3\+\_\+value\+\_\+int, sqlite3\+\_\+value\+\_\+int64, sqlite3\+\_\+value\+\_\+text, S\+Q\+L\+I\+T\+E\+\_\+\+OK, and write\+File().



Referenced by sqlite3\+\_\+fileio\+\_\+init().


\begin{DoxyCode}
2491  \{
2492   \textcolor{keyword}{const} \textcolor{keywordtype}{char} *zFile;
2493   mode\_t mode = 0;
2494   \textcolor{keywordtype}{int} res;
2495   sqlite3_int64 mtime = -1;
2496 
2497   \textcolor{keywordflow}{if}( argc<2 || argc>4 )\{
2498     sqlite3_result_error(context, 
2499         \textcolor{stringliteral}{"wrong number of arguments to function writefile()"}, -1
2500     );
2501     \textcolor{keywordflow}{return};
2502   \}
2503 
2504   zFile = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)sqlite3_value_text(argv[0]);
2505   \textcolor{keywordflow}{if}( zFile==0 ) \textcolor{keywordflow}{return};
2506   \textcolor{keywordflow}{if}( argc>=3 )\{
2507     mode = (mode\_t)sqlite3_value_int(argv[2]);
2508   \}
2509   \textcolor{keywordflow}{if}( argc==4 )\{
2510     mtime = sqlite3_value_int64(argv[3]);
2511   \}
2512 
2513   res = writeFile(context, zFile, argv[1], mode, mtime);
2514   \textcolor{keywordflow}{if}( res==1 && errno==ENOENT )\{
2515     \textcolor{keywordflow}{if}( makeDirectory(zFile)==SQLITE_OK )\{
2516       res = writeFile(context, zFile, argv[1], mode, mtime);
2517     \}
2518   \}
2519 
2520   \textcolor{keywordflow}{if}( argc>2 && res!=0 )\{
2521     \textcolor{keywordflow}{if}( S\_ISLNK(mode) )\{
2522       ctxErrorMsg(context, \textcolor{stringliteral}{"failed to create symlink: %s"}, zFile);
2523     \}\textcolor{keywordflow}{else} \textcolor{keywordflow}{if}( S\_ISDIR(mode) )\{
2524       ctxErrorMsg(context, \textcolor{stringliteral}{"failed to create directory: %s"}, zFile);
2525     \}\textcolor{keywordflow}{else}\{
2526       ctxErrorMsg(context, \textcolor{stringliteral}{"failed to write file: %s"}, zFile);
2527     \}
2528   \}
2529 \}
\end{DoxyCode}
\mbox{\label{shell_8c_aa9ba9e40a42ab4604602939dfdcab9dd}} 
\index{shell.\+c@{shell.\+c}!ws\+To\+Eol@{ws\+To\+Eol}}
\index{ws\+To\+Eol@{ws\+To\+Eol}!shell.\+c@{shell.\+c}}
\subsubsection{ws\+To\+Eol()}
{\footnotesize\ttfamily static int ws\+To\+Eol (\begin{DoxyParamCaption}\item[{const char $\ast$}]{z }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 10269 of file shell.\+c.



References Is\+Space.



Referenced by shell\+\_\+callback().


\begin{DoxyCode}
10269                                  \{
10270   \textcolor{keywordtype}{int} i;
10271   \textcolor{keywordflow}{for}(i=0; z[i]; i++)\{
10272     \textcolor{keywordflow}{if}( z[i]==\textcolor{charliteral}{'\(\backslash\)n'} ) \textcolor{keywordflow}{return} 1;
10273     \textcolor{keywordflow}{if}( IsSpace(z[i]) ) \textcolor{keywordflow}{continue};
10274     \textcolor{keywordflow}{if}( z[i]==\textcolor{charliteral}{'-'} && z[i+1]==\textcolor{charliteral}{'-'} ) \textcolor{keywordflow}{return} 1;
10275     \textcolor{keywordflow}{return} 0;
10276   \}
10277   \textcolor{keywordflow}{return} 1;
10278 \}
\end{DoxyCode}


\subsection{Variable Documentation}
\mbox{\label{shell_8c_aeb377708ef7f73fc709295f27a533706}} 
\index{shell.\+c@{shell.\+c}!apnd\+\_\+io\+\_\+methods@{apnd\+\_\+io\+\_\+methods}}
\index{apnd\+\_\+io\+\_\+methods@{apnd\+\_\+io\+\_\+methods}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+\_\+io\+\_\+methods}
{\footnotesize\ttfamily const \textbf{ sqlite3\+\_\+io\+\_\+methods} apnd\+\_\+io\+\_\+methods\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{
  3,                              
  apndClose,                      
  apndRead,                       
  apndWrite,                      
  apndTruncate,                   
  apndSync,                       
  apndFileSize,                   
  apndLock,                       
  apndUnlock,                     
  apndCheckReservedLock,          
  apndFileControl,                
  apndSectorSize,                 
  apndDeviceCharacteristics,      
  apndShmMap,                     
  apndShmLock,                    
  apndShmBarrier,                 
  apndShmUnmap,                   
  apndFetch,                      
  apndUnfetch                     
\}
\end{DoxyCode}


Definition at line 3696 of file shell.\+c.



Referenced by apnd\+Open().

\mbox{\label{shell_8c_a3c887a4b51605d3bfeb31ccea72a2e3b}} 
\index{shell.\+c@{shell.\+c}!apnd\+\_\+vfs@{apnd\+\_\+vfs}}
\index{apnd\+\_\+vfs@{apnd\+\_\+vfs}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+\_\+vfs}
{\footnotesize\ttfamily \textbf{ sqlite3\+\_\+vfs} apnd\+\_\+vfs\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{
  3,                            
  0,                            
  1024,                         
  0,                            
  \textcolor{stringliteral}{"apndvfs"},                    
  0,                             
  apndOpen,                     
  apndDelete,                   
  apndAccess,                   
  apndFullPathname,             
  apndDlOpen,                   
  apndDlError,                  
  apndDlSym,                    
  apndDlClose,                  
  apndRandomness,               
  apndSleep,                    
  apndCurrentTime,              
  apndGetLastError,             
  apndCurrentTimeInt64,         
  apndSetSystemCall,            
  apndGetSystemCall,            
  apndNextSystemCall            
\}
\end{DoxyCode}


Definition at line 3671 of file shell.\+c.

\mbox{\label{shell_8c_aab02ee173c489a9fbf026c13067df5ea}} 
\index{shell.\+c@{shell.\+c}!apnd\+Dl\+Sym@{apnd\+Dl\+Sym}}
\index{apnd\+Dl\+Sym@{apnd\+Dl\+Sym}!shell.\+c@{shell.\+c}}
\subsubsection{apnd\+Dl\+Sym}
{\footnotesize\ttfamily void($\ast$)(void) apnd\+Dl\+Sym(\textbf{ sqlite3\+\_\+vfs} $\ast$p\+Vfs, void $\ast$p, const char $\ast$z\+Sym)\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 3660 of file shell.\+c.



Referenced by apnd\+Dl\+Error().

\mbox{\label{shell_8c_ad906c78c2bf41002f903352c505b780f}} 
\index{shell.\+c@{shell.\+c}!Argv0@{Argv0}}
\index{Argv0@{Argv0}!shell.\+c@{shell.\+c}}
\subsubsection{Argv0}
{\footnotesize\ttfamily char$\ast$ Argv0\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 422 of file shell.\+c.

\mbox{\label{shell_8c_ad3947fa1f0ba643fbcbdf0daefbe3dd6}} 
\index{shell.\+c@{shell.\+c}!az\+Help@{az\+Help}}
\index{az\+Help@{az\+Help}!shell.\+c@{shell.\+c}}
\subsubsection{az\+Help}
{\footnotesize\ttfamily const char$\ast$ az\+Help[$\,$]\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 12031 of file shell.\+c.



Referenced by show\+Help().

\mbox{\label{shell_8c_a09cacd62c349d6713656bb6eaafe996d}} 
\index{shell.\+c@{shell.\+c}!bail\+\_\+on\+\_\+error@{bail\+\_\+on\+\_\+error}}
\index{bail\+\_\+on\+\_\+error@{bail\+\_\+on\+\_\+error}!shell.\+c@{shell.\+c}}
\subsubsection{bail\+\_\+on\+\_\+error}
{\footnotesize\ttfamily int bail\+\_\+on\+\_\+error = 0\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 391 of file shell.\+c.

\mbox{\label{shell_8c_a5cc662469b950b9fb2a19ecd7398e99b}} 
\index{shell.\+c@{shell.\+c}!completion\+Module@{completion\+Module}}
\index{completion\+Module@{completion\+Module}!shell.\+c@{shell.\+c}}
\subsubsection{completion\+Module}
{\footnotesize\ttfamily \textbf{ sqlite3\+\_\+module} completion\+Module\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{
  0,                         
  0,                         
  completionConnect,         
  completionBestIndex,       
  completionDisconnect,      
  0,                         
  completionOpen,            
  completionClose,           
  completionFilter,          
  completionNext,            
  completionEof,             
  completionColumn,          
  completionRowid,           
  0,                         
  0,                         
  0,                         
  0,                         
  0,                         
  0,                         
  0,                         
  0,                         
  0,                         
  0,                         
  0                          
\}
\end{DoxyCode}


Definition at line 3482 of file shell.\+c.

\mbox{\label{shell_8c_acf98b01fc34a1bbc4f7d61f3ae62b6da}} 
\index{shell.\+c@{shell.\+c}!continue\+Prompt@{continue\+Prompt}}
\index{continue\+Prompt@{continue\+Prompt}!shell.\+c@{shell.\+c}}
\subsubsection{continue\+Prompt}
{\footnotesize\ttfamily char continue\+Prompt[20]\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 429 of file shell.\+c.



Referenced by one\+\_\+input\+\_\+line().

\mbox{\label{shell_8c_ac8a1f6112bb3b4327605130a551d8dc4}} 
\index{shell.\+c@{shell.\+c}!enable\+Timer@{enable\+Timer}}
\index{enable\+Timer@{enable\+Timer}!shell.\+c@{shell.\+c}}
\subsubsection{enable\+Timer}
{\footnotesize\ttfamily int enable\+Timer = 0\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 225 of file shell.\+c.

\mbox{\label{shell_8c_a27e0c7d1e426e994d47c8f67f6e1dcf6}} 
\index{shell.\+c@{shell.\+c}!ersazt\+Methods@{ersazt\+Methods}}
\index{ersazt\+Methods@{ersazt\+Methods}!shell.\+c@{shell.\+c}}
\subsubsection{ersazt\+Methods}
{\footnotesize\ttfamily \textbf{ sqlite3\+\_\+mem\+\_\+methods} ersazt\+Methods\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{
  memtraceMalloc,
  memtraceFree,
  memtraceRealloc,
  memtraceSize,
  memtraceRoundup,
  memtraceInit,
  memtraceShutdown,
  0
\}
\end{DoxyCode}


Definition at line 4178 of file shell.\+c.

\mbox{\label{shell_8c_ae09e723b834e949e20aadf34501e10c8}} 
\index{shell.\+c@{shell.\+c}!global\+Db@{global\+Db}}
\index{global\+Db@{global\+Db}!shell.\+c@{shell.\+c}}
\subsubsection{global\+Db}
{\footnotesize\ttfamily \textbf{ sqlite3}$\ast$ global\+Db = 0\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 411 of file shell.\+c.

\mbox{\label{shell_8c_a6d71f0f74b48d086b34c24736c89a38d}} 
\index{shell.\+c@{shell.\+c}!i\+Begin@{i\+Begin}}
\index{i\+Begin@{i\+Begin}!shell.\+c@{shell.\+c}}
\subsubsection{i\+Begin}
{\footnotesize\ttfamily \textbf{ sqlite3\+\_\+int64} i\+Begin\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 257 of file shell.\+c.

\mbox{\label{shell_8c_acff55a5111149c7b0e53349d1487ec59}} 
\index{shell.\+c@{shell.\+c}!main\+Prompt@{main\+Prompt}}
\index{main\+Prompt@{main\+Prompt}!shell.\+c@{shell.\+c}}
\subsubsection{main\+Prompt}
{\footnotesize\ttfamily char main\+Prompt[20]\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 428 of file shell.\+c.



Referenced by one\+\_\+input\+\_\+line().

\mbox{\label{shell_8c_a3a4cae0972043e05c14f6a46e374b321}} 
\index{shell.\+c@{shell.\+c}!memtrace\+Base@{memtrace\+Base}}
\index{memtrace\+Base@{memtrace\+Base}!shell.\+c@{shell.\+c}}
\subsubsection{memtrace\+Base}
{\footnotesize\ttfamily \textbf{ sqlite3\+\_\+mem\+\_\+methods} memtrace\+Base\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4134 of file shell.\+c.

\mbox{\label{shell_8c_a288e005115dbb6a86d3b5f837bbfe7d1}} 
\index{shell.\+c@{shell.\+c}!memtrace\+Out@{memtrace\+Out}}
\index{memtrace\+Out@{memtrace\+Out}!shell.\+c@{shell.\+c}}
\subsubsection{memtrace\+Out}
{\footnotesize\ttfamily F\+I\+LE$\ast$ memtrace\+Out\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 4135 of file shell.\+c.

\mbox{\label{shell_8c_a583998c48830f321a47a17572f2dc933}} 
\index{shell.\+c@{shell.\+c}!mode\+Descr@{mode\+Descr}}
\index{mode\+Descr@{mode\+Descr}!shell.\+c@{shell.\+c}}
\subsubsection{mode\+Descr}
{\footnotesize\ttfamily const char$\ast$ mode\+Descr[$\,$]\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{
  \textcolor{stringliteral}{"line"},
  \textcolor{stringliteral}{"column"},
  \textcolor{stringliteral}{"list"},
  \textcolor{stringliteral}{"semi"},
  \textcolor{stringliteral}{"html"},
  \textcolor{stringliteral}{"insert"},
  \textcolor{stringliteral}{"quote"},
  \textcolor{stringliteral}{"tcl"},
  \textcolor{stringliteral}{"csv"},
  \textcolor{stringliteral}{"explain"},
  \textcolor{stringliteral}{"ascii"},
  \textcolor{stringliteral}{"prettyprint"},
  \textcolor{stringliteral}{"eqp"}
\}
\end{DoxyCode}


Definition at line 9700 of file shell.\+c.

\mbox{\label{shell_8c_a643e1ab0a846cd5dc5f1fbf2cfe3078e}} 
\index{shell.\+c@{shell.\+c}!need\+Csv\+Quote@{need\+Csv\+Quote}}
\index{need\+Csv\+Quote@{need\+Csv\+Quote}!shell.\+c@{shell.\+c}}
\subsubsection{need\+Csv\+Quote}
{\footnotesize\ttfamily const char need\+Csv\+Quote[$\,$]\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1,
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,
\}
\end{DoxyCode}


Definition at line 10118 of file shell.\+c.

\mbox{\label{shell_8c_a256978fb8ad6b4fe2eb4a02d112b1d4e}} 
\index{shell.\+c@{shell.\+c}!s\+Begin@{s\+Begin}}
\index{s\+Begin@{s\+Begin}!shell.\+c@{shell.\+c}}
\subsubsection{s\+Begin}
{\footnotesize\ttfamily struct rusage s\+Begin\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 256 of file shell.\+c.



Referenced by begin\+Timer(), and end\+Timer().

\mbox{\label{shell_8c_aab9c23da2da2dda99ea4b2703d56331a}} 
\index{shell.\+c@{shell.\+c}!seen\+Interrupt@{seen\+Interrupt}}
\index{seen\+Interrupt@{seen\+Interrupt}!shell.\+c@{shell.\+c}}
\subsubsection{seen\+Interrupt}
{\footnotesize\ttfamily volatile int seen\+Interrupt = 0\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 416 of file shell.\+c.

\mbox{\label{shell_8c_a55c1a0a7491e69398c3db400d86ab455}} 
\index{shell.\+c@{shell.\+c}!stdin\+\_\+is\+\_\+interactive@{stdin\+\_\+is\+\_\+interactive}}
\index{stdin\+\_\+is\+\_\+interactive@{stdin\+\_\+is\+\_\+interactive}!shell.\+c@{shell.\+c}}
\subsubsection{stdin\+\_\+is\+\_\+interactive}
{\footnotesize\ttfamily int stdin\+\_\+is\+\_\+interactive = 1\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 397 of file shell.\+c.

\mbox{\label{shell_8c_a022ffe09bf337d9973cfd0bdc9b53d4a}} 
\index{shell.\+c@{shell.\+c}!stdout\+\_\+is\+\_\+console@{stdout\+\_\+is\+\_\+console}}
\index{stdout\+\_\+is\+\_\+console@{stdout\+\_\+is\+\_\+console}!shell.\+c@{shell.\+c}}
\subsubsection{stdout\+\_\+is\+\_\+console}
{\footnotesize\ttfamily int stdout\+\_\+is\+\_\+console = 1\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 404 of file shell.\+c.

\mbox{\label{shell_8c_a7ae41c1716e5067e8d40df0cc6654b1e}} 
\index{shell.\+c@{shell.\+c}!z\+Options@{z\+Options}}
\index{z\+Options@{z\+Options}!shell.\+c@{shell.\+c}}
\subsubsection{z\+Options}
{\footnotesize\ttfamily const char z\+Options[$\,$]\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 18526 of file shell.\+c.

