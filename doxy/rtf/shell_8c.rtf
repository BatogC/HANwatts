{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
node-red-1881/node_modules/sqlite3/build/Release/obj/gen/sqlite-autoconf-3310100/shell.c File Reference\par \pard\plain 
{\tc\tcl2 \v node-red-1881/node_modules/sqlite3/build/Release/obj/gen/sqlite-autoconf-3310100/shell.c}
{\xe \v node-red-1881/node_modules/sqlite3/build/Release/obj/gen/sqlite-autoconf-3310100/shell.c}
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <assert.h>}\par
{\f2 #include "sqlite3.h"}\par
{\f2 #include <ctype.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <signal.h>}\par
{\f2 #include <pwd.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <dirent.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <sys/time.h>}\par
{\f2 #include <sys/resource.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <utime.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <errno.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for shell.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "shell_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ShellText}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SHA3Context}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b FsdirLevel}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b fsdir_cursor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b fsdir_tab}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b completion_vtab}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b completion_cursor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ApndFile}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IdxConstraint}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IdxScan}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IdxColumn}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IdxTable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IdxWrite}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IdxStatement}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IdxHashEntry}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IdxHash}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sqlite3expert}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ExpertVtab}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ExpertCsr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IdxSampleCtx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IdxRemCtx}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b IdxRemCtx::IdxRemSlot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SavedModeInfo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ExpertInfo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b EQPGraphRow}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b EQPGraph}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ShellState}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ImportCtx}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _LARGE_FILE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _FILE_OFFSET_BITS}\~ 64\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _LARGEFILE_SOURCE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GETPID}\~ getpid\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b shell_read_history}({\b X})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b shell_write_history}({\b X})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b shell_stifle_history}({\b X})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_USE_LOCAL_GETLINE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IsSpace}({\b X})\~ isspace((unsigned char){\b X})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IsDigit}({\b X})\~ isdigit((unsigned char){\b X})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ToLower}({\b X})\~ (char)tolower((unsigned char){\b X})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b setBinaryMode}({\b X},  Y)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b setTextMode}({\b X},  Y)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BEGIN_TIMER}\~ {\b beginTimer}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b END_TIMER}\~ {\b endTimer}()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HAS_TIMER}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNUSED_PARAMETER}(x)\~ (void)(x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ArraySize}({\b X})\~ (int)(sizeof({\b X})/sizeof({\b X}[0]))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b utf8_printf}\~ fprintf\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b raw_printf}\~ fprintf\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SQLITE_EXTENSION_INIT1}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SQLITE_EXTENSION_INIT2}({\b X})\~ (void)({\b X})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHA3_BYTEORDER}\~ 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a00}\~ (p->u.s[0])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a01}\~ (p->u.s[1])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a02}\~ (p->u.s[2])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a03}\~ (p->u.s[3])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a04}\~ (p->u.s[4])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a10}\~ (p->u.s[5])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a11}\~ (p->u.s[6])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a12}\~ (p->u.s[7])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a13}\~ (p->u.s[8])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a14}\~ (p->u.s[9])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a20}\~ (p->u.s[10])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a21}\~ (p->u.s[11])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a22}\~ (p->u.s[12])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a23}\~ (p->u.s[13])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a24}\~ (p->u.s[14])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a30}\~ (p->u.s[15])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a31}\~ (p->u.s[16])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a32}\~ (p->u.s[17])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a33}\~ (p->u.s[18])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a34}\~ (p->u.s[19])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a40}\~ (p->u.s[20])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a41}\~ (p->u.s[21])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a42}\~ (p->u.s[22])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a43}\~ (p->u.s[23])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b a44}\~ (p->u.s[24])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ROL64}(a,  x)\~ ((a<<x)|(a>>(64-x)))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FSDIR_SCHEMA}\~ "(name,mode,mtime,data,path HIDDEN,dir HIDDEN)"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FSDIR_COLUMN_NAME}\~ 0     /* Name of the file */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FSDIR_COLUMN_MODE}\~ 1     /* Access mode */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FSDIR_COLUMN_MTIME}\~ 2     /* Last modification time */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FSDIR_COLUMN_DATA}\~ 3     /* File content */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FSDIR_COLUMN_PATH}\~ 4     /* Path to top of search */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FSDIR_COLUMN_DIR}\~ 5     /* Path is relative to this directory */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_FIRST_PHASE}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_KEYWORDS}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_PRAGMAS}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_FUNCTIONS}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_COLLATIONS}\~ 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_INDEXES}\~ 5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_TRIGGERS}\~ 6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_DATABASES}\~ 7\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_TABLES}\~ 8    /* Also VIEWs and TRIGGERs */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_COLUMNS}\~ 9\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_MODULES}\~ 10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_EOF}\~ 11\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_COLUMN_CANDIDATE}\~ 0  /* Suggested completion of the input */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_COLUMN_PREFIX}\~ 1  /* Prefix of the word to be completed */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_COLUMN_WHOLELINE}\~ 2  /* Entire line seen so far */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMPLETION_COLUMN_PHASE}\~ 3  /* ePhase - used for debugging only */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APND_MARK_PREFIX}\~ "Start-Of-SQLite3-"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APND_MARK_PREFIX_SZ}\~ 17\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APND_MARK_SIZE}\~ 25\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APND_MAX_SIZE}\~ (65536*15259)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ORIGVFS}(p)\~ (({\b sqlite3_vfs}*)((p)->pAppData))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ORIGFILE}(p)\~ (({\b sqlite3_file}*)((({\b ApndFile}*)(p))+1))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SQLITEEXPERT_H}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPERT_CONFIG_SAMPLE}\~ 1    /* int */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPERT_REPORT_SQL}\~ 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPERT_REPORT_INDEXES}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPERT_REPORT_PLAN}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXPERT_REPORT_CANDIDATES}\~ 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b STRLEN}\~ (int)strlen\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNIQUE_TABLE_NAME}\~ "t592690916721053953805701627921227776"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IDX_HASH_SIZE}\~ 1023\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AUTOEQP_off}\~ 0           /* Automatic EXPLAIN QUERY PLAN is off */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AUTOEQP_on}\~ 1           /* Automatic EQP is on */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AUTOEQP_trigger}\~ 2           /* On and also show plans for triggers */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AUTOEQP_full}\~ 3           /* Show full EXPLAIN */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_OPEN_UNSPEC}\~ 0      /* No open-mode specified */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_OPEN_NORMAL}\~ 1      /* Normal database file */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_OPEN_APPENDVFS}\~ 2      /* Use appendvfs */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_OPEN_ZIPFILE}\~ 3      /* Use the zipfile virtual table */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_OPEN_READONLY}\~ 4      /* Open a normal database read-only */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_OPEN_DESERIALIZE}\~ 5      /* Open using {\b sqlite3_deserialize}() */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_OPEN_HEXDB}\~ 6      /* Use "dbtotxt" output as data source */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_TRACE_PLAIN}\~ 0      /* Show input SQL text */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_TRACE_EXPANDED}\~ 1      /* Show expanded SQL text */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_TRACE_NORMALIZED}\~ 2      /* Show normalized SQL text */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_PROGRESS_QUIET}\~ 0x01  /* Omit announcing every progress callback */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_PROGRESS_RESET}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHELL_PROGRESS_ONCE}\~ 0x04  /* Cancel the --limit after firing once */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHFLG_Pagecache}\~ 0x00000001 /* The --pagecache option is used */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHFLG_Lookaside}\~ 0x00000002 /* Lookaside memory is used */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHFLG_Backslash}\~ 0x00000004 /* The --backslash option is used */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHFLG_PreserveRowid}\~ 0x00000008 /* .dump preserves rowid values */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHFLG_Newlines}\~ 0x00000010 /* .dump --newline flag */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHFLG_CountChanges}\~ 0x00000020 /* .changes setting */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SHFLG_Echo}\~ 0x00000040 /* .echo or --echo setting */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ShellHasFlag}(P,  {\b X})\~ (((P)->shellFlgs & ({\b X}))!=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ShellSetFlag}(P,  {\b X})\~ ((P)->shellFlgs|=({\b X}))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ShellClearFlag}(P,  {\b X})\~ ((P)->shellFlgs&=(~({\b X})))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_Line}\~ 0  /* One column per line.  Blank line between records */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_Column}\~ 1  /* One record per line in neat columns */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_List}\~ 2  /* One record per line with a separator */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_Semi}\~ 3  /* Same as {\b MODE_List} but append ";" to each line */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_Html}\~ 4  /* Generate an XHTML table */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_Insert}\~ 5  /* Generate SQL "insert" statements */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_Quote}\~ 6  /* Quote values as for SQL */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_Tcl}\~ 7  /* Generate ANSI-C or TCL quoted elements */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_Csv}\~ 8  /* Quote strings, numbers are plain */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_Explain}\~ 9  /* Like {\b MODE_Column}, but do not truncate data */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_Ascii}\~ 10  /* Use ASCII unit and record separators (0x1F/0x1E) */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_Pretty}\~ 11  /* Pretty-print schemas */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODE_EQP}\~ 12  /* Converts EXPLAIN QUERY PLAN output into a graph */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEP_Column}\~ "|"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEP_Row}\~ "\\n"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEP_Tab}\~ "\\t"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEP_Space}\~ " "\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEP_Comma}\~ ","\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEP_CrLf}\~ "\\r\\n"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEP_Unit}\~ "\\x1F"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SEP_Record}\~ "\\x1E"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b session_close_all}({\b X})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OPEN_DB_KEEPALIVE}\~ 0x001   /* Return after error if true */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OPEN_DB_ZIPFILE}\~ 0x002   /* Open as ZIP if name matches *.zip */\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CTIMEOPT_VAL_}(opt)\~ #opt\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CTIMEOPT_VAL}(opt)\~ {\b CTIMEOPT_VAL_}(opt)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SQLITE_SHELL_IS_UTF8}\~ (1)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b sqlite3_int64} {\b i64}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b sqlite3_uint64} {\b u64}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned char {\b u8}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b ShellText} {\b ShellText}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b SHA3Context} {\b SHA3Context}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b fsdir_cursor} {\b fsdir_cursor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b FsdirLevel} {\b FsdirLevel}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b fsdir_tab} {\b fsdir_tab}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef typedefSQLITE_EXTENSION_INIT1 struct {\b completion_vtab} {\b completion_vtab}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b completion_cursor} {\b completion_cursor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b sqlite3_vfs} {\b ApndVfs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b ApndFile} {\b ApndFile}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b sqlite3expert} {\b sqlite3expert}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b IdxColumn} {\b IdxColumn}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b IdxConstraint} {\b IdxConstraint}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b IdxScan} {\b IdxScan}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b IdxStatement} {\b IdxStatement}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b IdxTable} {\b IdxTable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b IdxWrite} {\b IdxWrite}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b IdxHashEntry} {\b IdxHashEntry}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b IdxHash} {\b IdxHash}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b ExpertVtab} {\b ExpertVtab}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b ExpertCsr} {\b ExpertCsr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b SavedModeInfo} {\b SavedModeInfo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b ExpertInfo} {\b ExpertInfo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b EQPGraphRow} {\b EQPGraphRow}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b EQPGraph} {\b EQPGraph}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b ShellState} {\b ShellState}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b ImportCtx} {\b ImportCtx}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isatty} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b popen} (const char *, const char *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pclose} (FILE *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b sqlite3_int64} {\b timeOfDay} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b beginTimer} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b timeDiff} (struct timeval *pStart, struct timeval *pEnd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b endTimer} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b shell_out_of_memory} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b utf8_width_print} (FILE *pOut, int w, const char *zUtf)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b isNumber} (const char *z, int *realnum)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b strlen30} (const char *z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b strlenChar} (const char *z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b local_getline} (char *zLine, FILE *in)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b one_input_line} (FILE *in, char *zPrior, int isContinuation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b hexDigitValue} (char c)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b sqlite3_int64} {\b integerValue} (const char *zArg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b initText} ({\b ShellText} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b freeText} ({\b ShellText} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b appendText} ({\b ShellText} *p, char const *zAppend, char quote)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char {\b quoteChar} (const char *{\b zName})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b shellFakeSchema} ({\b sqlite3} *db, const char *zSchema, const char *{\b zName})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b shellModuleSchema} ({\b sqlite3_context} *pCtx, int nVal, {\b sqlite3_value} **apVal)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b shellAddSchemaName} ({\b sqlite3_context} *pCtx, int nVal, {\b sqlite3_value} **apVal)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b KeccakF1600Step} ({\b SHA3Context} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b SHA3Init} ({\b SHA3Context} *p, int iSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b SHA3Update} ({\b SHA3Context} *p, const unsigned char *aData, unsigned int nData)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned char * {\b SHA3Final} ({\b SHA3Context} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b sha3Func} ({\b sqlite3_context} *context, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b hash_step_vformat} ({\b SHA3Context} *p, const char *zFormat,...)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b sha3QueryFunc} ({\b sqlite3_context} *context, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sqlite3_shathree_init} ({\b sqlite3} *db, char **pzErrMsg, const {\b sqlite3_api_routines} *pApi)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b readFileContents} ({\b sqlite3_context} *ctx, const char *{\b zName})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b readfileFunc} ({\b sqlite3_context} *context, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b ctxErrorMsg} ({\b sqlite3_context} *ctx, const char *zFmt,...)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fileStat} (const char *zPath, struct stat *pStatBuf)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fileLinkStat} (const char *zPath, struct stat *pStatBuf)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b makeDirectory} (const char *zFile)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b writeFile} ({\b sqlite3_context} *pCtx, const char *zFile, {\b sqlite3_value} *pData, mode_t mode, {\b sqlite3_int64} mtime)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b writefileFunc} ({\b sqlite3_context} *context, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b lsModeFunc} ({\b sqlite3_context} *context, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fsdirConnect} ({\b sqlite3} *db, void *pAux, int argc, const char *const *argv, {\b sqlite3_vtab} **ppVtab, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fsdirDisconnect} ({\b sqlite3_vtab} *pVtab)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fsdirOpen} ({\b sqlite3_vtab} *p, {\b sqlite3_vtab_cursor} **ppCursor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b fsdirResetCursor} ({\b fsdir_cursor} *pCur)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fsdirClose} ({\b sqlite3_vtab_cursor} *cur)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b fsdirSetErrmsg} ({\b fsdir_cursor} *pCur, const char *zFmt,...)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fsdirNext} ({\b sqlite3_vtab_cursor} *cur)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fsdirColumn} ({\b sqlite3_vtab_cursor} *cur, {\b sqlite3_context} *ctx, int i)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fsdirRowid} ({\b sqlite3_vtab_cursor} *cur, {\b sqlite_int64} *pRowid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fsdirEof} ({\b sqlite3_vtab_cursor} *cur)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fsdirFilter} ({\b sqlite3_vtab_cursor} *cur, int idxNum, const char *idxStr, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fsdirBestIndex} ({\b sqlite3_vtab} *tab, {\b sqlite3_index_info} *pIdxInfo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b fsdirRegister} ({\b sqlite3} *db)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sqlite3_fileio_init} ({\b sqlite3} *db, char **pzErrMsg, const {\b sqlite3_api_routines} *pApi)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b completionConnect} ({\b sqlite3} *db, void *pAux, int argc, const char *const *argv, {\b sqlite3_vtab} **ppVtab, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b completionDisconnect} ({\b sqlite3_vtab} *pVtab)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b completionOpen} ({\b sqlite3_vtab} *p, {\b sqlite3_vtab_cursor} **ppCursor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b completionCursorReset} ({\b completion_cursor} *pCur)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b completionClose} ({\b sqlite3_vtab_cursor} *cur)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b completionNext} ({\b sqlite3_vtab_cursor} *cur)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b completionColumn} ({\b sqlite3_vtab_cursor} *cur, {\b sqlite3_context} *ctx, int i)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b completionRowid} ({\b sqlite3_vtab_cursor} *cur, {\b sqlite_int64} *pRowid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b completionEof} ({\b sqlite3_vtab_cursor} *cur)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b completionFilter} ({\b sqlite3_vtab_cursor} *pVtabCursor, int idxNum, const char *idxStr, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b completionBestIndex} ({\b sqlite3_vtab} *tab, {\b sqlite3_index_info} *pIdxInfo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sqlite3CompletionVtabInit} ({\b sqlite3} *db)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sqlite3_completion_init} ({\b sqlite3} *db, char **pzErrMsg, const {\b sqlite3_api_routines} *pApi)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndClose} ({\b sqlite3_file} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndRead} ({\b sqlite3_file} *, void *, int iAmt, {\b sqlite3_int64} iOfst)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndWrite} ({\b sqlite3_file} *, const void *, int iAmt, {\b sqlite3_int64} iOfst)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndTruncate} ({\b sqlite3_file} *, {\b sqlite3_int64} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndSync} ({\b sqlite3_file} *, int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndFileSize} ({\b sqlite3_file} *, {\b sqlite3_int64} *pSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndLock} ({\b sqlite3_file} *, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndUnlock} ({\b sqlite3_file} *, int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndCheckReservedLock} ({\b sqlite3_file} *, int *pResOut)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndFileControl} ({\b sqlite3_file} *, int op, void *pArg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndSectorSize} ({\b sqlite3_file} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndDeviceCharacteristics} ({\b sqlite3_file} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndShmMap} ({\b sqlite3_file} *, int iPg, int pgsz, int, void volatile **)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndShmLock} ({\b sqlite3_file} *, int offset, int n, int flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b apndShmBarrier} ({\b sqlite3_file} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndShmUnmap} ({\b sqlite3_file} *, int deleteFlag)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndFetch} ({\b sqlite3_file} *, {\b sqlite3_int64} iOfst, int iAmt, void **pp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndUnfetch} ({\b sqlite3_file} *, {\b sqlite3_int64} iOfst, void *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndOpen} ({\b sqlite3_vfs} *, const char *, {\b sqlite3_file} *, int, int *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndDelete} ({\b sqlite3_vfs} *, const char *{\b zName}, int syncDir)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndAccess} ({\b sqlite3_vfs} *, const char *{\b zName}, int flags, int *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndFullPathname} ({\b sqlite3_vfs} *, const char *{\b zName}, int, char *zOut)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b apndDlOpen} ({\b sqlite3_vfs} *, const char *zFilename)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b apndDlError} ({\b sqlite3_vfs} *, int nByte, char *zErrMsg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b apndDlClose} ({\b sqlite3_vfs} *, void *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndRandomness} ({\b sqlite3_vfs} *, int nByte, char *zOut)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndSleep} ({\b sqlite3_vfs} *, int microseconds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndCurrentTime} ({\b sqlite3_vfs} *, double *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndGetLastError} ({\b sqlite3_vfs} *, int, char *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndCurrentTimeInt64} ({\b sqlite3_vfs} *, {\b sqlite3_int64} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndSetSystemCall} ({\b sqlite3_vfs} *, const char *, {\b sqlite3_syscall_ptr})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b sqlite3_syscall_ptr} {\b apndGetSystemCall} ({\b sqlite3_vfs} *, const char *z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b apndNextSystemCall} ({\b sqlite3_vfs} *, const char *{\b zName})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndWriteMark} ({\b ApndFile} *p, {\b sqlite3_file} *pFile)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b apndIsOrdinaryDatabaseFile} ({\b sqlite3_int64} sz, {\b sqlite3_file} *pFile)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b sqlite3_int64} {\b apndReadMark} ({\b sqlite3_int64} sz, {\b sqlite3_file} *pFile)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sqlite3_appendvfs_init} ({\b sqlite3} *db, char **pzErrMsg, const {\b sqlite3_api_routines} *pApi)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b memtraceMalloc} (int n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b memtraceFree} (void *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b memtraceRealloc} (void *p, int n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b memtraceSize} (void *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b memtraceRoundup} (int n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b memtraceInit} (void *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b memtraceShutdown} (void *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sqlite3MemTraceActivate} (FILE *out)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sqlite3MemTraceDeactivate} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b sqlite3expert} * {\b sqlite3_expert_new} ({\b sqlite3} *db, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sqlite3_expert_config} ({\b sqlite3expert} *p, int op,...)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sqlite3_expert_sql} ({\b sqlite3expert} *p, const char *zSql, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sqlite3_expert_analyze} ({\b sqlite3expert} *p, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b sqlite3_expert_count} ({\b sqlite3expert} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b sqlite3_expert_report} ({\b sqlite3expert} *, int iStmt, int eReport)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sqlite3_expert_destroy} ({\b sqlite3expert} *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void * {\b idxMalloc} (int *pRc, int nByte)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b idxHashInit} ({\b IdxHash} *pHash)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b idxHashClear} ({\b IdxHash} *pHash)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxHashString} (const char *z, int n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxHashAdd} (int *pRc, {\b IdxHash} *pHash, const char *zKey, const char *zVal)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b IdxHashEntry} * {\b idxHashFind} ({\b IdxHash} *pHash, const char *zKey, int nKey)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b idxHashSearch} ({\b IdxHash} *pHash, const char *zKey, int nKey)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b IdxConstraint} * {\b idxNewConstraint} (int *pRc, const char *zColl)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b idxDatabaseError} ({\b sqlite3} *db, char **pzErrmsg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxPrepareStmt} ({\b sqlite3} *db, {\b sqlite3_stmt} **ppStmt, char **pzErrmsg, const char *zSql)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxPrintfPrepareStmt} ({\b sqlite3} *db, {\b sqlite3_stmt} **ppStmt, char **pzErrmsg, const char *zFmt,...)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b expertDequote} (const char *zIn)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertConnect} ({\b sqlite3} *db, void *pAux, int argc, const char *const *argv, {\b sqlite3_vtab} **ppVtab, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertDisconnect} ({\b sqlite3_vtab} *pVtab)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertBestIndex} ({\b sqlite3_vtab} *pVtab, {\b sqlite3_index_info} *pIdxInfo)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertUpdate} ({\b sqlite3_vtab} *pVtab, int nData, {\b sqlite3_value} **azData, {\b sqlite_int64} *pRowid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertOpen} ({\b sqlite3_vtab} *pVTab, {\b sqlite3_vtab_cursor} **ppCursor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertClose} ({\b sqlite3_vtab_cursor} *cur)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertEof} ({\b sqlite3_vtab_cursor} *cur)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertNext} ({\b sqlite3_vtab_cursor} *cur)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertRowid} ({\b sqlite3_vtab_cursor} *cur, {\b sqlite_int64} *pRowid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertColumn} ({\b sqlite3_vtab_cursor} *cur, {\b sqlite3_context} *ctx, int i)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertFilter} ({\b sqlite3_vtab_cursor} *cur, int idxNum, const char *idxStr, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxRegisterVtab} ({\b sqlite3expert} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b idxFinalize} (int *pRc, {\b sqlite3_stmt} *pStmt)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxGetTableInfo} ({\b sqlite3} *db, const char *zTab, {\b IdxTable} **ppOut, char **pzErrmsg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b idxAppendText} (int *pRc, char *zIn, const char *zFmt,...)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxIdentifierRequiresQuotes} (const char *zId)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b idxAppendColDefn} (int *pRc, char *zIn, {\b IdxTable} *pTab, {\b IdxConstraint} *pCons)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxFindCompatible} (int *pRc, {\b sqlite3} *dbm, {\b IdxScan} *pScan, {\b IdxConstraint} *pEq, {\b IdxConstraint} *pTail)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxCreateFromCons} ({\b sqlite3expert} *p, {\b IdxScan} *pScan, {\b IdxConstraint} *pEq, {\b IdxConstraint} *pTail)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxFindConstraint} ({\b IdxConstraint} *pList, {\b IdxConstraint} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxCreateFromWhere} ({\b sqlite3expert} *p, {\b IdxScan} *pScan, {\b IdxConstraint} *pTail)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxCreateCandidates} ({\b sqlite3expert} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b idxConstraintFree} ({\b IdxConstraint} *pConstraint)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b idxScanFree} ({\b IdxScan} *pScan, {\b IdxScan} *pLast)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b idxStatementFree} ({\b IdxStatement} *pStatement, {\b IdxStatement} *pLast)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b idxTableFree} ({\b IdxTable} *pTab)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b idxWriteFree} ({\b IdxWrite} *pTab)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b idxFindIndexes} ({\b sqlite3expert} *p, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxAuthCallback} (void *pCtx, int eOp, const char *z3, const char *z4, const char *zDb, const char *zTrigger)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxProcessOneTrigger} ({\b sqlite3expert} *p, {\b IdxWrite} *pWrite, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxProcessTriggers} ({\b sqlite3expert} *p, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxCreateVtabSchema} ({\b sqlite3expert} *p, char **pzErrmsg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b idxSampleFunc} ({\b sqlite3_context} *pCtx, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b idxRemFunc} ({\b sqlite3_context} *pCtx, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxLargestIndex} ({\b sqlite3} *db, int *pnMax, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxPopulateOneStat1} ({\b sqlite3expert} *p, {\b sqlite3_stmt} *pIndexXInfo, {\b sqlite3_stmt} *pWriteStat, const char *zTab, const char *zIdx, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxBuildSampleTable} ({\b sqlite3expert} *p, const char *zTab)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b idxPopulateStat1} ({\b sqlite3expert} *p, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b shellLog} (void *pArg, int iErrCode, const char *zMsg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b shellPutsFunc} ({\b sqlite3_context} *pCtx, int nVal, {\b sqlite3_value} **apVal)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b editFunc} ({\b sqlite3_context} *context, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b outputModePush} ({\b ShellState} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b outputModePop} ({\b ShellState} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b output_hex_blob} (FILE *out, const void *pBlob, int nBlob)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b unused_string} (const char *z, const char *zA, const char *zB, char *zBuf)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b output_quoted_string} (FILE *out, const char *z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b output_quoted_escaped_string} (FILE *out, const char *z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b output_c_string} (FILE *out, const char *z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b output_html_string} (FILE *out, const char *z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b output_csv} ({\b ShellState} *p, const char *z, int bSep)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b interrupt_handler} (int NotUsed)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b shellAuth} (void *pClientData, int op, const char *zA1, const char *zA2, const char *zA3, const char *zA4)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b printSchemaLine} (FILE *out, const char *z, const char *zTail)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b printSchemaLineN} (FILE *out, char *z, int n, const char *zTail)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b wsToEol} (const char *z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b eqp_append} ({\b ShellState} *p, int iEqpId, int p2, const char *zText)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b eqp_reset} ({\b ShellState} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b EQPGraphRow} * {\b eqp_next_row} ({\b ShellState} *p, int iEqpId, {\b EQPGraphRow} *pOld)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b eqp_render_level} ({\b ShellState} *p, int iEqpId)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b eqp_render} ({\b ShellState} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b progress_handler} (void *pClientData)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b shell_callback} (void *pArg, int nArg, char **azArg, char **azCol, int *aiType)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b callback} (void *pArg, int nArg, char **azArg, char **azCol)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b captureOutputCallback} (void *pArg, int nArg, char **azArg, char **az)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b createSelftestTable} ({\b ShellState} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b set_table_name} ({\b ShellState} *p, const char *{\b zName})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b run_table_dump_query} ({\b ShellState} *p, const char *zSelect, const char *zFirstRow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b save_err_msg} ({\b sqlite3} *db)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b displayStatLine} ({\b ShellState} *p, char *zLabel, char *zFormat, int iStatusCtrl, int bReset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b display_stats} ({\b sqlite3} *db, {\b ShellState} *pArg, int bReset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b display_scanstats} ({\b sqlite3} *db, {\b ShellState} *pArg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b str_in_array} (const char *zStr, const char **azArray)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b explain_data_prepare} ({\b ShellState} *p, {\b sqlite3_stmt} *pSql)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b explain_data_delete} ({\b ShellState} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b disable_debug_trace_modes} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b restore_debug_trace_modes} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b bind_table_init} ({\b ShellState} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b bind_prepared_stmt} ({\b ShellState} *pArg, {\b sqlite3_stmt} *pStmt)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b exec_prepared_stmt} ({\b ShellState} *pArg, {\b sqlite3_stmt} *pStmt)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertHandleSQL} ({\b ShellState} *pState, const char *zSql, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertFinish} ({\b ShellState} *pState, int bCancel, char **pzErr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b expertDotCommand} ({\b ShellState} *pState, char **azArg, int nArg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b shell_exec} ({\b ShellState} *pArg, const char *zSql, char **pzErrMsg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b freeColumnList} (char **azCol)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char ** {\b tableColumnList} ({\b ShellState} *p, const char *zTab)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b toggleSelectOrder} ({\b sqlite3} *db)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b dump_callback} (void *pArg, int nArg, char **azArg, char **azNotUsed)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b run_schema_dump_query} ({\b ShellState} *p, const char *zQuery)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b showHelp} (FILE *out, const char *zPattern)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b process_input} ({\b ShellState} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b readFile} (const char *{\b zName}, int *pnByte)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b deduceDatabaseType} (const char *{\b zName}, int dfltZip)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b shellInt32} ({\b sqlite3_context} *context, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b shellIdQuote} ({\b sqlite3_context} *context, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b shellEscapeCrnl} ({\b sqlite3_context} *context, int argc, {\b sqlite3_value} **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b open_db} ({\b ShellState} *p, int openFlags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b close_db} ({\b sqlite3} *db)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b resolve_backslashes} (char *z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b booleanValue} (const char *zArg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b setOrClearFlag} ({\b ShellState} *p, unsigned mFlag, const char *zArg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b output_file_close} (FILE *f)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static FILE * {\b output_file_open} (const char *zFile, int bTextMode)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b sql_trace_callback} (unsigned mType, void *pArg, void *pP, void *pX)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b test_breakpoint} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b import_append_char} ({\b ImportCtx} *p, int c)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char *{\b SQLITE_CDECL} {\b csv_read_one_field} ({\b ImportCtx} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char *{\b SQLITE_CDECL} {\b ascii_read_one_field} ({\b ImportCtx} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b tryToCloneData} ({\b ShellState} *p, {\b sqlite3} *newDb, const char *zTable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b tryToCloneSchema} ({\b ShellState} *p, {\b sqlite3} *newDb, const char *zWhere, void(*xForEach)({\b ShellState} *, {\b sqlite3} *, const char *))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b tryToClone} ({\b ShellState} *p, const char *zNewDb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b output_reset} ({\b ShellState} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b db_int} ({\b ShellState} *p, const char *zSql)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned int {\b get2byteInt} (unsigned char *a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static unsigned int {\b get4byteInt} (unsigned char *a)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b shell_dbinfo_command} ({\b ShellState} *p, int nArg, char **azArg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b shellDatabaseError} ({\b sqlite3} *db)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b testcase_glob} (const char *zGlob, const char *z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b optionMatch} (const char *zStr, const char *zOpt)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b shellDeleteFile} (const char *zFilename)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b clearTempFile} ({\b ShellState} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b newTempFile} ({\b ShellState} *p, const char *zSuffix)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b shellFkeyCollateClause} ({\b sqlite3_context} *pCtx, int nVal, {\b sqlite3_value} **apVal)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lintFkeyIndexes} ({\b ShellState} *pState, char **azArg, int nArg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b lintDotCommand} ({\b ShellState} *pState, char **azArg, int nArg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b shellPrepare} ({\b sqlite3} *db, int *pRc, const char *zSql, {\b sqlite3_stmt} **ppStmt)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b shellPreparePrintf} ({\b sqlite3} *db, int *pRc, {\b sqlite3_stmt} **ppStmt, const char *zFmt,...)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b shellFinalize} (int *pRc, {\b sqlite3_stmt} *pStmt)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b shellReset} (int *pRc, {\b sqlite3_stmt} *pStmt)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b do_meta_command} (char *zLine, {\b ShellState} *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b line_contains_semicolon} (const char *z, int N)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b _all_whitespace} (const char *z)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b line_is_command_terminator} (const char *zLine)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b line_is_complete} (char *zSql, int nSql)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b runOneSqlLine} ({\b ShellState} *p, char *zSql, FILE *in, int startline)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b find_home_dir} (int clearFlag)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b process_sqliterc} ({\b ShellState} *p, const char *sqliterc_override)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b usage} (int showDetail)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b verify_uninitialized} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b main_init} ({\b ShellState} *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b printBold} (const char *zText)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b cmdline_option_value} (int argc, char **argv, int i)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b SQLITE_CDECL} {\b main} (int argc, char **argv)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b enableTimer} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static struct rusage {\b sBegin}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b sqlite3_int64} {\b iBegin}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b bail_on_error} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b stdin_is_interactive} = 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b stdout_is_console} = 1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b sqlite3} * {\b globalDb} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static volatile int {\b seenInterrupt} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char * {\b Argv0}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char {\b mainPrompt} [20]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static char {\b continuePrompt} [20]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b sqlite3_module} {\b completionModule}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void(*)(void) {\b apndDlSym} ({\b sqlite3_vfs} *pVfs, void *p, const char *zSym)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b sqlite3_vfs} {\b apnd_vfs}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const {\b sqlite3_io_methods} {\b apnd_io_methods}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b sqlite3_mem_methods} {\b memtraceBase}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static FILE * {\b memtraceOut}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b sqlite3_mem_methods} {\b ersaztMethods}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b modeDescr} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b needCsvQuote} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char * {\b azHelp} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const char {\b zOptions} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _FILE_OFFSET_BITS\:shell.c}
{\xe \v shell.c\:_FILE_OFFSET_BITS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _FILE_OFFSET_BITS\~ 64}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file shell.c.}\par
}
{\xe \v _LARGE_FILE\:shell.c}
{\xe \v shell.c\:_LARGE_FILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _LARGE_FILE\~ 1}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file shell.c.}\par
}
{\xe \v _LARGEFILE_SOURCE\:shell.c}
{\xe \v shell.c\:_LARGEFILE_SOURCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _LARGEFILE_SOURCE\~ 1}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file shell.c.}\par
}
{\xe \v a00\:shell.c}
{\xe \v shell.c\:a00}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a00\~ (p->u.s[0])}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a01\:shell.c}
{\xe \v shell.c\:a01}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a01\~ (p->u.s[1])}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a02\:shell.c}
{\xe \v shell.c\:a02}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a02\~ (p->u.s[2])}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a03\:shell.c}
{\xe \v shell.c\:a03}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a03\~ (p->u.s[3])}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a04\:shell.c}
{\xe \v shell.c\:a04}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a04\~ (p->u.s[4])}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a10\:shell.c}
{\xe \v shell.c\:a10}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a10\~ (p->u.s[5])}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a11\:shell.c}
{\xe \v shell.c\:a11}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a11\~ (p->u.s[6])}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a12\:shell.c}
{\xe \v shell.c\:a12}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a12\~ (p->u.s[7])}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a13\:shell.c}
{\xe \v shell.c\:a13}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a13\~ (p->u.s[8])}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a14\:shell.c}
{\xe \v shell.c\:a14}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a14\~ (p->u.s[9])}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a20\:shell.c}
{\xe \v shell.c\:a20}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a20\~ (p->u.s[10])}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a21\:shell.c}
{\xe \v shell.c\:a21}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a21\~ (p->u.s[11])}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a22\:shell.c}
{\xe \v shell.c\:a22}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a22\~ (p->u.s[12])}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a23\:shell.c}
{\xe \v shell.c\:a23}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a23\~ (p->u.s[13])}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a24\:shell.c}
{\xe \v shell.c\:a24}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a24\~ (p->u.s[14])}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a30\:shell.c}
{\xe \v shell.c\:a30}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a30\~ (p->u.s[15])}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a31\:shell.c}
{\xe \v shell.c\:a31}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a31\~ (p->u.s[16])}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a32\:shell.c}
{\xe \v shell.c\:a32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a32\~ (p->u.s[17])}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a33\:shell.c}
{\xe \v shell.c\:a33}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a33\~ (p->u.s[18])}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a34\:shell.c}
{\xe \v shell.c\:a34}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a34\~ (p->u.s[19])}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a40\:shell.c}
{\xe \v shell.c\:a40}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a40\~ (p->u.s[20])}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a41\:shell.c}
{\xe \v shell.c\:a41}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a41\~ (p->u.s[21])}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a42\:shell.c}
{\xe \v shell.c\:a42}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a42\~ (p->u.s[22])}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a43\:shell.c}
{\xe \v shell.c\:a43}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a43\~ (p->u.s[23])}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v a44\:shell.c}
{\xe \v shell.c\:a44}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define a44\~ (p->u.s[24])}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v APND_MARK_PREFIX\:shell.c}
{\xe \v shell.c\:APND_MARK_PREFIX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APND_MARK_PREFIX\~ "Start-Of-SQLite3-"}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3600 of file shell.c.}\par
{
Referenced by apndReadMark(), and apndWriteMark().}\par
}
{\xe \v APND_MARK_PREFIX_SZ\:shell.c}
{\xe \v shell.c\:APND_MARK_PREFIX_SZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APND_MARK_PREFIX_SZ\~ 17}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3601 of file shell.c.}\par
{
Referenced by apndReadMark(), and apndWriteMark().}\par
}
{\xe \v APND_MARK_SIZE\:shell.c}
{\xe \v shell.c\:APND_MARK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APND_MARK_SIZE\~ 25}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3602 of file shell.c.}\par
{
Referenced by apndFileSize(), apndReadMark(), apndTruncate(), apndWrite(), and apndWriteMark().}\par
}
{\xe \v APND_MAX_SIZE\:shell.c}
{\xe \v shell.c\:APND_MAX_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APND_MAX_SIZE\~ (65536*15259)}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3608 of file shell.c.}\par
{
Referenced by apndWrite().}\par
}
{\xe \v ArraySize\:shell.c}
{\xe \v shell.c\:ArraySize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ArraySize( {\b X})\~ (int)(sizeof({\b X})/sizeof({\b X}[0]))}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 385 of file shell.c.}\par
{
Referenced by do_meta_command(), explain_data_prepare(), integerValue(), save_err_msg(), shell_callback(), shell_dbinfo_command(), and showHelp().}\par
}
{\xe \v AUTOEQP_full\:shell.c}
{\xe \v shell.c\:AUTOEQP_full}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AUTOEQP_full\~ 3           /* Show full EXPLAIN */}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9640 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), and shell_exec().}\par
}
{\xe \v AUTOEQP_off\:shell.c}
{\xe \v shell.c\:AUTOEQP_off}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AUTOEQP_off\~ 0           /* Automatic EXPLAIN QUERY PLAN is off */}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9637 of file shell.c.}\par
}
{\xe \v AUTOEQP_on\:shell.c}
{\xe \v shell.c\:AUTOEQP_on}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AUTOEQP_on\~ 1           /* Automatic EQP is on */}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9638 of file shell.c.}\par
{
Referenced by do_meta_command(), and main().}\par
}
{\xe \v AUTOEQP_trigger\:shell.c}
{\xe \v shell.c\:AUTOEQP_trigger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AUTOEQP_trigger\~ 2           /* On and also show plans for triggers */}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9639 of file shell.c.}\par
{
Referenced by do_meta_command(), and shell_exec().}\par
}
{\xe \v BEGIN_TIMER\:shell.c}
{\xe \v shell.c\:BEGIN_TIMER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BEGIN_TIMER\~ {\b beginTimer}()}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 290 of file shell.c.}\par
{
Referenced by runOneSqlLine().}\par
}
{\xe \v COMPLETION_COLLATIONS\:shell.c}
{\xe \v shell.c\:COMPLETION_COLLATIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_COLLATIONS\~ 4}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3111 of file shell.c.}\par
}
{\xe \v COMPLETION_COLUMN_CANDIDATE\:shell.c}
{\xe \v shell.c\:COMPLETION_COLUMN_CANDIDATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_COLUMN_CANDIDATE\~ 0  /* Suggested completion of the input */}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by completionColumn().}\par
}
{\xe \v COMPLETION_COLUMN_PHASE\:shell.c}
{\xe \v shell.c\:COMPLETION_COLUMN_PHASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_COLUMN_PHASE\~ 3  /* ePhase - used for debugging only */}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by completionColumn().}\par
}
{\xe \v COMPLETION_COLUMN_PREFIX\:shell.c}
{\xe \v shell.c\:COMPLETION_COLUMN_PREFIX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_COLUMN_PREFIX\~ 1  /* Prefix of the word to be completed */}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by completionBestIndex(), and completionColumn().}\par
}
{\xe \v COMPLETION_COLUMN_WHOLELINE\:shell.c}
{\xe \v shell.c\:COMPLETION_COLUMN_WHOLELINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_COLUMN_WHOLELINE\~ 2  /* Entire line seen so far */}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by completionBestIndex(), and completionColumn().}\par
}
{\xe \v COMPLETION_COLUMNS\:shell.c}
{\xe \v shell.c\:COMPLETION_COLUMNS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_COLUMNS\~ 9}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3116 of file shell.c.}\par
{
Referenced by completionNext().}\par
}
{\xe \v COMPLETION_DATABASES\:shell.c}
{\xe \v shell.c\:COMPLETION_DATABASES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_DATABASES\~ 7}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3114 of file shell.c.}\par
{
Referenced by completionNext().}\par
}
{\xe \v COMPLETION_EOF\:shell.c}
{\xe \v shell.c\:COMPLETION_EOF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_EOF\~ 11}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3118 of file shell.c.}\par
{
Referenced by completionEof(), and completionNext().}\par
}
{\xe \v COMPLETION_FIRST_PHASE\:shell.c}
{\xe \v shell.c\:COMPLETION_FIRST_PHASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_FIRST_PHASE\~ 1}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3107 of file shell.c.}\par
{
Referenced by completionFilter().}\par
}
{\xe \v COMPLETION_FUNCTIONS\:shell.c}
{\xe \v shell.c\:COMPLETION_FUNCTIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_FUNCTIONS\~ 3}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3110 of file shell.c.}\par
}
{\xe \v COMPLETION_INDEXES\:shell.c}
{\xe \v shell.c\:COMPLETION_INDEXES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_INDEXES\~ 5}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3112 of file shell.c.}\par
}
{\xe \v COMPLETION_KEYWORDS\:shell.c}
{\xe \v shell.c\:COMPLETION_KEYWORDS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_KEYWORDS\~ 1}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3108 of file shell.c.}\par
{
Referenced by completionNext().}\par
}
{\xe \v COMPLETION_MODULES\:shell.c}
{\xe \v shell.c\:COMPLETION_MODULES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_MODULES\~ 10}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3117 of file shell.c.}\par
}
{\xe \v COMPLETION_PRAGMAS\:shell.c}
{\xe \v shell.c\:COMPLETION_PRAGMAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_PRAGMAS\~ 2}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3109 of file shell.c.}\par
}
{\xe \v COMPLETION_TABLES\:shell.c}
{\xe \v shell.c\:COMPLETION_TABLES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_TABLES\~ 8    /* Also VIEWs and TRIGGERs */}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3115 of file shell.c.}\par
{
Referenced by completionNext().}\par
}
{\xe \v COMPLETION_TRIGGERS\:shell.c}
{\xe \v shell.c\:COMPLETION_TRIGGERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMPLETION_TRIGGERS\~ 6}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3113 of file shell.c.}\par
}
{\xe \v CTIMEOPT_VAL\:shell.c}
{\xe \v shell.c\:CTIMEOPT_VAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CTIMEOPT_VAL( opt)\~ {\b CTIMEOPT_VAL_}(opt)}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by do_meta_command().}\par
}
{\xe \v CTIMEOPT_VAL_\:shell.c}
{\xe \v shell.c\:CTIMEOPT_VAL_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CTIMEOPT_VAL_( opt)\~ #opt}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v END_TIMER\:shell.c}
{\xe \v shell.c\:END_TIMER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define END_TIMER\~ {\b endTimer}()}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 291 of file shell.c.}\par
{
Referenced by runOneSqlLine().}\par
}
{\xe \v EXPERT_CONFIG_SAMPLE\:shell.c}
{\xe \v shell.c\:EXPERT_CONFIG_SAMPLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPERT_CONFIG_SAMPLE\~ 1    /* int */}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6595 of file shell.c.}\par
{
Referenced by expertDotCommand(), and sqlite3_expert_config().}\par
}
{\xe \v EXPERT_REPORT_CANDIDATES\:shell.c}
{\xe \v shell.c\:EXPERT_REPORT_CANDIDATES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPERT_REPORT_CANDIDATES\~ 4}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6694 of file shell.c.}\par
{
Referenced by expertFinish(), and sqlite3_expert_report().}\par
}
{\xe \v EXPERT_REPORT_INDEXES\:shell.c}
{\xe \v shell.c\:EXPERT_REPORT_INDEXES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPERT_REPORT_INDEXES\~ 2}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6692 of file shell.c.}\par
{
Referenced by expertFinish(), and sqlite3_expert_report().}\par
}
{\xe \v EXPERT_REPORT_PLAN\:shell.c}
{\xe \v shell.c\:EXPERT_REPORT_PLAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPERT_REPORT_PLAN\~ 3}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6693 of file shell.c.}\par
{
Referenced by expertFinish(), and sqlite3_expert_report().}\par
}
{\xe \v EXPERT_REPORT_SQL\:shell.c}
{\xe \v shell.c\:EXPERT_REPORT_SQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXPERT_REPORT_SQL\~ 1}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6691 of file shell.c.}\par
{
Referenced by expertFinish(), and sqlite3_expert_report().}\par
}
{\xe \v FSDIR_COLUMN_DATA\:shell.c}
{\xe \v shell.c\:FSDIR_COLUMN_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FSDIR_COLUMN_DATA\~ 3     /* File content */}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2149 of file shell.c.}\par
{
Referenced by fsdirColumn().}\par
}
{\xe \v FSDIR_COLUMN_DIR\:shell.c}
{\xe \v shell.c\:FSDIR_COLUMN_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FSDIR_COLUMN_DIR\~ 5     /* Path is relative to this directory */}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2151 of file shell.c.}\par
{
Referenced by fsdirBestIndex().}\par
}
{\xe \v FSDIR_COLUMN_MODE\:shell.c}
{\xe \v shell.c\:FSDIR_COLUMN_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FSDIR_COLUMN_MODE\~ 1     /* Access mode */}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2147 of file shell.c.}\par
{
Referenced by fsdirColumn().}\par
}
{\xe \v FSDIR_COLUMN_MTIME\:shell.c}
{\xe \v shell.c\:FSDIR_COLUMN_MTIME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FSDIR_COLUMN_MTIME\~ 2     /* Last modification time */}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2148 of file shell.c.}\par
{
Referenced by fsdirColumn().}\par
}
{\xe \v FSDIR_COLUMN_NAME\:shell.c}
{\xe \v shell.c\:FSDIR_COLUMN_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FSDIR_COLUMN_NAME\~ 0     /* Name of the file */}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2146 of file shell.c.}\par
{
Referenced by fsdirColumn().}\par
}
{\xe \v FSDIR_COLUMN_PATH\:shell.c}
{\xe \v shell.c\:FSDIR_COLUMN_PATH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FSDIR_COLUMN_PATH\~ 4     /* Path to top of search */}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2150 of file shell.c.}\par
{
Referenced by fsdirBestIndex(), and fsdirColumn().}\par
}
{\xe \v FSDIR_SCHEMA\:shell.c}
{\xe \v shell.c\:FSDIR_SCHEMA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FSDIR_SCHEMA\~ "(name,mode,mtime,data,path HIDDEN,dir HIDDEN)"}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2145 of file shell.c.}\par
{
Referenced by fsdirConnect().}\par
}
{\xe \v GETPID\:shell.c}
{\xe \v shell.c\:GETPID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GETPID\~ getpid}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file shell.c.}\par
{
Referenced by main().}\par
}
{\xe \v HAS_TIMER\:shell.c}
{\xe \v shell.c\:HAS_TIMER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HAS_TIMER\~ 1}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 292 of file shell.c.}\par
{
Referenced by do_meta_command().}\par
}
{\xe \v IDX_HASH_SIZE\:shell.c}
{\xe \v shell.c\:IDX_HASH_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IDX_HASH_SIZE\~ 1023}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6825 of file shell.c.}\par
{
Referenced by idxHashClear(), and idxHashString().}\par
}
{\xe \v IsDigit\:shell.c}
{\xe \v shell.c\:IsDigit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IsDigit( {\b X})\~ isdigit((unsigned char){\b X})}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 190 of file shell.c.}\par
{
Referenced by integerValue(), isNumber(), and testcase_glob().}\par
}
{\xe \v IsSpace\:shell.c}
{\xe \v shell.c\:IsSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IsSpace( {\b X})\~ isspace((unsigned char){\b X})}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 189 of file shell.c.}\par
{
Referenced by _all_whitespace(), do_meta_command(), line_is_command_terminator(), process_input(), shell_callback(), shell_exec(), testcase_glob(), and wsToEol().}\par
}
{\xe \v MODE_Ascii\:shell.c}
{\xe \v shell.c\:MODE_Ascii}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_Ascii\~ 10  /* Use ASCII unit and record separators (0x1F/0x1E) */}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9696 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), and shell_callback().}\par
}
{\xe \v MODE_Column\:shell.c}
{\xe \v shell.c\:MODE_Column}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_Column\~ 1  /* One record per line in neat columns */}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9687 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), and shell_callback().}\par
}
{\xe \v MODE_Csv\:shell.c}
{\xe \v shell.c\:MODE_Csv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_Csv\~ 8  /* Quote strings, numbers are plain */}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9694 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), and shell_callback().}\par
}
{\xe \v MODE_EQP\:shell.c}
{\xe \v shell.c\:MODE_EQP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_EQP\~ 12  /* Converts EXPLAIN QUERY PLAN output into a graph */}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9698 of file shell.c.}\par
{
Referenced by shell_callback(), and shell_exec().}\par
}
{\xe \v MODE_Explain\:shell.c}
{\xe \v shell.c\:MODE_Explain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_Explain\~ 9  /* Like {\b MODE_Column}, but do not truncate data */}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9695 of file shell.c.}\par
{
Referenced by do_meta_command(), shell_callback(), and shell_exec().}\par
}
{\xe \v MODE_Html\:shell.c}
{\xe \v shell.c\:MODE_Html}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_Html\~ 4  /* Generate an XHTML table */}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9690 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), and shell_callback().}\par
}
{\xe \v MODE_Insert\:shell.c}
{\xe \v shell.c\:MODE_Insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_Insert\~ 5  /* Generate SQL "insert" statements */}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9691 of file shell.c.}\par
{
Referenced by do_meta_command(), dump_callback(), exec_prepared_stmt(), and shell_callback().}\par
}
{\xe \v MODE_Line\:shell.c}
{\xe \v shell.c\:MODE_Line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_Line\~ 0  /* One column per line.  Blank line between records */}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9686 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), and shell_callback().}\par
}
{\xe \v MODE_List\:shell.c}
{\xe \v shell.c\:MODE_List}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_List\~ 2  /* One record per line with a separator */}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9688 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), main_init(), and shell_callback().}\par
}
{\xe \v MODE_Pretty\:shell.c}
{\xe \v shell.c\:MODE_Pretty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_Pretty\~ 11  /* Pretty-print schemas */}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9697 of file shell.c.}\par
{
Referenced by do_meta_command(), and shell_callback().}\par
}
{\xe \v MODE_Quote\:shell.c}
{\xe \v shell.c\:MODE_Quote}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_Quote\~ 6  /* Quote values as for SQL */}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9692 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), and shell_callback().}\par
}
{\xe \v MODE_Semi\:shell.c}
{\xe \v shell.c\:MODE_Semi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_Semi\~ 3  /* Same as {\b MODE_List} but append ";" to each line */}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9689 of file shell.c.}\par
{
Referenced by do_meta_command(), and shell_callback().}\par
}
{\xe \v MODE_Tcl\:shell.c}
{\xe \v shell.c\:MODE_Tcl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODE_Tcl\~ 7  /* Generate ANSI-C or TCL quoted elements */}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9693 of file shell.c.}\par
{
Referenced by do_meta_command(), and shell_callback().}\par
}
{\xe \v OPEN_DB_KEEPALIVE\:shell.c}
{\xe \v shell.c\:OPEN_DB_KEEPALIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OPEN_DB_KEEPALIVE\~ 0x001   /* Return after error if true */}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12680 of file shell.c.}\par
{
Referenced by do_meta_command(), and open_db().}\par
}
{\xe \v OPEN_DB_ZIPFILE\:shell.c}
{\xe \v shell.c\:OPEN_DB_ZIPFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OPEN_DB_ZIPFILE\~ 0x002   /* Open as ZIP if name matches *.zip */}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12681 of file shell.c.}\par
{
Referenced by main(), and open_db().}\par
}
{\xe \v ORIGFILE\:shell.c}
{\xe \v shell.c\:ORIGFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ORIGFILE( p)\~ (({\b sqlite3_file}*)((({\b ApndFile}*)(p))+1))}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3620 of file shell.c.}\par
{
Referenced by apndCheckReservedLock(), apndClose(), apndDeviceCharacteristics(), apndFetch(), apndFileControl(), apndFileSize(), apndLock(), apndOpen(), apndRead(), apndSectorSize(), apndShmBarrier(), apndShmLock(), apndShmMap(), apndShmUnmap(), apndSync(), apndTruncate(), apndUnfetch(), apndUnlock(), and apndWrite().}\par
}
{\xe \v ORIGVFS\:shell.c}
{\xe \v shell.c\:ORIGVFS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ORIGVFS( p)\~ (({\b sqlite3_vfs}*)((p)->pAppData))}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3619 of file shell.c.}\par
{
Referenced by apndAccess(), apndCurrentTime(), apndCurrentTimeInt64(), apndDelete(), apndDlClose(), apndDlError(), apndDlOpen(), apndFullPathname(), apndGetLastError(), apndGetSystemCall(), apndNextSystemCall(), apndOpen(), apndRandomness(), apndSetSystemCall(), apndSleep(), and sqlite3_os_end().}\par
}
{\xe \v raw_printf\:shell.c}
{\xe \v shell.c\:raw_printf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define raw_printf\~ fprintf}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 460 of file shell.c.}\par
{
Referenced by display_scanstats(), display_stats(), displayStatLine(), do_meta_command(), dump_callback(), expertDotCommand(), expertFinish(), lintDotCommand(), lintFkeyIndexes(), main(), newTempFile(), output_c_string(), output_hex_blob(), output_html_string(), output_quoted_escaped_string(), output_quoted_string(), process_sqliterc(), progress_handler(), run_schema_dump_query(), run_table_dump_query(), runOneSqlLine(), shell_callback(), shell_dbinfo_command(), shell_out_of_memory(), shellAuth(), shellFinalize(), shellPrepare(), shellReset(), and usage().}\par
}
{\xe \v ROL64\:shell.c}
{\xe \v shell.c\:ROL64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ROL64( a,  x)\~ ((a<<x)|(a>>(64-x)))}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by KeccakF1600Step().}\par
}
{\xe \v SEP_Column\:shell.c}
{\xe \v shell.c\:SEP_Column}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEP_Column\~ "|"}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9720 of file shell.c.}\par
{
Referenced by do_meta_command(), and main_init().}\par
}
{\xe \v SEP_Comma\:shell.c}
{\xe \v shell.c\:SEP_Comma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEP_Comma\~ ","}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9724 of file shell.c.}\par
{
Referenced by do_meta_command().}\par
}
{\xe \v SEP_CrLf\:shell.c}
{\xe \v shell.c\:SEP_CrLf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEP_CrLf\~ "\\r\\n"}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9725 of file shell.c.}\par
{
Referenced by do_meta_command().}\par
}
{\xe \v SEP_Record\:shell.c}
{\xe \v shell.c\:SEP_Record}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEP_Record\~ "\\x1E"}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9727 of file shell.c.}\par
{
Referenced by do_meta_command(), and main().}\par
}
{\xe \v SEP_Row\:shell.c}
{\xe \v shell.c\:SEP_Row}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEP_Row\~ "\\n"}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9721 of file shell.c.}\par
{
Referenced by do_meta_command(), main_init(), and shell_callback().}\par
}
{\xe \v SEP_Space\:shell.c}
{\xe \v shell.c\:SEP_Space}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEP_Space\~ " "}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9723 of file shell.c.}\par
{
Referenced by do_meta_command().}\par
}
{\xe \v SEP_Tab\:shell.c}
{\xe \v shell.c\:SEP_Tab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEP_Tab\~ "\\t"}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9722 of file shell.c.}\par
{
Referenced by do_meta_command().}\par
}
{\xe \v SEP_Unit\:shell.c}
{\xe \v shell.c\:SEP_Unit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SEP_Unit\~ "\\x1F"}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9726 of file shell.c.}\par
{
Referenced by do_meta_command(), and main().}\par
}
{\xe \v session_close_all\:shell.c}
{\xe \v shell.c\:session_close_all}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define session_close_all( {\b X})}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12379 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), and readFile().}\par
}
{\xe \v setBinaryMode\:shell.c}
{\xe \v shell.c\:setBinaryMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define setBinaryMode( {\b X},  Y)}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 219 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), output_quoted_escaped_string(), output_quoted_string(), and shell_callback().}\par
}
{\xe \v setTextMode\:shell.c}
{\xe \v shell.c\:setTextMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define setTextMode( {\b X},  Y)}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 220 of file shell.c.}\par
{
Referenced by do_meta_command(), output_quoted_escaped_string(), output_quoted_string(), and shell_callback().}\par
}
{\xe \v SHA3_BYTEORDER\:shell.c}
{\xe \v shell.c\:SHA3_BYTEORDER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHA3_BYTEORDER\~ 0}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1368 of file shell.c.}\par
}
{\xe \v SHELL_OPEN_APPENDVFS\:shell.c}
{\xe \v shell.c\:SHELL_OPEN_APPENDVFS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_OPEN_APPENDVFS\~ 2      /* Use appendvfs */}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9646 of file shell.c.}\par
{
Referenced by deduceDatabaseType(), do_meta_command(), main(), open_db(), and shellReset().}\par
}
{\xe \v SHELL_OPEN_DESERIALIZE\:shell.c}
{\xe \v shell.c\:SHELL_OPEN_DESERIALIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_OPEN_DESERIALIZE\~ 5      /* Open using {\b sqlite3_deserialize}() */}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9649 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), and open_db().}\par
}
{\xe \v SHELL_OPEN_HEXDB\:shell.c}
{\xe \v shell.c\:SHELL_OPEN_HEXDB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_OPEN_HEXDB\~ 6      /* Use "dbtotxt" output as data source */}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9650 of file shell.c.}\par
{
Referenced by do_meta_command(), and open_db().}\par
}
{\xe \v SHELL_OPEN_NORMAL\:shell.c}
{\xe \v shell.c\:SHELL_OPEN_NORMAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_OPEN_NORMAL\~ 1      /* Normal database file */}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9645 of file shell.c.}\par
{
Referenced by deduceDatabaseType(), and open_db().}\par
}
{\xe \v SHELL_OPEN_READONLY\:shell.c}
{\xe \v shell.c\:SHELL_OPEN_READONLY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_OPEN_READONLY\~ 4      /* Open a normal database read-only */}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9648 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), and open_db().}\par
}
{\xe \v SHELL_OPEN_UNSPEC\:shell.c}
{\xe \v shell.c\:SHELL_OPEN_UNSPEC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_OPEN_UNSPEC\~ 0      /* No open-mode specified */}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9644 of file shell.c.}\par
{
Referenced by deduceDatabaseType(), do_meta_command(), open_db(), and shellReset().}\par
}
{\xe \v SHELL_OPEN_ZIPFILE\:shell.c}
{\xe \v shell.c\:SHELL_OPEN_ZIPFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_OPEN_ZIPFILE\~ 3      /* Use the zipfile virtual table */}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9647 of file shell.c.}\par
{
Referenced by deduceDatabaseType(), do_meta_command(), main(), open_db(), and shellReset().}\par
}
{\xe \v SHELL_PROGRESS_ONCE\:shell.c}
{\xe \v shell.c\:SHELL_PROGRESS_ONCE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_PROGRESS_ONCE\~ 0x04  /* Cancel the --limit after firing once */}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9663 of file shell.c.}\par
{
Referenced by do_meta_command(), and progress_handler().}\par
}
{\xe \v SHELL_PROGRESS_QUIET\:shell.c}
{\xe \v shell.c\:SHELL_PROGRESS_QUIET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_PROGRESS_QUIET\~ 0x01  /* Omit announcing every progress callback */}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9659 of file shell.c.}\par
{
Referenced by do_meta_command(), and progress_handler().}\par
}
{\xe \v SHELL_PROGRESS_RESET\:shell.c}
{\xe \v shell.c\:SHELL_PROGRESS_RESET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_PROGRESS_RESET}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 0x02  /* Reset the count when the progres\par
                                   ** callback limit is reached, and for each\par
                                   ** top-level SQL statement */\par
}
{
Definition at line 9660 of file shell.c.}\par
{
Referenced by do_meta_command(), progress_handler(), and runOneSqlLine().}\par
}
{\xe \v shell_read_history\:shell.c}
{\xe \v shell.c\:shell_read_history}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define shell_read_history( {\b X})}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 141 of file shell.c.}\par
{
Referenced by main().}\par
}
{\xe \v shell_stifle_history\:shell.c}
{\xe \v shell.c\:shell_stifle_history}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define shell_stifle_history( {\b X})}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file shell.c.}\par
{
Referenced by main().}\par
}
{\xe \v SHELL_TRACE_EXPANDED\:shell.c}
{\xe \v shell.c\:SHELL_TRACE_EXPANDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_TRACE_EXPANDED\~ 1      /* Show expanded SQL text */}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9655 of file shell.c.}\par
{
Referenced by do_meta_command(), and sql_trace_callback().}\par
}
{\xe \v SHELL_TRACE_NORMALIZED\:shell.c}
{\xe \v shell.c\:SHELL_TRACE_NORMALIZED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_TRACE_NORMALIZED\~ 2      /* Show normalized SQL text */}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9656 of file shell.c.}\par
{
Referenced by do_meta_command(), and sql_trace_callback().}\par
}
{\xe \v SHELL_TRACE_PLAIN\:shell.c}
{\xe \v shell.c\:SHELL_TRACE_PLAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_TRACE_PLAIN\~ 0      /* Show input SQL text */}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9654 of file shell.c.}\par
{
Referenced by do_meta_command().}\par
}
{\xe \v SHELL_USE_LOCAL_GETLINE\:shell.c}
{\xe \v shell.c\:SHELL_USE_LOCAL_GETLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHELL_USE_LOCAL_GETLINE\~ 1}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file shell.c.}\par
}
{\xe \v shell_write_history\:shell.c}
{\xe \v shell.c\:shell_write_history}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define shell_write_history( {\b X})}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file shell.c.}\par
{
Referenced by main().}\par
}
{\xe \v ShellClearFlag\:shell.c}
{\xe \v shell.c\:ShellClearFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ShellClearFlag( P,  {\b X})\~ ((P)->shellFlgs&=(~({\b X})))}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9681 of file shell.c.}\par
{
Referenced by do_meta_command(), and setOrClearFlag().}\par
}
{\xe \v ShellHasFlag\:shell.c}
{\xe \v shell.c\:ShellHasFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ShellHasFlag( P,  {\b X})\~ (((P)->shellFlgs & ({\b X}))!=0)}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9679 of file shell.c.}\par
{
Referenced by do_meta_command(), process_input(), runOneSqlLine(), shell_callback(), shell_exec(), and tableColumnList().}\par
}
{\xe \v ShellSetFlag\:shell.c}
{\xe \v shell.c\:ShellSetFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ShellSetFlag( P,  {\b X})\~ ((P)->shellFlgs|=({\b X}))}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9680 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), and setOrClearFlag().}\par
}
{\xe \v SHFLG_Backslash\:shell.c}
{\xe \v shell.c\:SHFLG_Backslash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHFLG_Backslash\~ 0x00000004 /* The --backslash option is used */}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9670 of file shell.c.}\par
{
Referenced by main(), and runOneSqlLine().}\par
}
{\xe \v SHFLG_CountChanges\:shell.c}
{\xe \v shell.c\:SHFLG_CountChanges}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHFLG_CountChanges\~ 0x00000020 /* .changes setting */}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9673 of file shell.c.}\par
{
Referenced by do_meta_command(), and runOneSqlLine().}\par
}
{\xe \v SHFLG_Echo\:shell.c}
{\xe \v shell.c\:SHFLG_Echo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHFLG_Echo\~ 0x00000040 /* .echo or --echo setting */}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9674 of file shell.c.}\par
{
Referenced by do_meta_command(), main(), process_input(), and shell_exec().}\par
}
{\xe \v SHFLG_Lookaside\:shell.c}
{\xe \v shell.c\:SHFLG_Lookaside}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHFLG_Lookaside\~ 0x00000002 /* Lookaside memory is used */}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9669 of file shell.c.}\par
{
Referenced by display_stats(), main(), and main_init().}\par
}
{\xe \v SHFLG_Newlines\:shell.c}
{\xe \v shell.c\:SHFLG_Newlines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHFLG_Newlines\~ 0x00000010 /* .dump --newline flag */}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9672 of file shell.c.}\par
{
Referenced by do_meta_command(), and shell_callback().}\par
}
{\xe \v SHFLG_Pagecache\:shell.c}
{\xe \v shell.c\:SHFLG_Pagecache}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHFLG_Pagecache\~ 0x00000001 /* The --pagecache option is used */}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9668 of file shell.c.}\par
{
Referenced by display_stats(), and main().}\par
}
{\xe \v SHFLG_PreserveRowid\:shell.c}
{\xe \v shell.c\:SHFLG_PreserveRowid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SHFLG_PreserveRowid\~ 0x00000008 /* .dump preserves rowid values */}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9671 of file shell.c.}\par
{
Referenced by do_meta_command(), and tableColumnList().}\par
}
{\xe \v SQLITE_EXTENSION_INIT1\:shell.c}
{\xe \v shell.c\:SQLITE_EXTENSION_INIT1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SQLITE_EXTENSION_INIT1}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 949 of file shell.c.}\par
{
Referenced by sqlite3_completion_init(), sqlite3_expert_destroy(), sqlite3_fileio_init(), sqlite3_shathree_init(), and sqlite3MemTraceDeactivate().}\par
}
{\xe \v SQLITE_EXTENSION_INIT2\:shell.c}
{\xe \v shell.c\:SQLITE_EXTENSION_INIT2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SQLITE_EXTENSION_INIT2( {\b X})\~ (void)({\b X})}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 950 of file shell.c.}\par
{
Referenced by sqlite3_appendvfs_init(), sqlite3_completion_init(), sqlite3_expert_destroy(), sqlite3_extension_init(), sqlite3_fileio_init(), sqlite3_shathree_init(), and sqlite3MemTraceDeactivate().}\par
}
{\xe \v SQLITE_SHELL_IS_UTF8\:shell.c}
{\xe \v shell.c\:SQLITE_SHELL_IS_UTF8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SQLITE_SHELL_IS_UTF8\~ (1)}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18660 of file shell.c.}\par
}
{\xe \v SQLITEEXPERT_H\:shell.c}
{\xe \v shell.c\:SQLITEEXPERT_H}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SQLITEEXPERT_H\~ 1}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6549 of file shell.c.}\par
}
{\xe \v STRLEN\:shell.c}
{\xe \v shell.c\:STRLEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define STRLEN\~ (int)strlen}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6736 of file shell.c.}\par
{
Referenced by expertDequote(), idxAppendText(), idxFindIndexes(), idxGetTableInfo(), idxHashAdd(), idxHashFind(), idxNewConstraint(), idxPopulateOneStat1(), and sqlite3_expert_sql().}\par
}
{\xe \v ToLower\:shell.c}
{\xe \v shell.c\:ToLower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ToLower( {\b X})\~ (char)tolower((unsigned char){\b X})}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 191 of file shell.c.}\par
{
Referenced by line_is_command_terminator().}\par
}
{\xe \v UNIQUE_TABLE_NAME\:shell.c}
{\xe \v shell.c\:UNIQUE_TABLE_NAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNIQUE_TABLE_NAME\~ "t592690916721053953805701627921227776"}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6743 of file shell.c.}\par
{
Referenced by idxBuildSampleTable(), idxPopulateOneStat1(), idxPopulateStat1(), and idxProcessOneTrigger().}\par
}
{\xe \v UNUSED_PARAMETER\:shell.c}
{\xe \v shell.c\:UNUSED_PARAMETER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNUSED_PARAMETER( x)\~ (void)(x)}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 380 of file shell.c.}\par
{
Referenced by captureOutputCallback(), display_scanstats(), dump_callback(), interrupt_handler(), shellAddSchemaName(), shellEscapeCrnl(), shellIdQuote(), shellInt32(), and shellModuleSchema().}\par
}
{\xe \v utf8_printf\:shell.c}
{\xe \v shell.c\:utf8_printf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define utf8_printf\~ fprintf}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 452 of file shell.c.}\par
{
Referenced by booleanValue(), close_db(), cmdline_option_value(), createSelftestTable(), csv_read_one_field(), deduceDatabaseType(), display_scanstats(), display_stats(), do_meta_command(), dump_callback(), eqp_append(), eqp_render(), eqp_render_level(), main(), open_db(), output_csv(), output_file_open(), output_html_string(), output_quoted_escaped_string(), output_quoted_string(), output_reset(), printSchemaLine(), process_sqliterc(), run_schema_dump_query(), run_table_dump_query(), runOneSqlLine(), save_err_msg(), shell_callback(), shell_dbinfo_command(), shell_exec(), shell_out_of_memory(), shellAuth(), shellDatabaseError(), shellLog(), shellPutsFunc(), shellReset(), showHelp(), sql_trace_callback(), tryToClone(), tryToCloneData(), tryToCloneSchema(), usage(), utf8_width_print(), and verify_uninitialized().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v ApndFile\:shell.c}
{\xe \v shell.c\:ApndFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b ApndFile} {\b ApndFile}}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3614 of file shell.c.}\par
}
{\xe \v ApndVfs\:shell.c}
{\xe \v shell.c\:ApndVfs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b sqlite3_vfs} {\b ApndVfs}}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3613 of file shell.c.}\par
}
{\xe \v completion_cursor\:shell.c}
{\xe \v shell.c\:completion_cursor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b completion_cursor} {\b completion_cursor}}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3090 of file shell.c.}\par
}
{\xe \v completion_vtab\:shell.c}
{\xe \v shell.c\:completion_vtab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef typedefSQLITE_EXTENSION_INIT1 struct {\b completion_vtab} {\b completion_vtab}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3080 of file shell.c.}\par
}
{\xe \v EQPGraph\:shell.c}
{\xe \v shell.c\:EQPGraph}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b EQPGraph} {\b EQPGraph}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9561 of file shell.c.}\par
}
{\xe \v EQPGraphRow\:shell.c}
{\xe \v shell.c\:EQPGraphRow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b EQPGraphRow} {\b EQPGraphRow}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9552 of file shell.c.}\par
}
{\xe \v ExpertCsr\:shell.c}
{\xe \v shell.c\:ExpertCsr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b ExpertCsr} {\b ExpertCsr}}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7063 of file shell.c.}\par
}
{\xe \v ExpertInfo\:shell.c}
{\xe \v shell.c\:ExpertInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b ExpertInfo} {\b ExpertInfo}}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9545 of file shell.c.}\par
}
{\xe \v ExpertVtab\:shell.c}
{\xe \v shell.c\:ExpertVtab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b ExpertVtab} {\b ExpertVtab}}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7056 of file shell.c.}\par
}
{\xe \v fsdir_cursor\:shell.c}
{\xe \v shell.c\:fsdir_cursor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b fsdir_cursor} {\b fsdir_cursor}}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2571 of file shell.c.}\par
}
{\xe \v fsdir_tab\:shell.c}
{\xe \v shell.c\:fsdir_tab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b fsdir_tab} {\b fsdir_tab}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2594 of file shell.c.}\par
}
{\xe \v FsdirLevel\:shell.c}
{\xe \v shell.c\:FsdirLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b FsdirLevel} {\b FsdirLevel}}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2572 of file shell.c.}\par
}
{\xe \v i64\:shell.c}
{\xe \v shell.c\:i64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b sqlite3_int64} {\b i64}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file shell.c.}\par
}
{\xe \v IdxColumn\:shell.c}
{\xe \v shell.c\:IdxColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b IdxColumn} {\b IdxColumn}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6729 of file shell.c.}\par
}
{\xe \v IdxConstraint\:shell.c}
{\xe \v shell.c\:IdxConstraint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b IdxConstraint} {\b IdxConstraint}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6730 of file shell.c.}\par
}
{\xe \v IdxHash\:shell.c}
{\xe \v shell.c\:IdxHash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b IdxHash} {\b IdxHash}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6827 of file shell.c.}\par
}
{\xe \v IdxHashEntry\:shell.c}
{\xe \v shell.c\:IdxHashEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b IdxHashEntry} {\b IdxHashEntry}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6826 of file shell.c.}\par
}
{\xe \v IdxScan\:shell.c}
{\xe \v shell.c\:IdxScan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b IdxScan} {\b IdxScan}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6731 of file shell.c.}\par
}
{\xe \v IdxStatement\:shell.c}
{\xe \v shell.c\:IdxStatement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b IdxStatement} {\b IdxStatement}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6732 of file shell.c.}\par
}
{\xe \v IdxTable\:shell.c}
{\xe \v shell.c\:IdxTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b IdxTable} {\b IdxTable}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6733 of file shell.c.}\par
}
{\xe \v IdxWrite\:shell.c}
{\xe \v shell.c\:IdxWrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b IdxWrite} {\b IdxWrite}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6734 of file shell.c.}\par
}
{\xe \v ImportCtx\:shell.c}
{\xe \v shell.c\:ImportCtx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b ImportCtx} {\b ImportCtx}}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13068 of file shell.c.}\par
}
{\xe \v SavedModeInfo\:shell.c}
{\xe \v shell.c\:SavedModeInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b SavedModeInfo} {\b SavedModeInfo}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9537 of file shell.c.}\par
}
{\xe \v SHA3Context\:shell.c}
{\xe \v shell.c\:SHA3Context}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b SHA3Context} {\b SHA3Context}}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1376 of file shell.c.}\par
}
{\xe \v ShellState\:shell.c}
{\xe \v shell.c\:ShellState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b ShellState} {\b ShellState}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9572 of file shell.c.}\par
}
{\xe \v ShellText\:shell.c}
{\xe \v shell.c\:ShellText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b ShellText} {\b ShellText}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 724 of file shell.c.}\par
}
{\xe \v sqlite3expert\:shell.c}
{\xe \v shell.c\:sqlite3expert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b sqlite3expert} {\b sqlite3expert}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6552 of file shell.c.}\par
}
{\xe \v u64\:shell.c}
{\xe \v shell.c\:u64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b sqlite3_uint64} {\b u64}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file shell.c.}\par
}
{\xe \v u8\:shell.c}
{\xe \v shell.c\:u8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned char {\b u8}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file shell.c.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _all_whitespace\:shell.c}
{\xe \v shell.c\:_all_whitespace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int _all_whitespace (const char *  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18221 of file shell.c.}\par
{
References IsSpace.}\par
{
Referenced by line_is_command_terminator(), and process_input().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18221                                          \{\par
18222   for(; *z; z++)\{\par
18223     if( IsSpace(z[0]) ) continue;\par
18224     if( *z=='/' && z[1]=='*' )\{\par
18225       z += 2;\par
18226       while( *z && (*z!='*' || z[1]!='/') )\{ z++; \}\par
18227       if( *z==0 ) return 0;\par
18228       z++;\par
18229       continue;\par
18230     \}\par
18231     if( *z=='-' && z[1]=='-' )\{\par
18232       z += 2;\par
18233       while( *z && *z!='\\n' )\{ z++; \}\par
18234       if( *z==0 ) return 1;\par
18235       continue;\par
18236     \}\par
18237     return 0;\par
18238   \}\par
18239   return 1;\par
18240 \}\par
}
}
{\xe \v apndAccess\:shell.c}
{\xe \v shell.c\:apndAccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndAccess ({\b sqlite3_vfs} *  {\i pVfs}, const char *  {\i zName}, int  {\i flags}, int *  {\i pResOut}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4012 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4017  \{\par
 4018   return ORIGVFS(pVfs)->xAccess(ORIGVFS(pVfs), zPath, flags, pResOut);\par
 4019 \}\par
}
}
{\xe \v apndCheckReservedLock\:shell.c}
{\xe \v shell.c\:apndCheckReservedLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndCheckReservedLock ({\b sqlite3_file} *  {\i pFile}, int *  {\i pResOut}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3839 of file shell.c.}\par
{
References ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xCheckReservedLock.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3839                                                                    \{\par
 3840   pFile = ORIGFILE(pFile);\par
 3841   return pFile->pMethods->xCheckReservedLock(pFile, pResOut);\par
 3842 \}\par
}
}
{\xe \v apndClose\:shell.c}
{\xe \v shell.c\:apndClose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndClose ({\b sqlite3_file} *  {\i pFile}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3723 of file shell.c.}\par
{
References ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xClose.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3723                                          \{\par
 3724   pFile = ORIGFILE(pFile);\par
 3725   return pFile->pMethods->xClose(pFile);\par
 3726 \}\par
}
}
{\xe \v apndCurrentTime\:shell.c}
{\xe \v shell.c\:apndCurrentTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndCurrentTime ({\b sqlite3_vfs} *  {\i pVfs}, double *  {\i pTimeOut}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4046 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4046                                                                \{\par
 4047   return ORIGVFS(pVfs)->xCurrentTime(ORIGVFS(pVfs), pTimeOut);\par
 4048 \}\par
}
}
{\xe \v apndCurrentTimeInt64\:shell.c}
{\xe \v shell.c\:apndCurrentTimeInt64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndCurrentTimeInt64 ({\b sqlite3_vfs} *  {\i pVfs}, {\b sqlite3_int64} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4052 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4052                                                                     \{\par
 4053   return ORIGVFS(pVfs)->xCurrentTimeInt64(ORIGVFS(pVfs), p);\par
 4054 \}\par
}
}
{\xe \v apndDelete\:shell.c}
{\xe \v shell.c\:apndDelete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndDelete ({\b sqlite3_vfs} *  {\i pVfs}, const char *  {\i zName}, int  {\i syncDir}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4009 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4009                                                                         \{\par
 4010   return ORIGVFS(pVfs)->xDelete(ORIGVFS(pVfs), zPath, dirSync);\par
 4011 \}\par
}
}
{\xe \v apndDeviceCharacteristics\:shell.c}
{\xe \v shell.c\:apndDeviceCharacteristics}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndDeviceCharacteristics ({\b sqlite3_file} *  {\i pFile}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3869 of file shell.c.}\par
{
References ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xDeviceCharacteristics.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3869                                                          \{\par
 3870   pFile = ORIGFILE(pFile);\par
 3871   return pFile->pMethods->xDeviceCharacteristics(pFile);\par
 3872 \}\par
}
}
{\xe \v apndDlClose\:shell.c}
{\xe \v shell.c\:apndDlClose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void apndDlClose ({\b sqlite3_vfs} *  {\i pVfs}, void *  {\i pHandle}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4037 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4037                                                          \{\par
 4038   ORIGVFS(pVfs)->xDlClose(ORIGVFS(pVfs), pHandle);\par
 4039 \}\par
}
}
{\xe \v apndDlError\:shell.c}
{\xe \v shell.c\:apndDlError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void apndDlError ({\b sqlite3_vfs} *  {\i pVfs}, int  {\i nByte}, char *  {\i zErrMsg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4031 of file shell.c.}\par
{
References apndDlSym, and ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4031                                                                     \{\par
 4032   ORIGVFS(pVfs)->xDlError(ORIGVFS(pVfs), nByte, zErrMsg);\par
 4033 \}\par
}
}
{\xe \v apndDlOpen\:shell.c}
{\xe \v shell.c\:apndDlOpen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void * apndDlOpen ({\b sqlite3_vfs} *  {\i pVfs}, const char *  {\i zFilename}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4028 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4028                                                              \{\par
 4029   return ORIGVFS(pVfs)->xDlOpen(ORIGVFS(pVfs), zPath);\par
 4030 \}\par
}
}
{\xe \v apndFetch\:shell.c}
{\xe \v shell.c\:apndFetch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndFetch ({\b sqlite3_file} *  {\i pFile}, {\b sqlite3_int64}  {\i iOfst}, int  {\i iAmt}, void **  {\i pp}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3905 of file shell.c.}\par
{
References ApndFile::iPgOne, ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xFetch.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3910  \{\par
 3911   ApndFile *p = (ApndFile *)pFile;\par
 3912   pFile = ORIGFILE(pFile);\par
 3913   return pFile->pMethods->xFetch(pFile, iOfst+p->iPgOne, iAmt, pp);\par
 3914 \}\par
}
}
{\xe \v apndFileControl\:shell.c}
{\xe \v shell.c\:apndFileControl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndFileControl ({\b sqlite3_file} *  {\i pFile}, int  {\i op}, void *  {\i pArg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3847 of file shell.c.}\par
{
References ApndFile::iPgOne, ORIGFILE, sqlite3_file::pMethods, sqlite3_mprintf, SQLITE_FCNTL_VFSNAME, SQLITE_OK, and sqlite3_io_methods::xFileControl.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3847                                                                    \{\par
 3848   ApndFile *p = (ApndFile *)pFile;\par
 3849   int rc;\par
 3850   pFile = ORIGFILE(pFile);\par
 3851   rc = pFile->pMethods->xFileControl(pFile, op, pArg);\par
 3852   if( rc==SQLITE_OK && op==SQLITE_FCNTL_VFSNAME )\{\par
 3853     *(char**)pArg = sqlite3_mprintf("apnd(%lld)/%z", p->iPgOne, *(char**)pArg);\par
 3854   \}\par
 3855   return rc;\par
 3856 \}\par
}
}
{\xe \v apndFileSize\:shell.c}
{\xe \v shell.c\:apndFileSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndFileSize ({\b sqlite3_file} *  {\i pFile}, {\b sqlite3_int64} *  {\i pSize}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3809 of file shell.c.}\par
{
References APND_MARK_SIZE, ApndFile::iPgOne, ORIGFILE, sqlite3_file::pMethods, SQLITE_OK, and sqlite3_io_methods::xFileSize.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3809                                                                  \{\par
 3810   ApndFile *p = (ApndFile *)pFile;\par
 3811   int rc;\par
 3812   pFile = ORIGFILE(p);\par
 3813   rc = pFile->pMethods->xFileSize(pFile, pSize);\par
 3814   if( rc==SQLITE_OK && p->iPgOne )\{\par
 3815     *pSize -= p->iPgOne + APND_MARK_SIZE;\par
 3816   \}\par
 3817   return rc;\par
 3818 \}\par
}
}
{\xe \v apndFullPathname\:shell.c}
{\xe \v shell.c\:apndFullPathname}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndFullPathname ({\b sqlite3_vfs} *  {\i pVfs}, const char *  {\i zName}, int  {\i nOut}, char *  {\i zOut}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4020 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4025  \{\par
 4026   return ORIGVFS(pVfs)->xFullPathname(ORIGVFS(pVfs),zPath,nOut,zOut);\par
 4027 \}\par
}
}
{\xe \v apndGetLastError\:shell.c}
{\xe \v shell.c\:apndGetLastError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndGetLastError ({\b sqlite3_vfs} *  {\i pVfs}, int  {\i a}, char *  {\i b}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4049 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4049                                                               \{\par
 4050   return ORIGVFS(pVfs)->xGetLastError(ORIGVFS(pVfs), a, b);\par
 4051 \}\par
}
}
{\xe \v apndGetSystemCall\:shell.c}
{\xe \v shell.c\:apndGetSystemCall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b sqlite3_syscall_ptr} apndGetSystemCall ({\b sqlite3_vfs} *  {\i pVfs}, const char *  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4062 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4065  \{\par
 4066   return ORIGVFS(pVfs)->xGetSystemCall(ORIGVFS(pVfs),zName);\par
 4067 \}\par
}
}
{\xe \v apndIsOrdinaryDatabaseFile\:shell.c}
{\xe \v shell.c\:apndIsOrdinaryDatabaseFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndIsOrdinaryDatabaseFile ({\b sqlite3_int64}  {\i sz}, {\b sqlite3_file} *  {\i pFile}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3926 of file shell.c.}\par
{
References sqlite3_file::pMethods, and sqlite3_io_methods::xRead.}\par
{
Referenced by apndOpen().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3926                                                                             \{\par
 3927   int rc;\par
 3928   char zHdr[16];\par
 3929   static const char aSqliteHdr[] = "SQLite format 3";\par
 3930   if( sz<512 ) return 0;\par
 3931   rc = pFile->pMethods->xRead(pFile, zHdr, sizeof(zHdr), 0);\par
 3932   if( rc ) return 0;\par
 3933   return memcmp(zHdr, aSqliteHdr, sizeof(zHdr))==0;\par
 3934 \}\par
}
}
{\xe \v apndLock\:shell.c}
{\xe \v shell.c\:apndLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndLock ({\b sqlite3_file} *  {\i pFile}, int  {\i eLock}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3823 of file shell.c.}\par
{
References ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xLock.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3823                                                    \{\par
 3824   pFile = ORIGFILE(pFile);\par
 3825   return pFile->pMethods->xLock(pFile, eLock);\par
 3826 \}\par
}
}
{\xe \v apndNextSystemCall\:shell.c}
{\xe \v shell.c\:apndNextSystemCall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char * apndNextSystemCall ({\b sqlite3_vfs} *  {\i pVfs}, const char *  {\i zName}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4068 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4068                                                                            \{\par
 4069   return ORIGVFS(pVfs)->xNextSystemCall(ORIGVFS(pVfs), zName);\par
 4070 \}\par
}
}
{\xe \v apndOpen\:shell.c}
{\xe \v shell.c\:apndOpen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndOpen ({\b sqlite3_vfs} *  {\i pVfs}, const char *  {\i zName}, {\b sqlite3_file} *  {\i pFile}, int  {\i flags}, int *  {\i pOutFlags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3960 of file shell.c.}\par
{
References apnd_io_methods, apndIsOrdinaryDatabaseFile(), apndReadMark(), ApndFile::base, ApndFile::iMark, ApndFile::iPgOne, ORIGFILE, ORIGVFS, sqlite3_file::pMethods, SQLITE_CANTOPEN, SQLITE_OK, SQLITE_OPEN_CREATE, SQLITE_OPEN_MAIN_DB, sqlite3_vfs::szOsFile, sqlite3_io_methods::xClose, sqlite3_io_methods::xFileSize, and sqlite3_vfs::xOpen.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3966  \{\par
 3967   ApndFile *p;\par
 3968   sqlite3_file *pSubFile;\par
 3969   sqlite3_vfs *pSubVfs;\par
 3970   int rc;\par
 3971   sqlite3_int64 sz;\par
 3972   pSubVfs = ORIGVFS(pVfs);\par
 3973   if( (flags & SQLITE_OPEN_MAIN_DB)==0 )\{\par
 3974     return pSubVfs->xOpen(pSubVfs, zName, pFile, flags, pOutFlags);\par
 3975   \}\par
 3976   p = (ApndFile*)pFile;\par
 3977   memset(p, 0, sizeof(*p));\par
 3978   pSubFile = ORIGFILE(pFile);\par
 3979   p->base.pMethods = &apnd_io_methods;\par
 3980   rc = pSubVfs->xOpen(pSubVfs, zName, pSubFile, flags, pOutFlags);\par
 3981   if( rc ) goto apnd_open_done;\par
 3982   rc = pSubFile->pMethods->xFileSize(pSubFile, &sz);\par
 3983   if( rc )\{\par
 3984     pSubFile->pMethods->xClose(pSubFile);\par
 3985     goto apnd_open_done;\par
 3986   \}\par
 3987   if( apndIsOrdinaryDatabaseFile(sz, pSubFile) )\{\par
 3988     memmove(pFile, pSubFile, pSubVfs->szOsFile);\par
 3989     return SQLITE_OK;\par
 3990   \}\par
 3991   p->iMark = 0;\par
 3992   p->iPgOne = apndReadMark(sz, pFile);\par
 3993   if( p->iPgOne>0 )\{\par
 3994     return SQLITE_OK;\par
 3995   \}\par
 3996   if( (flags & SQLITE_OPEN_CREATE)==0 )\{\par
 3997     pSubFile->pMethods->xClose(pSubFile);\par
 3998     rc = SQLITE_CANTOPEN;\par
 3999   \}\par
 4000   p->iPgOne = (sz+0xfff) & ~(sqlite3_int64)0xfff;\par
 4001 apnd_open_done:\par
 4002   if( rc ) pFile->pMethods = 0;\par
 4003   return rc;\par
 4004 \}\par
}
}
{\xe \v apndRandomness\:shell.c}
{\xe \v shell.c\:apndRandomness}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndRandomness ({\b sqlite3_vfs} *  {\i pVfs}, int  {\i nByte}, char *  {\i zOut}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4040 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4040                                                                       \{\par
 4041   return ORIGVFS(pVfs)->xRandomness(ORIGVFS(pVfs), nByte, zBufOut);\par
 4042 \}\par
}
}
{\xe \v apndRead\:shell.c}
{\xe \v shell.c\:apndRead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndRead ({\b sqlite3_file} *  {\i pFile}, void *  {\i zBuf}, int  {\i iAmt}, {\b sqlite3_int64}  {\i iOfst}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3731 of file shell.c.}\par
{
References ApndFile::iPgOne, ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xRead.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3736  \{\par
 3737   ApndFile *p = (ApndFile *)pFile;\par
 3738   pFile = ORIGFILE(pFile);\par
 3739   return pFile->pMethods->xRead(pFile, zBuf, iAmt, iOfst+p->iPgOne);\par
 3740 \}\par
}
}
{\xe \v apndReadMark\:shell.c}
{\xe \v shell.c\:apndReadMark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b sqlite3_int64} apndReadMark ({\b sqlite3_int64}  {\i sz}, {\b sqlite3_file} *  {\i pFile}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3941 of file shell.c.}\par
{
References APND_MARK_PREFIX, APND_MARK_PREFIX_SZ, APND_MARK_SIZE, sqlite3_file::pMethods, and sqlite3_io_methods::xRead.}\par
{
Referenced by apndOpen().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3941                                                                         \{\par
 3942   int rc, i;\par
 3943   sqlite3_int64 iMark;\par
 3944   unsigned char a[APND_MARK_SIZE];\par
 3945 \par
 3946   if( sz<=APND_MARK_SIZE ) return -1;\par
 3947   rc = pFile->pMethods->xRead(pFile, a, APND_MARK_SIZE, sz-APND_MARK_SIZE);\par
 3948   if( rc ) return -1;\par
 3949   if( memcmp(a, APND_MARK_PREFIX, APND_MARK_PREFIX_SZ)!=0 ) return -1;\par
 3950   iMark = ((sqlite3_int64)(a[APND_MARK_PREFIX_SZ]&0x7f))<<56;\par
 3951   for(i=1; i<8; i++)\{    \par
 3952     iMark += (sqlite3_int64)a[APND_MARK_PREFIX_SZ+i]<<(56-8*i);\par
 3953   \}\par
 3954   return iMark;\par
 3955 \}\par
}
}
{\xe \v apndSectorSize\:shell.c}
{\xe \v shell.c\:apndSectorSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndSectorSize ({\b sqlite3_file} *  {\i pFile}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3861 of file shell.c.}\par
{
References ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xSectorSize.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3861                                               \{\par
 3862   pFile = ORIGFILE(pFile);\par
 3863   return pFile->pMethods->xSectorSize(pFile);\par
 3864 \}\par
}
}
{\xe \v apndSetSystemCall\:shell.c}
{\xe \v shell.c\:apndSetSystemCall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndSetSystemCall ({\b sqlite3_vfs} *  {\i pVfs}, const char *  {\i zName}, {\b sqlite3_syscall_ptr}  {\i pCall}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4055 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4059  \{\par
 4060   return ORIGVFS(pVfs)->xSetSystemCall(ORIGVFS(pVfs),zName,pCall);\par
 4061 \}\par
}
}
{\xe \v apndShmBarrier\:shell.c}
{\xe \v shell.c\:apndShmBarrier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void apndShmBarrier ({\b sqlite3_file} *  {\i pFile}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3893 of file shell.c.}\par
{
References ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xShmBarrier.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3893                                                \{\par
 3894   pFile = ORIGFILE(pFile);\par
 3895   pFile->pMethods->xShmBarrier(pFile);\par
 3896 \}\par
}
}
{\xe \v apndShmLock\:shell.c}
{\xe \v shell.c\:apndShmLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndShmLock ({\b sqlite3_file} *  {\i pFile}, int  {\i offset}, int  {\i n}, int  {\i flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3887 of file shell.c.}\par
{
References ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xShmLock.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3887                                                                          \{\par
 3888   pFile = ORIGFILE(pFile);\par
 3889   return pFile->pMethods->xShmLock(pFile,offset,n,flags);\par
 3890 \}\par
}
}
{\xe \v apndShmMap\:shell.c}
{\xe \v shell.c\:apndShmMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndShmMap ({\b sqlite3_file} *  {\i pFile}, int  {\i iPg}, int  {\i pgsz}, int  {\i bExtend}, void volatile **  {\i pp}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3875 of file shell.c.}\par
{
References ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xShmMap.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3881  \{\par
 3882   pFile = ORIGFILE(pFile);\par
 3883   return pFile->pMethods->xShmMap(pFile,iPg,pgsz,bExtend,pp);\par
 3884 \}\par
}
}
{\xe \v apndShmUnmap\:shell.c}
{\xe \v shell.c\:apndShmUnmap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndShmUnmap ({\b sqlite3_file} *  {\i pFile}, int  {\i deleteFlag}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3899 of file shell.c.}\par
{
References ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xShmUnmap.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3899                                                             \{\par
 3900   pFile = ORIGFILE(pFile);\par
 3901   return pFile->pMethods->xShmUnmap(pFile,deleteFlag);\par
 3902 \}\par
}
}
{\xe \v apndSleep\:shell.c}
{\xe \v shell.c\:apndSleep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndSleep ({\b sqlite3_vfs} *  {\i pVfs}, int  {\i microseconds}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4043 of file shell.c.}\par
{
References ORIGVFS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4043                                                    \{\par
 4044   return ORIGVFS(pVfs)->xSleep(ORIGVFS(pVfs), nMicro);\par
 4045 \}\par
}
}
{\xe \v apndSync\:shell.c}
{\xe \v shell.c\:apndSync}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndSync ({\b sqlite3_file} *  {\i pFile}, int  {\i flags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3801 of file shell.c.}\par
{
References ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xSync.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3801                                                    \{\par
 3802   pFile = ORIGFILE(pFile);\par
 3803   return pFile->pMethods->xSync(pFile, flags);\par
 3804 \}\par
}
}
{\xe \v apndTruncate\:shell.c}
{\xe \v shell.c\:apndTruncate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndTruncate ({\b sqlite3_file} *  {\i pFile}, {\b sqlite3_int64}  {\i size}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3786 of file shell.c.}\par
{
References APND_MARK_SIZE, apndWriteMark(), ApndFile::iMark, ApndFile::iPgOne, ORIGFILE, sqlite3_file::pMethods, SQLITE_OK, and sqlite3_io_methods::xTruncate.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3786                                                                \{\par
 3787   int rc;\par
 3788   ApndFile *p = (ApndFile *)pFile;\par
 3789   pFile = ORIGFILE(pFile);\par
 3790   rc = pFile->pMethods->xTruncate(pFile, size+p->iPgOne+APND_MARK_SIZE);\par
 3791   if( rc==SQLITE_OK )\{\par
 3792     p->iMark = p->iPgOne+size;\par
 3793     rc = apndWriteMark(p, pFile);\par
 3794   \}\par
 3795   return rc;\par
 3796 \}\par
}
}
{\xe \v apndUnfetch\:shell.c}
{\xe \v shell.c\:apndUnfetch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndUnfetch ({\b sqlite3_file} *  {\i pFile}, {\b sqlite3_int64}  {\i iOfst}, void *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3917 of file shell.c.}\par
{
References ApndFile::iPgOne, ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xUnfetch.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3917                                                                              \{\par
 3918   ApndFile *p = (ApndFile *)pFile;\par
 3919   pFile = ORIGFILE(pFile);\par
 3920   return pFile->pMethods->xUnfetch(pFile, iOfst+p->iPgOne, pPage);\par
 3921 \}\par
}
}
{\xe \v apndUnlock\:shell.c}
{\xe \v shell.c\:apndUnlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndUnlock ({\b sqlite3_file} *  {\i pFile}, int  {\i eLock}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3831 of file shell.c.}\par
{
References ORIGFILE, sqlite3_file::pMethods, and sqlite3_io_methods::xUnlock.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3831                                                      \{\par
 3832   pFile = ORIGFILE(pFile);\par
 3833   return pFile->pMethods->xUnlock(pFile, eLock);\par
 3834 \}\par
}
}
{\xe \v apndWrite\:shell.c}
{\xe \v shell.c\:apndWrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndWrite ({\b sqlite3_file} *  {\i pFile}, const void *  {\i zBuf}, int  {\i iAmt}, {\b sqlite3_int64}  {\i iOfst}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3758 of file shell.c.}\par
{
References APND_MARK_SIZE, APND_MAX_SIZE, apndWriteMark(), ApndFile::iMark, ApndFile::iPgOne, ORIGFILE, sqlite3_file::pMethods, SQLITE_FULL, SQLITE_OK, sqlite3_io_methods::xFileSize, and sqlite3_io_methods::xWrite.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3763  \{\par
 3764   int rc;\par
 3765   ApndFile *p = (ApndFile *)pFile;\par
 3766   pFile = ORIGFILE(pFile);\par
 3767   if( iOfst+iAmt>=APND_MAX_SIZE ) return SQLITE_FULL;\par
 3768   rc = pFile->pMethods->xWrite(pFile, zBuf, iAmt, iOfst+p->iPgOne);\par
 3769   if( rc==SQLITE_OK &&  iOfst + iAmt + p->iPgOne > p->iMark )\{\par
 3770     sqlite3_int64 sz = 0;\par
 3771     rc = pFile->pMethods->xFileSize(pFile, &sz);\par
 3772     if( rc==SQLITE_OK )\{\par
 3773       p->iMark = sz - APND_MARK_SIZE;\par
 3774       if( iOfst + iAmt + p->iPgOne > p->iMark )\{\par
 3775         p->iMark = p->iPgOne + iOfst + iAmt;\par
 3776         rc = apndWriteMark(p, pFile);\par
 3777       \}\par
 3778     \}\par
 3779   \}\par
 3780   return rc;\par
 3781 \}\par
}
}
{\xe \v apndWriteMark\:shell.c}
{\xe \v shell.c\:apndWriteMark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int apndWriteMark ({\b ApndFile} *  {\i p}, {\b sqlite3_file} *  {\i pFile}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3745 of file shell.c.}\par
{
References APND_MARK_PREFIX, APND_MARK_PREFIX_SZ, APND_MARK_SIZE, ApndFile::iMark, ApndFile::iPgOne, sqlite3_file::pMethods, and sqlite3_io_methods::xWrite.}\par
{
Referenced by apndTruncate(), and apndWrite().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3745                                                           \{\par
 3746   int i;\par
 3747   unsigned char a[APND_MARK_SIZE];\par
 3748   memcpy(a, APND_MARK_PREFIX, APND_MARK_PREFIX_SZ);\par
 3749   for(i=0; i<8; i++)\{\par
 3750     a[APND_MARK_PREFIX_SZ+i] = (p->iPgOne >> (56 - i*8)) & 0xff;\par
 3751   \}\par
 3752   return pFile->pMethods->xWrite(pFile, a, APND_MARK_SIZE, p->iMark);\par
 3753 \}\par
}
}
{\xe \v appendText\:shell.c}
{\xe \v shell.c\:appendText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void appendText ({\b ShellText} *  {\i p}, char const *  {\i zAppend}, char  {\i quote}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 750 of file shell.c.}\par
{
References ShellText::n, ShellText::nAlloc, shell_out_of_memory(), strlen30(), and ShellText::z.}\par
{
Referenced by captureOutputCallback(), do_meta_command(), dump_callback(), and shellFakeSchema().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   750                                                                      \{\par
  751   int len;\par
  752   int i;\par
  753   int nAppend = strlen30(zAppend);\par
  754 \par
  755   len = nAppend+p->n+1;\par
  756   if( quote )\{\par
  757     len += 2;\par
  758     for(i=0; i<nAppend; i++)\{\par
  759       if( zAppend[i]==quote ) len++;\par
  760     \}\par
  761   \}\par
  762 \par
  763   if( p->n+len>=p->nAlloc )\{\par
  764     p->nAlloc = p->nAlloc*2 + len + 20;\par
  765     p->z = realloc(p->z, p->nAlloc);\par
  766     if( p->z==0 ) shell_out_of_memory();\par
  767   \}\par
  768 \par
  769   if( quote )\{\par
  770     char *zCsr = p->z+p->n;\par
  771     *zCsr++ = quote;\par
  772     for(i=0; i<nAppend; i++)\{\par
  773       *zCsr++ = zAppend[i];\par
  774       if( zAppend[i]==quote ) *zCsr++ = quote;\par
  775     \}\par
  776     *zCsr++ = quote;\par
  777     p->n = (int)(zCsr - p->z);\par
  778     *zCsr = '\\0';\par
  779   \}else\{\par
  780     memcpy(p->z+p->n, zAppend, nAppend);\par
  781     p->n += nAppend;\par
  782     p->z[p->n] = '\\0';\par
  783   \}\par
  784 \}\par
}
}
{\xe \v ascii_read_one_field\:shell.c}
{\xe \v shell.c\:ascii_read_one_field}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* {\b SQLITE_CDECL} ascii_read_one_field ({\b ImportCtx} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13195 of file shell.c.}\par
{
References ImportCtx::cColSep, ImportCtx::cRowSep, ImportCtx::cTerm, import_append_char(), ImportCtx::in, ImportCtx::n, ImportCtx::nLine, and ImportCtx::z.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13195                                                             \{\par
13196   int c;\par
13197   int cSep = p->cColSep;\par
13198   int rSep = p->cRowSep;\par
13199   p->n = 0;\par
13200   c = fgetc(p->in);\par
13201   if( c==EOF || seenInterrupt )\{\par
13202     p->cTerm = EOF;\par
13203     return 0;\par
13204   \}\par
13205   while( c!=EOF && c!=cSep && c!=rSep )\{\par
13206     import_append_char(p, c);\par
13207     c = fgetc(p->in);\par
13208   \}\par
13209   if( c==rSep )\{\par
13210     p->nLine++;\par
13211   \}\par
13212   p->cTerm = c;\par
13213   if( p->z ) p->z[p->n] = 0;\par
13214   return p->z;\par
13215 \}\par
}
}
{\xe \v beginTimer\:shell.c}
{\xe \v shell.c\:beginTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void beginTimer (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 262 of file shell.c.}\par
{
References sBegin, and timeOfDay().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   262                             \{\par
  263   if( enableTimer )\{\par
  264     getrusage(RUSAGE_SELF, &sBegin);\par
  265     iBegin = timeOfDay();\par
  266   \}\par
  267 \}\par
}
}
{\xe \v bind_prepared_stmt\:shell.c}
{\xe \v shell.c\:bind_prepared_stmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void bind_prepared_stmt ({\b ShellState} *  {\i pArg}, {\b sqlite3_stmt} *  {\i pStmt}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11356 of file shell.c.}\par
{
References ShellState::db, sqlite3_bind_null, sqlite3_bind_parameter_count, sqlite3_bind_parameter_name, sqlite3_bind_text, sqlite3_bind_value, sqlite3_column_value, sqlite3_finalize, sqlite3_prepare_v2, sqlite3_reset, sqlite3_snprintf, sqlite3_step, sqlite3_table_column_metadata, SQLITE_OK, SQLITE_ROW, and SQLITE_STATIC.}\par
{
Referenced by shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11356                                                                      \{\par
11357   int nVar;\par
11358   int i;\par
11359   int rc;\par
11360   sqlite3_stmt *pQ = 0;\par
11361 \par
11362   nVar = sqlite3_bind_parameter_count(pStmt);\par
11363   if( nVar==0 ) return;  /* Nothing to do */\par
11364   if( sqlite3_table_column_metadata(pArg->db, "TEMP", "sqlite_parameters",\par
11365                                     "key", 0, 0, 0, 0, 0)!=SQLITE_OK )\{\par
11366     return; /* Parameter table does not exist */\par
11367   \}\par
11368   rc = sqlite3_prepare_v2(pArg->db,\par
11369           "SELECT value FROM temp.sqlite_parameters"\par
11370           " WHERE key=?1", -1, &pQ, 0);\par
11371   if( rc || pQ==0 ) return;\par
11372   for(i=1; i<=nVar; i++)\{\par
11373     char zNum[30];\par
11374     const char *zVar = sqlite3_bind_parameter_name(pStmt, i);\par
11375     if( zVar==0 )\{\par
11376       sqlite3_snprintf(sizeof(zNum),zNum,"?%d",i);\par
11377       zVar = zNum;\par
11378     \}\par
11379     sqlite3_bind_text(pQ, 1, zVar, -1, SQLITE_STATIC);\par
11380     if( sqlite3_step(pQ)==SQLITE_ROW )\{\par
11381       sqlite3_bind_value(pStmt, i, sqlite3_column_value(pQ, 0));\par
11382     \}else\{\par
11383       sqlite3_bind_null(pStmt, i);\par
11384     \}\par
11385     sqlite3_reset(pQ);\par
11386   \}\par
11387   sqlite3_finalize(pQ);\par
11388 \}\par
}
}
{\xe \v bind_table_init\:shell.c}
{\xe \v shell.c\:bind_table_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void bind_table_init ({\b ShellState} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11327 of file shell.c.}\par
{
References ShellState::db, sqlite3_db_config, sqlite3_exec, SQLITE_DBCONFIG_DEFENSIVE, and SQLITE_DBCONFIG_WRITABLE_SCHEMA.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11327                                           \{\par
11328   int wrSchema = 0;\par
11329   int defensiveMode = 0;\par
11330   sqlite3_db_config(p->db, SQLITE_DBCONFIG_DEFENSIVE, -1, &defensiveMode);\par
11331   sqlite3_db_config(p->db, SQLITE_DBCONFIG_DEFENSIVE, 0, 0);\par
11332   sqlite3_db_config(p->db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, -1, &wrSchema);\par
11333   sqlite3_db_config(p->db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, 1, 0);\par
11334   sqlite3_exec(p->db,\par
11335     "CREATE TABLE IF NOT EXISTS temp.sqlite_parameters(\\n"\par
11336     "  key TEXT PRIMARY KEY,\\n"\par
11337     "  value ANY\\n"\par
11338     ") WITHOUT ROWID;",\par
11339     0, 0, 0);\par
11340   sqlite3_db_config(p->db, SQLITE_DBCONFIG_WRITABLE_SCHEMA, wrSchema, 0);\par
11341   sqlite3_db_config(p->db, SQLITE_DBCONFIG_DEFENSIVE, defensiveMode, 0);\par
11342 \}\par
}
}
{\xe \v booleanValue\:shell.c}
{\xe \v shell.c\:booleanValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int booleanValue (const char *  {\i zArg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12938 of file shell.c.}\par
{
References hexDigitValue(), integerValue(), sqlite3_stricmp, and utf8_printf.}\par
{
Referenced by do_meta_command(), and setOrClearFlag().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12938                                          \{\par
12939   int i;\par
12940   if( zArg[0]=='0' && zArg[1]=='x' )\{\par
12941     for(i=2; hexDigitValue(zArg[i])>=0; i++)\{\}\par
12942   \}else\{\par
12943     for(i=0; zArg[i]>='0' && zArg[i]<='9'; i++)\{\}\par
12944   \}\par
12945   if( i>0 && zArg[i]==0 ) return (int)(integerValue(zArg) & 0xffffffff);\par
12946   if( sqlite3_stricmp(zArg, "on")==0 || sqlite3_stricmp(zArg,"yes")==0 )\{\par
12947     return 1;\par
12948   \}\par
12949   if( sqlite3_stricmp(zArg, "off")==0 || sqlite3_stricmp(zArg,"no")==0 )\{\par
12950     return 0;\par
12951   \}\par
12952   utf8_printf(stderr, "ERROR: Not a boolean value: \\"%s\\". Assuming \\"no\\".\\n",\par
12953           zArg);\par
12954   return 0;\par
12955 \}\par
}
}
{\xe \v callback\:shell.c}
{\xe \v shell.c\:callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int callback (void *  {\i pArg}, int  {\i nArg}, char **  {\i azArg}, char **  {\i azCol}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10760 of file shell.c.}\par
{
References shell_callback().}\par
{
Referenced by node_sqlite3::Statement::Bind(), Nan::ContextDisposedNotification(), Persistent< T, M >::Copy(), do_meta_command(), imp::FunctionCallbackWrapper(), imp::GetterCallbackWrapper(), imp::IndexDeleterCallbackWrapper(), imp::IndexEnumeratorCallbackWrapper(), imp::IndexGetterCallbackWrapper(), imp::IndexQueryCallbackWrapper(), imp::IndexSetterCallbackWrapper(), NAN_METHOD(), PersistentBase< T >::operator!=(), imp::PropertyDeleterCallbackWrapper(), imp::PropertyEnumeratorCallbackWrapper(), imp::PropertyGetterCallbackWrapper(), imp::PropertyQueryCallbackWrapper(), imp::PropertySetterCallbackWrapper(), Persistent< T, M >::Reset(), node_sqlite3::Database::Schedule(), node_sqlite3::Backup::Schedule(), node_sqlite3::Statement::Schedule(), Nan::SetMethod(), Nan::SetPrototypeMethod(), imp::SetterCallbackWrapper(), WeakCallbackInfo< T >::unwrap(), Nan::AsyncWorker::WorkComplete(), Nan::AsyncWorker::~AsyncWorker(), node_sqlite3::Backup::~Backup(), node_sqlite3::Database::~Database(), and node_sqlite3::Statement::~Statement().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10760                                                                      \{\par
10761   /* since we don't have type info, call the shell_callback with a NULL value */\par
10762   return shell_callback(pArg, nArg, azArg, azCol, NULL);\par
10763 \}\par
}
}
{\xe \v captureOutputCallback\:shell.c}
{\xe \v shell.c\:captureOutputCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int captureOutputCallback (void *  {\i pArg}, int  {\i nArg}, char **  {\i azArg}, char **  {\i az}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10769 of file shell.c.}\par
{
References appendText(), ShellText::n, and UNUSED_PARAMETER.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10769                                                                                \{\par
10770   ShellText *p = (ShellText*)pArg;\par
10771   int i;\par
10772   UNUSED_PARAMETER(az);\par
10773   if( azArg==0 ) return 0;\par
10774   if( p->n ) appendText(p, "|", 0);\par
10775   for(i=0; i<nArg; i++)\{\par
10776     if( i ) appendText(p, ",", 0);\par
10777     if( azArg[i] ) appendText(p, azArg[i], 0);\par
10778   \}\par
10779   return 0;\par
10780 \}\par
}
}
{\xe \v clearTempFile\:shell.c}
{\xe \v shell.c\:clearTempFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void clearTempFile ({\b ShellState} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13732 of file shell.c.}\par
{
References ShellState::doXdgOpen, shellDeleteFile(), sqlite3_free, and ShellState::zTempFile.}\par
{
Referenced by do_meta_command(), main(), newTempFile(), and process_input().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13732                                         \{\par
13733   if( p->zTempFile==0 ) return;\par
13734   if( p->doXdgOpen ) return;\par
13735   if( shellDeleteFile(p->zTempFile) ) return;\par
13736   sqlite3_free(p->zTempFile);\par
13737   p->zTempFile = 0;\par
13738 \}\par
}
}
{\xe \v close_db\:shell.c}
{\xe \v shell.c\:close_db}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void close_db ({\b sqlite3} *  {\i db})}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12802 of file shell.c.}\par
{
References sqlite3_close, sqlite3_column_bytes, sqlite3_column_text, sqlite3_errmsg, sqlite3_exec, sqlite3_finalize, sqlite3_free, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_step, SQLITE_ROW, strlen30(), and utf8_printf.}\par
{
Referenced by do_meta_command(), main(), shellReset(), and tryToClone().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12802                           \{\par
12803   int rc = sqlite3_close(db);\par
12804   if( rc )\{\par
12805     utf8_printf(stderr, "Error: sqlite3_close() returns %d: %s\\n",\par
12806         rc, sqlite3_errmsg(db));\par
12807   \} \par
12808 \}\par
}
}
{\xe \v cmdline_option_value\:shell.c}
{\xe \v shell.c\:cmdline_option_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* cmdline_option_value (int  {\i argc}, char **  {\i argv}, int  {\i i}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18647 of file shell.c.}\par
{
References utf8_printf.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18647                                                                \{\par
18648   if( i==argc )\{\par
18649     utf8_printf(stderr, "%s: Error: missing argument to %s\\n",\par
18650             argv[0], argv[argc-1]);\par
18651     exit(1);\par
18652   \}\par
18653   return argv[i];\par
18654 \}\par
}
}
{\xe \v completionBestIndex\:shell.c}
{\xe \v shell.c\:completionBestIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int completionBestIndex ({\b sqlite3_vtab} *  {\i tab}, {\b sqlite3_index_info} *  {\i pIdxInfo}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3437 of file shell.c.}\par
{
References sqlite3_index_info::aConstraint, sqlite3_index_info::aConstraintUsage, sqlite3_index_info::sqlite3_index_constraint_usage::argvIndex, COMPLETION_COLUMN_PREFIX, COMPLETION_COLUMN_WHOLELINE, sqlite3_index_info::estimatedCost, sqlite3_index_info::estimatedRows, sqlite3_index_info::idxNum, sqlite3_index_info::nConstraint, sqlite3_index_info::sqlite3_index_constraint_usage::omit, SQLITE_INDEX_CONSTRAINT_EQ, and SQLITE_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3440  \{\par
 3441   int i;                 /* Loop over constraints */\par
 3442   int idxNum = 0;        /* The query plan bitmask */\par
 3443   int prefixIdx = -1;    /* Index of the start= constraint, or -1 if none */\par
 3444   int wholelineIdx = -1; /* Index of the stop= constraint, or -1 if none */\par
 3445   int nArg = 0;          /* Number of arguments that completeFilter() expects */\par
 3446   const struct sqlite3_index_constraint *pConstraint;\par
 3447 \par
 3448   (void)(tab);    /* Unused parameter */\par
 3449   pConstraint = pIdxInfo->aConstraint;\par
 3450   for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++)\{\par
 3451     if( pConstraint->usable==0 ) continue;\par
 3452     if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;\par
 3453     switch( pConstraint->iColumn )\{\par
 3454       case COMPLETION_COLUMN_PREFIX:\par
 3455         prefixIdx = i;\par
 3456         idxNum |= 1;\par
 3457         break;\par
 3458       case COMPLETION_COLUMN_WHOLELINE:\par
 3459         wholelineIdx = i;\par
 3460         idxNum |= 2;\par
 3461         break;\par
 3462     \}\par
 3463   \}\par
 3464   if( prefixIdx>=0 )\{\par
 3465     pIdxInfo->aConstraintUsage[prefixIdx].argvIndex = ++nArg;\par
 3466     pIdxInfo->aConstraintUsage[prefixIdx].omit = 1;\par
 3467   \}\par
 3468   if( wholelineIdx>=0 )\{\par
 3469     pIdxInfo->aConstraintUsage[wholelineIdx].argvIndex = ++nArg;\par
 3470     pIdxInfo->aConstraintUsage[wholelineIdx].omit = 1;\par
 3471   \}\par
 3472   pIdxInfo->idxNum = idxNum;\par
 3473   pIdxInfo->estimatedCost = (double)5000 - 1000*nArg;\par
 3474   pIdxInfo->estimatedRows = 500 - 100*nArg;\par
 3475   return SQLITE_OK;\par
 3476 \}\par
}
}
{\xe \v completionClose\:shell.c}
{\xe \v shell.c\:completionClose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int completionClose ({\b sqlite3_vtab_cursor} *  {\i cur}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3206 of file shell.c.}\par
{
References completionCursorReset(), sqlite3_free, and SQLITE_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3206                                                     \{\par
 3207   completionCursorReset((completion_cursor*)cur);\par
 3208   sqlite3_free(cur);\par
 3209   return SQLITE_OK;\par
 3210 \}\par
}
}
{\xe \v completionColumn\:shell.c}
{\xe \v shell.c\:completionColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int completionColumn ({\b sqlite3_vtab_cursor} *  {\i cur}, {\b sqlite3_context} *  {\i ctx}, int  {\i i}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3334 of file shell.c.}\par
{
References COMPLETION_COLUMN_CANDIDATE, COMPLETION_COLUMN_PHASE, COMPLETION_COLUMN_PREFIX, COMPLETION_COLUMN_WHOLELINE, completion_cursor::ePhase, sqlite3_result_int, sqlite3_result_text, SQLITE_OK, SQLITE_TRANSIENT, completion_cursor::szRow, completion_cursor::zCurrentRow, completion_cursor::zLine, and completion_cursor::zPrefix.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3338  \{\par
 3339   completion_cursor *pCur = (completion_cursor*)cur;\par
 3340   switch( i )\{\par
 3341     case COMPLETION_COLUMN_CANDIDATE: \{\par
 3342       sqlite3_result_text(ctx, pCur->zCurrentRow, pCur->szRow,SQLITE_TRANSIENT);\par
 3343       break;\par
 3344     \}\par
 3345     case COMPLETION_COLUMN_PREFIX: \{\par
 3346       sqlite3_result_text(ctx, pCur->zPrefix, -1, SQLITE_TRANSIENT);\par
 3347       break;\par
 3348     \}\par
 3349     case COMPLETION_COLUMN_WHOLELINE: \{\par
 3350       sqlite3_result_text(ctx, pCur->zLine, -1, SQLITE_TRANSIENT);\par
 3351       break;\par
 3352     \}\par
 3353     case COMPLETION_COLUMN_PHASE: \{\par
 3354       sqlite3_result_int(ctx, pCur->ePhase);\par
 3355       break;\par
 3356     \}\par
 3357   \}\par
 3358   return SQLITE_OK;\par
 3359 \}\par
}
}
{\xe \v completionConnect\:shell.c}
{\xe \v shell.c\:completionConnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int completionConnect ({\b sqlite3} *  {\i db}, void *  {\i pAux}, int  {\i argc}, const char *const *  {\i argv}, {\b sqlite3_vtab} **  {\i ppVtab}, char **  {\i pzErr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3133 of file shell.c.}\par
{
References completion_vtab::db, sqlite3_declare_vtab, sqlite3_malloc, sqlite3_vtab_config, SQLITE_NOMEM, SQLITE_OK, and SQLITE_VTAB_INNOCUOUS.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3139  \{\par
 3140   completion_vtab *pNew;\par
 3141   int rc;\par
 3142 \par
 3143   (void)(pAux);    /* Unused parameter */\par
 3144   (void)(argc);    /* Unused parameter */\par
 3145   (void)(argv);    /* Unused parameter */\par
 3146   (void)(pzErr);   /* Unused parameter */\par
 3147 \par
 3148 /* Column numbers */\par
 3149 #define COMPLETION_COLUMN_CANDIDATE 0  /* Suggested completion of the input */\par
 3150 #define COMPLETION_COLUMN_PREFIX    1  /* Prefix of the word to be completed */\par
 3151 #define COMPLETION_COLUMN_WHOLELINE 2  /* Entire line seen so far */\par
 3152 #define COMPLETION_COLUMN_PHASE     3  /* ePhase - used for debugging only */\par
 3153 \par
 3154   sqlite3_vtab_config(db, SQLITE_VTAB_INNOCUOUS);\par
 3155   rc = sqlite3_declare_vtab(db,\par
 3156       "CREATE TABLE x("\par
 3157       "  candidate TEXT,"\par
 3158       "  prefix TEXT HIDDEN,"\par
 3159       "  wholeline TEXT HIDDEN,"\par
 3160       "  phase INT HIDDEN"        /* Used for debugging only */\par
 3161       ")");\par
 3162   if( rc==SQLITE_OK )\{\par
 3163     pNew = sqlite3_malloc( sizeof(*pNew) );\par
 3164     *ppVtab = (sqlite3_vtab*)pNew;\par
 3165     if( pNew==0 ) return SQLITE_NOMEM;\par
 3166     memset(pNew, 0, sizeof(*pNew));\par
 3167     pNew->db = db;\par
 3168   \}\par
 3169   return rc;\par
 3170 \}\par
}
}
{\xe \v completionCursorReset\:shell.c}
{\xe \v shell.c\:completionCursorReset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void completionCursorReset ({\b completion_cursor} *  {\i pCur}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3196 of file shell.c.}\par
{
References completion_cursor::j, completion_cursor::nLine, completion_cursor::nPrefix, completion_cursor::pStmt, sqlite3_finalize, sqlite3_free, completion_cursor::zLine, and completion_cursor::zPrefix.}\par
{
Referenced by completionClose(), and completionFilter().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3196                                                           \{\par
 3197   sqlite3_free(pCur->zPrefix);   pCur->zPrefix = 0;  pCur->nPrefix = 0;\par
 3198   sqlite3_free(pCur->zLine);     pCur->zLine = 0;    pCur->nLine = 0;\par
 3199   sqlite3_finalize(pCur->pStmt); pCur->pStmt = 0;\par
 3200   pCur->j = 0;\par
 3201 \}\par
}
}
{\xe \v completionDisconnect\:shell.c}
{\xe \v shell.c\:completionDisconnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int completionDisconnect ({\b sqlite3_vtab} *  {\i pVtab}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3175 of file shell.c.}\par
{
References sqlite3_free, and SQLITE_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3175                                                     \{\par
 3176   sqlite3_free(pVtab);\par
 3177   return SQLITE_OK;\par
 3178 \}\par
}
}
{\xe \v completionEof\:shell.c}
{\xe \v shell.c\:completionEof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int completionEof ({\b sqlite3_vtab_cursor} *  {\i cur}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3375 of file shell.c.}\par
{
References COMPLETION_EOF, and completion_cursor::ePhase.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3375                                                   \{\par
 3376   completion_cursor *pCur = (completion_cursor*)cur;\par
 3377   return pCur->ePhase >= COMPLETION_EOF;\par
 3378 \}\par
}
}
{\xe \v completionFilter\:shell.c}
{\xe \v shell.c\:completionFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int completionFilter ({\b sqlite3_vtab_cursor} *  {\i pVtabCursor}, int  {\i idxNum}, const char *  {\i idxStr}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3386 of file shell.c.}\par
{
References COMPLETION_FIRST_PHASE, completionCursorReset(), completionNext(), completion_cursor::ePhase, completion_cursor::iRowid, completion_cursor::nLine, completion_cursor::nPrefix, sqlite3_mprintf, sqlite3_value_bytes, sqlite3_value_text, SQLITE_NOMEM, completion_cursor::zLine, and completion_cursor::zPrefix.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3390  \{\par
 3391   completion_cursor *pCur = (completion_cursor *)pVtabCursor;\par
 3392   int iArg = 0;\par
 3393   (void)(idxStr);   /* Unused parameter */\par
 3394   (void)(argc);     /* Unused parameter */\par
 3395   completionCursorReset(pCur);\par
 3396   if( idxNum & 1 )\{\par
 3397     pCur->nPrefix = sqlite3_value_bytes(argv[iArg]);\par
 3398     if( pCur->nPrefix>0 )\{\par
 3399       pCur->zPrefix = sqlite3_mprintf("%s", sqlite3_value_text(argv[iArg]));\par
 3400       if( pCur->zPrefix==0 ) return SQLITE_NOMEM;\par
 3401     \}\par
 3402     iArg = 1;\par
 3403   \}\par
 3404   if( idxNum & 2 )\{\par
 3405     pCur->nLine = sqlite3_value_bytes(argv[iArg]);\par
 3406     if( pCur->nLine>0 )\{\par
 3407       pCur->zLine = sqlite3_mprintf("%s", sqlite3_value_text(argv[iArg]));\par
 3408       if( pCur->zLine==0 ) return SQLITE_NOMEM;\par
 3409     \}\par
 3410   \}\par
 3411   if( pCur->zLine!=0 && pCur->zPrefix==0 )\{\par
 3412     int i = pCur->nLine;\par
 3413     while( i>0 && (isalnum(pCur->zLine[i-1]) || pCur->zLine[i-1]=='_') )\{\par
 3414       i--;\par
 3415     \}\par
 3416     pCur->nPrefix = pCur->nLine - i;\par
 3417     if( pCur->nPrefix>0 )\{\par
 3418       pCur->zPrefix = sqlite3_mprintf("%.*s", pCur->nPrefix, pCur->zLine + i);\par
 3419       if( pCur->zPrefix==0 ) return SQLITE_NOMEM;\par
 3420     \}\par
 3421   \}\par
 3422   pCur->iRowid = 0;\par
 3423   pCur->ePhase = COMPLETION_FIRST_PHASE;\par
 3424   return completionNext(pVtabCursor);\par
 3425 \}\par
}
}
{\xe \v completionNext\:shell.c}
{\xe \v shell.c\:completionNext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int completionNext ({\b sqlite3_vtab_cursor} *  {\i cur}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3226 of file shell.c.}\par
{
References COMPLETION_COLUMNS, COMPLETION_DATABASES, COMPLETION_EOF, COMPLETION_KEYWORDS, COMPLETION_TABLES, completion_cursor::db, completion_cursor::ePhase, completion_cursor::iRowid, completion_cursor::j, completion_cursor::nPrefix, completion_cursor::pStmt, sqlite3_column_bytes, sqlite3_column_text, sqlite3_finalize, sqlite3_free, sqlite3_keyword_count, sqlite3_keyword_name, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_step, sqlite3_strnicmp, SQLITE_NOMEM, SQLITE_OK, SQLITE_ROW, completion_cursor::szRow, completion_cursor::zCurrentRow, and completion_cursor::zPrefix.}\par
{
Referenced by completionFilter().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3226                                                    \{\par
 3227   completion_cursor *pCur = (completion_cursor*)cur;\par
 3228   int eNextPhase = 0;  /* Next phase to try if current phase reaches end */\par
 3229   int iCol = -1;       /* If >=0, step pCur->pStmt and use the i-th column */\par
 3230   pCur->iRowid++;\par
 3231   while( pCur->ePhase!=COMPLETION_EOF )\{\par
 3232     switch( pCur->ePhase )\{\par
 3233       case COMPLETION_KEYWORDS: \{\par
 3234         if( pCur->j >= sqlite3_keyword_count() )\{\par
 3235           pCur->zCurrentRow = 0;\par
 3236           pCur->ePhase = COMPLETION_DATABASES;\par
 3237         \}else\{\par
 3238           sqlite3_keyword_name(pCur->j++, &pCur->zCurrentRow, &pCur->szRow);\par
 3239         \}\par
 3240         iCol = -1;\par
 3241         break;\par
 3242       \}\par
 3243       case COMPLETION_DATABASES: \{\par
 3244         if( pCur->pStmt==0 )\{\par
 3245           sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1,\par
 3246                              &pCur->pStmt, 0);\par
 3247         \}\par
 3248         iCol = 1;\par
 3249         eNextPhase = COMPLETION_TABLES;\par
 3250         break;\par
 3251       \}\par
 3252       case COMPLETION_TABLES: \{\par
 3253         if( pCur->pStmt==0 )\{\par
 3254           sqlite3_stmt *pS2;\par
 3255           char *zSql = 0;\par
 3256           const char *zSep = "";\par
 3257           sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1, &pS2, 0);\par
 3258           while( sqlite3_step(pS2)==SQLITE_ROW )\{\par
 3259             const char *zDb = (const char*)sqlite3_column_text(pS2, 1);\par
 3260             zSql = sqlite3_mprintf(\par
 3261                "%z%s"\par
 3262                "SELECT name FROM \\"%w\\".sqlite_master",\par
 3263                zSql, zSep, zDb\par
 3264             );\par
 3265             if( zSql==0 ) return SQLITE_NOMEM;\par
 3266             zSep = " UNION ";\par
 3267           \}\par
 3268           sqlite3_finalize(pS2);\par
 3269           sqlite3_prepare_v2(pCur->db, zSql, -1, &pCur->pStmt, 0);\par
 3270           sqlite3_free(zSql);\par
 3271         \}\par
 3272         iCol = 0;\par
 3273         eNextPhase = COMPLETION_COLUMNS;\par
 3274         break;\par
 3275       \}\par
 3276       case COMPLETION_COLUMNS: \{\par
 3277         if( pCur->pStmt==0 )\{\par
 3278           sqlite3_stmt *pS2;\par
 3279           char *zSql = 0;\par
 3280           const char *zSep = "";\par
 3281           sqlite3_prepare_v2(pCur->db, "PRAGMA database_list", -1, &pS2, 0);\par
 3282           while( sqlite3_step(pS2)==SQLITE_ROW )\{\par
 3283             const char *zDb = (const char*)sqlite3_column_text(pS2, 1);\par
 3284             zSql = sqlite3_mprintf(\par
 3285                "%z%s"\par
 3286                "SELECT pti.name FROM \\"%w\\".sqlite_master AS sm"\par
 3287                        " JOIN pragma_table_info(sm.name,%Q) AS pti"\par
 3288                " WHERE sm.type='table'",\par
 3289                zSql, zSep, zDb, zDb\par
 3290             );\par
 3291             if( zSql==0 ) return SQLITE_NOMEM;\par
 3292             zSep = " UNION ";\par
 3293           \}\par
 3294           sqlite3_finalize(pS2);\par
 3295           sqlite3_prepare_v2(pCur->db, zSql, -1, &pCur->pStmt, 0);\par
 3296           sqlite3_free(zSql);\par
 3297         \}\par
 3298         iCol = 0;\par
 3299         eNextPhase = COMPLETION_EOF;\par
 3300         break;\par
 3301       \}\par
 3302     \}\par
 3303     if( iCol<0 )\{\par
 3304       /* This case is when the phase presets zCurrentRow */\par
 3305       if( pCur->zCurrentRow==0 ) continue;\par
 3306     \}else\{\par
 3307       if( sqlite3_step(pCur->pStmt)==SQLITE_ROW )\{\par
 3308         /* Extract the next row of content */\par
 3309         pCur->zCurrentRow = (const char*)sqlite3_column_text(pCur->pStmt, iCol);\par
 3310         pCur->szRow = sqlite3_column_bytes(pCur->pStmt, iCol);\par
 3311       \}else\{\par
 3312         /* When all rows are finished, advance to the next phase */\par
 3313         sqlite3_finalize(pCur->pStmt);\par
 3314         pCur->pStmt = 0;\par
 3315         pCur->ePhase = eNextPhase;\par
 3316         continue;\par
 3317       \}\par
 3318     \}\par
 3319     if( pCur->nPrefix==0 ) break;\par
 3320     if( pCur->nPrefix<=pCur->szRow\par
 3321      && sqlite3_strnicmp(pCur->zPrefix, pCur->zCurrentRow, pCur->nPrefix)==0\par
 3322     )\{\par
 3323       break;\par
 3324     \}\par
 3325   \}\par
 3326 \par
 3327   return SQLITE_OK;\par
 3328 \}\par
}
}
{\xe \v completionOpen\:shell.c}
{\xe \v shell.c\:completionOpen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int completionOpen ({\b sqlite3_vtab} *  {\i p}, {\b sqlite3_vtab_cursor} **  {\i ppCursor}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3183 of file shell.c.}\par
{
References completion_cursor::base, completion_cursor::db, sqlite3_malloc, SQLITE_NOMEM, and SQLITE_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3183                                                                           \{\par
 3184   completion_cursor *pCur;\par
 3185   pCur = sqlite3_malloc( sizeof(*pCur) );\par
 3186   if( pCur==0 ) return SQLITE_NOMEM;\par
 3187   memset(pCur, 0, sizeof(*pCur));\par
 3188   pCur->db = ((completion_vtab*)p)->db;\par
 3189   *ppCursor = &pCur->base;\par
 3190   return SQLITE_OK;\par
 3191 \}\par
}
}
{\xe \v completionRowid\:shell.c}
{\xe \v shell.c\:completionRowid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int completionRowid ({\b sqlite3_vtab_cursor} *  {\i cur}, {\b sqlite_int64} *  {\i pRowid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3365 of file shell.c.}\par
{
References completion_cursor::iRowid, and SQLITE_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3365                                                                           \{\par
 3366   completion_cursor *pCur = (completion_cursor*)cur;\par
 3367   *pRowid = pCur->iRowid;\par
 3368   return SQLITE_OK;\par
 3369 \}\par
}
}
{\xe \v createSelftestTable\:shell.c}
{\xe \v shell.c\:createSelftestTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void createSelftestTable ({\b ShellState} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10785 of file shell.c.}\par
{
References ShellState::db, sqlite3_exec, sqlite3_free, and utf8_printf.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10785                                               \{\par
10786   char *zErrMsg = 0;\par
10787   sqlite3_exec(p->db,\par
10788     "SAVEPOINT selftest_init;\\n"\par
10789     "CREATE TABLE IF NOT EXISTS selftest(\\n"\par
10790     "  tno INTEGER PRIMARY KEY,\\n"   /* Test number */\par
10791     "  op TEXT,\\n"                   /* Operator:  memo run */\par
10792     "  cmd TEXT,\\n"                  /* Command text */\par
10793     "  ans TEXT\\n"                   /* Desired answer */\par
10794     ");"\par
10795     "CREATE TEMP TABLE [_shell$self](op,cmd,ans);\\n"\par
10796     "INSERT INTO [_shell$self](rowid,op,cmd)\\n"\par
10797     "  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\\n"\par
10798     "         'memo','Tests generated by --init');\\n"\par
10799     "INSERT INTO [_shell$self]\\n"\par
10800     "  SELECT 'run',\\n"\par
10801     "    'SELECT hex(sha3_query(''SELECT type,name,tbl_name,sql "\par
10802                                  "FROM sqlite_master ORDER BY 2'',224))',\\n"\par
10803     "    hex(sha3_query('SELECT type,name,tbl_name,sql "\par
10804                           "FROM sqlite_master ORDER BY 2',224));\\n"\par
10805     "INSERT INTO [_shell$self]\\n"\par
10806     "  SELECT 'run',"\par
10807     "    'SELECT hex(sha3_query(''SELECT * FROM \\"' ||"\par
10808     "        printf('%w',name) || '\\" NOT INDEXED'',224))',\\n"\par
10809     "    hex(sha3_query(printf('SELECT * FROM \\"%w\\" NOT INDEXED',name),224))\\n"\par
10810     "  FROM (\\n"\par
10811     "    SELECT name FROM sqlite_master\\n"\par
10812     "     WHERE type='table'\\n"\par
10813     "       AND name<>'selftest'\\n"\par
10814     "       AND coalesce(rootpage,0)>0\\n"\par
10815     "  )\\n"\par
10816     " ORDER BY name;\\n"\par
10817     "INSERT INTO [_shell$self]\\n"\par
10818     "  VALUES('run','PRAGMA integrity_check','ok');\\n"\par
10819     "INSERT INTO selftest(tno,op,cmd,ans)"\par
10820     "  SELECT rowid*10,op,cmd,ans FROM [_shell$self];\\n"\par
10821     "DROP TABLE [_shell$self];"\par
10822     ,0,0,&zErrMsg);\par
10823   if( zErrMsg )\{\par
10824     utf8_printf(stderr, "SELFTEST initialization failure: %s\\n", zErrMsg);\par
10825     sqlite3_free(zErrMsg);\par
10826   \}\par
10827   sqlite3_exec(p->db, "RELEASE selftest_init",0,0,0);\par
10828 \}\par
}
}
{\xe \v csv_read_one_field\:shell.c}
{\xe \v shell.c\:csv_read_one_field}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* {\b SQLITE_CDECL} csv_read_one_field ({\b ImportCtx} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13105 of file shell.c.}\par
{
References ImportCtx::bNotFirst, ImportCtx::cColSep, ImportCtx::cRowSep, ImportCtx::cTerm, import_append_char(), ImportCtx::in, ImportCtx::n, ImportCtx::nLine, utf8_printf, ImportCtx::z, and ImportCtx::zFile.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13105                                                           \{\par
13106   int c;\par
13107   int cSep = p->cColSep;\par
13108   int rSep = p->cRowSep;\par
13109   p->n = 0;\par
13110   c = fgetc(p->in);\par
13111   if( c==EOF || seenInterrupt )\{\par
13112     p->cTerm = EOF;\par
13113     return 0;\par
13114   \}\par
13115   if( c=='"' )\{\par
13116     int pc, ppc;\par
13117     int startLine = p->nLine;\par
13118     int cQuote = c;\par
13119     pc = ppc = 0;\par
13120     while( 1 )\{\par
13121       c = fgetc(p->in);\par
13122       if( c==rSep ) p->nLine++;\par
13123       if( c==cQuote )\{\par
13124         if( pc==cQuote )\{\par
13125           pc = 0;\par
13126           continue;\par
13127         \}\par
13128       \}\par
13129       if( (c==cSep && pc==cQuote)\par
13130        || (c==rSep && pc==cQuote)\par
13131        || (c==rSep && pc=='\\r' && ppc==cQuote)\par
13132        || (c==EOF && pc==cQuote)\par
13133       )\{\par
13134         do\{ p->n--; \}while( p->z[p->n]!=cQuote );\par
13135         p->cTerm = c;\par
13136         break;\par
13137       \}\par
13138       if( pc==cQuote && c!='\\r' )\{\par
13139         utf8_printf(stderr, "%s:%d: unescaped %c character\\n",\par
13140                 p->zFile, p->nLine, cQuote);\par
13141       \}\par
13142       if( c==EOF )\{\par
13143         utf8_printf(stderr, "%s:%d: unterminated %c-quoted field\\n",\par
13144                 p->zFile, startLine, cQuote);\par
13145         p->cTerm = c;\par
13146         break;\par
13147       \}\par
13148       import_append_char(p, c);\par
13149       ppc = pc;\par
13150       pc = c;\par
13151     \}\par
13152   \}else\{\par
13153     /* If this is the first field being parsed and it begins with the\par
13154     ** UTF-8 BOM  (0xEF BB BF) then skip the BOM */\par
13155     if( (c&0xff)==0xef && p->bNotFirst==0 )\{\par
13156       import_append_char(p, c);\par
13157       c = fgetc(p->in);\par
13158       if( (c&0xff)==0xbb )\{\par
13159         import_append_char(p, c);\par
13160         c = fgetc(p->in);\par
13161         if( (c&0xff)==0xbf )\{\par
13162           p->bNotFirst = 1;\par
13163           p->n = 0;\par
13164           return csv_read_one_field(p);\par
13165         \}\par
13166       \}\par
13167     \}\par
13168     while( c!=EOF && c!=cSep && c!=rSep )\{\par
13169       import_append_char(p, c);\par
13170       c = fgetc(p->in);\par
13171     \}\par
13172     if( c==rSep )\{\par
13173       p->nLine++;\par
13174       if( p->n>0 && p->z[p->n-1]=='\\r' ) p->n--;\par
13175     \}\par
13176     p->cTerm = c;\par
13177   \}\par
13178   if( p->z ) p->z[p->n] = 0;\par
13179   p->bNotFirst = 1;\par
13180   return p->z;\par
13181 \}\par
}
}
{\xe \v ctxErrorMsg\:shell.c}
{\xe \v shell.c\:ctxErrorMsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void ctxErrorMsg ({\b sqlite3_context} *  {\i ctx}, const char *  {\i zFmt},   {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2223 of file shell.c.}\par
{
References sqlite3_free, sqlite3_result_error, and sqlite3_vmprintf.}\par
{
Referenced by writefileFunc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2223                                                                     \{\par
 2224   char *zMsg = 0;\par
 2225   va_list ap;\par
 2226   va_start(ap, zFmt);\par
 2227   zMsg = sqlite3_vmprintf(zFmt, ap);\par
 2228   sqlite3_result_error(ctx, zMsg, -1);\par
 2229   sqlite3_free(zMsg);\par
 2230   va_end(ap);\par
 2231 \}\par
}
}
{\xe \v db_int\:shell.c}
{\xe \v shell.c\:db_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int db_int ({\b ShellState} *  {\i p}, const char *  {\i zSql}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13472 of file shell.c.}\par
{
References ShellState::db, sqlite3_column_int, sqlite3_finalize, sqlite3_prepare_v2, sqlite3_step, and SQLITE_ROW.}\par
{
Referenced by shell_dbinfo_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13472                                                   \{\par
13473   sqlite3_stmt *pStmt;\par
13474   int res = 0;\par
13475   sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\par
13476   if( pStmt && sqlite3_step(pStmt)==SQLITE_ROW )\{\par
13477     res = sqlite3_column_int(pStmt,0);\par
13478   \}\par
13479   sqlite3_finalize(pStmt);\par
13480   return res;\par
13481 \}\par
}
}
{\xe \v deduceDatabaseType\:shell.c}
{\xe \v shell.c\:deduceDatabaseType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int deduceDatabaseType (const char *  {\i zName}, int  {\i dfltZip})}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12406 of file shell.c.}\par
{
References ShellState::in, ShellState::lineno, SHELL_OPEN_APPENDVFS, SHELL_OPEN_NORMAL, SHELL_OPEN_UNSPEC, SHELL_OPEN_ZIPFILE, sqlite3_free, sqlite3_malloc, sqlite3_strlike, utf8_printf, time_test::x, and ShellState::zDbFilename.}\par
{
Referenced by open_db(), and shellReset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12406                                                       \{\par
12407   FILE *f = fopen(zName, "rb");\par
12408   size_t n;\par
12409   int rc = SHELL_OPEN_UNSPEC;\par
12410   char zBuf[100];\par
12411   if( f==0 )\{\par
12412     if( dfltZip && sqlite3_strlike("%.zip",zName,0)==0 )\{\par
12413        return SHELL_OPEN_ZIPFILE;\par
12414     \}else\{\par
12415        return SHELL_OPEN_NORMAL;\par
12416     \}\par
12417   \}\par
12418   n = fread(zBuf, 16, 1, f);\par
12419   if( n==1 && memcmp(zBuf, "SQLite format 3", 16)==0 )\{\par
12420     fclose(f);\par
12421     return SHELL_OPEN_NORMAL;\par
12422   \}\par
12423   fseek(f, -25, SEEK_END);\par
12424   n = fread(zBuf, 25, 1, f);\par
12425   if( n==1 && memcmp(zBuf, "Start-Of-SQLite3-", 17)==0 )\{\par
12426     rc = SHELL_OPEN_APPENDVFS;\par
12427   \}else\{\par
12428     fseek(f, -22, SEEK_END);\par
12429     n = fread(zBuf, 22, 1, f);\par
12430     if( n==1 && zBuf[0]==0x50 && zBuf[1]==0x4b && zBuf[2]==0x05\par
12431        && zBuf[3]==0x06 )\{\par
12432       rc = SHELL_OPEN_ZIPFILE;\par
12433     \}else if( n==0 && dfltZip && sqlite3_strlike("%.zip",zName,0)==0 )\{\par
12434       rc = SHELL_OPEN_ZIPFILE;\par
12435     \}\par
12436   \}\par
12437   fclose(f);\par
12438   return rc;  \par
12439 \}\par
}
}
{\xe \v disable_debug_trace_modes\:shell.c}
{\xe \v shell.c\:disable_debug_trace_modes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void disable_debug_trace_modes (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11307 of file shell.c.}\par
{
Referenced by shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11307                                            \{\par
11308 #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_SELECTTRACE)\par
11309   savedSelectTrace = sqlite3SelectTrace;\par
11310   sqlite3SelectTrace = 0;\par
11311 #endif\par
11312 #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)\par
11313   savedWhereTrace = sqlite3WhereTrace;\par
11314   sqlite3WhereTrace = 0;\par
11315 #endif\par
11316 \}\par
}
}
{\xe \v display_scanstats\:shell.c}
{\xe \v shell.c\:display_scanstats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void display_scanstats ({\b sqlite3} *  {\i db}, {\b ShellState} *  {\i pArg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11129 of file shell.c.}\par
{
References ShellState::out, ShellState::pStmt, raw_printf, sqlite3_stmt_scanstatus(), SQLITE_SCANSTAT_EST, SQLITE_SCANSTAT_EXPLAIN, SQLITE_SCANSTAT_NLOOP, SQLITE_SCANSTAT_NVISIT, SQLITE_SCANSTAT_SELECTID, UNUSED_PARAMETER, and utf8_printf.}\par
{
Referenced by shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11132  \{\par
11133 #ifndef SQLITE_ENABLE_STMT_SCANSTATUS\par
11134   UNUSED_PARAMETER(db);\par
11135   UNUSED_PARAMETER(pArg);\par
11136 #else\par
11137   int i, k, n, mx;\par
11138   raw_printf(pArg->out, "-------- scanstats --------\\n");\par
11139   mx = 0;\par
11140   for(k=0; k<=mx; k++)\{\par
11141     double rEstLoop = 1.0;\par
11142     for(i=n=0; 1; i++)\{\par
11143       sqlite3_stmt *p = pArg->pStmt;\par
11144       sqlite3_int64 nLoop, nVisit;\par
11145       double rEst;\par
11146       int iSid;\par
11147       const char *zExplain;\par
11148       if( sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_NLOOP, (void*)&nLoop) )\{\par
11149         break;\par
11150       \}\par
11151       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_SELECTID, (void*)&iSid);\par
11152       if( iSid>mx ) mx = iSid;\par
11153       if( iSid!=k ) continue;\par
11154       if( n==0 )\{\par
11155         rEstLoop = (double)nLoop;\par
11156         if( k>0 ) raw_printf(pArg->out, "-------- subquery %d -------\\n", k);\par
11157       \}\par
11158       n++;\par
11159       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_NVISIT, (void*)&nVisit);\par
11160       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_EST, (void*)&rEst);\par
11161       sqlite3_stmt_scanstatus(p, i, SQLITE_SCANSTAT_EXPLAIN, (void*)&zExplain);\par
11162       utf8_printf(pArg->out, "Loop %2d: %s\\n", n, zExplain);\par
11163       rEstLoop *= rEst;\par
11164       raw_printf(pArg->out,\par
11165           "         nLoop=%-8lld nRow=%-8lld estRow=%-8lld estRow/Loop=%-8g\\n",\par
11166           nLoop, nVisit, (sqlite3_int64)(rEstLoop+0.5), rEst\par
11167       );\par
11168     \}\par
11169   \}\par
11170   raw_printf(pArg->out, "---------------------------\\n");\par
11171 #endif\par
11172 \}\par
}
}
{\xe \v display_stats\:shell.c}
{\xe \v shell.c\:display_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int display_stats ({\b sqlite3} *  {\i db}, {\b ShellState} *  {\i pArg}, int  {\i bReset}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10998 of file shell.c.}\par
{
References displayStatLine(), ShellState::out, ShellState::pStmt, raw_printf, ShellState::shellFlgs, SHFLG_Lookaside, SHFLG_Pagecache, sqlite3_column_count, sqlite3_column_database_name, sqlite3_column_decltype, sqlite3_column_name, sqlite3_column_origin_name, sqlite3_column_table_name, sqlite3_db_status, sqlite3_snprintf, sqlite3_stmt_status, SQLITE_DBSTATUS_CACHE_HIT, SQLITE_DBSTATUS_CACHE_MISS, SQLITE_DBSTATUS_CACHE_SPILL, SQLITE_DBSTATUS_CACHE_USED, SQLITE_DBSTATUS_CACHE_WRITE, SQLITE_DBSTATUS_LOOKASIDE_HIT, SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL, SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE, SQLITE_DBSTATUS_LOOKASIDE_USED, SQLITE_DBSTATUS_SCHEMA_USED, SQLITE_DBSTATUS_STMT_USED, SQLITE_STATUS_MALLOC_COUNT, SQLITE_STATUS_MALLOC_SIZE, SQLITE_STATUS_MEMORY_USED, SQLITE_STATUS_PAGECACHE_OVERFLOW, SQLITE_STATUS_PAGECACHE_SIZE, SQLITE_STATUS_PAGECACHE_USED, SQLITE_STATUS_PARSER_STACK, SQLITE_STMTSTATUS_AUTOINDEX, SQLITE_STMTSTATUS_FULLSCAN_STEP, SQLITE_STMTSTATUS_MEMUSED, SQLITE_STMTSTATUS_REPREPARE, SQLITE_STMTSTATUS_RUN, SQLITE_STMTSTATUS_SORT, SQLITE_STMTSTATUS_VM_STEP, ShellState::statsOn, utf8_printf, and time_test::x.}\par
{
Referenced by do_meta_command(), and shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11002  \{\par
11003   int iCur;\par
11004   int iHiwtr;\par
11005   FILE *out;\par
11006   if( pArg==0 || pArg->out==0 ) return 0;\par
11007   out = pArg->out;\par
11008 \par
11009   if( pArg->pStmt && (pArg->statsOn & 2) )\{\par
11010     int nCol, i, x;\par
11011     sqlite3_stmt *pStmt = pArg->pStmt;\par
11012     char z[100];\par
11013     nCol = sqlite3_column_count(pStmt);\par
11014     raw_printf(out, "%-36s %d\\n", "Number of output columns:", nCol);\par
11015     for(i=0; i<nCol; i++)\{\par
11016       sqlite3_snprintf(sizeof(z),z,"Column %d %nname:", i, &x);\par
11017       utf8_printf(out, "%-36s %s\\n", z, sqlite3_column_name(pStmt,i));\par
11018 #ifndef SQLITE_OMIT_DECLTYPE\par
11019       sqlite3_snprintf(30, z+x, "declared type:");\par
11020       utf8_printf(out, "%-36s %s\\n", z, sqlite3_column_decltype(pStmt, i));\par
11021 #endif\par
11022 #ifdef SQLITE_ENABLE_COLUMN_METADATA\par
11023       sqlite3_snprintf(30, z+x, "database name:");\par
11024       utf8_printf(out, "%-36s %s\\n", z, sqlite3_column_database_name(pStmt,i));\par
11025       sqlite3_snprintf(30, z+x, "table name:");\par
11026       utf8_printf(out, "%-36s %s\\n", z, sqlite3_column_table_name(pStmt,i));\par
11027       sqlite3_snprintf(30, z+x, "origin name:");\par
11028       utf8_printf(out, "%-36s %s\\n", z, sqlite3_column_origin_name(pStmt,i));\par
11029 #endif\par
11030     \}\par
11031   \}\par
11032 \par
11033   displayStatLine(pArg, "Memory Used:",\par
11034      "%lld (max %lld) bytes", SQLITE_STATUS_MEMORY_USED, bReset);\par
11035   displayStatLine(pArg, "Number of Outstanding Allocations:",\par
11036      "%lld (max %lld)", SQLITE_STATUS_MALLOC_COUNT, bReset);\par
11037   if( pArg->shellFlgs & SHFLG_Pagecache )\{\par
11038     displayStatLine(pArg, "Number of Pcache Pages Used:",\par
11039        "%lld (max %lld) pages", SQLITE_STATUS_PAGECACHE_USED, bReset);\par
11040   \}\par
11041   displayStatLine(pArg, "Number of Pcache Overflow Bytes:",\par
11042      "%lld (max %lld) bytes", SQLITE_STATUS_PAGECACHE_OVERFLOW, bReset);\par
11043   displayStatLine(pArg, "Largest Allocation:",\par
11044      "%lld bytes", SQLITE_STATUS_MALLOC_SIZE, bReset);\par
11045   displayStatLine(pArg, "Largest Pcache Allocation:",\par
11046      "%lld bytes", SQLITE_STATUS_PAGECACHE_SIZE, bReset);\par
11047 #ifdef YYTRACKMAXSTACKDEPTH\par
11048   displayStatLine(pArg, "Deepest Parser Stack:",\par
11049      "%lld (max %lld)", SQLITE_STATUS_PARSER_STACK, bReset);\par
11050 #endif\par
11051 \par
11052   if( db )\{\par
11053     if( pArg->shellFlgs & SHFLG_Lookaside )\{\par
11054       iHiwtr = iCur = -1;\par
11055       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_USED,\par
11056                         &iCur, &iHiwtr, bReset);\par
11057       raw_printf(pArg->out,\par
11058               "Lookaside Slots Used:                %d (max %d)\\n",\par
11059               iCur, iHiwtr);\par
11060       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_HIT,\par
11061                         &iCur, &iHiwtr, bReset);\par
11062       raw_printf(pArg->out, "Successful lookaside attempts:       %d\\n",\par
11063               iHiwtr);\par
11064       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE,\par
11065                         &iCur, &iHiwtr, bReset);\par
11066       raw_printf(pArg->out, "Lookaside failures due to size:      %d\\n",\par
11067               iHiwtr);\par
11068       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL,\par
11069                         &iCur, &iHiwtr, bReset);\par
11070       raw_printf(pArg->out, "Lookaside failures due to OOM:       %d\\n",\par
11071               iHiwtr);\par
11072     \}\par
11073     iHiwtr = iCur = -1;\par
11074     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_USED, &iCur, &iHiwtr, bReset);\par
11075     raw_printf(pArg->out, "Pager Heap Usage:                    %d bytes\\n",\par
11076             iCur);\par
11077     iHiwtr = iCur = -1;\par
11078     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_HIT, &iCur, &iHiwtr, 1);\par
11079     raw_printf(pArg->out, "Page cache hits:                     %d\\n", iCur);\par
11080     iHiwtr = iCur = -1;\par
11081     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_MISS, &iCur, &iHiwtr, 1);\par
11082     raw_printf(pArg->out, "Page cache misses:                   %d\\n", iCur);\par
11083     iHiwtr = iCur = -1;\par
11084     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_WRITE, &iCur, &iHiwtr, 1);\par
11085     raw_printf(pArg->out, "Page cache writes:                   %d\\n", iCur);\par
11086     iHiwtr = iCur = -1;\par
11087     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_SPILL, &iCur, &iHiwtr, 1);\par
11088     raw_printf(pArg->out, "Page cache spills:                   %d\\n", iCur);\par
11089     iHiwtr = iCur = -1;\par
11090     sqlite3_db_status(db, SQLITE_DBSTATUS_SCHEMA_USED, &iCur, &iHiwtr, bReset);\par
11091     raw_printf(pArg->out, "Schema Heap Usage:                   %d bytes\\n",\par
11092             iCur);\par
11093     iHiwtr = iCur = -1;\par
11094     sqlite3_db_status(db, SQLITE_DBSTATUS_STMT_USED, &iCur, &iHiwtr, bReset);\par
11095     raw_printf(pArg->out, "Statement Heap/Lookaside Usage:      %d bytes\\n",\par
11096             iCur);\par
11097   \}\par
11098 \par
11099   if( pArg->pStmt )\{\par
11100     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_FULLSCAN_STEP,\par
11101                                bReset);\par
11102     raw_printf(pArg->out, "Fullscan Steps:                      %d\\n", iCur);\par
11103     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_SORT, bReset);\par
11104     raw_printf(pArg->out, "Sort Operations:                     %d\\n", iCur);\par
11105     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_AUTOINDEX,bReset);\par
11106     raw_printf(pArg->out, "Autoindex Inserts:                   %d\\n", iCur);\par
11107     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_VM_STEP, bReset);\par
11108     raw_printf(pArg->out, "Virtual Machine Steps:               %d\\n", iCur);\par
11109     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_REPREPARE,bReset);\par
11110     raw_printf(pArg->out, "Reprepare operations:                %d\\n", iCur);\par
11111     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_RUN, bReset);\par
11112     raw_printf(pArg->out, "Number of times run:                 %d\\n", iCur);\par
11113     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_MEMUSED, bReset);\par
11114     raw_printf(pArg->out, "Memory used by prepared stmt:        %d\\n", iCur);\par
11115   \}\par
11116 \par
11117 #ifdef __linux__\par
11118   displayLinuxIoStats(pArg->out);\par
11119 #endif\par
11120 \par
11121   /* Do not remove this machine readable comment: extra-stats-output-here */\par
11122 \par
11123   return 0;\par
11124 \}\par
}
}
{\xe \v displayStatLine\:shell.c}
{\xe \v shell.c\:displayStatLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void displayStatLine ({\b ShellState} *  {\i p}, char *  {\i zLabel}, char *  {\i zFormat}, int  {\i iStatusCtrl}, int  {\i bReset}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10972 of file shell.c.}\par
{
References ShellState::out, raw_printf, sqlite3_snprintf, and sqlite3_status64.}\par
{
Referenced by display_stats().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10978  \{\par
10979   sqlite3_int64 iCur = -1;\par
10980   sqlite3_int64 iHiwtr = -1;\par
10981   int i, nPercent;\par
10982   char zLine[200];\par
10983   sqlite3_status64(iStatusCtrl, &iCur, &iHiwtr, bReset);\par
10984   for(i=0, nPercent=0; zFormat[i]; i++)\{\par
10985     if( zFormat[i]=='%' ) nPercent++;\par
10986   \}\par
10987   if( nPercent>1 )\{\par
10988     sqlite3_snprintf(sizeof(zLine), zLine, zFormat, iCur, iHiwtr);\par
10989   \}else\{\par
10990     sqlite3_snprintf(sizeof(zLine), zLine, zFormat, iHiwtr);\par
10991   \}\par
10992   raw_printf(p->out, "%-36s %s\\n", zLabel, zLine);\par
10993 \}\par
}
}
{\xe \v do_meta_command\:shell.c}
{\xe \v shell.c\:do_meta_command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int do_meta_command (char *  {\i zLine}, {\b ShellState} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15481 of file shell.c.}\par
{
References appendText(), ArraySize, ascii_read_one_field(), ShellState::autoEQP, AUTOEQP_full, AUTOEQP_on, AUTOEQP_trigger, ShellState::autoEQPtest, ShellState::autoEQPtrace, ShellState::autoExplain, bind_table_init(), booleanValue(), callback(), captureOutputCallback(), ImportCtx::cColSep, clearTempFile(), close_db(), ShellState::cMode, ShellState::cnt, ShellState::colSeparator, ShellState::colWidth, createSelftestTable(), ImportCtx::cRowSep, csv_read_one_field(), ImportCtx::cTerm, CTIMEOPT_VAL, main3::data, ShellState::db, display_stats(), ShellState::doXdgOpen, ShellState::eTraceType, ShellState::expert, expertDotCommand(), expertFinish(), ShellState::flgProgress, freeText(), HAS_TIMER, import_append_char(), ShellState::in, ImportCtx::in, initText(), integerValue(), IsSpace, sqlite3_vfs::iVersion, ShellState::lineno, lintDotCommand(), ShellState::mode, MODE_Ascii, MODE_Column, MODE_Csv, MODE_Explain, MODE_Html, MODE_Insert, MODE_Line, MODE_List, MODE_Pretty, MODE_Quote, MODE_Semi, MODE_Tcl, sqlite3_vfs::mxPathname, ShellState::mxProgress, ShellText::n, ShellState::nCheck, ShellState::nErr, newTempFile(), ImportCtx::nLine, ShellState::normalMode, ShellState::nProgress, ShellState::nullValue, open_db(), OPEN_DB_KEEPALIVE, ShellState::openFlags, ShellState::openMode, optionMatch(), ShellState::out, ShellState::outCount, ShellState::outfile, output_c_string(), output_file_close(), output_file_open(), output_reset(), outputModePush(), pclose(), ExpertInfo::pExpert, ShellState::pLog, sqlite3_vfs::pNext, popen(), process_input(), progress_handler(), quoteChar(), raw_printf, readFile(), resolve_backslashes(), ShellState::rowSeparator, run_schema_dump_query(), run_table_dump_query(), ShellState::scanstatsOn, SEP_Column, SEP_Comma, SEP_CrLf, SEP_Record, SEP_Row, SEP_Space, SEP_Tab, SEP_Unit, session_close_all, set_table_name(), setBinaryMode, setOrClearFlag(), setTextMode, shell_dbinfo_command(), shell_exec(), SHELL_OPEN_APPENDVFS, SHELL_OPEN_DESERIALIZE, SHELL_OPEN_HEXDB, SHELL_OPEN_READONLY, SHELL_OPEN_UNSPEC, SHELL_OPEN_ZIPFILE, shell_out_of_memory(), SHELL_PROGRESS_ONCE, SHELL_PROGRESS_QUIET, SHELL_PROGRESS_RESET, SHELL_TRACE_EXPANDED, SHELL_TRACE_NORMALIZED, SHELL_TRACE_PLAIN, shellAuth(), ShellClearFlag, shellDatabaseError(), shellDeleteFile(), ShellState::shellFlgs, ShellHasFlag, ShellSetFlag, SHFLG_CountChanges, SHFLG_Echo, SHFLG_Newlines, SHFLG_PreserveRowid, ShellState::showHeader, showHelp(), sql_trace_callback(), sqlite3_backup_finish, sqlite3_backup_init, sqlite3_backup_step, sqlite3_bind_null, sqlite3_bind_text, sqlite3_busy_timeout, sqlite3_column_count, sqlite3_column_int, sqlite3_column_text, sqlite3_create_module, sqlite3_db_config, sqlite3_drop_modules, sqlite3_errmsg, sqlite3_exec, sqlite3_file_control, sqlite3_finalize, sqlite3_free, sqlite3_get_autocommit, sqlite3_libversion, sqlite3_limit, sqlite3_load_extension, sqlite3_malloc, sqlite3_malloc64, sqlite3_mprintf, sqlite3_open, sqlite3_open_v2, sqlite3_prepare_v2, sqlite3_progress_handler, sqlite3_randomness, sqlite3_realloc64, sqlite3_reset, sqlite3_set_authorizer, sqlite3_sleep, sqlite3_snprintf, sqlite3_sourceid, sqlite3_step, sqlite3_strglob, sqlite3_stricmp, sqlite3_strlike, sqlite3_strnicmp, sqlite3_table_column_metadata, sqlite3_test_control, sqlite3_trace_v2, sqlite3_vfs_find, SQLITE_API, SQLITE_BUSY, SQLITE_CDECL, SQLITE_DBCONFIG_DEFENSIVE, SQLITE_DBCONFIG_DQS_DDL, SQLITE_DBCONFIG_DQS_DML, SQLITE_DBCONFIG_ENABLE_FKEY, SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER, SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION, SQLITE_DBCONFIG_ENABLE_QPSG, SQLITE_DBCONFIG_ENABLE_TRIGGER, SQLITE_DBCONFIG_ENABLE_VIEW, SQLITE_DBCONFIG_LEGACY_ALTER_TABLE, SQLITE_DBCONFIG_LEGACY_FILE_FORMAT, SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE, SQLITE_DBCONFIG_RESET_DATABASE, SQLITE_DBCONFIG_TRIGGER_EQP, SQLITE_DBCONFIG_TRUSTED_SCHEMA, SQLITE_DBCONFIG_WRITABLE_SCHEMA, SQLITE_DONE, SQLITE_FCNTL_CHUNK_SIZE, SQLITE_FCNTL_HAS_MOVED, SQLITE_FCNTL_LOCK_TIMEOUT, SQLITE_FCNTL_PERSIST_WAL, SQLITE_FCNTL_POWERSAFE_OVERWRITE, SQLITE_FCNTL_SIZE_LIMIT, SQLITE_FCNTL_TEMPFILENAME, SQLITE_FCNTL_VFS_POINTER, SQLITE_FCNTL_VFSNAME, SQLITE_LIMIT_ATTACHED, SQLITE_LIMIT_COLUMN, SQLITE_LIMIT_COMPOUND_SELECT, SQLITE_LIMIT_EXPR_DEPTH, SQLITE_LIMIT_FUNCTION_ARG, SQLITE_LIMIT_LENGTH, SQLITE_LIMIT_LIKE_PATTERN_LENGTH, SQLITE_LIMIT_SQL_LENGTH, SQLITE_LIMIT_TRIGGER_DEPTH, SQLITE_LIMIT_VARIABLE_NUMBER, SQLITE_LIMIT_VDBE_OP, SQLITE_LIMIT_WORKER_THREADS, SQLITE_LOCKED, SQLITE_OK, SQLITE_OPEN_CREATE, SQLITE_OPEN_NOFOLLOW, SQLITE_OPEN_READWRITE, SQLITE_ROW, SQLITE_STATIC, SQLITE_TESTCTRL_ALWAYS, SQLITE_TESTCTRL_ASSERT, SQLITE_TESTCTRL_BYTEORDER, SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS, SQLITE_TESTCTRL_IMPOSTER, SQLITE_TESTCTRL_INTERNAL_FUNCTIONS, SQLITE_TESTCTRL_LOCALTIME_FAULT, SQLITE_TESTCTRL_NEVER_CORRUPT, SQLITE_TESTCTRL_OPTIMIZATIONS, SQLITE_TESTCTRL_PARSER_COVERAGE, SQLITE_TESTCTRL_PENDING_BYTE, SQLITE_TESTCTRL_PRNG_RESET, SQLITE_TESTCTRL_PRNG_RESTORE, SQLITE_TESTCTRL_PRNG_SAVE, SQLITE_TESTCTRL_PRNG_SEED, SQLITE_TESTCTRL_RESERVE, SQLITE_TRACE_CLOSE, SQLITE_TRACE_PROFILE, SQLITE_TRACE_ROW, SQLITE_TRACE_STMT, SQLITE_TRANSIENT, ShellState::statsOn, strlen30(), ShellState::szMax, sqlite3_vfs::szOsFile, test_breakpoint(), testcase_glob(), ShellState::traceOut, tryToClone(), utf8_printf, ShellState::writableSchema, time_test::x, ShellText::z, ImportCtx::z, ShellState::zDbFilename, ShellState::zDestTable, ImportCtx::zFile, ShellState::zFreeOnClose, sqlite3_vfs::zName, zName, ShellState::zTempFile, and ShellState::zTestcase.}\par
{
Referenced by main(), and process_input().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 15481                                                       \{\par
15482   int h = 1;\par
15483   int nArg = 0;\par
15484   int n, c;\par
15485   int rc = 0;\par
15486   char *azArg[52];\par
15487 \par
15488 #ifndef SQLITE_OMIT_VIRTUALTABLE\par
15489   if( p->expert.pExpert )\{\par
15490     expertFinish(p, 1, 0);\par
15491   \}\par
15492 #endif\par
15493 \par
15494   /* Parse the input line into tokens.\par
15495   */\par
15496   while( zLine[h] && nArg<ArraySize(azArg)-1 )\{\par
15497     while( IsSpace(zLine[h]) )\{ h++; \}\par
15498     if( zLine[h]==0 ) break;\par
15499     if( zLine[h]=='\\'' || zLine[h]=='"' )\{\par
15500       int delim = zLine[h++];\par
15501       azArg[nArg++] = &zLine[h];\par
15502       while( zLine[h] && zLine[h]!=delim )\{\par
15503         if( zLine[h]=='\\\\' && delim=='"' && zLine[h+1]!=0 ) h++;\par
15504         h++;\par
15505       \}\par
15506       if( zLine[h]==delim )\{\par
15507         zLine[h++] = 0;\par
15508       \}\par
15509       if( delim=='"' ) resolve_backslashes(azArg[nArg-1]);\par
15510     \}else\{\par
15511       azArg[nArg++] = &zLine[h];\par
15512       while( zLine[h] && !IsSpace(zLine[h]) )\{ h++; \}\par
15513       if( zLine[h] ) zLine[h++] = 0;\par
15514       resolve_backslashes(azArg[nArg-1]);\par
15515     \}\par
15516   \}\par
15517   azArg[nArg] = 0;\par
15518 \par
15519   /* Process the input line.\par
15520   */\par
15521   if( nArg==0 ) return 0; /* no tokens, no error */\par
15522   n = strlen30(azArg[0]);\par
15523   c = azArg[0][0];\par
15524   clearTempFile(p);\par
15525 \par
15526 #ifndef SQLITE_OMIT_AUTHORIZATION\par
15527   if( c=='a' && strncmp(azArg[0], "auth", n)==0 )\{\par
15528     if( nArg!=2 )\{\par
15529       raw_printf(stderr, "Usage: .auth ON|OFF\\n");\par
15530       rc = 1;\par
15531       goto meta_command_exit;\par
15532     \}\par
15533     open_db(p, 0);\par
15534     if( booleanValue(azArg[1]) )\{\par
15535       sqlite3_set_authorizer(p->db, shellAuth, p);\par
15536     \}else\{\par
15537       sqlite3_set_authorizer(p->db, 0, 0);\par
15538     \}\par
15539   \}else\par
15540 #endif\par
15541 \par
15542 #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)\par
15543   if( c=='a' && strncmp(azArg[0], "archive", n)==0 )\{\par
15544     open_db(p, 0);\par
15545     rc = arDotCommand(p, 0, azArg, nArg);\par
15546   \}else\par
15547 #endif\par
15548 \par
15549   if( (c=='b' && n>=3 && strncmp(azArg[0], "backup", n)==0)\par
15550    || (c=='s' && n>=3 && strncmp(azArg[0], "save", n)==0)\par
15551   )\{\par
15552     const char *zDestFile = 0;\par
15553     const char *zDb = 0;\par
15554     sqlite3 *pDest;\par
15555     sqlite3_backup *pBackup;\par
15556     int j;\par
15557     int bAsync = 0;\par
15558     const char *zVfs = 0;\par
15559     for(j=1; j<nArg; j++)\{\par
15560       const char *z = azArg[j];\par
15561       if( z[0]=='-' )\{\par
15562         if( z[1]=='-' ) z++;\par
15563         if( strcmp(z, "-append")==0 )\{\par
15564           zVfs = "apndvfs";\par
15565         \}else\par
15566         if( strcmp(z, "-async")==0 )\{\par
15567           bAsync = 1;\par
15568         \}else\par
15569         \{\par
15570           utf8_printf(stderr, "unknown option: %s\\n", azArg[j]);\par
15571           return 1;\par
15572         \}\par
15573       \}else if( zDestFile==0 )\{\par
15574         zDestFile = azArg[j];\par
15575       \}else if( zDb==0 )\{\par
15576         zDb = zDestFile;\par
15577         zDestFile = azArg[j];\par
15578       \}else\{\par
15579         raw_printf(stderr, "Usage: .backup ?DB? ?OPTIONS? FILENAME\\n");\par
15580         return 1;\par
15581       \}\par
15582     \}\par
15583     if( zDestFile==0 )\{\par
15584       raw_printf(stderr, "missing FILENAME argument on .backup\\n");\par
15585       return 1;\par
15586     \}\par
15587     if( zDb==0 ) zDb = "main";\par
15588     rc = sqlite3_open_v2(zDestFile, &pDest, \par
15589                   SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE, zVfs);\par
15590     if( rc!=SQLITE_OK )\{\par
15591       utf8_printf(stderr, "Error: cannot open \\"%s\\"\\n", zDestFile);\par
15592       close_db(pDest);\par
15593       return 1;\par
15594     \}\par
15595     if( bAsync )\{\par
15596       sqlite3_exec(pDest, "PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;",\par
15597                    0, 0, 0);\par
15598     \}\par
15599     open_db(p, 0);\par
15600     pBackup = sqlite3_backup_init(pDest, "main", p->db, zDb);\par
15601     if( pBackup==0 )\{\par
15602       utf8_printf(stderr, "Error: %s\\n", sqlite3_errmsg(pDest));\par
15603       close_db(pDest);\par
15604       return 1;\par
15605     \}\par
15606     while(  (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK )\{\}\par
15607     sqlite3_backup_finish(pBackup);\par
15608     if( rc==SQLITE_DONE )\{\par
15609       rc = 0;\par
15610     \}else\{\par
15611       utf8_printf(stderr, "Error: %s\\n", sqlite3_errmsg(pDest));\par
15612       rc = 1;\par
15613     \}\par
15614     close_db(pDest);\par
15615   \}else\par
15616 \par
15617   if( c=='b' && n>=3 && strncmp(azArg[0], "bail", n)==0 )\{\par
15618     if( nArg==2 )\{\par
15619       bail_on_error = booleanValue(azArg[1]);\par
15620     \}else\{\par
15621       raw_printf(stderr, "Usage: .bail on|off\\n");\par
15622       rc = 1;\par
15623     \}\par
15624   \}else\par
15625 \par
15626   if( c=='b' && n>=3 && strncmp(azArg[0], "binary", n)==0 )\{\par
15627     if( nArg==2 )\{\par
15628       if( booleanValue(azArg[1]) )\{\par
15629         setBinaryMode(p->out, 1);\par
15630       \}else\{\par
15631         setTextMode(p->out, 1);\par
15632       \}\par
15633     \}else\{\par
15634       raw_printf(stderr, "Usage: .binary on|off\\n");\par
15635       rc = 1;\par
15636     \}\par
15637   \}else\par
15638 \par
15639   if( c=='c' && strcmp(azArg[0],"cd")==0 )\{\par
15640     if( nArg==2 )\{\par
15641 #if defined(_WIN32) || defined(WIN32)\par
15642       wchar_t *z = sqlite3_win32_utf8_to_unicode(azArg[1]);\par
15643       rc = !SetCurrentDirectoryW(z);\par
15644       sqlite3_free(z);\par
15645 #else\par
15646       rc = chdir(azArg[1]);\par
15647 #endif\par
15648       if( rc )\{\par
15649         utf8_printf(stderr, "Cannot change to directory \\"%s\\"\\n", azArg[1]);\par
15650         rc = 1;\par
15651       \}\par
15652     \}else\{\par
15653       raw_printf(stderr, "Usage: .cd DIRECTORY\\n");\par
15654       rc = 1;\par
15655     \}\par
15656   \}else\par
15657 \par
15658   /* The undocumented ".breakpoint" command causes a call to the no-op\par
15659   ** routine named test_breakpoint().\par
15660   */\par
15661   if( c=='b' && n>=3 && strncmp(azArg[0], "breakpoint", n)==0 )\{\par
15662     test_breakpoint();\par
15663   \}else\par
15664 \par
15665   if( c=='c' && n>=3 && strncmp(azArg[0], "changes", n)==0 )\{\par
15666     if( nArg==2 )\{\par
15667       setOrClearFlag(p, SHFLG_CountChanges, azArg[1]);\par
15668     \}else\{\par
15669       raw_printf(stderr, "Usage: .changes on|off\\n");\par
15670       rc = 1;\par
15671     \}\par
15672   \}else\par
15673 \par
15674   /* Cancel output redirection, if it is currently set (by .testcase)\par
15675   ** Then read the content of the testcase-out.txt file and compare against\par
15676   ** azArg[1].  If there are differences, report an error and exit.\par
15677   */\par
15678   if( c=='c' && n>=3 && strncmp(azArg[0], "check", n)==0 )\{\par
15679     char *zRes = 0;\par
15680     output_reset(p);\par
15681     if( nArg!=2 )\{\par
15682       raw_printf(stderr, "Usage: .check GLOB-PATTERN\\n");\par
15683       rc = 2;\par
15684     \}else if( (zRes = readFile("testcase-out.txt", 0))==0 )\{\par
15685       raw_printf(stderr, "Error: cannot read 'testcase-out.txt'\\n");\par
15686       rc = 2;\par
15687     \}else if( testcase_glob(azArg[1],zRes)==0 )\{\par
15688       utf8_printf(stderr,\par
15689                  "testcase-%s FAILED\\n Expected: [%s]\\n      Got: [%s]\\n",\par
15690                  p->zTestcase, azArg[1], zRes);\par
15691       rc = 1;\par
15692     \}else\{\par
15693       utf8_printf(stdout, "testcase-%s ok\\n", p->zTestcase);\par
15694       p->nCheck++;\par
15695     \}\par
15696     sqlite3_free(zRes);\par
15697   \}else\par
15698 \par
15699   if( c=='c' && strncmp(azArg[0], "clone", n)==0 )\{\par
15700     if( nArg==2 )\{\par
15701       tryToClone(p, azArg[1]);\par
15702     \}else\{\par
15703       raw_printf(stderr, "Usage: .clone FILENAME\\n");\par
15704       rc = 1;\par
15705     \}\par
15706   \}else\par
15707 \par
15708   if( c=='d' && n>1 && strncmp(azArg[0], "databases", n)==0 )\{\par
15709     ShellState data;\par
15710     char *zErrMsg = 0;\par
15711     open_db(p, 0);\par
15712     memcpy(&data, p, sizeof(data));\par
15713     data.showHeader = 0;\par
15714     data.cMode = data.mode = MODE_List;\par
15715     sqlite3_snprintf(sizeof(data.colSeparator),data.colSeparator,": ");\par
15716     data.cnt = 0;\par
15717     sqlite3_exec(p->db, "SELECT name, file FROM pragma_database_list",\par
15718                  callback, &data, &zErrMsg);\par
15719     if( zErrMsg )\{\par
15720       utf8_printf(stderr,"Error: %s\\n", zErrMsg);\par
15721       sqlite3_free(zErrMsg);\par
15722       rc = 1;\par
15723     \}\par
15724   \}else\par
15725 \par
15726   if( c=='d' && n>=3 && strncmp(azArg[0], "dbconfig", n)==0 )\{\par
15727     static const struct DbConfigChoices \{\par
15728       const char *zName;\par
15729       int op;\par
15730     \} aDbConfig[] = \{\par
15731         \{ "defensive",          SQLITE_DBCONFIG_DEFENSIVE             \},\par
15732         \{ "dqs_ddl",            SQLITE_DBCONFIG_DQS_DDL               \},\par
15733         \{ "dqs_dml",            SQLITE_DBCONFIG_DQS_DML               \},\par
15734         \{ "enable_fkey",        SQLITE_DBCONFIG_ENABLE_FKEY           \},\par
15735         \{ "enable_qpsg",        SQLITE_DBCONFIG_ENABLE_QPSG           \},\par
15736         \{ "enable_trigger",     SQLITE_DBCONFIG_ENABLE_TRIGGER        \},\par
15737         \{ "enable_view",        SQLITE_DBCONFIG_ENABLE_VIEW           \},\par
15738         \{ "fts3_tokenizer",     SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER \},\par
15739         \{ "legacy_alter_table", SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    \},\par
15740         \{ "legacy_file_format", SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    \},\par
15741         \{ "load_extension",     SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION \},\par
15742         \{ "no_ckpt_on_close",   SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      \},\par
15743         \{ "reset_database",     SQLITE_DBCONFIG_RESET_DATABASE        \},\par
15744         \{ "trigger_eqp",        SQLITE_DBCONFIG_TRIGGER_EQP           \},\par
15745         \{ "trusted_schema",     SQLITE_DBCONFIG_TRUSTED_SCHEMA        \},\par
15746         \{ "writable_schema",    SQLITE_DBCONFIG_WRITABLE_SCHEMA       \},\par
15747     \};\par
15748     int ii, v;\par
15749     open_db(p, 0);\par
15750     for(ii=0; ii<ArraySize(aDbConfig); ii++)\{\par
15751       if( nArg>1 && strcmp(azArg[1], aDbConfig[ii].zName)!=0 ) continue;\par
15752       if( nArg>=3 )\{\par
15753         sqlite3_db_config(p->db, aDbConfig[ii].op, booleanValue(azArg[2]), 0);\par
15754       \}\par
15755       sqlite3_db_config(p->db, aDbConfig[ii].op, -1, &v);\par
15756       utf8_printf(p->out, "%19s %s\\n", aDbConfig[ii].zName, v ? "on" : "off");\par
15757       if( nArg>1 ) break;\par
15758     \}\par
15759     if( nArg>1 && ii==ArraySize(aDbConfig) )\{\par
15760       utf8_printf(stderr, "Error: unknown dbconfig \\"%s\\"\\n", azArg[1]);\par
15761       utf8_printf(stderr, "Enter \\".dbconfig\\" with no arguments for a list\\n");\par
15762     \}   \par
15763   \}else\par
15764 \par
15765   if( c=='d' && n>=3 && strncmp(azArg[0], "dbinfo", n)==0 )\{\par
15766     rc = shell_dbinfo_command(p, nArg, azArg);\par
15767   \}else\par
15768 \par
15769 #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)\par
15770   if( c=='r' && strncmp(azArg[0], "recover", n)==0 )\{\par
15771     open_db(p, 0);\par
15772     rc = recoverDatabaseCmd(p, nArg, azArg);\par
15773   \}else\par
15774 #endif /* !(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB) */\par
15775 \par
15776   if( c=='d' && strncmp(azArg[0], "dump", n)==0 )\{\par
15777     const char *zLike = 0;\par
15778     int i;\par
15779     int savedShowHeader = p->showHeader;\par
15780     int savedShellFlags = p->shellFlgs;\par
15781     ShellClearFlag(p, SHFLG_PreserveRowid|SHFLG_Newlines|SHFLG_Echo);\par
15782     for(i=1; i<nArg; i++)\{\par
15783       if( azArg[i][0]=='-' )\{\par
15784         const char *z = azArg[i]+1;\par
15785         if( z[0]=='-' ) z++;\par
15786         if( strcmp(z,"preserve-rowids")==0 )\{\par
15787 #ifdef SQLITE_OMIT_VIRTUALTABLE\par
15788           raw_printf(stderr, "The --preserve-rowids option is not compatible"\par
15789                              " with SQLITE_OMIT_VIRTUALTABLE\\n");\par
15790           rc = 1;\par
15791           goto meta_command_exit;\par
15792 #else\par
15793           ShellSetFlag(p, SHFLG_PreserveRowid);\par
15794 #endif\par
15795         \}else\par
15796         if( strcmp(z,"newlines")==0 )\{\par
15797           ShellSetFlag(p, SHFLG_Newlines);\par
15798         \}else\par
15799         \{\par
15800           raw_printf(stderr, "Unknown option \\"%s\\" on \\".dump\\"\\n", azArg[i]);\par
15801           rc = 1;\par
15802           goto meta_command_exit;\par
15803         \}\par
15804       \}else if( zLike )\{\par
15805         raw_printf(stderr, "Usage: .dump ?--preserve-rowids? "\par
15806                            "?--newlines? ?LIKE-PATTERN?\\n");\par
15807         rc = 1;\par
15808         goto meta_command_exit;\par
15809       \}else\{\par
15810         zLike = azArg[i];\par
15811       \}\par
15812     \}\par
15813 \par
15814     open_db(p, 0);\par
15815 \par
15816     /* When playing back a "dump", the content might appear in an order\par
15817     ** which causes immediate foreign key constraints to be violated.\par
15818     ** So disable foreign-key constraint enforcement to prevent problems. */\par
15819     raw_printf(p->out, "PRAGMA foreign_keys=OFF;\\n");\par
15820     raw_printf(p->out, "BEGIN TRANSACTION;\\n");\par
15821     p->writableSchema = 0;\par
15822     p->showHeader = 0;\par
15823     /* Set writable_schema=ON since doing so forces SQLite to initialize\par
15824     ** as much of the schema as it can even if the sqlite_master table is\par
15825     ** corrupt. */\par
15826     sqlite3_exec(p->db, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);\par
15827     p->nErr = 0;\par
15828     if( zLike==0 )\{\par
15829       run_schema_dump_query(p,\par
15830         "SELECT name, type, sql FROM sqlite_master "\par
15831         "WHERE sql NOT NULL AND type=='table' AND name!='sqlite_sequence'"\par
15832       );\par
15833       run_schema_dump_query(p,\par
15834         "SELECT name, type, sql FROM sqlite_master "\par
15835         "WHERE name=='sqlite_sequence'"\par
15836       );\par
15837       run_table_dump_query(p,\par
15838         "SELECT sql FROM sqlite_master "\par
15839         "WHERE sql NOT NULL AND type IN ('index','trigger','view')", 0\par
15840       );\par
15841     \}else\{\par
15842       char *zSql;\par
15843       zSql = sqlite3_mprintf(\par
15844         "SELECT name, type, sql FROM sqlite_master "\par
15845         "WHERE tbl_name LIKE %Q AND type=='table'"\par
15846         "  AND sql NOT NULL", zLike);\par
15847       run_schema_dump_query(p,zSql);\par
15848       sqlite3_free(zSql);\par
15849       zSql = sqlite3_mprintf(\par
15850         "SELECT sql FROM sqlite_master "\par
15851         "WHERE sql NOT NULL"\par
15852         "  AND type IN ('index','trigger','view')"\par
15853         "  AND tbl_name LIKE %Q", zLike);\par
15854       run_table_dump_query(p, zSql, 0);\par
15855       sqlite3_free(zSql);\par
15856     \}\par
15857     if( p->writableSchema )\{\par
15858       raw_printf(p->out, "PRAGMA writable_schema=OFF;\\n");\par
15859       p->writableSchema = 0;\par
15860     \}\par
15861     sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);\par
15862     sqlite3_exec(p->db, "RELEASE dump;", 0, 0, 0);\par
15863     raw_printf(p->out, p->nErr?"ROLLBACK; -- due to errors\\n":"COMMIT;\\n");\par
15864     p->showHeader = savedShowHeader;\par
15865     p->shellFlgs = savedShellFlags;\par
15866   \}else\par
15867 \par
15868   if( c=='e' && strncmp(azArg[0], "echo", n)==0 )\{\par
15869     if( nArg==2 )\{\par
15870       setOrClearFlag(p, SHFLG_Echo, azArg[1]);\par
15871     \}else\{\par
15872       raw_printf(stderr, "Usage: .echo on|off\\n");\par
15873       rc = 1;\par
15874     \}\par
15875   \}else\par
15876 \par
15877   if( c=='e' && strncmp(azArg[0], "eqp", n)==0 )\{\par
15878     if( nArg==2 )\{\par
15879       p->autoEQPtest = 0;\par
15880       if( p->autoEQPtrace )\{\par
15881         if( p->db ) sqlite3_exec(p->db, "PRAGMA vdbe_trace=OFF;", 0, 0, 0);\par
15882         p->autoEQPtrace = 0;\par
15883       \}\par
15884       if( strcmp(azArg[1],"full")==0 )\{\par
15885         p->autoEQP = AUTOEQP_full;\par
15886       \}else if( strcmp(azArg[1],"trigger")==0 )\{\par
15887         p->autoEQP = AUTOEQP_trigger;\par
15888 #ifdef SQLITE_DEBUG\par
15889       \}else if( strcmp(azArg[1],"test")==0 )\{\par
15890         p->autoEQP = AUTOEQP_on;\par
15891         p->autoEQPtest = 1;\par
15892       \}else if( strcmp(azArg[1],"trace")==0 )\{\par
15893         p->autoEQP = AUTOEQP_full;\par
15894         p->autoEQPtrace = 1;\par
15895         open_db(p, 0);\par
15896         sqlite3_exec(p->db, "SELECT name FROM sqlite_master LIMIT 1", 0, 0, 0);\par
15897         sqlite3_exec(p->db, "PRAGMA vdbe_trace=ON;", 0, 0, 0);\par
15898 #endif\par
15899       \}else\{\par
15900         p->autoEQP = (u8)booleanValue(azArg[1]);\par
15901       \}\par
15902     \}else\{\par
15903       raw_printf(stderr, "Usage: .eqp off|on|trace|trigger|full\\n");\par
15904       rc = 1;\par
15905     \}\par
15906   \}else\par
15907 \par
15908   if( c=='e' && strncmp(azArg[0], "exit", n)==0 )\{\par
15909     if( nArg>1 && (rc = (int)integerValue(azArg[1]))!=0 ) exit(rc);\par
15910     rc = 2;\par
15911   \}else\par
15912 \par
15913   /* The ".explain" command is automatic now.  It is largely pointless.  It\par
15914   ** retained purely for backwards compatibility */\par
15915   if( c=='e' && strncmp(azArg[0], "explain", n)==0 )\{\par
15916     int val = 1;\par
15917     if( nArg>=2 )\{\par
15918       if( strcmp(azArg[1],"auto")==0 )\{\par
15919         val = 99;\par
15920       \}else\{\par
15921         val =  booleanValue(azArg[1]);\par
15922       \}\par
15923     \}\par
15924     if( val==1 && p->mode!=MODE_Explain )\{\par
15925       p->normalMode = p->mode;\par
15926       p->mode = MODE_Explain;\par
15927       p->autoExplain = 0;\par
15928     \}else if( val==0 )\{\par
15929       if( p->mode==MODE_Explain ) p->mode = p->normalMode;\par
15930       p->autoExplain = 0;\par
15931     \}else if( val==99 )\{\par
15932       if( p->mode==MODE_Explain ) p->mode = p->normalMode;\par
15933       p->autoExplain = 1;\par
15934     \}\par
15935   \}else\par
15936 \par
15937 #ifndef SQLITE_OMIT_VIRTUALTABLE\par
15938   if( c=='e' && strncmp(azArg[0], "expert", n)==0 )\{\par
15939     open_db(p, 0);\par
15940     expertDotCommand(p, azArg, nArg);\par
15941   \}else\par
15942 #endif\par
15943 \par
15944   if( c=='f' && strncmp(azArg[0], "filectrl", n)==0 )\{\par
15945     static const struct \{\par
15946        const char *zCtrlName;   /* Name of a test-control option */\par
15947        int ctrlCode;            /* Integer code for that option */\par
15948        const char *zUsage;      /* Usage notes */\par
15949     \} aCtrl[] = \{\par
15950       \{ "size_limit",     SQLITE_FCNTL_SIZE_LIMIT,      "[LIMIT]"        \},\par
15951       \{ "chunk_size",     SQLITE_FCNTL_CHUNK_SIZE,      "SIZE"           \},\par
15952    /* \{ "win32_av_retry", SQLITE_FCNTL_WIN32_AV_RETRY,  "COUNT DELAY"    \},*/\par
15953       \{ "persist_wal",    SQLITE_FCNTL_PERSIST_WAL,     "[BOOLEAN]"      \},\par
15954       \{ "psow",       SQLITE_FCNTL_POWERSAFE_OVERWRITE, "[BOOLEAN]"      \},\par
15955    /* \{ "pragma",         SQLITE_FCNTL_PRAGMA,          "NAME ARG"       \},*/\par
15956       \{ "tempfilename",   SQLITE_FCNTL_TEMPFILENAME,    ""               \},\par
15957       \{ "has_moved",      SQLITE_FCNTL_HAS_MOVED,       ""               \},  \par
15958       \{ "lock_timeout",   SQLITE_FCNTL_LOCK_TIMEOUT,    "MILLISEC"       \},\par
15959     \};\par
15960     int filectrl = -1;\par
15961     int iCtrl = -1;\par
15962     sqlite3_int64 iRes = 0;  /* Integer result to display if rc2==1 */\par
15963     int isOk = 0;            /* 0: usage  1: %lld  2: no-result */\par
15964     int n2, i;\par
15965     const char *zCmd = 0;\par
15966 \par
15967     open_db(p, 0);\par
15968     zCmd = nArg>=2 ? azArg[1] : "help";\par
15969 \par
15970     /* The argument can optionally begin with "-" or "--" */\par
15971     if( zCmd[0]=='-' && zCmd[1] )\{\par
15972       zCmd++;\par
15973       if( zCmd[0]=='-' && zCmd[1] ) zCmd++;\par
15974     \}\par
15975 \par
15976     /* --help lists all file-controls */\par
15977     if( strcmp(zCmd,"help")==0 )\{\par
15978       utf8_printf(p->out, "Available file-controls:\\n");\par
15979       for(i=0; i<ArraySize(aCtrl); i++)\{\par
15980         utf8_printf(p->out, "  .filectrl %s %s\\n",\par
15981                     aCtrl[i].zCtrlName, aCtrl[i].zUsage);\par
15982       \}\par
15983       rc = 1;\par
15984       goto meta_command_exit;\par
15985     \}\par
15986 \par
15987     /* convert filectrl text option to value. allow any unique prefix\par
15988     ** of the option name, or a numerical value. */\par
15989     n2 = strlen30(zCmd);\par
15990     for(i=0; i<ArraySize(aCtrl); i++)\{\par
15991       if( strncmp(zCmd, aCtrl[i].zCtrlName, n2)==0 )\{\par
15992         if( filectrl<0 )\{\par
15993           filectrl = aCtrl[i].ctrlCode;\par
15994           iCtrl = i;\par
15995         \}else\{\par
15996           utf8_printf(stderr, "Error: ambiguous file-control: \\"%s\\"\\n"\par
15997                               "Use \\".filectrl --help\\" for help\\n", zCmd);\par
15998           rc = 1;\par
15999           goto meta_command_exit;\par
16000         \}\par
16001       \}\par
16002     \}\par
16003     if( filectrl<0 )\{\par
16004       utf8_printf(stderr,"Error: unknown file-control: %s\\n"\par
16005                          "Use \\".filectrl --help\\" for help\\n", zCmd);\par
16006     \}else\{\par
16007       switch(filectrl)\{\par
16008         case SQLITE_FCNTL_SIZE_LIMIT: \{\par
16009           if( nArg!=2 && nArg!=3 ) break;\par
16010           iRes = nArg==3 ? integerValue(azArg[2]) : -1;\par
16011           sqlite3_file_control(p->db, 0, SQLITE_FCNTL_SIZE_LIMIT, &iRes);\par
16012           isOk = 1;\par
16013           break;\par
16014         \}\par
16015         case SQLITE_FCNTL_LOCK_TIMEOUT:\par
16016         case SQLITE_FCNTL_CHUNK_SIZE: \{\par
16017           int x;\par
16018           if( nArg!=3 ) break;\par
16019           x = (int)integerValue(azArg[2]);\par
16020           sqlite3_file_control(p->db, 0, filectrl, &x);\par
16021           isOk = 2;\par
16022           break;\par
16023         \}\par
16024         case SQLITE_FCNTL_PERSIST_WAL:\par
16025         case SQLITE_FCNTL_POWERSAFE_OVERWRITE: \{\par
16026           int x;\par
16027           if( nArg!=2 && nArg!=3 ) break;\par
16028           x = nArg==3 ? booleanValue(azArg[2]) : -1;\par
16029           sqlite3_file_control(p->db, 0, filectrl, &x);\par
16030           iRes = x;\par
16031           isOk = 1;\par
16032           break;\par
16033         \}\par
16034         case SQLITE_FCNTL_HAS_MOVED: \{\par
16035           int x;\par
16036           if( nArg!=2 ) break;\par
16037           sqlite3_file_control(p->db, 0, filectrl, &x);\par
16038           iRes = x;\par
16039           isOk = 1;\par
16040           break;\par
16041         \}\par
16042         case SQLITE_FCNTL_TEMPFILENAME: \{\par
16043           char *z = 0;\par
16044           if( nArg!=2 ) break;\par
16045           sqlite3_file_control(p->db, 0, filectrl, &z);\par
16046           if( z )\{\par
16047             utf8_printf(p->out, "%s\\n", z);\par
16048             sqlite3_free(z);\par
16049           \}\par
16050           isOk = 2;\par
16051           break;\par
16052         \}\par
16053       \}\par
16054     \}\par
16055     if( isOk==0 && iCtrl>=0 )\{\par
16056       utf8_printf(p->out, "Usage: .filectrl %s %s\\n", zCmd,aCtrl[iCtrl].zUsage);\par
16057       rc = 1;\par
16058     \}else if( isOk==1 )\{\par
16059       char zBuf[100];\par
16060       sqlite3_snprintf(sizeof(zBuf), zBuf, "%lld", iRes);\par
16061       raw_printf(p->out, "%s\\n", zBuf);\par
16062     \}\par
16063   \}else\par
16064 \par
16065   if( c=='f' && strncmp(azArg[0], "fullschema", n)==0 )\{\par
16066     ShellState data;\par
16067     char *zErrMsg = 0;\par
16068     int doStats = 0;\par
16069     memcpy(&data, p, sizeof(data));\par
16070     data.showHeader = 0;\par
16071     data.cMode = data.mode = MODE_Semi;\par
16072     if( nArg==2 && optionMatch(azArg[1], "indent") )\{\par
16073       data.cMode = data.mode = MODE_Pretty;\par
16074       nArg = 1;\par
16075     \}\par
16076     if( nArg!=1 )\{\par
16077       raw_printf(stderr, "Usage: .fullschema ?--indent?\\n");\par
16078       rc = 1;\par
16079       goto meta_command_exit;\par
16080     \}\par
16081     open_db(p, 0);\par
16082     rc = sqlite3_exec(p->db,\par
16083        "SELECT sql FROM"\par
16084        "  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x"\par
16085        "     FROM sqlite_master UNION ALL"\par
16086        "   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_master) "\par
16087        "WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%' "\par
16088        "ORDER BY rowid",\par
16089        callback, &data, &zErrMsg\par
16090     );\par
16091     if( rc==SQLITE_OK )\{\par
16092       sqlite3_stmt *pStmt;\par
16093       rc = sqlite3_prepare_v2(p->db,\par
16094                "SELECT rowid FROM sqlite_master"\par
16095                " WHERE name GLOB 'sqlite_stat[134]'",\par
16096                -1, &pStmt, 0);\par
16097       doStats = sqlite3_step(pStmt)==SQLITE_ROW;\par
16098       sqlite3_finalize(pStmt);\par
16099     \}\par
16100     if( doStats==0 )\{\par
16101       raw_printf(p->out, "/* No STAT tables available */\\n");\par
16102     \}else\{\par
16103       raw_printf(p->out, "ANALYZE sqlite_master;\\n");\par
16104       sqlite3_exec(p->db, "SELECT 'ANALYZE sqlite_master'",\par
16105                    callback, &data, &zErrMsg);\par
16106       data.cMode = data.mode = MODE_Insert;\par
16107       data.zDestTable = "sqlite_stat1";\par
16108       shell_exec(&data, "SELECT * FROM sqlite_stat1", &zErrMsg);\par
16109       data.zDestTable = "sqlite_stat4";\par
16110       shell_exec(&data, "SELECT * FROM sqlite_stat4", &zErrMsg);\par
16111       raw_printf(p->out, "ANALYZE sqlite_master;\\n");\par
16112     \}\par
16113   \}else\par
16114 \par
16115   if( c=='h' && strncmp(azArg[0], "headers", n)==0 )\{\par
16116     if( nArg==2 )\{\par
16117       p->showHeader = booleanValue(azArg[1]);\par
16118     \}else\{\par
16119       raw_printf(stderr, "Usage: .headers on|off\\n");\par
16120       rc = 1;\par
16121     \}\par
16122   \}else\par
16123 \par
16124   if( c=='h' && strncmp(azArg[0], "help", n)==0 )\{\par
16125     if( nArg>=2 )\{\par
16126       n = showHelp(p->out, azArg[1]);\par
16127       if( n==0 )\{\par
16128         utf8_printf(p->out, "Nothing matches '%s'\\n", azArg[1]);\par
16129       \}\par
16130     \}else\{\par
16131       showHelp(p->out, 0);\par
16132     \}\par
16133   \}else\par
16134 \par
16135   if( c=='i' && strncmp(azArg[0], "import", n)==0 )\{\par
16136     char *zTable;               /* Insert data into this table */\par
16137     char *zFile;                /* Name of file to extra content from */\par
16138     sqlite3_stmt *pStmt = NULL; /* A statement */\par
16139     int nCol;                   /* Number of columns in the table */\par
16140     int nByte;                  /* Number of bytes in an SQL string */\par
16141     int i, j;                   /* Loop counters */\par
16142     int needCommit;             /* True to COMMIT or ROLLBACK at end */\par
16143     int nSep;                   /* Number of bytes in p->colSeparator[] */\par
16144     char *zSql;                 /* An SQL statement */\par
16145     ImportCtx sCtx;             /* Reader context */\par
16146     char *(SQLITE_CDECL *xRead)(ImportCtx*); /* Func to read one value */\par
16147     int (SQLITE_CDECL *xCloser)(FILE*);      /* Func to close file */\par
16148 \par
16149     if( nArg!=3 )\{\par
16150       raw_printf(stderr, "Usage: .import FILE TABLE\\n");\par
16151       goto meta_command_exit;\par
16152     \}\par
16153     zFile = azArg[1];\par
16154     zTable = azArg[2];\par
16155     seenInterrupt = 0;\par
16156     memset(&sCtx, 0, sizeof(sCtx));\par
16157     open_db(p, 0);\par
16158     nSep = strlen30(p->colSeparator);\par
16159     if( nSep==0 )\{\par
16160       raw_printf(stderr,\par
16161                  "Error: non-null column separator required for import\\n");\par
16162       return 1;\par
16163     \}\par
16164     if( nSep>1 )\{\par
16165       raw_printf(stderr, "Error: multi-character column separators not allowed"\par
16166                       " for import\\n");\par
16167       return 1;\par
16168     \}\par
16169     nSep = strlen30(p->rowSeparator);\par
16170     if( nSep==0 )\{\par
16171       raw_printf(stderr, "Error: non-null row separator required for import\\n");\par
16172       return 1;\par
16173     \}\par
16174     if( nSep==2 && p->mode==MODE_Csv && strcmp(p->rowSeparator, SEP_CrLf)==0 )\{\par
16175       /* When importing CSV (only), if the row separator is set to the\par
16176       ** default output row separator, change it to the default input\par
16177       ** row separator.  This avoids having to maintain different input\par
16178       ** and output row separators. */\par
16179       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);\par
16180       nSep = strlen30(p->rowSeparator);\par
16181     \}\par
16182     if( nSep>1 )\{\par
16183       raw_printf(stderr, "Error: multi-character row separators not allowed"\par
16184                       " for import\\n");\par
16185       return 1;\par
16186     \}\par
16187     sCtx.zFile = zFile;\par
16188     sCtx.nLine = 1;\par
16189     if( sCtx.zFile[0]=='|' )\{\par
16190 #ifdef SQLITE_OMIT_POPEN\par
16191       raw_printf(stderr, "Error: pipes are not supported in this OS\\n");\par
16192       return 1;\par
16193 #else\par
16194       sCtx.in = popen(sCtx.zFile+1, "r");\par
16195       sCtx.zFile = "<pipe>";\par
16196       xCloser = pclose;\par
16197 #endif\par
16198     \}else\{\par
16199       sCtx.in = fopen(sCtx.zFile, "rb");\par
16200       xCloser = fclose;\par
16201     \}\par
16202     if( p->mode==MODE_Ascii )\{\par
16203       xRead = ascii_read_one_field;\par
16204     \}else\{\par
16205       xRead = csv_read_one_field;\par
16206     \}\par
16207     if( sCtx.in==0 )\{\par
16208       utf8_printf(stderr, "Error: cannot open \\"%s\\"\\n", zFile);\par
16209       return 1;\par
16210     \}\par
16211     sCtx.cColSep = p->colSeparator[0];\par
16212     sCtx.cRowSep = p->rowSeparator[0];\par
16213     zSql = sqlite3_mprintf("SELECT * FROM %s", zTable);\par
16214     if( zSql==0 )\{\par
16215       xCloser(sCtx.in);\par
16216       shell_out_of_memory();\par
16217     \}\par
16218     nByte = strlen30(zSql);\par
16219     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\par
16220     import_append_char(&sCtx, 0);    /* To ensure sCtx.z is allocated */\par
16221     if( rc && sqlite3_strglob("no such table: *", sqlite3_errmsg(p->db))==0 )\{\par
16222       char *zCreate = sqlite3_mprintf("CREATE TABLE %s", zTable);\par
16223       char cSep = '(';\par
16224       while( xRead(&sCtx) )\{\par
16225         zCreate = sqlite3_mprintf("%z%c\\n  \\"%w\\" TEXT", zCreate, cSep, sCtx.z);\par
16226         cSep = ',';\par
16227         if( sCtx.cTerm!=sCtx.cColSep ) break;\par
16228       \}\par
16229       if( cSep=='(' )\{\par
16230         sqlite3_free(zCreate);\par
16231         sqlite3_free(sCtx.z);\par
16232         xCloser(sCtx.in);\par
16233         utf8_printf(stderr,"%s: empty file\\n", sCtx.zFile);\par
16234         return 1;\par
16235       \}\par
16236       zCreate = sqlite3_mprintf("%z\\n)", zCreate);\par
16237       rc = sqlite3_exec(p->db, zCreate, 0, 0, 0);\par
16238       sqlite3_free(zCreate);\par
16239       if( rc )\{\par
16240         utf8_printf(stderr, "CREATE TABLE %s(...) failed: %s\\n", zTable,\par
16241                 sqlite3_errmsg(p->db));\par
16242         sqlite3_free(sCtx.z);\par
16243         xCloser(sCtx.in);\par
16244         return 1;\par
16245       \}\par
16246       rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\par
16247     \}\par
16248     sqlite3_free(zSql);\par
16249     if( rc )\{\par
16250       if (pStmt) sqlite3_finalize(pStmt);\par
16251       utf8_printf(stderr,"Error: %s\\n", sqlite3_errmsg(p->db));\par
16252       xCloser(sCtx.in);\par
16253       return 1;\par
16254     \}\par
16255     nCol = sqlite3_column_count(pStmt);\par
16256     sqlite3_finalize(pStmt);\par
16257     pStmt = 0;\par
16258     if( nCol==0 ) return 0; /* no columns, no error */\par
16259     zSql = sqlite3_malloc64( nByte*2 + 20 + nCol*2 );\par
16260     if( zSql==0 )\{\par
16261       xCloser(sCtx.in);\par
16262       shell_out_of_memory();\par
16263     \}\par
16264     sqlite3_snprintf(nByte+20, zSql, "INSERT INTO \\"%w\\" VALUES(?", zTable);\par
16265     j = strlen30(zSql);\par
16266     for(i=1; i<nCol; i++)\{\par
16267       zSql[j++] = ',';\par
16268       zSql[j++] = '?';\par
16269     \}\par
16270     zSql[j++] = ')';\par
16271     zSql[j] = 0;\par
16272     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\par
16273     sqlite3_free(zSql);\par
16274     if( rc )\{\par
16275       utf8_printf(stderr, "Error: %s\\n", sqlite3_errmsg(p->db));\par
16276       if (pStmt) sqlite3_finalize(pStmt);\par
16277       xCloser(sCtx.in);\par
16278       return 1;\par
16279     \}\par
16280     needCommit = sqlite3_get_autocommit(p->db);\par
16281     if( needCommit ) sqlite3_exec(p->db, "BEGIN", 0, 0, 0);\par
16282     do\{\par
16283       int startLine = sCtx.nLine;\par
16284       for(i=0; i<nCol; i++)\{\par
16285         char *z = xRead(&sCtx);\par
16286         /*\par
16287         ** Did we reach end-of-file before finding any columns?\par
16288         ** If so, stop instead of NULL filling the remaining columns.\par
16289         */\par
16290         if( z==0 && i==0 ) break;\par
16291         /*\par
16292         ** Did we reach end-of-file OR end-of-line before finding any\par
16293         ** columns in ASCII mode?  If so, stop instead of NULL filling\par
16294         ** the remaining columns.\par
16295         */\par
16296         if( p->mode==MODE_Ascii && (z==0 || z[0]==0) && i==0 ) break;\par
16297         sqlite3_bind_text(pStmt, i+1, z, -1, SQLITE_TRANSIENT);\par
16298         if( i<nCol-1 && sCtx.cTerm!=sCtx.cColSep )\{\par
16299           utf8_printf(stderr, "%s:%d: expected %d columns but found %d - "\par
16300                           "filling the rest with NULL\\n",\par
16301                           sCtx.zFile, startLine, nCol, i+1);\par
16302           i += 2;\par
16303           while( i<=nCol )\{ sqlite3_bind_null(pStmt, i); i++; \}\par
16304         \}\par
16305       \}\par
16306       if( sCtx.cTerm==sCtx.cColSep )\{\par
16307         do\{\par
16308           xRead(&sCtx);\par
16309           i++;\par
16310         \}while( sCtx.cTerm==sCtx.cColSep );\par
16311         utf8_printf(stderr, "%s:%d: expected %d columns but found %d - "\par
16312                         "extras ignored\\n",\par
16313                         sCtx.zFile, startLine, nCol, i);\par
16314       \}\par
16315       if( i>=nCol )\{\par
16316         sqlite3_step(pStmt);\par
16317         rc = sqlite3_reset(pStmt);\par
16318         if( rc!=SQLITE_OK )\{\par
16319           utf8_printf(stderr, "%s:%d: INSERT failed: %s\\n", sCtx.zFile,\par
16320                       startLine, sqlite3_errmsg(p->db));\par
16321         \}\par
16322       \}\par
16323     \}while( sCtx.cTerm!=EOF );\par
16324 \par
16325     xCloser(sCtx.in);\par
16326     sqlite3_free(sCtx.z);\par
16327     sqlite3_finalize(pStmt);\par
16328     if( needCommit ) sqlite3_exec(p->db, "COMMIT", 0, 0, 0);\par
16329   \}else\par
16330 \par
16331 #ifndef SQLITE_UNTESTABLE\par
16332   if( c=='i' && strncmp(azArg[0], "imposter", n)==0 )\{\par
16333     char *zSql;\par
16334     char *zCollist = 0;\par
16335     sqlite3_stmt *pStmt;\par
16336     int tnum = 0;\par
16337     int isWO = 0;  /* True if making an imposter of a WITHOUT ROWID table */\par
16338     int lenPK = 0; /* Length of the PRIMARY KEY string for isWO tables */\par
16339     int i;\par
16340     if( !(nArg==3 || (nArg==2 && sqlite3_stricmp(azArg[1],"off")==0)) )\{\par
16341       utf8_printf(stderr, "Usage: .imposter INDEX IMPOSTER\\n"\par
16342                           "       .imposter off\\n");\par
16343       /* Also allowed, but not documented:\par
16344       **\par
16345       **    .imposter TABLE IMPOSTER\par
16346       **\par
16347       ** where TABLE is a WITHOUT ROWID table.  In that case, the\par
16348       ** imposter is another WITHOUT ROWID table with the columns in\par
16349       ** storage order. */\par
16350       rc = 1;\par
16351       goto meta_command_exit;\par
16352     \}\par
16353     open_db(p, 0);\par
16354     if( nArg==2 )\{\par
16355       sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, "main", 0, 1);\par
16356       goto meta_command_exit;\par
16357     \}\par
16358     zSql = sqlite3_mprintf(\par
16359       "SELECT rootpage, 0 FROM sqlite_master"\par
16360       " WHERE name='%q' AND type='index'"\par
16361       "UNION ALL "\par
16362       "SELECT rootpage, 1 FROM sqlite_master"\par
16363       " WHERE name='%q' AND type='table'"\par
16364       "   AND sql LIKE '%%without%%rowid%%'",\par
16365       azArg[1], azArg[1]\par
16366     );\par
16367     sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\par
16368     sqlite3_free(zSql);\par
16369     if( sqlite3_step(pStmt)==SQLITE_ROW )\{\par
16370       tnum = sqlite3_column_int(pStmt, 0);\par
16371       isWO = sqlite3_column_int(pStmt, 1);\par
16372     \}\par
16373     sqlite3_finalize(pStmt);\par
16374     zSql = sqlite3_mprintf("PRAGMA index_xinfo='%q'", azArg[1]);\par
16375     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\par
16376     sqlite3_free(zSql);\par
16377     i = 0;\par
16378     while( sqlite3_step(pStmt)==SQLITE_ROW )\{\par
16379       char zLabel[20];\par
16380       const char *zCol = (const char*)sqlite3_column_text(pStmt,2);\par
16381       i++;\par
16382       if( zCol==0 )\{\par
16383         if( sqlite3_column_int(pStmt,1)==-1 )\{\par
16384           zCol = "_ROWID_";\par
16385         \}else\{\par
16386           sqlite3_snprintf(sizeof(zLabel),zLabel,"expr%d",i);\par
16387           zCol = zLabel;\par
16388         \}\par
16389       \}\par
16390       if( isWO && lenPK==0 && sqlite3_column_int(pStmt,5)==0 && zCollist )\{\par
16391         lenPK = (int)strlen(zCollist);\par
16392       \}\par
16393       if( zCollist==0 )\{\par
16394         zCollist = sqlite3_mprintf("\\"%w\\"", zCol);\par
16395       \}else\{\par
16396         zCollist = sqlite3_mprintf("%z,\\"%w\\"", zCollist, zCol);\par
16397       \}\par
16398     \}\par
16399     sqlite3_finalize(pStmt);\par
16400     if( i==0 || tnum==0 )\{\par
16401       utf8_printf(stderr, "no such index: \\"%s\\"\\n", azArg[1]);\par
16402       rc = 1;\par
16403       sqlite3_free(zCollist);\par
16404       goto meta_command_exit;\par
16405     \}\par
16406     if( lenPK==0 ) lenPK = 100000;\par
16407     zSql = sqlite3_mprintf(\par
16408           "CREATE TABLE \\"%w\\"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID",\par
16409           azArg[2], zCollist, lenPK, zCollist);\par
16410     sqlite3_free(zCollist);\par
16411     rc = sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, "main", 1, tnum);\par
16412     if( rc==SQLITE_OK )\{\par
16413       rc = sqlite3_exec(p->db, zSql, 0, 0, 0);\par
16414       sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->db, "main", 0, 0);\par
16415       if( rc )\{\par
16416         utf8_printf(stderr, "Error in [%s]: %s\\n", zSql, sqlite3_errmsg(p->db));\par
16417       \}else\{\par
16418         utf8_printf(stdout, "%s;\\n", zSql);\par
16419         raw_printf(stdout,\par
16420           "WARNING: writing to an imposter table will corrupt the \\"%s\\" %s!\\n",\par
16421           azArg[1], isWO ? "table" : "index"\par
16422         );\par
16423       \}\par
16424     \}else\{\par
16425       raw_printf(stderr, "SQLITE_TESTCTRL_IMPOSTER returns %d\\n", rc);\par
16426       rc = 1;\par
16427     \}\par
16428     sqlite3_free(zSql);\par
16429   \}else\par
16430 #endif /* !defined(SQLITE_OMIT_TEST_CONTROL) */\par
16431 \par
16432 #ifdef SQLITE_ENABLE_IOTRACE\par
16433   if( c=='i' && strncmp(azArg[0], "iotrace", n)==0 )\{\par
16434     SQLITE_API extern void (SQLITE_CDECL *sqlite3IoTrace)(const char*, ...);\par
16435     if( iotrace && iotrace!=stdout ) fclose(iotrace);\par
16436     iotrace = 0;\par
16437     if( nArg<2 )\{\par
16438       sqlite3IoTrace = 0;\par
16439     \}else if( strcmp(azArg[1], "-")==0 )\{\par
16440       sqlite3IoTrace = iotracePrintf;\par
16441       iotrace = stdout;\par
16442     \}else\{\par
16443       iotrace = fopen(azArg[1], "w");\par
16444       if( iotrace==0 )\{\par
16445         utf8_printf(stderr, "Error: cannot open \\"%s\\"\\n", azArg[1]);\par
16446         sqlite3IoTrace = 0;\par
16447         rc = 1;\par
16448       \}else\{\par
16449         sqlite3IoTrace = iotracePrintf;\par
16450       \}\par
16451     \}\par
16452   \}else\par
16453 #endif\par
16454 \par
16455   if( c=='l' && n>=5 && strncmp(azArg[0], "limits", n)==0 )\{\par
16456     static const struct \{\par
16457        const char *zLimitName;   /* Name of a limit */\par
16458        int limitCode;            /* Integer code for that limit */\par
16459     \} aLimit[] = \{\par
16460       \{ "length",                SQLITE_LIMIT_LENGTH                    \},\par
16461       \{ "sql_length",            SQLITE_LIMIT_SQL_LENGTH                \},\par
16462       \{ "column",                SQLITE_LIMIT_COLUMN                    \},\par
16463       \{ "expr_depth",            SQLITE_LIMIT_EXPR_DEPTH                \},\par
16464       \{ "compound_select",       SQLITE_LIMIT_COMPOUND_SELECT           \},\par
16465       \{ "vdbe_op",               SQLITE_LIMIT_VDBE_OP                   \},\par
16466       \{ "function_arg",          SQLITE_LIMIT_FUNCTION_ARG              \},\par
16467       \{ "attached",              SQLITE_LIMIT_ATTACHED                  \},\par
16468       \{ "like_pattern_length",   SQLITE_LIMIT_LIKE_PATTERN_LENGTH       \},\par
16469       \{ "variable_number",       SQLITE_LIMIT_VARIABLE_NUMBER           \},\par
16470       \{ "trigger_depth",         SQLITE_LIMIT_TRIGGER_DEPTH             \},\par
16471       \{ "worker_threads",        SQLITE_LIMIT_WORKER_THREADS            \},\par
16472     \};\par
16473     int i, n2;\par
16474     open_db(p, 0);\par
16475     if( nArg==1 )\{\par
16476       for(i=0; i<ArraySize(aLimit); i++)\{\par
16477         printf("%20s %d\\n", aLimit[i].zLimitName,\par
16478                sqlite3_limit(p->db, aLimit[i].limitCode, -1));\par
16479       \}\par
16480     \}else if( nArg>3 )\{\par
16481       raw_printf(stderr, "Usage: .limit NAME ?NEW-VALUE?\\n");\par
16482       rc = 1;\par
16483       goto meta_command_exit;\par
16484     \}else\{\par
16485       int iLimit = -1;\par
16486       n2 = strlen30(azArg[1]);\par
16487       for(i=0; i<ArraySize(aLimit); i++)\{\par
16488         if( sqlite3_strnicmp(aLimit[i].zLimitName, azArg[1], n2)==0 )\{\par
16489           if( iLimit<0 )\{\par
16490             iLimit = i;\par
16491           \}else\{\par
16492             utf8_printf(stderr, "ambiguous limit: \\"%s\\"\\n", azArg[1]);\par
16493             rc = 1;\par
16494             goto meta_command_exit;\par
16495           \}\par
16496         \}\par
16497       \}\par
16498       if( iLimit<0 )\{\par
16499         utf8_printf(stderr, "unknown limit: \\"%s\\"\\n"\par
16500                         "enter \\".limits\\" with no arguments for a list.\\n",\par
16501                          azArg[1]);\par
16502         rc = 1;\par
16503         goto meta_command_exit;\par
16504       \}\par
16505       if( nArg==3 )\{\par
16506         sqlite3_limit(p->db, aLimit[iLimit].limitCode,\par
16507                       (int)integerValue(azArg[2]));\par
16508       \}\par
16509       printf("%20s %d\\n", aLimit[iLimit].zLimitName,\par
16510              sqlite3_limit(p->db, aLimit[iLimit].limitCode, -1));\par
16511     \}\par
16512   \}else\par
16513 \par
16514   if( c=='l' && n>2 && strncmp(azArg[0], "lint", n)==0 )\{\par
16515     open_db(p, 0);\par
16516     lintDotCommand(p, azArg, nArg);\par
16517   \}else\par
16518 \par
16519 #ifndef SQLITE_OMIT_LOAD_EXTENSION\par
16520   if( c=='l' && strncmp(azArg[0], "load", n)==0 )\{\par
16521     const char *zFile, *zProc;\par
16522     char *zErrMsg = 0;\par
16523     if( nArg<2 )\{\par
16524       raw_printf(stderr, "Usage: .load FILE ?ENTRYPOINT?\\n");\par
16525       rc = 1;\par
16526       goto meta_command_exit;\par
16527     \}\par
16528     zFile = azArg[1];\par
16529     zProc = nArg>=3 ? azArg[2] : 0;\par
16530     open_db(p, 0);\par
16531     rc = sqlite3_load_extension(p->db, zFile, zProc, &zErrMsg);\par
16532     if( rc!=SQLITE_OK )\{\par
16533       utf8_printf(stderr, "Error: %s\\n", zErrMsg);\par
16534       sqlite3_free(zErrMsg);\par
16535       rc = 1;\par
16536     \}\par
16537   \}else\par
16538 #endif\par
16539 \par
16540   if( c=='l' && strncmp(azArg[0], "log", n)==0 )\{\par
16541     if( nArg!=2 )\{\par
16542       raw_printf(stderr, "Usage: .log FILENAME\\n");\par
16543       rc = 1;\par
16544     \}else\{\par
16545       const char *zFile = azArg[1];\par
16546       output_file_close(p->pLog);\par
16547       p->pLog = output_file_open(zFile, 0);\par
16548     \}\par
16549   \}else\par
16550 \par
16551   if( c=='m' && strncmp(azArg[0], "mode", n)==0 )\{\par
16552     const char *zMode = nArg>=2 ? azArg[1] : "";\par
16553     int n2 = strlen30(zMode);\par
16554     int c2 = zMode[0];\par
16555     if( c2=='l' && n2>2 && strncmp(azArg[1],"lines",n2)==0 )\{\par
16556       p->mode = MODE_Line;\par
16557       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);\par
16558     \}else if( c2=='c' && strncmp(azArg[1],"columns",n2)==0 )\{\par
16559       p->mode = MODE_Column;\par
16560       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);\par
16561     \}else if( c2=='l' && n2>2 && strncmp(azArg[1],"list",n2)==0 )\{\par
16562       p->mode = MODE_List;\par
16563       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Column);\par
16564       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);\par
16565     \}else if( c2=='h' && strncmp(azArg[1],"html",n2)==0 )\{\par
16566       p->mode = MODE_Html;\par
16567     \}else if( c2=='t' && strncmp(azArg[1],"tcl",n2)==0 )\{\par
16568       p->mode = MODE_Tcl;\par
16569       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Space);\par
16570       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Row);\par
16571     \}else if( c2=='c' && strncmp(azArg[1],"csv",n2)==0 )\{\par
16572       p->mode = MODE_Csv;\par
16573       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Comma);\par
16574       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_CrLf);\par
16575     \}else if( c2=='t' && strncmp(azArg[1],"tabs",n2)==0 )\{\par
16576       p->mode = MODE_List;\par
16577       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Tab);\par
16578     \}else if( c2=='i' && strncmp(azArg[1],"insert",n2)==0 )\{\par
16579       p->mode = MODE_Insert;\par
16580       set_table_name(p, nArg>=3 ? azArg[2] : "table");\par
16581     \}else if( c2=='q' && strncmp(azArg[1],"quote",n2)==0 )\{\par
16582       p->mode = MODE_Quote;\par
16583     \}else if( c2=='a' && strncmp(azArg[1],"ascii",n2)==0 )\{\par
16584       p->mode = MODE_Ascii;\par
16585       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Unit);\par
16586       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_Record);\par
16587     \}else if( nArg==1 )\{\par
16588       raw_printf(p->out, "current output mode: %s\\n", modeDescr[p->mode]);\par
16589     \}else\{\par
16590       raw_printf(stderr, "Error: mode should be one of: "\par
16591          "ascii column csv html insert line list quote tabs tcl\\n");\par
16592       rc = 1;\par
16593     \}\par
16594     p->cMode = p->mode;\par
16595   \}else\par
16596 \par
16597   if( c=='n' && strncmp(azArg[0], "nullvalue", n)==0 )\{\par
16598     if( nArg==2 )\{\par
16599       sqlite3_snprintf(sizeof(p->nullValue), p->nullValue,\par
16600                        "%.*s", (int)ArraySize(p->nullValue)-1, azArg[1]);\par
16601     \}else\{\par
16602       raw_printf(stderr, "Usage: .nullvalue STRING\\n");\par
16603       rc = 1;\par
16604     \}\par
16605   \}else\par
16606 \par
16607   if( c=='o' && strncmp(azArg[0], "open", n)==0 && n>=2 )\{\par
16608     char *zNewFilename;  /* Name of the database file to open */\par
16609     int iName = 1;       /* Index in azArg[] of the filename */\par
16610     int newFlag = 0;     /* True to delete file before opening */\par
16611     /* Close the existing database */\par
16612     session_close_all(p);\par
16613     close_db(p->db);\par
16614     p->db = 0;\par
16615     p->zDbFilename = 0;\par
16616     sqlite3_free(p->zFreeOnClose);\par
16617     p->zFreeOnClose = 0;\par
16618     p->openMode = SHELL_OPEN_UNSPEC;\par
16619     p->openFlags = 0;\par
16620     p->szMax = 0;\par
16621     /* Check for command-line arguments */\par
16622     for(iName=1; iName<nArg && azArg[iName][0]=='-'; iName++)\{\par
16623       const char *z = azArg[iName];\par
16624       if( optionMatch(z,"new") )\{\par
16625         newFlag = 1;\par
16626 #ifdef SQLITE_HAVE_ZLIB\par
16627       \}else if( optionMatch(z, "zip") )\{\par
16628         p->openMode = SHELL_OPEN_ZIPFILE;\par
16629 #endif\par
16630       \}else if( optionMatch(z, "append") )\{\par
16631         p->openMode = SHELL_OPEN_APPENDVFS;\par
16632       \}else if( optionMatch(z, "readonly") )\{\par
16633         p->openMode = SHELL_OPEN_READONLY;\par
16634       \}else if( optionMatch(z, "nofollow") )\{\par
16635         p->openFlags |= SQLITE_OPEN_NOFOLLOW;\par
16636 #ifdef SQLITE_ENABLE_DESERIALIZE\par
16637       \}else if( optionMatch(z, "deserialize") )\{\par
16638         p->openMode = SHELL_OPEN_DESERIALIZE;\par
16639       \}else if( optionMatch(z, "hexdb") )\{\par
16640         p->openMode = SHELL_OPEN_HEXDB;\par
16641       \}else if( optionMatch(z, "maxsize") && iName+1<nArg )\{\par
16642         p->szMax = integerValue(azArg[++iName]);\par
16643 #endif /* SQLITE_ENABLE_DESERIALIZE */\par
16644       \}else if( z[0]=='-' )\{\par
16645         utf8_printf(stderr, "unknown option: %s\\n", z);\par
16646         rc = 1;\par
16647         goto meta_command_exit;\par
16648       \}\par
16649     \}\par
16650     /* If a filename is specified, try to open it first */\par
16651     zNewFilename = nArg>iName ? sqlite3_mprintf("%s", azArg[iName]) : 0;\par
16652     if( zNewFilename || p->openMode==SHELL_OPEN_HEXDB )\{\par
16653       if( newFlag ) shellDeleteFile(zNewFilename);\par
16654       p->zDbFilename = zNewFilename;\par
16655       open_db(p, OPEN_DB_KEEPALIVE);\par
16656       if( p->db==0 )\{\par
16657         utf8_printf(stderr, "Error: cannot open '%s'\\n", zNewFilename);\par
16658         sqlite3_free(zNewFilename);\par
16659       \}else\{\par
16660         p->zFreeOnClose = zNewFilename;\par
16661       \}\par
16662     \}\par
16663     if( p->db==0 )\{\par
16664       /* As a fall-back open a TEMP database */\par
16665       p->zDbFilename = 0;\par
16666       open_db(p, 0);\par
16667     \}\par
16668   \}else\par
16669 \par
16670   if( (c=='o'\par
16671         && (strncmp(azArg[0], "output", n)==0||strncmp(azArg[0], "once", n)==0))\par
16672    || (c=='e' && n==5 && strcmp(azArg[0],"excel")==0)\par
16673   )\{\par
16674     const char *zFile = nArg>=2 ? azArg[1] : "stdout";\par
16675     int bTxtMode = 0;\par
16676     if( azArg[0][0]=='e' )\{\par
16677       /* Transform the ".excel" command into ".once -x" */\par
16678       nArg = 2;\par
16679       azArg[0] = "once";\par
16680       zFile = azArg[1] = "-x";\par
16681       n = 4;\par
16682     \}\par
16683     if( nArg>2 )\{\par
16684       utf8_printf(stderr, "Usage: .%s [-e|-x|FILE]\\n", azArg[0]);\par
16685       rc = 1;\par
16686       goto meta_command_exit;\par
16687     \}\par
16688     if( n>1 && strncmp(azArg[0], "once", n)==0 )\{\par
16689       if( nArg<2 )\{\par
16690         raw_printf(stderr, "Usage: .once (-e|-x|FILE)\\n");\par
16691         rc = 1;\par
16692         goto meta_command_exit;\par
16693       \}\par
16694       p->outCount = 2;\par
16695     \}else\{\par
16696       p->outCount = 0;\par
16697     \}\par
16698     output_reset(p);\par
16699     if( zFile[0]=='-' && zFile[1]=='-' ) zFile++;\par
16700 #ifndef SQLITE_NOHAVE_SYSTEM\par
16701     if( strcmp(zFile, "-e")==0 || strcmp(zFile, "-x")==0 )\{\par
16702       p->doXdgOpen = 1;\par
16703       outputModePush(p);\par
16704       if( zFile[1]=='x' )\{\par
16705         newTempFile(p, "csv");\par
16706         p->mode = MODE_Csv;\par
16707         sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator, SEP_Comma);\par
16708         sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator, SEP_CrLf);\par
16709       \}else\{\par
16710         newTempFile(p, "txt");\par
16711         bTxtMode = 1;\par
16712       \}\par
16713       zFile = p->zTempFile;\par
16714     \}\par
16715 #endif /* SQLITE_NOHAVE_SYSTEM */\par
16716     if( zFile[0]=='|' )\{\par
16717 #ifdef SQLITE_OMIT_POPEN\par
16718       raw_printf(stderr, "Error: pipes are not supported in this OS\\n");\par
16719       rc = 1;\par
16720       p->out = stdout;\par
16721 #else\par
16722       p->out = popen(zFile + 1, "w");\par
16723       if( p->out==0 )\{\par
16724         utf8_printf(stderr,"Error: cannot open pipe \\"%s\\"\\n", zFile + 1);\par
16725         p->out = stdout;\par
16726         rc = 1;\par
16727       \}else\{\par
16728         sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", zFile);\par
16729       \}\par
16730 #endif\par
16731     \}else\{\par
16732       p->out = output_file_open(zFile, bTxtMode);\par
16733       if( p->out==0 )\{\par
16734         if( strcmp(zFile,"off")!=0 )\{\par
16735           utf8_printf(stderr,"Error: cannot write to \\"%s\\"\\n", zFile);\par
16736         \}\par
16737         p->out = stdout;\par
16738         rc = 1;\par
16739       \} else \{\par
16740         sqlite3_snprintf(sizeof(p->outfile), p->outfile, "%s", zFile);\par
16741       \}\par
16742     \}\par
16743   \}else\par
16744 \par
16745   if( c=='p' && n>=3 && strncmp(azArg[0], "parameter", n)==0 )\{\par
16746     open_db(p,0);\par
16747     if( nArg<=1 ) goto parameter_syntax_error;\par
16748 \par
16749     /* .parameter clear\par
16750     ** Clear all bind parameters by dropping the TEMP table that holds them.\par
16751     */\par
16752     if( nArg==2 && strcmp(azArg[1],"clear")==0 )\{\par
16753       sqlite3_exec(p->db, "DROP TABLE IF EXISTS temp.sqlite_parameters;",\par
16754                    0, 0, 0);\par
16755     \}else\par
16756 \par
16757     /* .parameter list\par
16758     ** List all bind parameters.\par
16759     */\par
16760     if( nArg==2 && strcmp(azArg[1],"list")==0 )\{\par
16761       sqlite3_stmt *pStmt = 0;\par
16762       int rx;\par
16763       int len = 0;\par
16764       rx = sqlite3_prepare_v2(p->db,\par
16765              "SELECT max(length(key)) "\par
16766              "FROM temp.sqlite_parameters;", -1, &pStmt, 0);\par
16767       if( rx==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW )\{\par
16768         len = sqlite3_column_int(pStmt, 0);\par
16769         if( len>40 ) len = 40;\par
16770       \}\par
16771       sqlite3_finalize(pStmt);\par
16772       pStmt = 0;\par
16773       if( len )\{\par
16774         rx = sqlite3_prepare_v2(p->db,\par
16775              "SELECT key, quote(value) "\par
16776              "FROM temp.sqlite_parameters;", -1, &pStmt, 0);\par
16777         while( sqlite3_step(pStmt)==SQLITE_ROW )\{\par
16778           utf8_printf(p->out, "%-*s %s\\n", len, sqlite3_column_text(pStmt,0),\par
16779                       sqlite3_column_text(pStmt,1));\par
16780         \}\par
16781         sqlite3_finalize(pStmt);\par
16782       \}\par
16783     \}else\par
16784 \par
16785     /* .parameter init\par
16786     ** Make sure the TEMP table used to hold bind parameters exists.\par
16787     ** Create it if necessary.\par
16788     */\par
16789     if( nArg==2 && strcmp(azArg[1],"init")==0 )\{\par
16790       bind_table_init(p);\par
16791     \}else\par
16792 \par
16793     /* .parameter set NAME VALUE\par
16794     ** Set or reset a bind parameter.  NAME should be the full parameter\par
16795     ** name exactly as it appears in the query.  (ex: $abc, @def).  The\par
16796     ** VALUE can be in either SQL literal notation, or if not it will be\par
16797     ** understood to be a text string.\par
16798     */\par
16799     if( nArg==4 && strcmp(azArg[1],"set")==0 )\{\par
16800       int rx;\par
16801       char *zSql;\par
16802       sqlite3_stmt *pStmt;\par
16803       const char *zKey = azArg[2];\par
16804       const char *zValue = azArg[3];\par
16805       bind_table_init(p);\par
16806       zSql = sqlite3_mprintf(\par
16807                   "REPLACE INTO temp.sqlite_parameters(key,value)"\par
16808                   "VALUES(%Q,%s);", zKey, zValue);\par
16809       if( zSql==0 ) shell_out_of_memory();\par
16810       pStmt = 0;\par
16811       rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\par
16812       sqlite3_free(zSql);\par
16813       if( rx!=SQLITE_OK )\{\par
16814         sqlite3_finalize(pStmt);\par
16815         pStmt = 0;\par
16816         zSql = sqlite3_mprintf(\par
16817                    "REPLACE INTO temp.sqlite_parameters(key,value)"\par
16818                    "VALUES(%Q,%Q);", zKey, zValue);\par
16819         if( zSql==0 ) shell_out_of_memory();\par
16820         rx = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\par
16821         sqlite3_free(zSql);\par
16822         if( rx!=SQLITE_OK )\{\par
16823           utf8_printf(p->out, "Error: %s\\n", sqlite3_errmsg(p->db));\par
16824           sqlite3_finalize(pStmt);\par
16825           pStmt = 0;\par
16826           rc = 1;\par
16827         \}\par
16828       \}\par
16829       sqlite3_step(pStmt);\par
16830       sqlite3_finalize(pStmt);\par
16831     \}else\par
16832 \par
16833     /* .parameter unset NAME\par
16834     ** Remove the NAME binding from the parameter binding table, if it\par
16835     ** exists.\par
16836     */\par
16837     if( nArg==3 && strcmp(azArg[1],"unset")==0 )\{\par
16838       char *zSql = sqlite3_mprintf(\par
16839           "DELETE FROM temp.sqlite_parameters WHERE key=%Q", azArg[2]);\par
16840       if( zSql==0 ) shell_out_of_memory();\par
16841       sqlite3_exec(p->db, zSql, 0, 0, 0);\par
16842       sqlite3_free(zSql);\par
16843     \}else\par
16844     /* If no command name matches, show a syntax error */\par
16845     parameter_syntax_error:\par
16846     showHelp(p->out, "parameter");\par
16847   \}else\par
16848 \par
16849   if( c=='p' && n>=3 && strncmp(azArg[0], "print", n)==0 )\{\par
16850     int i;\par
16851     for(i=1; i<nArg; i++)\{\par
16852       if( i>1 ) raw_printf(p->out, " ");\par
16853       utf8_printf(p->out, "%s", azArg[i]);\par
16854     \}\par
16855     raw_printf(p->out, "\\n");\par
16856   \}else\par
16857 \par
16858 #ifndef SQLITE_OMIT_PROGRESS_CALLBACK\par
16859   if( c=='p' && n>=3 && strncmp(azArg[0], "progress", n)==0 )\{\par
16860     int i;\par
16861     int nn = 0;\par
16862     p->flgProgress = 0;\par
16863     p->mxProgress = 0;\par
16864     p->nProgress = 0;\par
16865     for(i=1; i<nArg; i++)\{\par
16866       const char *z = azArg[i];\par
16867       if( z[0]=='-' )\{\par
16868         z++;\par
16869         if( z[0]=='-' ) z++;\par
16870         if( strcmp(z,"quiet")==0 || strcmp(z,"q")==0 )\{\par
16871           p->flgProgress |= SHELL_PROGRESS_QUIET;\par
16872           continue;\par
16873         \}\par
16874         if( strcmp(z,"reset")==0 )\{\par
16875           p->flgProgress |= SHELL_PROGRESS_RESET;\par
16876           continue;\par
16877         \}\par
16878         if( strcmp(z,"once")==0 )\{\par
16879           p->flgProgress |= SHELL_PROGRESS_ONCE;\par
16880           continue;\par
16881         \}\par
16882         if( strcmp(z,"limit")==0 )\{\par
16883           if( i+1>=nArg )\{\par
16884             utf8_printf(stderr, "Error: missing argument on --limit\\n");\par
16885             rc = 1;\par
16886             goto meta_command_exit;\par
16887           \}else\{\par
16888             p->mxProgress = (int)integerValue(azArg[++i]);\par
16889           \}\par
16890           continue;\par
16891         \}\par
16892         utf8_printf(stderr, "Error: unknown option: \\"%s\\"\\n", azArg[i]);\par
16893         rc = 1;\par
16894         goto meta_command_exit;\par
16895       \}else\{\par
16896         nn = (int)integerValue(z);\par
16897       \}\par
16898     \}\par
16899     open_db(p, 0);\par
16900     sqlite3_progress_handler(p->db, nn, progress_handler, p);\par
16901   \}else\par
16902 #endif /* SQLITE_OMIT_PROGRESS_CALLBACK */\par
16903 \par
16904   if( c=='p' && strncmp(azArg[0], "prompt", n)==0 )\{\par
16905     if( nArg >= 2) \{\par
16906       strncpy(mainPrompt,azArg[1],(int)ArraySize(mainPrompt)-1);\par
16907     \}\par
16908     if( nArg >= 3) \{\par
16909       strncpy(continuePrompt,azArg[2],(int)ArraySize(continuePrompt)-1);\par
16910     \}\par
16911   \}else\par
16912 \par
16913   if( c=='q' && strncmp(azArg[0], "quit", n)==0 )\{\par
16914     rc = 2;\par
16915   \}else\par
16916 \par
16917   if( c=='r' && n>=3 && strncmp(azArg[0], "read", n)==0 )\{\par
16918     FILE *inSaved = p->in;\par
16919     int savedLineno = p->lineno;\par
16920     if( nArg!=2 )\{\par
16921       raw_printf(stderr, "Usage: .read FILE\\n");\par
16922       rc = 1;\par
16923       goto meta_command_exit;\par
16924     \}\par
16925     p->in = fopen(azArg[1], "rb");\par
16926     if( p->in==0 )\{\par
16927       utf8_printf(stderr,"Error: cannot open \\"%s\\"\\n", azArg[1]);\par
16928       rc = 1;\par
16929     \}else\{\par
16930       rc = process_input(p);\par
16931       fclose(p->in);\par
16932     \}\par
16933     p->in = inSaved;\par
16934     p->lineno = savedLineno;\par
16935   \}else\par
16936 \par
16937   if( c=='r' && n>=3 && strncmp(azArg[0], "restore", n)==0 )\{\par
16938     const char *zSrcFile;\par
16939     const char *zDb;\par
16940     sqlite3 *pSrc;\par
16941     sqlite3_backup *pBackup;\par
16942     int nTimeout = 0;\par
16943 \par
16944     if( nArg==2 )\{\par
16945       zSrcFile = azArg[1];\par
16946       zDb = "main";\par
16947     \}else if( nArg==3 )\{\par
16948       zSrcFile = azArg[2];\par
16949       zDb = azArg[1];\par
16950     \}else\{\par
16951       raw_printf(stderr, "Usage: .restore ?DB? FILE\\n");\par
16952       rc = 1;\par
16953       goto meta_command_exit;\par
16954     \}\par
16955     rc = sqlite3_open(zSrcFile, &pSrc);\par
16956     if( rc!=SQLITE_OK )\{\par
16957       utf8_printf(stderr, "Error: cannot open \\"%s\\"\\n", zSrcFile);\par
16958       close_db(pSrc);\par
16959       return 1;\par
16960     \}\par
16961     open_db(p, 0);\par
16962     pBackup = sqlite3_backup_init(p->db, zDb, pSrc, "main");\par
16963     if( pBackup==0 )\{\par
16964       utf8_printf(stderr, "Error: %s\\n", sqlite3_errmsg(p->db));\par
16965       close_db(pSrc);\par
16966       return 1;\par
16967     \}\par
16968     while( (rc = sqlite3_backup_step(pBackup,100))==SQLITE_OK\par
16969           || rc==SQLITE_BUSY  )\{\par
16970       if( rc==SQLITE_BUSY )\{\par
16971         if( nTimeout++ >= 3 ) break;\par
16972         sqlite3_sleep(100);\par
16973       \}\par
16974     \}\par
16975     sqlite3_backup_finish(pBackup);\par
16976     if( rc==SQLITE_DONE )\{\par
16977       rc = 0;\par
16978     \}else if( rc==SQLITE_BUSY || rc==SQLITE_LOCKED )\{\par
16979       raw_printf(stderr, "Error: source database is busy\\n");\par
16980       rc = 1;\par
16981     \}else\{\par
16982       utf8_printf(stderr, "Error: %s\\n", sqlite3_errmsg(p->db));\par
16983       rc = 1;\par
16984     \}\par
16985     close_db(pSrc);\par
16986   \}else\par
16987 \par
16988   if( c=='s' && strncmp(azArg[0], "scanstats", n)==0 )\{\par
16989     if( nArg==2 )\{\par
16990       p->scanstatsOn = (u8)booleanValue(azArg[1]);\par
16991 #ifndef SQLITE_ENABLE_STMT_SCANSTATUS\par
16992       raw_printf(stderr, "Warning: .scanstats not available in this build.\\n");\par
16993 #endif\par
16994     \}else\{\par
16995       raw_printf(stderr, "Usage: .scanstats on|off\\n");\par
16996       rc = 1;\par
16997     \}\par
16998   \}else\par
16999 \par
17000   if( c=='s' && strncmp(azArg[0], "schema", n)==0 )\{\par
17001     ShellText sSelect;\par
17002     ShellState data;\par
17003     char *zErrMsg = 0;\par
17004     const char *zDiv = "(";\par
17005     const char *zName = 0;\par
17006     int iSchema = 0;\par
17007     int bDebug = 0;\par
17008     int ii;\par
17009 \par
17010     open_db(p, 0);\par
17011     memcpy(&data, p, sizeof(data));\par
17012     data.showHeader = 0;\par
17013     data.cMode = data.mode = MODE_Semi;\par
17014     initText(&sSelect);\par
17015     for(ii=1; ii<nArg; ii++)\{\par
17016       if( optionMatch(azArg[ii],"indent") )\{\par
17017         data.cMode = data.mode = MODE_Pretty;\par
17018       \}else if( optionMatch(azArg[ii],"debug") )\{\par
17019         bDebug = 1;\par
17020       \}else if( zName==0 )\{\par
17021         zName = azArg[ii];\par
17022       \}else\{\par
17023         raw_printf(stderr, "Usage: .schema ?--indent? ?LIKE-PATTERN?\\n");\par
17024         rc = 1;\par
17025         goto meta_command_exit;\par
17026       \}\par
17027     \}\par
17028     if( zName!=0 )\{\par
17029       int isMaster = sqlite3_strlike(zName, "sqlite_master", '\\\\')==0;\par
17030       if( isMaster || sqlite3_strlike(zName,"sqlite_temp_master", '\\\\')==0 )\{\par
17031         char *new_argv[2], *new_colv[2];\par
17032         new_argv[0] = sqlite3_mprintf(\par
17033                       "CREATE TABLE %s (\\n"\par
17034                       "  type text,\\n"\par
17035                       "  name text,\\n"\par
17036                       "  tbl_name text,\\n"\par
17037                       "  rootpage integer,\\n"\par
17038                       "  sql text\\n"\par
17039                       ")", isMaster ? "sqlite_master" : "sqlite_temp_master");\par
17040         new_argv[1] = 0;\par
17041         new_colv[0] = "sql";\par
17042         new_colv[1] = 0;\par
17043         callback(&data, 1, new_argv, new_colv);\par
17044         sqlite3_free(new_argv[0]);\par
17045       \}\par
17046     \}\par
17047     if( zDiv )\{\par
17048       sqlite3_stmt *pStmt = 0;\par
17049       rc = sqlite3_prepare_v2(p->db, "SELECT name FROM pragma_database_list",\par
17050                               -1, &pStmt, 0);\par
17051       if( rc )\{\par
17052         utf8_printf(stderr, "Error: %s\\n", sqlite3_errmsg(p->db));\par
17053         sqlite3_finalize(pStmt);\par
17054         rc = 1;\par
17055         goto meta_command_exit;\par
17056       \}\par
17057       appendText(&sSelect, "SELECT sql FROM", 0);\par
17058       iSchema = 0;\par
17059       while( sqlite3_step(pStmt)==SQLITE_ROW )\{\par
17060         const char *zDb = (const char*)sqlite3_column_text(pStmt, 0);\par
17061         char zScNum[30];\par
17062         sqlite3_snprintf(sizeof(zScNum), zScNum, "%d", ++iSchema);\par
17063         appendText(&sSelect, zDiv, 0);\par
17064         zDiv = " UNION ALL ";\par
17065         appendText(&sSelect, "SELECT shell_add_schema(sql,", 0);\par
17066         if( sqlite3_stricmp(zDb, "main")!=0 )\{\par
17067           appendText(&sSelect, zDb, '\\'');\par
17068         \}else\{\par
17069           appendText(&sSelect, "NULL", 0);\par
17070         \}\par
17071         appendText(&sSelect, ",name) AS sql, type, tbl_name, name, rowid,", 0);\par
17072         appendText(&sSelect, zScNum, 0);\par
17073         appendText(&sSelect, " AS snum, ", 0);\par
17074         appendText(&sSelect, zDb, '\\'');\par
17075         appendText(&sSelect, " AS sname FROM ", 0);\par
17076         appendText(&sSelect, zDb, quoteChar(zDb));\par
17077         appendText(&sSelect, ".sqlite_master", 0);\par
17078       \}\par
17079       sqlite3_finalize(pStmt);\par
17080 #ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS\par
17081       if( zName )\{\par
17082         appendText(&sSelect,\par
17083            " UNION ALL SELECT shell_module_schema(name),"\par
17084            " 'table', name, name, name, 9e+99, 'main' FROM pragma_module_list",\par
17085         0);\par
17086       \}\par
17087 #endif\par
17088       appendText(&sSelect, ") WHERE ", 0);\par
17089       if( zName )\{\par
17090         char *zQarg = sqlite3_mprintf("%Q", zName);\par
17091         int bGlob = strchr(zName, '*') != 0 || strchr(zName, '?') != 0 ||\par
17092                     strchr(zName, '[') != 0;\par
17093         if( strchr(zName, '.') )\{\par
17094           appendText(&sSelect, "lower(printf('%s.%s',sname,tbl_name))", 0);\par
17095         \}else\{\par
17096           appendText(&sSelect, "lower(tbl_name)", 0);\par
17097         \}\par
17098         appendText(&sSelect, bGlob ? " GLOB " : " LIKE ", 0);\par
17099         appendText(&sSelect, zQarg, 0);\par
17100         if( !bGlob )\{\par
17101           appendText(&sSelect, " ESCAPE '\\\\' ", 0);\par
17102         \}\par
17103         appendText(&sSelect, " AND ", 0);\par
17104         sqlite3_free(zQarg);\par
17105       \}\par
17106       appendText(&sSelect, "type!='meta' AND sql IS NOT NULL"\par
17107                            " ORDER BY snum, rowid", 0);\par
17108       if( bDebug )\{\par
17109         utf8_printf(p->out, "SQL: %s;\\n", sSelect.z);\par
17110       \}else\{\par
17111         rc = sqlite3_exec(p->db, sSelect.z, callback, &data, &zErrMsg);\par
17112       \}\par
17113       freeText(&sSelect);\par
17114     \}\par
17115     if( zErrMsg )\{\par
17116       utf8_printf(stderr,"Error: %s\\n", zErrMsg);\par
17117       sqlite3_free(zErrMsg);\par
17118       rc = 1;\par
17119     \}else if( rc != SQLITE_OK )\{\par
17120       raw_printf(stderr,"Error: querying schema information\\n");\par
17121       rc = 1;\par
17122     \}else\{\par
17123       rc = 0;\par
17124     \}\par
17125   \}else\par
17126 \par
17127 #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_SELECTTRACE)\par
17128   if( c=='s' && n==11 && strncmp(azArg[0], "selecttrace", n)==0 )\{\par
17129     sqlite3SelectTrace = (int)integerValue(azArg[1]);\par
17130   \}else\par
17131 #endif\par
17132 \par
17133 #if defined(SQLITE_ENABLE_SESSION)\par
17134   if( c=='s' && strncmp(azArg[0],"session",n)==0 && n>=3 )\{\par
17135     OpenSession *pSession = &p->aSession[0];\par
17136     char **azCmd = &azArg[1];\par
17137     int iSes = 0;\par
17138     int nCmd = nArg - 1;\par
17139     int i;\par
17140     if( nArg<=1 ) goto session_syntax_error;\par
17141     open_db(p, 0);\par
17142     if( nArg>=3 )\{\par
17143       for(iSes=0; iSes<p->nSession; iSes++)\{\par
17144         if( strcmp(p->aSession[iSes].zName, azArg[1])==0 ) break;\par
17145       \}\par
17146       if( iSes<p->nSession )\{\par
17147         pSession = &p->aSession[iSes];\par
17148         azCmd++;\par
17149         nCmd--;\par
17150       \}else\{\par
17151         pSession = &p->aSession[0];\par
17152         iSes = 0;\par
17153       \}\par
17154     \}\par
17155 \par
17156     /* .session attach TABLE\par
17157     ** Invoke the sqlite3session_attach() interface to attach a particular\par
17158     ** table so that it is never filtered.\par
17159     */\par
17160     if( strcmp(azCmd[0],"attach")==0 )\{\par
17161       if( nCmd!=2 ) goto session_syntax_error;\par
17162       if( pSession->p==0 )\{\par
17163         session_not_open:\par
17164         raw_printf(stderr, "ERROR: No sessions are open\\n");\par
17165       \}else\{\par
17166         rc = sqlite3session_attach(pSession->p, azCmd[1]);\par
17167         if( rc )\{\par
17168           raw_printf(stderr, "ERROR: sqlite3session_attach() returns %d\\n", rc);\par
17169           rc = 0;\par
17170         \}\par
17171       \}\par
17172     \}else\par
17173 \par
17174     /* .session changeset FILE\par
17175     ** .session patchset FILE\par
17176     ** Write a changeset or patchset into a file.  The file is overwritten.\par
17177     */\par
17178     if( strcmp(azCmd[0],"changeset")==0 || strcmp(azCmd[0],"patchset")==0 )\{\par
17179       FILE *out = 0;\par
17180       if( nCmd!=2 ) goto session_syntax_error;\par
17181       if( pSession->p==0 ) goto session_not_open;\par
17182       out = fopen(azCmd[1], "wb");\par
17183       if( out==0 )\{\par
17184         utf8_printf(stderr, "ERROR: cannot open \\"%s\\" for writing\\n",\par
17185                     azCmd[1]);\par
17186       \}else\{\par
17187         int szChng;\par
17188         void *pChng;\par
17189         if( azCmd[0][0]=='c' )\{\par
17190           rc = sqlite3session_changeset(pSession->p, &szChng, &pChng);\par
17191         \}else\{\par
17192           rc = sqlite3session_patchset(pSession->p, &szChng, &pChng);\par
17193         \}\par
17194         if( rc )\{\par
17195           printf("Error: error code %d\\n", rc);\par
17196           rc = 0;\par
17197         \}\par
17198         if( pChng\par
17199           && fwrite(pChng, szChng, 1, out)!=1 )\{\par
17200           raw_printf(stderr, "ERROR: Failed to write entire %d-byte output\\n",\par
17201                   szChng);\par
17202         \}\par
17203         sqlite3_free(pChng);\par
17204         fclose(out);\par
17205       \}\par
17206     \}else\par
17207 \par
17208     /* .session close\par
17209     ** Close the identified session\par
17210     */\par
17211     if( strcmp(azCmd[0], "close")==0 )\{\par
17212       if( nCmd!=1 ) goto session_syntax_error;\par
17213       if( p->nSession )\{\par
17214         session_close(pSession);\par
17215         p->aSession[iSes] = p->aSession[--p->nSession];\par
17216       \}\par
17217     \}else\par
17218 \par
17219     /* .session enable ?BOOLEAN?\par
17220     ** Query or set the enable flag\par
17221     */\par
17222     if( strcmp(azCmd[0], "enable")==0 )\{\par
17223       int ii;\par
17224       if( nCmd>2 ) goto session_syntax_error;\par
17225       ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);\par
17226       if( p->nSession )\{\par
17227         ii = sqlite3session_enable(pSession->p, ii);\par
17228         utf8_printf(p->out, "session %s enable flag = %d\\n",\par
17229                     pSession->zName, ii);\par
17230       \}\par
17231     \}else\par
17232 \par
17233     /* .session filter GLOB ....\par
17234     ** Set a list of GLOB patterns of table names to be excluded.\par
17235     */\par
17236     if( strcmp(azCmd[0], "filter")==0 )\{\par
17237       int ii, nByte;\par
17238       if( nCmd<2 ) goto session_syntax_error;\par
17239       if( p->nSession )\{\par
17240         for(ii=0; ii<pSession->nFilter; ii++)\{\par
17241           sqlite3_free(pSession->azFilter[ii]);\par
17242         \}\par
17243         sqlite3_free(pSession->azFilter);\par
17244         nByte = sizeof(pSession->azFilter[0])*(nCmd-1);\par
17245         pSession->azFilter = sqlite3_malloc( nByte );\par
17246         if( pSession->azFilter==0 )\{\par
17247           raw_printf(stderr, "Error: out or memory\\n");\par
17248           exit(1);\par
17249         \}\par
17250         for(ii=1; ii<nCmd; ii++)\{\par
17251           pSession->azFilter[ii-1] = sqlite3_mprintf("%s", azCmd[ii]);\par
17252         \}\par
17253         pSession->nFilter = ii-1;\par
17254       \}\par
17255     \}else\par
17256 \par
17257     /* .session indirect ?BOOLEAN?\par
17258     ** Query or set the indirect flag\par
17259     */\par
17260     if( strcmp(azCmd[0], "indirect")==0 )\{\par
17261       int ii;\par
17262       if( nCmd>2 ) goto session_syntax_error;\par
17263       ii = nCmd==1 ? -1 : booleanValue(azCmd[1]);\par
17264       if( p->nSession )\{\par
17265         ii = sqlite3session_indirect(pSession->p, ii);\par
17266         utf8_printf(p->out, "session %s indirect flag = %d\\n",\par
17267                     pSession->zName, ii);\par
17268       \}\par
17269     \}else\par
17270 \par
17271     /* .session isempty\par
17272     ** Determine if the session is empty\par
17273     */\par
17274     if( strcmp(azCmd[0], "isempty")==0 )\{\par
17275       int ii;\par
17276       if( nCmd!=1 ) goto session_syntax_error;\par
17277       if( p->nSession )\{\par
17278         ii = sqlite3session_isempty(pSession->p);\par
17279         utf8_printf(p->out, "session %s isempty flag = %d\\n",\par
17280                     pSession->zName, ii);\par
17281       \}\par
17282     \}else\par
17283 \par
17284     /* .session list\par
17285     ** List all currently open sessions\par
17286     */\par
17287     if( strcmp(azCmd[0],"list")==0 )\{\par
17288       for(i=0; i<p->nSession; i++)\{\par
17289         utf8_printf(p->out, "%d %s\\n", i, p->aSession[i].zName);\par
17290       \}\par
17291     \}else\par
17292 \par
17293     /* .session open DB NAME\par
17294     ** Open a new session called NAME on the attached database DB.\par
17295     ** DB is normally "main".\par
17296     */\par
17297     if( strcmp(azCmd[0],"open")==0 )\{\par
17298       char *zName;\par
17299       if( nCmd!=3 ) goto session_syntax_error;\par
17300       zName = azCmd[2];\par
17301       if( zName[0]==0 ) goto session_syntax_error;\par
17302       for(i=0; i<p->nSession; i++)\{\par
17303         if( strcmp(p->aSession[i].zName,zName)==0 )\{\par
17304           utf8_printf(stderr, "Session \\"%s\\" already exists\\n", zName);\par
17305           goto meta_command_exit;\par
17306         \}\par
17307       \}\par
17308       if( p->nSession>=ArraySize(p->aSession) )\{\par
17309         raw_printf(stderr, "Maximum of %d sessions\\n", ArraySize(p->aSession));\par
17310         goto meta_command_exit;\par
17311       \}\par
17312       pSession = &p->aSession[p->nSession];\par
17313       rc = sqlite3session_create(p->db, azCmd[1], &pSession->p);\par
17314       if( rc )\{\par
17315         raw_printf(stderr, "Cannot open session: error code=%d\\n", rc);\par
17316         rc = 0;\par
17317         goto meta_command_exit;\par
17318       \}\par
17319       pSession->nFilter = 0;\par
17320       sqlite3session_table_filter(pSession->p, session_filter, pSession);\par
17321       p->nSession++;\par
17322       pSession->zName = sqlite3_mprintf("%s", zName);\par
17323     \}else\par
17324     /* If no command name matches, show a syntax error */\par
17325     session_syntax_error:\par
17326     showHelp(p->out, "session");\par
17327   \}else\par
17328 #endif\par
17329 \par
17330 #ifdef SQLITE_DEBUG\par
17331   /* Undocumented commands for internal testing.  Subject to change\par
17332   ** without notice. */\par
17333   if( c=='s' && n>=10 && strncmp(azArg[0], "selftest-", 9)==0 )\{\par
17334     if( strncmp(azArg[0]+9, "boolean", n-9)==0 )\{\par
17335       int i, v;\par
17336       for(i=1; i<nArg; i++)\{\par
17337         v = booleanValue(azArg[i]);\par
17338         utf8_printf(p->out, "%s: %d 0x%x\\n", azArg[i], v, v);\par
17339       \}\par
17340     \}\par
17341     if( strncmp(azArg[0]+9, "integer", n-9)==0 )\{\par
17342       int i; sqlite3_int64 v;\par
17343       for(i=1; i<nArg; i++)\{\par
17344         char zBuf[200];\par
17345         v = integerValue(azArg[i]);\par
17346         sqlite3_snprintf(sizeof(zBuf),zBuf,"%s: %lld 0x%llx\\n", azArg[i],v,v);\par
17347         utf8_printf(p->out, "%s", zBuf);\par
17348       \}\par
17349     \}\par
17350   \}else\par
17351 #endif\par
17352 \par
17353   if( c=='s' && n>=4 && strncmp(azArg[0],"selftest",n)==0 )\{\par
17354     int bIsInit = 0;         /* True to initialize the SELFTEST table */\par
17355     int bVerbose = 0;        /* Verbose output */\par
17356     int bSelftestExists;     /* True if SELFTEST already exists */\par
17357     int i, k;                /* Loop counters */\par
17358     int nTest = 0;           /* Number of tests runs */\par
17359     int nErr = 0;            /* Number of errors seen */\par
17360     ShellText str;           /* Answer for a query */\par
17361     sqlite3_stmt *pStmt = 0; /* Query against the SELFTEST table */\par
17362 \par
17363     open_db(p,0);\par
17364     for(i=1; i<nArg; i++)\{\par
17365       const char *z = azArg[i];\par
17366       if( z[0]=='-' && z[1]=='-' ) z++;\par
17367       if( strcmp(z,"-init")==0 )\{\par
17368         bIsInit = 1;\par
17369       \}else\par
17370       if( strcmp(z,"-v")==0 )\{\par
17371         bVerbose++;\par
17372       \}else\par
17373       \{\par
17374         utf8_printf(stderr, "Unknown option \\"%s\\" on \\"%s\\"\\n",\par
17375                     azArg[i], azArg[0]);\par
17376         raw_printf(stderr, "Should be one of: --init -v\\n");\par
17377         rc = 1;\par
17378         goto meta_command_exit;\par
17379       \}\par
17380     \}\par
17381     if( sqlite3_table_column_metadata(p->db,"main","selftest",0,0,0,0,0,0)\par
17382            != SQLITE_OK )\{\par
17383       bSelftestExists = 0;\par
17384     \}else\{\par
17385       bSelftestExists = 1;\par
17386     \}\par
17387     if( bIsInit )\{\par
17388       createSelftestTable(p);\par
17389       bSelftestExists = 1;\par
17390     \}\par
17391     initText(&str);\par
17392     appendText(&str, "x", 0);\par
17393     for(k=bSelftestExists; k>=0; k--)\{\par
17394       if( k==1 )\{\par
17395         rc = sqlite3_prepare_v2(p->db,\par
17396             "SELECT tno,op,cmd,ans FROM selftest ORDER BY tno",\par
17397             -1, &pStmt, 0);\par
17398       \}else\{\par
17399         rc = sqlite3_prepare_v2(p->db,\par
17400           "VALUES(0,'memo','Missing SELFTEST table - default checks only',''),"\par
17401           "      (1,'run','PRAGMA integrity_check','ok')",\par
17402           -1, &pStmt, 0);\par
17403       \}\par
17404       if( rc )\{\par
17405         raw_printf(stderr, "Error querying the selftest table\\n");\par
17406         rc = 1;\par
17407         sqlite3_finalize(pStmt);\par
17408         goto meta_command_exit;\par
17409       \}\par
17410       for(i=1; sqlite3_step(pStmt)==SQLITE_ROW; i++)\{\par
17411         int tno = sqlite3_column_int(pStmt, 0);\par
17412         const char *zOp = (const char*)sqlite3_column_text(pStmt, 1);\par
17413         const char *zSql = (const char*)sqlite3_column_text(pStmt, 2);\par
17414         const char *zAns = (const char*)sqlite3_column_text(pStmt, 3);\par
17415 \par
17416         k = 0;\par
17417         if( bVerbose>0 )\{\par
17418           char *zQuote = sqlite3_mprintf("%q", zSql);\par
17419           printf("%d: %s %s\\n", tno, zOp, zSql);\par
17420           sqlite3_free(zQuote);\par
17421         \}\par
17422         if( strcmp(zOp,"memo")==0 )\{\par
17423           utf8_printf(p->out, "%s\\n", zSql);\par
17424         \}else\par
17425         if( strcmp(zOp,"run")==0 )\{\par
17426           char *zErrMsg = 0;\par
17427           str.n = 0;\par
17428           str.z[0] = 0;\par
17429           rc = sqlite3_exec(p->db, zSql, captureOutputCallback, &str, &zErrMsg);\par
17430           nTest++;\par
17431           if( bVerbose )\{\par
17432             utf8_printf(p->out, "Result: %s\\n", str.z);\par
17433           \}\par
17434           if( rc || zErrMsg )\{\par
17435             nErr++;\par
17436             rc = 1;\par
17437             utf8_printf(p->out, "%d: error-code-%d: %s\\n", tno, rc, zErrMsg);\par
17438             sqlite3_free(zErrMsg);\par
17439           \}else if( strcmp(zAns,str.z)!=0 )\{\par
17440             nErr++;\par
17441             rc = 1;\par
17442             utf8_printf(p->out, "%d: Expected: [%s]\\n", tno, zAns);\par
17443             utf8_printf(p->out, "%d:      Got: [%s]\\n", tno, str.z);\par
17444           \}\par
17445         \}else\par
17446         \{\par
17447           utf8_printf(stderr,\par
17448             "Unknown operation \\"%s\\" on selftest line %d\\n", zOp, tno);\par
17449           rc = 1;\par
17450           break;\par
17451         \}\par
17452       \} /* End loop over rows of content from SELFTEST */\par
17453       sqlite3_finalize(pStmt);\par
17454     \} /* End loop over k */\par
17455     freeText(&str);\par
17456     utf8_printf(p->out, "%d errors out of %d tests\\n", nErr, nTest);\par
17457   \}else\par
17458 \par
17459   if( c=='s' && strncmp(azArg[0], "separator", n)==0 )\{\par
17460     if( nArg<2 || nArg>3 )\{\par
17461       raw_printf(stderr, "Usage: .separator COL ?ROW?\\n");\par
17462       rc = 1;\par
17463     \}\par
17464     if( nArg>=2 )\{\par
17465       sqlite3_snprintf(sizeof(p->colSeparator), p->colSeparator,\par
17466                        "%.*s", (int)ArraySize(p->colSeparator)-1, azArg[1]);\par
17467     \}\par
17468     if( nArg>=3 )\{\par
17469       sqlite3_snprintf(sizeof(p->rowSeparator), p->rowSeparator,\par
17470                        "%.*s", (int)ArraySize(p->rowSeparator)-1, azArg[2]);\par
17471     \}\par
17472   \}else\par
17473 \par
17474   if( c=='s' && n>=4 && strncmp(azArg[0],"sha3sum",n)==0 )\{\par
17475     const char *zLike = 0;   /* Which table to checksum. 0 means everything */\par
17476     int i;                   /* Loop counter */\par
17477     int bSchema = 0;         /* Also hash the schema */\par
17478     int bSeparate = 0;       /* Hash each table separately */\par
17479     int iSize = 224;         /* Hash algorithm to use */\par
17480     int bDebug = 0;          /* Only show the query that would have run */\par
17481     sqlite3_stmt *pStmt;     /* For querying tables names */\par
17482     char *zSql;              /* SQL to be run */\par
17483     char *zSep;              /* Separator */\par
17484     ShellText sSql;          /* Complete SQL for the query to run the hash */\par
17485     ShellText sQuery;        /* Set of queries used to read all content */\par
17486     open_db(p, 0);\par
17487     for(i=1; i<nArg; i++)\{\par
17488       const char *z = azArg[i];\par
17489       if( z[0]=='-' )\{\par
17490         z++;\par
17491         if( z[0]=='-' ) z++;\par
17492         if( strcmp(z,"schema")==0 )\{\par
17493           bSchema = 1;\par
17494         \}else\par
17495         if( strcmp(z,"sha3-224")==0 || strcmp(z,"sha3-256")==0\par
17496          || strcmp(z,"sha3-384")==0 || strcmp(z,"sha3-512")==0\par
17497         )\{\par
17498           iSize = atoi(&z[5]);\par
17499         \}else\par
17500         if( strcmp(z,"debug")==0 )\{\par
17501           bDebug = 1;\par
17502         \}else\par
17503         \{\par
17504           utf8_printf(stderr, "Unknown option \\"%s\\" on \\"%s\\"\\n",\par
17505                       azArg[i], azArg[0]);\par
17506           showHelp(p->out, azArg[0]);\par
17507           rc = 1;\par
17508           goto meta_command_exit;\par
17509         \}\par
17510       \}else if( zLike )\{\par
17511         raw_printf(stderr, "Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\\n");\par
17512         rc = 1;\par
17513         goto meta_command_exit;\par
17514       \}else\{\par
17515         zLike = z;\par
17516         bSeparate = 1;\par
17517         if( sqlite3_strlike("sqlite\\\\_%", zLike, '\\\\')==0 ) bSchema = 1;\par
17518       \}\par
17519     \}\par
17520     if( bSchema )\{\par
17521       zSql = "SELECT lower(name) FROM sqlite_master"\par
17522              " WHERE type='table' AND coalesce(rootpage,0)>1"\par
17523              " UNION ALL SELECT 'sqlite_master'"\par
17524              " ORDER BY 1 collate nocase";\par
17525     \}else\{\par
17526       zSql = "SELECT lower(name) FROM sqlite_master"\par
17527              " WHERE type='table' AND coalesce(rootpage,0)>1"\par
17528              " AND name NOT LIKE 'sqlite_%'"\par
17529              " ORDER BY 1 collate nocase";\par
17530     \}\par
17531     sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\par
17532     initText(&sQuery);\par
17533     initText(&sSql);\par
17534     appendText(&sSql, "WITH [sha3sum$query](a,b) AS(",0);\par
17535     zSep = "VALUES(";\par
17536     while( SQLITE_ROW==sqlite3_step(pStmt) )\{\par
17537       const char *zTab = (const char*)sqlite3_column_text(pStmt,0);\par
17538       if( zLike && sqlite3_strlike(zLike, zTab, 0)!=0 ) continue;\par
17539       if( strncmp(zTab, "sqlite_",7)!=0 )\{\par
17540         appendText(&sQuery,"SELECT * FROM ", 0);\par
17541         appendText(&sQuery,zTab,'"');\par
17542         appendText(&sQuery," NOT INDEXED;", 0);\par
17543       \}else if( strcmp(zTab, "sqlite_master")==0 )\{\par
17544         appendText(&sQuery,"SELECT type,name,tbl_name,sql FROM sqlite_master"\par
17545                            " ORDER BY name;", 0);\par
17546       \}else if( strcmp(zTab, "sqlite_sequence")==0 )\{\par
17547         appendText(&sQuery,"SELECT name,seq FROM sqlite_sequence"\par
17548                            " ORDER BY name;", 0);\par
17549       \}else if( strcmp(zTab, "sqlite_stat1")==0 )\{\par
17550         appendText(&sQuery,"SELECT tbl,idx,stat FROM sqlite_stat1"\par
17551                            " ORDER BY tbl,idx;", 0);\par
17552       \}else if( strcmp(zTab, "sqlite_stat4")==0 )\{\par
17553         appendText(&sQuery, "SELECT * FROM ", 0);\par
17554         appendText(&sQuery, zTab, 0);\par
17555         appendText(&sQuery, " ORDER BY tbl, idx, rowid;\\n", 0);\par
17556       \}\par
17557       appendText(&sSql, zSep, 0);\par
17558       appendText(&sSql, sQuery.z, '\\'');\par
17559       sQuery.n = 0;\par
17560       appendText(&sSql, ",", 0);\par
17561       appendText(&sSql, zTab, '\\'');\par
17562       zSep = "),(";\par
17563     \}\par
17564     sqlite3_finalize(pStmt);\par
17565     if( bSeparate )\{\par
17566       zSql = sqlite3_mprintf(\par
17567           "%s))"\par
17568           " SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label"\par
17569           "   FROM [sha3sum$query]",\par
17570           sSql.z, iSize);\par
17571     \}else\{\par
17572       zSql = sqlite3_mprintf(\par
17573           "%s))"\par
17574           " SELECT lower(hex(sha3_query(group_concat(a,''),%d))) AS hash"\par
17575           "   FROM [sha3sum$query]",\par
17576           sSql.z, iSize);\par
17577     \}\par
17578     freeText(&sQuery);\par
17579     freeText(&sSql);\par
17580     if( bDebug )\{\par
17581       utf8_printf(p->out, "%s\\n", zSql);\par
17582     \}else\{\par
17583       shell_exec(p, zSql, 0);\par
17584     \}\par
17585     sqlite3_free(zSql);\par
17586   \}else\par
17587 \par
17588 #ifndef SQLITE_NOHAVE_SYSTEM\par
17589   if( c=='s'\par
17590    && (strncmp(azArg[0], "shell", n)==0 || strncmp(azArg[0],"system",n)==0)\par
17591   )\{\par
17592     char *zCmd;\par
17593     int i, x;\par
17594     if( nArg<2 )\{\par
17595       raw_printf(stderr, "Usage: .system COMMAND\\n");\par
17596       rc = 1;\par
17597       goto meta_command_exit;\par
17598     \}\par
17599     zCmd = sqlite3_mprintf(strchr(azArg[1],' ')==0?"%s":"\\"%s\\"", azArg[1]);\par
17600     for(i=2; i<nArg; i++)\{\par
17601       zCmd = sqlite3_mprintf(strchr(azArg[i],' ')==0?"%z %s":"%z \\"%s\\"",\par
17602                              zCmd, azArg[i]);\par
17603     \}\par
17604     x = system(zCmd);\par
17605     sqlite3_free(zCmd);\par
17606     if( x ) raw_printf(stderr, "System command returns %d\\n", x);\par
17607   \}else\par
17608 #endif /* !defined(SQLITE_NOHAVE_SYSTEM) */\par
17609 \par
17610   if( c=='s' && strncmp(azArg[0], "show", n)==0 )\{\par
17611     static const char *azBool[] = \{ "off", "on", "trigger", "full"\};\par
17612     int i;\par
17613     if( nArg!=1 )\{\par
17614       raw_printf(stderr, "Usage: .show\\n");\par
17615       rc = 1;\par
17616       goto meta_command_exit;\par
17617     \}\par
17618     utf8_printf(p->out, "%12.12s: %s\\n","echo",\par
17619                                   azBool[ShellHasFlag(p, SHFLG_Echo)]);\par
17620     utf8_printf(p->out, "%12.12s: %s\\n","eqp", azBool[p->autoEQP&3]);\par
17621     utf8_printf(p->out, "%12.12s: %s\\n","explain",\par
17622          p->mode==MODE_Explain ? "on" : p->autoExplain ? "auto" : "off");\par
17623     utf8_printf(p->out,"%12.12s: %s\\n","headers", azBool[p->showHeader!=0]);\par
17624     utf8_printf(p->out, "%12.12s: %s\\n","mode", modeDescr[p->mode]);\par
17625     utf8_printf(p->out, "%12.12s: ", "nullvalue");\par
17626       output_c_string(p->out, p->nullValue);\par
17627       raw_printf(p->out, "\\n");\par
17628     utf8_printf(p->out,"%12.12s: %s\\n","output",\par
17629             strlen30(p->outfile) ? p->outfile : "stdout");\par
17630     utf8_printf(p->out,"%12.12s: ", "colseparator");\par
17631       output_c_string(p->out, p->colSeparator);\par
17632       raw_printf(p->out, "\\n");\par
17633     utf8_printf(p->out,"%12.12s: ", "rowseparator");\par
17634       output_c_string(p->out, p->rowSeparator);\par
17635       raw_printf(p->out, "\\n");\par
17636     utf8_printf(p->out, "%12.12s: %s\\n","stats", azBool[p->statsOn!=0]);\par
17637     utf8_printf(p->out, "%12.12s: ", "width");\par
17638     for (i=0;i<(int)ArraySize(p->colWidth) && p->colWidth[i] != 0;i++) \{\par
17639       raw_printf(p->out, "%d ", p->colWidth[i]);\par
17640     \}\par
17641     raw_printf(p->out, "\\n");\par
17642     utf8_printf(p->out, "%12.12s: %s\\n", "filename",\par
17643                 p->zDbFilename ? p->zDbFilename : "");\par
17644   \}else\par
17645 \par
17646   if( c=='s' && strncmp(azArg[0], "stats", n)==0 )\{\par
17647     if( nArg==2 )\{\par
17648       p->statsOn = (u8)booleanValue(azArg[1]);\par
17649     \}else if( nArg==1 )\{\par
17650       display_stats(p->db, p, 0);\par
17651     \}else\{\par
17652       raw_printf(stderr, "Usage: .stats ?on|off?\\n");\par
17653       rc = 1;\par
17654     \}\par
17655   \}else\par
17656 \par
17657   if( (c=='t' && n>1 && strncmp(azArg[0], "tables", n)==0)\par
17658    || (c=='i' && (strncmp(azArg[0], "indices", n)==0\par
17659                  || strncmp(azArg[0], "indexes", n)==0) )\par
17660   )\{\par
17661     sqlite3_stmt *pStmt;\par
17662     char **azResult;\par
17663     int nRow, nAlloc;\par
17664     int ii;\par
17665     ShellText s;\par
17666     initText(&s);\par
17667     open_db(p, 0);\par
17668     rc = sqlite3_prepare_v2(p->db, "PRAGMA database_list", -1, &pStmt, 0);\par
17669     if( rc )\{\par
17670       sqlite3_finalize(pStmt);\par
17671       return shellDatabaseError(p->db);\par
17672     \}\par
17673 \par
17674     if( nArg>2 && c=='i' )\{\par
17675       /* It is an historical accident that the .indexes command shows an error\par
17676       ** when called with the wrong number of arguments whereas the .tables\par
17677       ** command does not. */\par
17678       raw_printf(stderr, "Usage: .indexes ?LIKE-PATTERN?\\n");\par
17679       rc = 1;\par
17680       sqlite3_finalize(pStmt);\par
17681       goto meta_command_exit;\par
17682     \}\par
17683     for(ii=0; sqlite3_step(pStmt)==SQLITE_ROW; ii++)\{\par
17684       const char *zDbName = (const char*)sqlite3_column_text(pStmt, 1);\par
17685       if( zDbName==0 ) continue;\par
17686       if( s.z && s.z[0] ) appendText(&s, " UNION ALL ", 0);\par
17687       if( sqlite3_stricmp(zDbName, "main")==0 )\{\par
17688         appendText(&s, "SELECT name FROM ", 0);\par
17689       \}else\{\par
17690         appendText(&s, "SELECT ", 0);\par
17691         appendText(&s, zDbName, '\\'');\par
17692         appendText(&s, "||'.'||name FROM ", 0);\par
17693       \}\par
17694       appendText(&s, zDbName, '"');\par
17695       appendText(&s, ".sqlite_master ", 0);\par
17696       if( c=='t' )\{\par
17697         appendText(&s," WHERE type IN ('table','view')"\par
17698                       "   AND name NOT LIKE 'sqlite_%'"\par
17699                       "   AND name LIKE ?1", 0);\par
17700       \}else\{\par
17701         appendText(&s," WHERE type='index'"\par
17702                       "   AND tbl_name LIKE ?1", 0);\par
17703       \}\par
17704     \}\par
17705     rc = sqlite3_finalize(pStmt);\par
17706     appendText(&s, " ORDER BY 1", 0);\par
17707     rc = sqlite3_prepare_v2(p->db, s.z, -1, &pStmt, 0);\par
17708     freeText(&s);\par
17709     if( rc ) return shellDatabaseError(p->db);\par
17710 \par
17711     /* Run the SQL statement prepared by the above block. Store the results\par
17712     ** as an array of nul-terminated strings in azResult[].  */\par
17713     nRow = nAlloc = 0;\par
17714     azResult = 0;\par
17715     if( nArg>1 )\{\par
17716       sqlite3_bind_text(pStmt, 1, azArg[1], -1, SQLITE_TRANSIENT);\par
17717     \}else\{\par
17718       sqlite3_bind_text(pStmt, 1, "%", -1, SQLITE_STATIC);\par
17719     \}\par
17720     while( sqlite3_step(pStmt)==SQLITE_ROW )\{\par
17721       if( nRow>=nAlloc )\{\par
17722         char **azNew;\par
17723         int n2 = nAlloc*2 + 10;\par
17724         azNew = sqlite3_realloc64(azResult, sizeof(azResult[0])*n2);\par
17725         if( azNew==0 ) shell_out_of_memory();\par
17726         nAlloc = n2;\par
17727         azResult = azNew;\par
17728       \}\par
17729       azResult[nRow] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 0));\par
17730       if( 0==azResult[nRow] ) shell_out_of_memory();\par
17731       nRow++;\par
17732     \}\par
17733     if( sqlite3_finalize(pStmt)!=SQLITE_OK )\{\par
17734       rc = shellDatabaseError(p->db);\par
17735     \}\par
17736 \par
17737     /* Pretty-print the contents of array azResult[] to the output */\par
17738     if( rc==0 && nRow>0 )\{\par
17739       int len, maxlen = 0;\par
17740       int i, j;\par
17741       int nPrintCol, nPrintRow;\par
17742       for(i=0; i<nRow; i++)\{\par
17743         len = strlen30(azResult[i]);\par
17744         if( len>maxlen ) maxlen = len;\par
17745       \}\par
17746       nPrintCol = 80/(maxlen+2);\par
17747       if( nPrintCol<1 ) nPrintCol = 1;\par
17748       nPrintRow = (nRow + nPrintCol - 1)/nPrintCol;\par
17749       for(i=0; i<nPrintRow; i++)\{\par
17750         for(j=i; j<nRow; j+=nPrintRow)\{\par
17751           char *zSp = j<nPrintRow ? "" : "  ";\par
17752           utf8_printf(p->out, "%s%-*s", zSp, maxlen,\par
17753                       azResult[j] ? azResult[j]:"");\par
17754         \}\par
17755         raw_printf(p->out, "\\n");\par
17756       \}\par
17757     \}\par
17758 \par
17759     for(ii=0; ii<nRow; ii++) sqlite3_free(azResult[ii]);\par
17760     sqlite3_free(azResult);\par
17761   \}else\par
17762 \par
17763   /* Begin redirecting output to the file "testcase-out.txt" */\par
17764   if( c=='t' && strcmp(azArg[0],"testcase")==0 )\{\par
17765     output_reset(p);\par
17766     p->out = output_file_open("testcase-out.txt", 0);\par
17767     if( p->out==0 )\{\par
17768       raw_printf(stderr, "Error: cannot open 'testcase-out.txt'\\n");\par
17769     \}\par
17770     if( nArg>=2 )\{\par
17771       sqlite3_snprintf(sizeof(p->zTestcase), p->zTestcase, "%s", azArg[1]);\par
17772     \}else\{\par
17773       sqlite3_snprintf(sizeof(p->zTestcase), p->zTestcase, "?");\par
17774     \}\par
17775   \}else\par
17776 \par
17777 #ifndef SQLITE_UNTESTABLE\par
17778   if( c=='t' && n>=8 && strncmp(azArg[0], "testctrl", n)==0 )\{\par
17779     static const struct \{\par
17780        const char *zCtrlName;   /* Name of a test-control option */\par
17781        int ctrlCode;            /* Integer code for that option */\par
17782        const char *zUsage;      /* Usage notes */\par
17783     \} aCtrl[] = \{\par
17784       \{ "always",             SQLITE_TESTCTRL_ALWAYS,        "BOOLEAN"        \},\par
17785       \{ "assert",             SQLITE_TESTCTRL_ASSERT,        "BOOLEAN"        \},\par
17786     /*\{ "benign_malloc_hooks",SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS, ""       \},*/\par
17787     /*\{ "bitvec_test",        SQLITE_TESTCTRL_BITVEC_TEST,   ""             \},*/\par
17788       \{ "byteorder",          SQLITE_TESTCTRL_BYTEORDER,     ""               \},\par
17789       \{ "extra_schema_checks",SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS,"BOOLEAN"   \},\par
17790     /*\{ "fault_install",      SQLITE_TESTCTRL_FAULT_INSTALL, ""             \},*/\par
17791       \{ "imposter",         SQLITE_TESTCTRL_IMPOSTER, "SCHEMA ON/OFF ROOTPAGE"\},\par
17792       \{ "internal_functions", SQLITE_TESTCTRL_INTERNAL_FUNCTIONS, "" \},\par
17793       \{ "localtime_fault",    SQLITE_TESTCTRL_LOCALTIME_FAULT,"BOOLEAN"       \},\par
17794       \{ "never_corrupt",      SQLITE_TESTCTRL_NEVER_CORRUPT, "BOOLEAN"        \},\par
17795       \{ "optimizations",      SQLITE_TESTCTRL_OPTIMIZATIONS, "DISABLE-MASK"   \},\par
17796 #ifdef YYCOVERAGE\par
17797       \{ "parser_coverage",    SQLITE_TESTCTRL_PARSER_COVERAGE, ""             \},\par
17798 #endif\par
17799       \{ "pending_byte",       SQLITE_TESTCTRL_PENDING_BYTE,  "OFFSET  "       \},\par
17800       \{ "prng_restore",       SQLITE_TESTCTRL_PRNG_RESTORE,  ""               \},\par
17801       \{ "prng_save",          SQLITE_TESTCTRL_PRNG_SAVE,     ""               \},\par
17802       \{ "prng_seed",          SQLITE_TESTCTRL_PRNG_SEED,     "SEED ?db?"      \},\par
17803       \{ "reserve",            SQLITE_TESTCTRL_RESERVE,      "BYTES-OF-RESERVE"\},\par
17804     \};\par
17805     int testctrl = -1;\par
17806     int iCtrl = -1;\par
17807     int rc2 = 0;    /* 0: usage.  1: %d  2: %x  3: no-output */\par
17808     int isOk = 0;\par
17809     int i, n2;\par
17810     const char *zCmd = 0;\par
17811 \par
17812     open_db(p, 0);\par
17813     zCmd = nArg>=2 ? azArg[1] : "help";\par
17814 \par
17815     /* The argument can optionally begin with "-" or "--" */\par
17816     if( zCmd[0]=='-' && zCmd[1] )\{\par
17817       zCmd++;\par
17818       if( zCmd[0]=='-' && zCmd[1] ) zCmd++;\par
17819     \}\par
17820 \par
17821     /* --help lists all test-controls */\par
17822     if( strcmp(zCmd,"help")==0 )\{\par
17823       utf8_printf(p->out, "Available test-controls:\\n");\par
17824       for(i=0; i<ArraySize(aCtrl); i++)\{\par
17825         utf8_printf(p->out, "  .testctrl %s %s\\n",\par
17826                     aCtrl[i].zCtrlName, aCtrl[i].zUsage);\par
17827       \}\par
17828       rc = 1;\par
17829       goto meta_command_exit;\par
17830     \}\par
17831 \par
17832     /* convert testctrl text option to value. allow any unique prefix\par
17833     ** of the option name, or a numerical value. */\par
17834     n2 = strlen30(zCmd);\par
17835     for(i=0; i<ArraySize(aCtrl); i++)\{\par
17836       if( strncmp(zCmd, aCtrl[i].zCtrlName, n2)==0 )\{\par
17837         if( testctrl<0 )\{\par
17838           testctrl = aCtrl[i].ctrlCode;\par
17839           iCtrl = i;\par
17840         \}else\{\par
17841           utf8_printf(stderr, "Error: ambiguous test-control: \\"%s\\"\\n"\par
17842                               "Use \\".testctrl --help\\" for help\\n", zCmd);\par
17843           rc = 1;\par
17844           goto meta_command_exit;\par
17845         \}\par
17846       \}\par
17847     \}\par
17848     if( testctrl<0 )\{\par
17849       utf8_printf(stderr,"Error: unknown test-control: %s\\n"\par
17850                          "Use \\".testctrl --help\\" for help\\n", zCmd);\par
17851     \}else\{\par
17852       switch(testctrl)\{\par
17853 \par
17854         /* sqlite3_test_control(int, db, int) */\par
17855         case SQLITE_TESTCTRL_OPTIMIZATIONS:\par
17856         case SQLITE_TESTCTRL_RESERVE:\par
17857           if( nArg==3 )\{\par
17858             int opt = (int)strtol(azArg[2], 0, 0);\par
17859             rc2 = sqlite3_test_control(testctrl, p->db, opt);\par
17860             isOk = 3;\par
17861           \}\par
17862           break;\par
17863 \par
17864         /* sqlite3_test_control(int) */\par
17865         case SQLITE_TESTCTRL_PRNG_SAVE:\par
17866         case SQLITE_TESTCTRL_PRNG_RESTORE:\par
17867         case SQLITE_TESTCTRL_PRNG_RESET:\par
17868         case SQLITE_TESTCTRL_BYTEORDER:\par
17869           if( nArg==2 )\{\par
17870             rc2 = sqlite3_test_control(testctrl);\par
17871             isOk = testctrl==SQLITE_TESTCTRL_BYTEORDER ? 1 : 3;\par
17872           \}\par
17873           break;\par
17874 \par
17875         /* sqlite3_test_control(int, uint) */\par
17876         case SQLITE_TESTCTRL_PENDING_BYTE:\par
17877           if( nArg==3 )\{\par
17878             unsigned int opt = (unsigned int)integerValue(azArg[2]);\par
17879             rc2 = sqlite3_test_control(testctrl, opt);\par
17880             isOk = 3;\par
17881           \}\par
17882           break;\par
17883 \par
17884         /* sqlite3_test_control(int, int, sqlite3*) */\par
17885         case SQLITE_TESTCTRL_PRNG_SEED:\par
17886           if( nArg==3 || nArg==4 )\{\par
17887             int ii = (int)integerValue(azArg[2]);\par
17888             sqlite3 *db;\par
17889             if( ii==0 && strcmp(azArg[2],"random")==0 )\{\par
17890               sqlite3_randomness(sizeof(ii),&ii);\par
17891               printf("-- random seed: %d\\n", ii);\par
17892             \}\par
17893             if( nArg==3 )\{\par
17894               db = 0;\par
17895             \}else\{\par
17896               db = p->db;\par
17897               /* Make sure the schema has been loaded */\par
17898               sqlite3_table_column_metadata(db, 0, "x", 0, 0, 0, 0, 0, 0);\par
17899             \}\par
17900             rc2 = sqlite3_test_control(testctrl, ii, db);\par
17901             isOk = 3;\par
17902           \}\par
17903           break;\par
17904 \par
17905         /* sqlite3_test_control(int, int) */\par
17906         case SQLITE_TESTCTRL_ASSERT:\par
17907         case SQLITE_TESTCTRL_ALWAYS:\par
17908           if( nArg==3 )\{\par
17909             int opt = booleanValue(azArg[2]);\par
17910             rc2 = sqlite3_test_control(testctrl, opt);\par
17911             isOk = 1;\par
17912           \}\par
17913           break;\par
17914 \par
17915         /* sqlite3_test_control(int, int) */\par
17916         case SQLITE_TESTCTRL_LOCALTIME_FAULT:\par
17917         case SQLITE_TESTCTRL_NEVER_CORRUPT:\par
17918           if( nArg==3 )\{\par
17919             int opt = booleanValue(azArg[2]);\par
17920             rc2 = sqlite3_test_control(testctrl, opt);\par
17921             isOk = 3;\par
17922           \}\par
17923           break;\par
17924 \par
17925         /* sqlite3_test_control(sqlite3*) */\par
17926         case SQLITE_TESTCTRL_INTERNAL_FUNCTIONS:\par
17927           rc2 = sqlite3_test_control(testctrl, p->db);\par
17928           isOk = 3;\par
17929           break;\par
17930 \par
17931         case SQLITE_TESTCTRL_IMPOSTER:\par
17932           if( nArg==5 )\{\par
17933             rc2 = sqlite3_test_control(testctrl, p->db,\par
17934                           azArg[2],\par
17935                           integerValue(azArg[3]),\par
17936                           integerValue(azArg[4]));\par
17937             isOk = 3;\par
17938           \}\par
17939           break;\par
17940 \par
17941 #ifdef YYCOVERAGE\par
17942         case SQLITE_TESTCTRL_PARSER_COVERAGE:\par
17943           if( nArg==2 )\{\par
17944             sqlite3_test_control(testctrl, p->out);\par
17945             isOk = 3;\par
17946           \}\par
17947 #endif\par
17948       \}\par
17949     \}\par
17950     if( isOk==0 && iCtrl>=0 )\{\par
17951       utf8_printf(p->out, "Usage: .testctrl %s %s\\n", zCmd,aCtrl[iCtrl].zUsage);\par
17952       rc = 1;\par
17953     \}else if( isOk==1 )\{\par
17954       raw_printf(p->out, "%d\\n", rc2);\par
17955     \}else if( isOk==2 )\{\par
17956       raw_printf(p->out, "0x%08x\\n", rc2);\par
17957     \}\par
17958   \}else\par
17959 #endif /* !defined(SQLITE_UNTESTABLE) */\par
17960 \par
17961   if( c=='t' && n>4 && strncmp(azArg[0], "timeout", n)==0 )\{\par
17962     open_db(p, 0);\par
17963     sqlite3_busy_timeout(p->db, nArg>=2 ? (int)integerValue(azArg[1]) : 0);\par
17964   \}else\par
17965 \par
17966   if( c=='t' && n>=5 && strncmp(azArg[0], "timer", n)==0 )\{\par
17967     if( nArg==2 )\{\par
17968       enableTimer = booleanValue(azArg[1]);\par
17969       if( enableTimer && !HAS_TIMER )\{\par
17970         raw_printf(stderr, "Error: timer not available on this system.\\n");\par
17971         enableTimer = 0;\par
17972       \}\par
17973     \}else\{\par
17974       raw_printf(stderr, "Usage: .timer on|off\\n");\par
17975       rc = 1;\par
17976     \}\par
17977   \}else\par
17978 \par
17979 #ifndef SQLITE_OMIT_TRACE\par
17980   if( c=='t' && strncmp(azArg[0], "trace", n)==0 )\{\par
17981     int mType = 0;\par
17982     int jj;\par
17983     open_db(p, 0);\par
17984     for(jj=1; jj<nArg; jj++)\{\par
17985       const char *z = azArg[jj];\par
17986       if( z[0]=='-' )\{\par
17987         if( optionMatch(z, "expanded") )\{\par
17988           p->eTraceType = SHELL_TRACE_EXPANDED;\par
17989         \}\par
17990 #ifdef SQLITE_ENABLE_NORMALIZE\par
17991         else if( optionMatch(z, "normalized") )\{\par
17992           p->eTraceType = SHELL_TRACE_NORMALIZED;\par
17993         \}\par
17994 #endif\par
17995         else if( optionMatch(z, "plain") )\{\par
17996           p->eTraceType = SHELL_TRACE_PLAIN;\par
17997         \}\par
17998         else if( optionMatch(z, "profile") )\{\par
17999           mType |= SQLITE_TRACE_PROFILE;\par
18000         \}\par
18001         else if( optionMatch(z, "row") )\{\par
18002           mType |= SQLITE_TRACE_ROW;\par
18003         \}\par
18004         else if( optionMatch(z, "stmt") )\{\par
18005           mType |= SQLITE_TRACE_STMT;\par
18006         \}\par
18007         else if( optionMatch(z, "close") )\{\par
18008           mType |= SQLITE_TRACE_CLOSE;\par
18009         \}\par
18010         else \{\par
18011           raw_printf(stderr, "Unknown option \\"%s\\" on \\".trace\\"\\n", z);\par
18012           rc = 1;\par
18013           goto meta_command_exit;\par
18014         \}\par
18015       \}else\{\par
18016         output_file_close(p->traceOut);\par
18017         p->traceOut = output_file_open(azArg[1], 0);\par
18018       \}\par
18019     \}\par
18020     if( p->traceOut==0 )\{\par
18021       sqlite3_trace_v2(p->db, 0, 0, 0);\par
18022     \}else\{\par
18023       if( mType==0 ) mType = SQLITE_TRACE_STMT;\par
18024       sqlite3_trace_v2(p->db, mType, sql_trace_callback, p);\par
18025     \}\par
18026   \}else\par
18027 #endif /* !defined(SQLITE_OMIT_TRACE) */\par
18028 \par
18029 #if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_VIRTUALTABLE)\par
18030   if( c=='u' && strncmp(azArg[0], "unmodule", n)==0 )\{\par
18031     int ii;\par
18032     int lenOpt;\par
18033     char *zOpt;\par
18034     if( nArg<2 )\{\par
18035       raw_printf(stderr, "Usage: .unmodule [--allexcept] NAME ...\\n");\par
18036       rc = 1;\par
18037       goto meta_command_exit;\par
18038     \}\par
18039     open_db(p, 0);\par
18040     zOpt = azArg[1];\par
18041     if( zOpt[0]=='-' && zOpt[1]=='-' && zOpt[2]!=0 ) zOpt++;\par
18042     lenOpt = (int)strlen(zOpt);\par
18043     if( lenOpt>=3 && strncmp(zOpt, "-allexcept",lenOpt)==0 )\{\par
18044       assert( azArg[nArg]==0 );\par
18045       sqlite3_drop_modules(p->db, nArg>2 ? (const char**)(azArg+2) : 0);\par
18046     \}else\{\par
18047       for(ii=1; ii<nArg; ii++)\{\par
18048         sqlite3_create_module(p->db, azArg[ii], 0, 0);\par
18049       \}\par
18050     \}\par
18051   \}else\par
18052 #endif\par
18053 \par
18054 #if SQLITE_USER_AUTHENTICATION\par
18055   if( c=='u' && strncmp(azArg[0], "user", n)==0 )\{\par
18056     if( nArg<2 )\{\par
18057       raw_printf(stderr, "Usage: .user SUBCOMMAND ...\\n");\par
18058       rc = 1;\par
18059       goto meta_command_exit;\par
18060     \}\par
18061     open_db(p, 0);\par
18062     if( strcmp(azArg[1],"login")==0 )\{\par
18063       if( nArg!=4 )\{\par
18064         raw_printf(stderr, "Usage: .user login USER PASSWORD\\n");\par
18065         rc = 1;\par
18066         goto meta_command_exit;\par
18067       \}\par
18068       rc = sqlite3_user_authenticate(p->db, azArg[2], azArg[3],\par
18069                                      strlen30(azArg[3]));\par
18070       if( rc )\{\par
18071         utf8_printf(stderr, "Authentication failed for user %s\\n", azArg[2]);\par
18072         rc = 1;\par
18073       \}\par
18074     \}else if( strcmp(azArg[1],"add")==0 )\{\par
18075       if( nArg!=5 )\{\par
18076         raw_printf(stderr, "Usage: .user add USER PASSWORD ISADMIN\\n");\par
18077         rc = 1;\par
18078         goto meta_command_exit;\par
18079       \}\par
18080       rc = sqlite3_user_add(p->db, azArg[2], azArg[3], strlen30(azArg[3]),\par
18081                             booleanValue(azArg[4]));\par
18082       if( rc )\{\par
18083         raw_printf(stderr, "User-Add failed: %d\\n", rc);\par
18084         rc = 1;\par
18085       \}\par
18086     \}else if( strcmp(azArg[1],"edit")==0 )\{\par
18087       if( nArg!=5 )\{\par
18088         raw_printf(stderr, "Usage: .user edit USER PASSWORD ISADMIN\\n");\par
18089         rc = 1;\par
18090         goto meta_command_exit;\par
18091       \}\par
18092       rc = sqlite3_user_change(p->db, azArg[2], azArg[3], strlen30(azArg[3]),\par
18093                               booleanValue(azArg[4]));\par
18094       if( rc )\{\par
18095         raw_printf(stderr, "User-Edit failed: %d\\n", rc);\par
18096         rc = 1;\par
18097       \}\par
18098     \}else if( strcmp(azArg[1],"delete")==0 )\{\par
18099       if( nArg!=3 )\{\par
18100         raw_printf(stderr, "Usage: .user delete USER\\n");\par
18101         rc = 1;\par
18102         goto meta_command_exit;\par
18103       \}\par
18104       rc = sqlite3_user_delete(p->db, azArg[2]);\par
18105       if( rc )\{\par
18106         raw_printf(stderr, "User-Delete failed: %d\\n", rc);\par
18107         rc = 1;\par
18108       \}\par
18109     \}else\{\par
18110       raw_printf(stderr, "Usage: .user login|add|edit|delete ...\\n");\par
18111       rc = 1;\par
18112       goto meta_command_exit;\par
18113     \}\par
18114   \}else\par
18115 #endif /* SQLITE_USER_AUTHENTICATION */\par
18116 \par
18117   if( c=='v' && strncmp(azArg[0], "version", n)==0 )\{\par
18118     utf8_printf(p->out, "SQLite %s %s\\n" /*extra-version-info*/,\par
18119         sqlite3_libversion(), sqlite3_sourceid());\par
18120 #if SQLITE_HAVE_ZLIB\par
18121     utf8_printf(p->out, "zlib version %s\\n", zlibVersion());\par
18122 #endif\par
18123 #define CTIMEOPT_VAL_(opt) #opt\par
18124 #define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)\par
18125 #if defined(__clang__) && defined(__clang_major__)\par
18126     utf8_printf(p->out, "clang-" CTIMEOPT_VAL(__clang_major__) "."\par
18127                     CTIMEOPT_VAL(__clang_minor__) "."\par
18128                     CTIMEOPT_VAL(__clang_patchlevel__) "\\n");\par
18129 #elif defined(_MSC_VER)\par
18130     utf8_printf(p->out, "msvc-" CTIMEOPT_VAL(_MSC_VER) "\\n");\par
18131 #elif defined(__GNUC__) && defined(__VERSION__)\par
18132     utf8_printf(p->out, "gcc-" __VERSION__ "\\n");\par
18133 #endif\par
18134   \}else\par
18135 \par
18136   if( c=='v' && strncmp(azArg[0], "vfsinfo", n)==0 )\{\par
18137     const char *zDbName = nArg==2 ? azArg[1] : "main";\par
18138     sqlite3_vfs *pVfs = 0;\par
18139     if( p->db )\{\par
18140       sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFS_POINTER, &pVfs);\par
18141       if( pVfs )\{\par
18142         utf8_printf(p->out, "vfs.zName      = \\"%s\\"\\n", pVfs->zName);\par
18143         raw_printf(p->out, "vfs.iVersion   = %d\\n", pVfs->iVersion);\par
18144         raw_printf(p->out, "vfs.szOsFile   = %d\\n", pVfs->szOsFile);\par
18145         raw_printf(p->out, "vfs.mxPathname = %d\\n", pVfs->mxPathname);\par
18146       \}\par
18147     \}\par
18148   \}else\par
18149 \par
18150   if( c=='v' && strncmp(azArg[0], "vfslist", n)==0 )\{\par
18151     sqlite3_vfs *pVfs;\par
18152     sqlite3_vfs *pCurrent = 0;\par
18153     if( p->db )\{\par
18154       sqlite3_file_control(p->db, "main", SQLITE_FCNTL_VFS_POINTER, &pCurrent);\par
18155     \}\par
18156     for(pVfs=sqlite3_vfs_find(0); pVfs; pVfs=pVfs->pNext)\{\par
18157       utf8_printf(p->out, "vfs.zName      = \\"%s\\"%s\\n", pVfs->zName,\par
18158            pVfs==pCurrent ? "  <--- CURRENT" : "");\par
18159       raw_printf(p->out, "vfs.iVersion   = %d\\n", pVfs->iVersion);\par
18160       raw_printf(p->out, "vfs.szOsFile   = %d\\n", pVfs->szOsFile);\par
18161       raw_printf(p->out, "vfs.mxPathname = %d\\n", pVfs->mxPathname);\par
18162       if( pVfs->pNext )\{\par
18163         raw_printf(p->out, "-----------------------------------\\n");\par
18164       \}\par
18165     \}\par
18166   \}else\par
18167 \par
18168   if( c=='v' && strncmp(azArg[0], "vfsname", n)==0 )\{\par
18169     const char *zDbName = nArg==2 ? azArg[1] : "main";\par
18170     char *zVfsName = 0;\par
18171     if( p->db )\{\par
18172       sqlite3_file_control(p->db, zDbName, SQLITE_FCNTL_VFSNAME, &zVfsName);\par
18173       if( zVfsName )\{\par
18174         utf8_printf(p->out, "%s\\n", zVfsName);\par
18175         sqlite3_free(zVfsName);\par
18176       \}\par
18177     \}\par
18178   \}else\par
18179 \par
18180 #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)\par
18181   if( c=='w' && strncmp(azArg[0], "wheretrace", n)==0 )\{\par
18182     sqlite3WhereTrace = nArg>=2 ? booleanValue(azArg[1]) : 0xff;\par
18183   \}else\par
18184 #endif\par
18185 \par
18186   if( c=='w' && strncmp(azArg[0], "width", n)==0 )\{\par
18187     int j;\par
18188     assert( nArg<=ArraySize(azArg) );\par
18189     for(j=1; j<nArg && j<ArraySize(p->colWidth); j++)\{\par
18190       p->colWidth[j-1] = (int)integerValue(azArg[j]);\par
18191     \}\par
18192   \}else\par
18193 \par
18194   \{\par
18195     utf8_printf(stderr, "Error: unknown command or invalid arguments: "\par
18196       " \\"%s\\". Enter \\".help\\" for help\\n", azArg[0]);\par
18197     rc = 1;\par
18198   \}\par
18199 \par
18200 meta_command_exit:\par
18201   if( p->outCount )\{\par
18202     p->outCount--;\par
18203     if( p->outCount==0 ) output_reset(p);\par
18204   \}\par
18205   return rc;\par
18206 \}\par
}
}
{\xe \v dump_callback\:shell.c}
{\xe \v shell.c\:dump_callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int dump_callback (void *  {\i pArg}, int  {\i nArg}, char **  {\i azArg}, char **  {\i azNotUsed}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11879 of file shell.c.}\par
{
References appendText(), ShellState::cMode, ShellState::db, freeColumnList(), freeText(), initText(), ShellState::mode, MODE_Insert, ShellState::nErr, ShellState::out, printSchemaLine(), quoteChar(), raw_printf, shell_exec(), sqlite3_free, sqlite3_mprintf, sqlite3_strglob, SQLITE_CORRUPT, tableColumnList(), toggleSelectOrder(), UNUSED_PARAMETER, utf8_printf, ShellState::writableSchema, ShellText::z, and ShellState::zDestTable.}\par
{
Referenced by run_schema_dump_query().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11879                                                                               \{\par
11880   int rc;\par
11881   const char *zTable;\par
11882   const char *zType;\par
11883   const char *zSql;\par
11884   ShellState *p = (ShellState *)pArg;\par
11885 \par
11886   UNUSED_PARAMETER(azNotUsed);\par
11887   if( nArg!=3 || azArg==0 ) return 0;\par
11888   zTable = azArg[0];\par
11889   zType = azArg[1];\par
11890   zSql = azArg[2];\par
11891 \par
11892   if( strcmp(zTable, "sqlite_sequence")==0 )\{\par
11893     raw_printf(p->out, "DELETE FROM sqlite_sequence;\\n");\par
11894   \}else if( sqlite3_strglob("sqlite_stat?", zTable)==0 )\{\par
11895     raw_printf(p->out, "ANALYZE sqlite_master;\\n");\par
11896   \}else if( strncmp(zTable, "sqlite_", 7)==0 )\{\par
11897     return 0;\par
11898   \}else if( strncmp(zSql, "CREATE VIRTUAL TABLE", 20)==0 )\{\par
11899     char *zIns;\par
11900     if( !p->writableSchema )\{\par
11901       raw_printf(p->out, "PRAGMA writable_schema=ON;\\n");\par
11902       p->writableSchema = 1;\par
11903     \}\par
11904     zIns = sqlite3_mprintf(\par
11905        "INSERT INTO sqlite_master(type,name,tbl_name,rootpage,sql)"\par
11906        "VALUES('table','%q','%q',0,'%q');",\par
11907        zTable, zTable, zSql);\par
11908     utf8_printf(p->out, "%s\\n", zIns);\par
11909     sqlite3_free(zIns);\par
11910     return 0;\par
11911   \}else\{\par
11912     printSchemaLine(p->out, zSql, ";\\n");\par
11913   \}\par
11914 \par
11915   if( strcmp(zType, "table")==0 )\{\par
11916     ShellText sSelect;\par
11917     ShellText sTable;\par
11918     char **azCol;\par
11919     int i;\par
11920     char *savedDestTable;\par
11921     int savedMode;\par
11922 \par
11923     azCol = tableColumnList(p, zTable);\par
11924     if( azCol==0 )\{\par
11925       p->nErr++;\par
11926       return 0;\par
11927     \}\par
11928 \par
11929     /* Always quote the table name, even if it appears to be pure ascii,\par
11930     ** in case it is a keyword. Ex:  INSERT INTO "table" ... */\par
11931     initText(&sTable);\par
11932     appendText(&sTable, zTable, quoteChar(zTable));\par
11933     /* If preserving the rowid, add a column list after the table name.\par
11934     ** In other words:  "INSERT INTO tab(rowid,a,b,c,...) VALUES(...)"\par
11935     ** instead of the usual "INSERT INTO tab VALUES(...)".\par
11936     */\par
11937     if( azCol[0] )\{\par
11938       appendText(&sTable, "(", 0);\par
11939       appendText(&sTable, azCol[0], 0);\par
11940       for(i=1; azCol[i]; i++)\{\par
11941         appendText(&sTable, ",", 0);\par
11942         appendText(&sTable, azCol[i], quoteChar(azCol[i]));\par
11943       \}\par
11944       appendText(&sTable, ")", 0);\par
11945     \}\par
11946 \par
11947     /* Build an appropriate SELECT statement */\par
11948     initText(&sSelect);\par
11949     appendText(&sSelect, "SELECT ", 0);\par
11950     if( azCol[0] )\{\par
11951       appendText(&sSelect, azCol[0], 0);\par
11952       appendText(&sSelect, ",", 0);\par
11953     \}\par
11954     for(i=1; azCol[i]; i++)\{\par
11955       appendText(&sSelect, azCol[i], quoteChar(azCol[i]));\par
11956       if( azCol[i+1] )\{\par
11957         appendText(&sSelect, ",", 0);\par
11958       \}\par
11959     \}\par
11960     freeColumnList(azCol);\par
11961     appendText(&sSelect, " FROM ", 0);\par
11962     appendText(&sSelect, zTable, quoteChar(zTable));\par
11963 \par
11964     savedDestTable = p->zDestTable;\par
11965     savedMode = p->mode;\par
11966     p->zDestTable = sTable.z;\par
11967     p->mode = p->cMode = MODE_Insert;\par
11968     rc = shell_exec(p, sSelect.z, 0);\par
11969     if( (rc&0xff)==SQLITE_CORRUPT )\{\par
11970       raw_printf(p->out, "/****** CORRUPTION ERROR *******/\\n");\par
11971       toggleSelectOrder(p->db);\par
11972       shell_exec(p, sSelect.z, 0);\par
11973       toggleSelectOrder(p->db);\par
11974     \}\par
11975     p->zDestTable = savedDestTable;\par
11976     p->mode = savedMode;\par
11977     freeText(&sTable);\par
11978     freeText(&sSelect);\par
11979     if( rc ) p->nErr++;\par
11980   \}\par
11981   return 0;\par
11982 \}\par
}
}
{\xe \v editFunc\:shell.c}
{\xe \v shell.c\:editFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void editFunc ({\b sqlite3_context} *  {\i context}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9773 of file shell.c.}\par
{
References sqlite3_context_db_handle, sqlite3_file_control, sqlite3_free, sqlite3_malloc64, sqlite3_mprintf, sqlite3_randomness, sqlite3_result_blob64, sqlite3_result_error, sqlite3_result_error_nomem, sqlite3_result_text64, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_text, sqlite3_value_type, SQLITE_BLOB, SQLITE_FCNTL_TEMPFILENAME, SQLITE_NULL, SQLITE_UTF8, and time_test::x.}\par
{
Referenced by open_db().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9777  \{\par
 9778   const char *zEditor;\par
 9779   char *zTempFile = 0;\par
 9780   sqlite3 *db;\par
 9781   char *zCmd = 0;\par
 9782   int bBin;\par
 9783   int rc;\par
 9784   int hasCRNL = 0;\par
 9785   FILE *f = 0;\par
 9786   sqlite3_int64 sz;\par
 9787   sqlite3_int64 x;\par
 9788   unsigned char *p = 0;\par
 9789 \par
 9790   if( argc==2 )\{\par
 9791     zEditor = (const char*)sqlite3_value_text(argv[1]);\par
 9792   \}else\{\par
 9793     zEditor = getenv("VISUAL");\par
 9794   \}\par
 9795   if( zEditor==0 )\{\par
 9796     sqlite3_result_error(context, "no editor for edit()", -1);\par
 9797     return;\par
 9798   \}\par
 9799   if( sqlite3_value_type(argv[0])==SQLITE_NULL )\{\par
 9800     sqlite3_result_error(context, "NULL input to edit()", -1);\par
 9801     return;\par
 9802   \}\par
 9803   db = sqlite3_context_db_handle(context);\par
 9804   zTempFile = 0;\par
 9805   sqlite3_file_control(db, 0, SQLITE_FCNTL_TEMPFILENAME, &zTempFile);\par
 9806   if( zTempFile==0 )\{\par
 9807     sqlite3_uint64 r = 0;\par
 9808     sqlite3_randomness(sizeof(r), &r);\par
 9809     zTempFile = sqlite3_mprintf("temp%llx", r);\par
 9810     if( zTempFile==0 )\{\par
 9811       sqlite3_result_error_nomem(context);\par
 9812       return;\par
 9813     \}\par
 9814   \}\par
 9815   bBin = sqlite3_value_type(argv[0])==SQLITE_BLOB;\par
 9816   /* When writing the file to be edited, do \\n to \\r\\n conversions on systems\par
 9817   ** that want \\r\\n line endings */\par
 9818   f = fopen(zTempFile, bBin ? "wb" : "w");\par
 9819   if( f==0 )\{\par
 9820     sqlite3_result_error(context, "edit() cannot open temp file", -1);\par
 9821     goto edit_func_end;\par
 9822   \}\par
 9823   sz = sqlite3_value_bytes(argv[0]);\par
 9824   if( bBin )\{\par
 9825     x = fwrite(sqlite3_value_blob(argv[0]), 1, (size_t)sz, f);\par
 9826   \}else\{\par
 9827     const char *z = (const char*)sqlite3_value_text(argv[0]);\par
 9828     /* Remember whether or not the value originally contained \\r\\n */\par
 9829     if( z && strstr(z,"\\r\\n")!=0 ) hasCRNL = 1;\par
 9830     x = fwrite(sqlite3_value_text(argv[0]), 1, (size_t)sz, f);\par
 9831   \}\par
 9832   fclose(f);\par
 9833   f = 0;\par
 9834   if( x!=sz )\{\par
 9835     sqlite3_result_error(context, "edit() could not write the whole file", -1);\par
 9836     goto edit_func_end;\par
 9837   \}\par
 9838   zCmd = sqlite3_mprintf("%s \\"%s\\"", zEditor, zTempFile);\par
 9839   if( zCmd==0 )\{\par
 9840     sqlite3_result_error_nomem(context);\par
 9841     goto edit_func_end;\par
 9842   \}\par
 9843   rc = system(zCmd);\par
 9844   sqlite3_free(zCmd);\par
 9845   if( rc )\{\par
 9846     sqlite3_result_error(context, "EDITOR returned non-zero", -1);\par
 9847     goto edit_func_end;\par
 9848   \}\par
 9849   f = fopen(zTempFile, "rb");\par
 9850   if( f==0 )\{\par
 9851     sqlite3_result_error(context,\par
 9852       "edit() cannot reopen temp file after edit", -1);\par
 9853     goto edit_func_end;\par
 9854   \}\par
 9855   fseek(f, 0, SEEK_END);\par
 9856   sz = ftell(f);\par
 9857   rewind(f);\par
 9858   p = sqlite3_malloc64( sz+1 );\par
 9859   if( p==0 )\{\par
 9860     sqlite3_result_error_nomem(context);\par
 9861     goto edit_func_end;\par
 9862   \}\par
 9863   x = fread(p, 1, (size_t)sz, f);\par
 9864   fclose(f);\par
 9865   f = 0;\par
 9866   if( x!=sz )\{\par
 9867     sqlite3_result_error(context, "could not read back the whole file", -1);\par
 9868     goto edit_func_end;\par
 9869   \}\par
 9870   if( bBin )\{\par
 9871     sqlite3_result_blob64(context, p, sz, sqlite3_free);\par
 9872   \}else\{\par
 9873     sqlite3_int64 i, j;\par
 9874     if( hasCRNL )\{\par
 9875       /* If the original contains \\r\\n then do no conversions back to \\n */\par
 9876       j = sz;\par
 9877     \}else\{\par
 9878       /* If the file did not originally contain \\r\\n then convert any new\par
 9879       ** \\r\\n back into \\n */\par
 9880       for(i=j=0; i<sz; i++)\{\par
 9881         if( p[i]=='\\r' && p[i+1]=='\\n' ) i++;\par
 9882         p[j++] = p[i];\par
 9883       \}\par
 9884       sz = j;\par
 9885       p[sz] = 0;\par
 9886     \} \par
 9887     sqlite3_result_text64(context, (const char*)p, sz,\par
 9888                           sqlite3_free, SQLITE_UTF8);\par
 9889   \}\par
 9890   p = 0;\par
 9891 \par
 9892 edit_func_end:\par
 9893   if( f ) fclose(f);\par
 9894   unlink(zTempFile);\par
 9895   sqlite3_free(zTempFile);\par
 9896   sqlite3_free(p);\par
 9897 \}\par
}
}
{\xe \v endTimer\:shell.c}
{\xe \v shell.c\:endTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void endTimer (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 278 of file shell.c.}\par
{
References sBegin, timeDiff(), and timeOfDay().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   278                           \{\par
  279   if( enableTimer )\{\par
  280     sqlite3_int64 iEnd = timeOfDay();\par
  281     struct rusage sEnd;\par
  282     getrusage(RUSAGE_SELF, &sEnd);\par
  283     printf("Run Time: real %.3f user %f sys %f\\n",\par
  284        (iEnd - iBegin)*0.001,\par
  285        timeDiff(&sBegin.ru_utime, &sEnd.ru_utime),\par
  286        timeDiff(&sBegin.ru_stime, &sEnd.ru_stime));\par
  287   \}\par
  288 \}\par
}
}
{\xe \v eqp_append\:shell.c}
{\xe \v shell.c\:eqp_append}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void eqp_append ({\b ShellState} *  {\i p}, int  {\i iEqpId}, int  {\i p2}, const char *  {\i zText}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10283 of file shell.c.}\par
{
References ShellState::autoEQPtest, EQPGraphRow::iEqpId, EQPGraphRow::iParentId, ShellState::out, EQPGraph::pLast, EQPGraphRow::pNext, EQPGraph::pRow, ShellState::sGraph, shell_out_of_memory(), sqlite3_malloc64, strlen30(), utf8_printf, and EQPGraphRow::zText.}\par
{
Referenced by shell_callback(), and shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10283                                                                             \{\par
10284   EQPGraphRow *pNew;\par
10285   int nText = strlen30(zText);\par
10286   if( p->autoEQPtest )\{\par
10287     utf8_printf(p->out, "%d,%d,%s\\n", iEqpId, p2, zText);\par
10288   \}\par
10289   pNew = sqlite3_malloc64( sizeof(*pNew) + nText );\par
10290   if( pNew==0 ) shell_out_of_memory();\par
10291   pNew->iEqpId = iEqpId;\par
10292   pNew->iParentId = p2;\par
10293   memcpy(pNew->zText, zText, nText+1);\par
10294   pNew->pNext = 0;\par
10295   if( p->sGraph.pLast )\{\par
10296     p->sGraph.pLast->pNext = pNew;\par
10297   \}else\{\par
10298     p->sGraph.pRow = pNew;\par
10299   \}\par
10300   p->sGraph.pLast = pNew;\par
10301 \}\par
}
}
{\xe \v eqp_next_row\:shell.c}
{\xe \v shell.c\:eqp_next_row}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b EQPGraphRow}* eqp_next_row ({\b ShellState} *  {\i p}, int  {\i iEqpId}, {\b EQPGraphRow} *  {\i pOld}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10319 of file shell.c.}\par
{
References EQPGraphRow::iParentId, EQPGraphRow::pNext, EQPGraph::pRow, and ShellState::sGraph.}\par
{
Referenced by eqp_render_level().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10319                                                                               \{\par
10320   EQPGraphRow *pRow = pOld ? pOld->pNext : p->sGraph.pRow;\par
10321   while( pRow && pRow->iParentId!=iEqpId ) pRow = pRow->pNext;\par
10322   return pRow;\par
10323 \}\par
}
}
{\xe \v eqp_render\:shell.c}
{\xe \v shell.c\:eqp_render}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void eqp_render ({\b ShellState} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10348 of file shell.c.}\par
{
References eqp_render_level(), eqp_reset(), ShellState::out, EQPGraphRow::pNext, EQPGraph::pRow, ShellState::sGraph, sqlite3_free, utf8_printf, EQPGraph::zPrefix, and EQPGraphRow::zText.}\par
{
Referenced by shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10348                                      \{\par
10349   EQPGraphRow *pRow = p->sGraph.pRow;\par
10350   if( pRow )\{\par
10351     if( pRow->zText[0]=='-' )\{\par
10352       if( pRow->pNext==0 )\{\par
10353         eqp_reset(p);\par
10354         return;\par
10355       \}\par
10356       utf8_printf(p->out, "%s\\n", pRow->zText+3);\par
10357       p->sGraph.pRow = pRow->pNext;\par
10358       sqlite3_free(pRow);\par
10359     \}else\{\par
10360       utf8_printf(p->out, "QUERY PLAN\\n");\par
10361     \}\par
10362     p->sGraph.zPrefix[0] = 0;\par
10363     eqp_render_level(p, 0);\par
10364     eqp_reset(p);\par
10365   \}\par
10366 \}\par
}
}
{\xe \v eqp_render_level\:shell.c}
{\xe \v shell.c\:eqp_render_level}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void eqp_render_level ({\b ShellState} *  {\i p}, int  {\i iEqpId}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10328 of file shell.c.}\par
{
References eqp_next_row(), EQPGraphRow::iEqpId, ShellState::out, ShellState::sGraph, strlen30(), utf8_printf, EQPGraph::zPrefix, and EQPGraphRow::zText.}\par
{
Referenced by eqp_render().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10328                                                        \{\par
10329   EQPGraphRow *pRow, *pNext;\par
10330   int n = strlen30(p->sGraph.zPrefix);\par
10331   char *z;\par
10332   for(pRow = eqp_next_row(p, iEqpId, 0); pRow; pRow = pNext)\{\par
10333     pNext = eqp_next_row(p, iEqpId, pRow);\par
10334     z = pRow->zText;\par
10335     utf8_printf(p->out, "%s%s%s\\n", p->sGraph.zPrefix,\par
10336                 pNext ? "|--" : "`--", z);\par
10337     if( n<(int)sizeof(p->sGraph.zPrefix)-7 )\{\par
10338       memcpy(&p->sGraph.zPrefix[n], pNext ? "|  " : "   ", 4);\par
10339       eqp_render_level(p, pRow->iEqpId);\par
10340       p->sGraph.zPrefix[n] = 0;\par
10341     \}\par
10342   \}\par
10343 \}\par
}
}
{\xe \v eqp_reset\:shell.c}
{\xe \v shell.c\:eqp_reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void eqp_reset ({\b ShellState} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10307 of file shell.c.}\par
{
References EQPGraphRow::pNext, EQPGraph::pRow, ShellState::sGraph, and sqlite3_free.}\par
{
Referenced by eqp_render().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10307                                     \{\par
10308   EQPGraphRow *pRow, *pNext;\par
10309   for(pRow = p->sGraph.pRow; pRow; pRow = pNext)\{\par
10310     pNext = pRow->pNext;\par
10311     sqlite3_free(pRow);\par
10312   \}\par
10313   memset(&p->sGraph, 0, sizeof(p->sGraph));\par
10314 \}\par
}
}
{\xe \v exec_prepared_stmt\:shell.c}
{\xe \v shell.c\:exec_prepared_stmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void exec_prepared_stmt ({\b ShellState} *  {\i pArg}, {\b sqlite3_stmt} *  {\i pStmt}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11393 of file shell.c.}\par
{
References ShellState::cMode, MODE_Insert, shell_callback(), sqlite3_column_count, sqlite3_column_name, sqlite3_column_text, sqlite3_column_type, sqlite3_free, sqlite3_malloc64, sqlite3_step, SQLITE_ABORT, SQLITE_BLOB, SQLITE_NOMEM, SQLITE_NULL, SQLITE_ROW, and time_test::x.}\par
{
Referenced by shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11396  \{\par
11397   int rc;\par
11398 \par
11399   /* perform the first step.  this will tell us if we\par
11400   ** have a result set or not and how wide it is.\par
11401   */\par
11402   rc = sqlite3_step(pStmt);\par
11403   /* if we have a result set... */\par
11404   if( SQLITE_ROW == rc )\{\par
11405     /* allocate space for col name ptr, value ptr, and type */\par
11406     int nCol = sqlite3_column_count(pStmt);\par
11407     void *pData = sqlite3_malloc64(3*nCol*sizeof(const char*) + 1);\par
11408     if( !pData )\{\par
11409       rc = SQLITE_NOMEM;\par
11410     \}else\{\par
11411       char **azCols = (char **)pData;      /* Names of result columns */\par
11412       char **azVals = &azCols[nCol];       /* Results */\par
11413       int *aiTypes = (int *)&azVals[nCol]; /* Result types */\par
11414       int i, x;\par
11415       assert(sizeof(int) <= sizeof(char *));\par
11416       /* save off ptrs to column names */\par
11417       for(i=0; i<nCol; i++)\{\par
11418         azCols[i] = (char *)sqlite3_column_name(pStmt, i);\par
11419       \}\par
11420       do\{\par
11421         /* extract the data and data types */\par
11422         for(i=0; i<nCol; i++)\{\par
11423           aiTypes[i] = x = sqlite3_column_type(pStmt, i);\par
11424           if( x==SQLITE_BLOB && pArg && pArg->cMode==MODE_Insert )\{\par
11425             azVals[i] = "";\par
11426           \}else\{\par
11427             azVals[i] = (char*)sqlite3_column_text(pStmt, i);\par
11428           \}\par
11429           if( !azVals[i] && (aiTypes[i]!=SQLITE_NULL) )\{\par
11430             rc = SQLITE_NOMEM;\par
11431             break; /* from for */\par
11432           \}\par
11433         \} /* end for */\par
11434 \par
11435         /* if data and types extracted successfully... */\par
11436         if( SQLITE_ROW == rc )\{\par
11437           /* call the supplied callback with the result row data */\par
11438           if( shell_callback(pArg, nCol, azVals, azCols, aiTypes) )\{\par
11439             rc = SQLITE_ABORT;\par
11440           \}else\{\par
11441             rc = sqlite3_step(pStmt);\par
11442           \}\par
11443         \}\par
11444       \} while( SQLITE_ROW == rc );\par
11445       sqlite3_free(pData);\par
11446     \}\par
11447   \}\par
11448 \}\par
}
}
{\xe \v expertBestIndex\:shell.c}
{\xe \v shell.c\:expertBestIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertBestIndex ({\b sqlite3_vtab} *  {\i pVtab}, {\b sqlite3_index_info} *  {\i pIdxInfo}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7143 of file shell.c.}\par
{
References IdxTable::aCol, sqlite3_index_info::aConstraint, sqlite3_index_info::aConstraintUsage, sqlite3_index_info::aOrderBy, sqlite3_index_info::sqlite3_index_constraint_usage::argvIndex, IdxConstraint::bDesc, IdxConstraint::bRange, sqlite3_index_info::sqlite3_index_orderby::desc, sqlite3_index_info::estimatedCost, IdxConstraint::iCol, sqlite3_index_info::sqlite3_index_orderby::iColumn, idxMalloc(), idxNewConstraint(), IdxColumn::iPk, sqlite3_index_info::nConstraint, sqlite3_index_info::nOrderBy, IdxScan::pEq, ExpertVtab::pExpert, IdxConstraint::pLink, IdxConstraint::pNext, IdxScan::pNextScan, IdxScan::pOrder, IdxScan::pRange, sqlite3expert::pScan, IdxScan::pTab, ExpertVtab::pTab, sqlite3_vtab_collation, SQLITE_INDEX_CONSTRAINT_EQ, SQLITE_INDEX_CONSTRAINT_GE, SQLITE_INDEX_CONSTRAINT_GT, SQLITE_INDEX_CONSTRAINT_LE, SQLITE_INDEX_CONSTRAINT_LT, SQLITE_OK, and IdxColumn::zColl.}\par
{
Referenced by idxRegisterVtab().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7143                                                                              \{\par
 7144   ExpertVtab *p = (ExpertVtab*)pVtab;\par
 7145   int rc = SQLITE_OK;\par
 7146   int n = 0;\par
 7147   IdxScan *pScan;\par
 7148   const int opmask = \par
 7149     SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_GT |\par
 7150     SQLITE_INDEX_CONSTRAINT_LT | SQLITE_INDEX_CONSTRAINT_GE |\par
 7151     SQLITE_INDEX_CONSTRAINT_LE;\par
 7152 \par
 7153   pScan = idxMalloc(&rc, sizeof(IdxScan));\par
 7154   if( pScan )\{\par
 7155     int i;\par
 7156 \par
 7157     /* Link the new scan object into the list */\par
 7158     pScan->pTab = p->pTab;\par
 7159     pScan->pNextScan = p->pExpert->pScan;\par
 7160     p->pExpert->pScan = pScan;\par
 7161 \par
 7162     /* Add the constraints to the IdxScan object */\par
 7163     for(i=0; i<pIdxInfo->nConstraint; i++)\{\par
 7164       struct sqlite3_index_constraint *pCons = &pIdxInfo->aConstraint[i];\par
 7165       if( pCons->usable \par
 7166        && pCons->iColumn>=0 \par
 7167        && p->pTab->aCol[pCons->iColumn].iPk==0\par
 7168        && (pCons->op & opmask) \par
 7169       )\{\par
 7170         IdxConstraint *pNew;\par
 7171         const char *zColl = sqlite3_vtab_collation(pIdxInfo, i);\par
 7172         pNew = idxNewConstraint(&rc, zColl);\par
 7173         if( pNew )\{\par
 7174           pNew->iCol = pCons->iColumn;\par
 7175           if( pCons->op==SQLITE_INDEX_CONSTRAINT_EQ )\{\par
 7176             pNew->pNext = pScan->pEq;\par
 7177             pScan->pEq = pNew;\par
 7178           \}else\{\par
 7179             pNew->bRange = 1;\par
 7180             pNew->pNext = pScan->pRange;\par
 7181             pScan->pRange = pNew;\par
 7182           \}\par
 7183         \}\par
 7184         n++;\par
 7185         pIdxInfo->aConstraintUsage[i].argvIndex = n;\par
 7186       \}\par
 7187     \}\par
 7188 \par
 7189     /* Add the ORDER BY to the IdxScan object */\par
 7190     for(i=pIdxInfo->nOrderBy-1; i>=0; i--)\{\par
 7191       int iCol = pIdxInfo->aOrderBy[i].iColumn;\par
 7192       if( iCol>=0 )\{\par
 7193         IdxConstraint *pNew = idxNewConstraint(&rc, p->pTab->aCol[iCol].zColl);\par
 7194         if( pNew )\{\par
 7195           pNew->iCol = iCol;\par
 7196           pNew->bDesc = pIdxInfo->aOrderBy[i].desc;\par
 7197           pNew->pNext = pScan->pOrder;\par
 7198           pNew->pLink = pScan->pOrder;\par
 7199           pScan->pOrder = pNew;\par
 7200           n++;\par
 7201         \}\par
 7202       \}\par
 7203     \}\par
 7204   \}\par
 7205 \par
 7206   pIdxInfo->estimatedCost = 1000000.0 / (n+1);\par
 7207   return rc;\par
 7208 \}\par
}
}
{\xe \v expertClose\:shell.c}
{\xe \v shell.c\:expertClose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertClose ({\b sqlite3_vtab_cursor} *  {\i cur}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7238 of file shell.c.}\par
{
References ExpertCsr::pData, sqlite3_finalize, sqlite3_free, and SQLITE_OK.}\par
{
Referenced by idxRegisterVtab().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7238                                                 \{\par
 7239   ExpertCsr *pCsr = (ExpertCsr*)cur;\par
 7240   sqlite3_finalize(pCsr->pData);\par
 7241   sqlite3_free(pCsr);\par
 7242   return SQLITE_OK;\par
 7243 \}\par
}
}
{\xe \v expertColumn\:shell.c}
{\xe \v shell.c\:expertColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertColumn ({\b sqlite3_vtab_cursor} *  {\i cur}, {\b sqlite3_context} *  {\i ctx}, int  {\i i}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7287 of file shell.c.}\par
{
References ExpertCsr::pData, sqlite3_column_value, sqlite3_result_value, and SQLITE_OK.}\par
{
Referenced by idxRegisterVtab().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7287                                                                               \{\par
 7288   ExpertCsr *pCsr = (ExpertCsr*)cur;\par
 7289   sqlite3_value *pVal;\par
 7290   pVal = sqlite3_column_value(pCsr->pData, i);\par
 7291   if( pVal )\{\par
 7292     sqlite3_result_value(ctx, pVal);\par
 7293   \}\par
 7294   return SQLITE_OK;\par
 7295 \}\par
}
}
{\xe \v expertConnect\:shell.c}
{\xe \v shell.c\:expertConnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertConnect ({\b sqlite3} *  {\i db}, void *  {\i pAux}, int  {\i argc}, const char *const *  {\i argv}, {\b sqlite3_vtab} **  {\i ppVtab}, char **  {\i pzErr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7101 of file shell.c.}\par
{
References expertDequote(), idxMalloc(), ExpertVtab::pExpert, ExpertVtab::pTab, sqlite3expert::pTable, sqlite3_declare_vtab, sqlite3_free, sqlite3_mprintf, sqlite3_stricmp, SQLITE_ERROR, SQLITE_NOMEM, SQLITE_OK, and IdxTable::zName.}\par
{
Referenced by idxRegisterVtab().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7107  \{\par
 7108   sqlite3expert *pExpert = (sqlite3expert*)pAux;\par
 7109   ExpertVtab *p = 0;\par
 7110   int rc;\par
 7111 \par
 7112   if( argc!=4 )\{\par
 7113     *pzErr = sqlite3_mprintf("internal error!");\par
 7114     rc = SQLITE_ERROR;\par
 7115   \}else\{\par
 7116     char *zCreateTable = expertDequote(argv[3]);\par
 7117     if( zCreateTable )\{\par
 7118       rc = sqlite3_declare_vtab(db, zCreateTable);\par
 7119       if( rc==SQLITE_OK )\{\par
 7120         p = idxMalloc(&rc, sizeof(ExpertVtab));\par
 7121       \}\par
 7122       if( rc==SQLITE_OK )\{\par
 7123         p->pExpert = pExpert;\par
 7124         p->pTab = pExpert->pTable;\par
 7125         assert( sqlite3_stricmp(p->pTab->zName, argv[2])==0 );\par
 7126       \}\par
 7127       sqlite3_free(zCreateTable);\par
 7128     \}else\{\par
 7129       rc = SQLITE_NOMEM;\par
 7130     \}\par
 7131   \}\par
 7132 \par
 7133   *ppVtab = (sqlite3_vtab*)p;\par
 7134   return rc;\par
 7135 \}\par
}
}
{\xe \v expertDequote\:shell.c}
{\xe \v shell.c\:expertDequote}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* expertDequote (const char *  {\i zIn}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7069 of file shell.c.}\par
{
References sqlite3_malloc, and STRLEN.}\par
{
Referenced by expertConnect().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7069                                            \{\par
 7070   int n = STRLEN(zIn);\par
 7071   char *zRet = sqlite3_malloc(n);\par
 7072 \par
 7073   assert( zIn[0]=='\\'' );\par
 7074   assert( zIn[n-1]=='\\'' );\par
 7075 \par
 7076   if( zRet )\{\par
 7077     int iOut = 0;\par
 7078     int iIn = 0;\par
 7079     for(iIn=1; iIn<(n-1); iIn++)\{\par
 7080       if( zIn[iIn]=='\\'' )\{\par
 7081         assert( zIn[iIn+1]=='\\'' );\par
 7082         iIn++;\par
 7083       \}\par
 7084       zRet[iOut++] = zIn[iIn];\par
 7085     \}\par
 7086     zRet[iOut] = '\\0';\par
 7087   \}\par
 7088 \par
 7089   return zRet;\par
 7090 \}\par
}
}
{\xe \v expertDisconnect\:shell.c}
{\xe \v shell.c\:expertDisconnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertDisconnect ({\b sqlite3_vtab} *  {\i pVtab}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7137 of file shell.c.}\par
{
References sqlite3_free, and SQLITE_OK.}\par
{
Referenced by idxRegisterVtab().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7137                                                 \{\par
 7138   ExpertVtab *p = (ExpertVtab*)pVtab;\par
 7139   sqlite3_free(p);\par
 7140   return SQLITE_OK;\par
 7141 \}\par
}
}
{\xe \v expertDotCommand\:shell.c}
{\xe \v shell.c\:expertDotCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertDotCommand ({\b ShellState} *  {\i pState}, char **  {\i azArg}, int  {\i nArg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11526 of file shell.c.}\par
{
References ExpertInfo::bVerbose, ShellState::db, ShellState::expert, EXPERT_CONFIG_SAMPLE, integerValue(), ExpertInfo::pExpert, raw_printf, sqlite3_expert_config(), sqlite3_expert_new(), SQLITE_ERROR, SQLITE_OK, and strlen30().}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11530  \{\par
11531   int rc = SQLITE_OK;\par
11532   char *zErr = 0;\par
11533   int i;\par
11534   int iSample = 0;\par
11535 \par
11536   assert( pState->expert.pExpert==0 );\par
11537   memset(&pState->expert, 0, sizeof(ExpertInfo));\par
11538 \par
11539   for(i=1; rc==SQLITE_OK && i<nArg; i++)\{\par
11540     char *z = azArg[i];\par
11541     int n;\par
11542     if( z[0]=='-' && z[1]=='-' ) z++;\par
11543     n = strlen30(z);\par
11544     if( n>=2 && 0==strncmp(z, "-verbose", n) )\{\par
11545       pState->expert.bVerbose = 1;\par
11546     \}\par
11547     else if( n>=2 && 0==strncmp(z, "-sample", n) )\{\par
11548       if( i==(nArg-1) )\{\par
11549         raw_printf(stderr, "option requires an argument: %s\\n", z);\par
11550         rc = SQLITE_ERROR;\par
11551       \}else\{\par
11552         iSample = (int)integerValue(azArg[++i]);\par
11553         if( iSample<0 || iSample>100 )\{\par
11554           raw_printf(stderr, "value out of range: %s\\n", azArg[i]);\par
11555           rc = SQLITE_ERROR;\par
11556         \}\par
11557       \}\par
11558     \}\par
11559     else\{\par
11560       raw_printf(stderr, "unknown option: %s\\n", z);\par
11561       rc = SQLITE_ERROR;\par
11562     \}\par
11563   \}\par
11564 \par
11565   if( rc==SQLITE_OK )\{\par
11566     pState->expert.pExpert = sqlite3_expert_new(pState->db, &zErr);\par
11567     if( pState->expert.pExpert==0 )\{\par
11568       raw_printf(stderr, "sqlite3_expert_new: %s\\n", zErr);\par
11569       rc = SQLITE_ERROR;\par
11570     \}else\{\par
11571       sqlite3_expert_config(\par
11572           pState->expert.pExpert, EXPERT_CONFIG_SAMPLE, iSample\par
11573       );\par
11574     \}\par
11575   \}\par
11576 \par
11577   return rc;\par
11578 \}\par
}
}
{\xe \v expertEof\:shell.c}
{\xe \v shell.c\:expertEof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertEof ({\b sqlite3_vtab_cursor} *  {\i cur}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7251 of file shell.c.}\par
{
References ExpertCsr::pData.}\par
{
Referenced by idxRegisterVtab().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7251                                               \{\par
 7252   ExpertCsr *pCsr = (ExpertCsr*)cur;\par
 7253   return pCsr->pData==0;\par
 7254 \}\par
}
}
{\xe \v expertFilter\:shell.c}
{\xe \v shell.c\:expertFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertFilter ({\b sqlite3_vtab_cursor} *  {\i cur}, int  {\i idxNum}, const char *  {\i idxStr}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7300 of file shell.c.}\par
{
References ExpertVtab::base, sqlite3expert::db, expertNext(), idxPrintfPrepareStmt(), ExpertCsr::pData, ExpertVtab::pExpert, ExpertVtab::pTab, sqlite3_vtab_cursor::pVtab, sqlite3_finalize, SQLITE_OK, sqlite3_vtab::zErrMsg, and IdxTable::zName.}\par
{
Referenced by idxRegisterVtab().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7304  \{\par
 7305   ExpertCsr *pCsr = (ExpertCsr*)cur;\par
 7306   ExpertVtab *pVtab = (ExpertVtab*)(cur->pVtab);\par
 7307   sqlite3expert *pExpert = pVtab->pExpert;\par
 7308   int rc;\par
 7309 \par
 7310   (void)idxNum;\par
 7311   (void)idxStr;\par
 7312   (void)argc;\par
 7313   (void)argv;\par
 7314   rc = sqlite3_finalize(pCsr->pData);\par
 7315   pCsr->pData = 0;\par
 7316   if( rc==SQLITE_OK )\{\par
 7317     rc = idxPrintfPrepareStmt(pExpert->db, &pCsr->pData, &pVtab->base.zErrMsg,\par
 7318         "SELECT * FROM main.%Q WHERE sample()", pVtab->pTab->zName\par
 7319     );\par
 7320   \}\par
 7321 \par
 7322   if( rc==SQLITE_OK )\{\par
 7323     rc = expertNext(cur);\par
 7324   \}\par
 7325   return rc;\par
 7326 \}\par
}
}
{\xe \v expertFinish\:shell.c}
{\xe \v shell.c\:expertFinish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertFinish ({\b ShellState} *  {\i pState}, int  {\i bCancel}, char **  {\i pzErr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11481 of file shell.c.}\par
{
References ExpertInfo::bVerbose, ShellState::expert, EXPERT_REPORT_CANDIDATES, EXPERT_REPORT_INDEXES, EXPERT_REPORT_PLAN, EXPERT_REPORT_SQL, ShellState::out, ExpertInfo::pExpert, raw_printf, sqlite3_expert_analyze(), sqlite3_expert_count(), sqlite3_expert_destroy(), sqlite3_expert_report(), and SQLITE_OK.}\par
{
Referenced by do_meta_command(), and shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11485  \{\par
11486   int rc = SQLITE_OK;\par
11487   sqlite3expert *p = pState->expert.pExpert;\par
11488   assert( p );\par
11489   assert( bCancel || pzErr==0 || *pzErr==0 );\par
11490   if( bCancel==0 )\{\par
11491     FILE *out = pState->out;\par
11492     int bVerbose = pState->expert.bVerbose;\par
11493 \par
11494     rc = sqlite3_expert_analyze(p, pzErr);\par
11495     if( rc==SQLITE_OK )\{\par
11496       int nQuery = sqlite3_expert_count(p);\par
11497       int i;\par
11498 \par
11499       if( bVerbose )\{\par
11500         const char *zCand = sqlite3_expert_report(p,0,EXPERT_REPORT_CANDIDATES);\par
11501         raw_printf(out, "-- Candidates -----------------------------\\n");\par
11502         raw_printf(out, "%s\\n", zCand);\par
11503       \}\par
11504       for(i=0; i<nQuery; i++)\{\par
11505         const char *zSql = sqlite3_expert_report(p, i, EXPERT_REPORT_SQL);\par
11506         const char *zIdx = sqlite3_expert_report(p, i, EXPERT_REPORT_INDEXES);\par
11507         const char *zEQP = sqlite3_expert_report(p, i, EXPERT_REPORT_PLAN);\par
11508         if( zIdx==0 ) zIdx = "(no new indexes)\\n";\par
11509         if( bVerbose )\{\par
11510           raw_printf(out, "-- Query %d --------------------------------\\n",i+1);\par
11511           raw_printf(out, "%s\\n\\n", zSql);\par
11512         \}\par
11513         raw_printf(out, "%s\\n", zIdx);\par
11514         raw_printf(out, "%s\\n", zEQP);\par
11515       \}\par
11516     \}\par
11517   \}\par
11518   sqlite3_expert_destroy(p);\par
11519   pState->expert.pExpert = 0;\par
11520   return rc;\par
11521 \}\par
}
}
{\xe \v expertHandleSQL\:shell.c}
{\xe \v shell.c\:expertHandleSQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertHandleSQL ({\b ShellState} *  {\i pState}, const char *  {\i zSql}, char **  {\i pzErr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11461 of file shell.c.}\par
{
References ShellState::expert, ExpertInfo::pExpert, and sqlite3_expert_sql().}\par
{
Referenced by shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11465  \{\par
11466   assert( pState->expert.pExpert );\par
11467   assert( pzErr==0 || *pzErr==0 );\par
11468   return sqlite3_expert_sql(pState->expert.pExpert, zSql, pzErr);\par
11469 \}\par
}
}
{\xe \v expertNext\:shell.c}
{\xe \v shell.c\:expertNext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertNext ({\b sqlite3_vtab_cursor} *  {\i cur}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7259 of file shell.c.}\par
{
References ExpertCsr::pData, sqlite3_finalize, sqlite3_step, SQLITE_OK, and SQLITE_ROW.}\par
{
Referenced by expertFilter(), and idxRegisterVtab().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7259                                                \{\par
 7260   ExpertCsr *pCsr = (ExpertCsr*)cur;\par
 7261   int rc = SQLITE_OK;\par
 7262 \par
 7263   assert( pCsr->pData );\par
 7264   rc = sqlite3_step(pCsr->pData);\par
 7265   if( rc!=SQLITE_ROW )\{\par
 7266     rc = sqlite3_finalize(pCsr->pData);\par
 7267     pCsr->pData = 0;\par
 7268   \}else\{\par
 7269     rc = SQLITE_OK;\par
 7270   \}\par
 7271 \par
 7272   return rc;\par
 7273 \}\par
}
}
{\xe \v expertOpen\:shell.c}
{\xe \v shell.c\:expertOpen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertOpen ({\b sqlite3_vtab} *  {\i pVTab}, {\b sqlite3_vtab_cursor} **  {\i ppCursor}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7226 of file shell.c.}\par
{
References idxMalloc(), and SQLITE_OK.}\par
{
Referenced by idxRegisterVtab().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7226                                                                           \{\par
 7227   int rc = SQLITE_OK;\par
 7228   ExpertCsr *pCsr;\par
 7229   (void)pVTab;\par
 7230   pCsr = idxMalloc(&rc, sizeof(ExpertCsr));\par
 7231   *ppCursor = (sqlite3_vtab_cursor*)pCsr;\par
 7232   return rc;\par
 7233 \}\par
}
}
{\xe \v expertRowid\:shell.c}
{\xe \v shell.c\:expertRowid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertRowid ({\b sqlite3_vtab_cursor} *  {\i cur}, {\b sqlite_int64} *  {\i pRowid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7278 of file shell.c.}\par
{
References SQLITE_OK.}\par
{
Referenced by idxRegisterVtab().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7278                                                                       \{\par
 7279   (void)cur;\par
 7280   *pRowid = 0;\par
 7281   return SQLITE_OK;\par
 7282 \}\par
}
}
{\xe \v expertUpdate\:shell.c}
{\xe \v shell.c\:expertUpdate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int expertUpdate ({\b sqlite3_vtab} *  {\i pVtab}, int  {\i nData}, {\b sqlite3_value} **  {\i azData}, {\b sqlite_int64} *  {\i pRowid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7210 of file shell.c.}\par
{
References SQLITE_OK.}\par
{
Referenced by idxRegisterVtab().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7215  \{\par
 7216   (void)pVtab;\par
 7217   (void)nData;\par
 7218   (void)azData;\par
 7219   (void)pRowid;\par
 7220   return SQLITE_OK;\par
 7221 \}\par
}
}
{\xe \v explain_data_delete\:shell.c}
{\xe \v shell.c\:explain_data_delete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void explain_data_delete ({\b ShellState} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11289 of file shell.c.}\par
{
References ShellState::aiIndent, ShellState::iIndent, ShellState::nIndent, and sqlite3_free.}\par
{
Referenced by shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11289                                               \{\par
11290   sqlite3_free(p->aiIndent);\par
11291   p->aiIndent = 0;\par
11292   p->nIndent = 0;\par
11293   p->iIndent = 0;\par
11294 \}\par
}
}
{\xe \v explain_data_prepare\:shell.c}
{\xe \v shell.c\:explain_data_prepare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void explain_data_prepare ({\b ShellState} *  {\i p}, {\b sqlite3_stmt} *  {\i pSql}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11206 of file shell.c.}\par
{
References ShellState::aiIndent, ArraySize, ShellState::cMode, ShellState::iIndent, ShellState::mode, ShellState::nIndent, shell_out_of_memory(), sqlite3_column_count, sqlite3_column_int, sqlite3_column_name, sqlite3_column_text, sqlite3_free, sqlite3_realloc64, sqlite3_reset, sqlite3_sql, sqlite3_step, sqlite3_strnicmp, SQLITE_ROW, and str_in_array().}\par
{
Referenced by shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11206                                                                    \{\par
11207   const char *zSql;               /* The text of the SQL statement */\par
11208   const char *z;                  /* Used to check if this is an EXPLAIN */\par
11209   int *abYield = 0;               /* True if op is an OP_Yield */\par
11210   int nAlloc = 0;                 /* Allocated size of p->aiIndent[], abYield */\par
11211   int iOp;                        /* Index of operation in p->aiIndent[] */\par
11212 \par
11213   const char *azNext[] = \{ "Next", "Prev", "VPrev", "VNext", "SorterNext", 0 \};\par
11214   const char *azYield[] = \{ "Yield", "SeekLT", "SeekGT", "RowSetRead",\par
11215                             "Rewind", 0 \};\par
11216   const char *azGoto[] = \{ "Goto", 0 \};\par
11217 \par
11218   /* Try to figure out if this is really an EXPLAIN statement. If this\par
11219   ** cannot be verified, return early.  */\par
11220   if( sqlite3_column_count(pSql)!=8 )\{\par
11221     p->cMode = p->mode;\par
11222     return;\par
11223   \}\par
11224   zSql = sqlite3_sql(pSql);\par
11225   if( zSql==0 ) return;\par
11226   for(z=zSql; *z==' ' || *z=='\\t' || *z=='\\n' || *z=='\\f' || *z=='\\r'; z++);\par
11227   if( sqlite3_strnicmp(z, "explain", 7) )\{\par
11228     p->cMode = p->mode;\par
11229     return;\par
11230   \}\par
11231 \par
11232   for(iOp=0; SQLITE_ROW==sqlite3_step(pSql); iOp++)\{\par
11233     int i;\par
11234     int iAddr = sqlite3_column_int(pSql, 0);\par
11235     const char *zOp = (const char*)sqlite3_column_text(pSql, 1);\par
11236 \par
11237     /* Set p2 to the P2 field of the current opcode. Then, assuming that\par
11238     ** p2 is an instruction address, set variable p2op to the index of that\par
11239     ** instruction in the aiIndent[] array. p2 and p2op may be different if\par
11240     ** the current instruction is part of a sub-program generated by an\par
11241     ** SQL trigger or foreign key.  */\par
11242     int p2 = sqlite3_column_int(pSql, 3);\par
11243     int p2op = (p2 + (iOp-iAddr));\par
11244 \par
11245     /* Grow the p->aiIndent array as required */\par
11246     if( iOp>=nAlloc )\{\par
11247       if( iOp==0 )\{\par
11248         /* Do further verfication that this is explain output.  Abort if\par
11249         ** it is not */\par
11250         static const char *explainCols[] = \{\par
11251            "addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment" \};\par
11252         int jj;\par
11253         for(jj=0; jj<ArraySize(explainCols); jj++)\{\par
11254           if( strcmp(sqlite3_column_name(pSql,jj),explainCols[jj])!=0 )\{\par
11255             p->cMode = p->mode;\par
11256             sqlite3_reset(pSql);\par
11257             return;\par
11258           \}\par
11259         \}\par
11260       \}\par
11261       nAlloc += 100;\par
11262       p->aiIndent = (int*)sqlite3_realloc64(p->aiIndent, nAlloc*sizeof(int));\par
11263       if( p->aiIndent==0 ) shell_out_of_memory();\par
11264       abYield = (int*)sqlite3_realloc64(abYield, nAlloc*sizeof(int));\par
11265       if( abYield==0 ) shell_out_of_memory();\par
11266     \}\par
11267     abYield[iOp] = str_in_array(zOp, azYield);\par
11268     p->aiIndent[iOp] = 0;\par
11269     p->nIndent = iOp+1;\par
11270 \par
11271     if( str_in_array(zOp, azNext) )\{\par
11272       for(i=p2op; i<iOp; i++) p->aiIndent[i] += 2;\par
11273     \}\par
11274     if( str_in_array(zOp, azGoto) && p2op<p->nIndent\par
11275      && (abYield[p2op] || sqlite3_column_int(pSql, 2))\par
11276     )\{\par
11277       for(i=p2op; i<iOp; i++) p->aiIndent[i] += 2;\par
11278     \}\par
11279   \}\par
11280 \par
11281   p->iIndent = 0;\par
11282   sqlite3_free(abYield);\par
11283   sqlite3_reset(pSql);\par
11284 \}\par
}
}
{\xe \v fileLinkStat\:shell.c}
{\xe \v shell.c\:fileLinkStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fileLinkStat (const char *  {\i zPath}, struct stat *  {\i pStatBuf}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2311 of file shell.c.}\par
{
Referenced by fsdirFilter(), and fsdirNext().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2314  \{\par
 2315 #if defined(_WIN32)\par
 2316   int rc = lstat(zPath, pStatBuf);\par
 2317   if( rc==0 ) statTimesToUtc(zPath, pStatBuf);\par
 2318   return rc;\par
 2319 #else\par
 2320   return lstat(zPath, pStatBuf);\par
 2321 #endif\par
 2322 \}\par
}
}
{\xe \v fileStat\:shell.c}
{\xe \v shell.c\:fileStat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fileStat (const char *  {\i zPath}, struct stat *  {\i pStatBuf}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2293 of file shell.c.}\par
{
Referenced by makeDirectory(), and writeFile().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2296  \{\par
 2297 #if defined(_WIN32)\par
 2298   int rc = stat(zPath, pStatBuf);\par
 2299   if( rc==0 ) statTimesToUtc(zPath, pStatBuf);\par
 2300   return rc;\par
 2301 #else\par
 2302   return stat(zPath, pStatBuf);\par
 2303 #endif\par
 2304 \}\par
}
}
{\xe \v find_home_dir\:shell.c}
{\xe \v shell.c\:find_home_dir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* find_home_dir (int  {\i clearFlag}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18419 of file shell.c.}\par
{
References sqlite3_snprintf, and strlen30().}\par
{
Referenced by main(), and process_sqliterc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18419                                          \{\par
18420   static char *home_dir = NULL;\par
18421   if( clearFlag )\{\par
18422     free(home_dir);\par
18423     home_dir = 0;\par
18424     return 0;\par
18425   \}\par
18426   if( home_dir ) return home_dir;\par
18427 \par
18428 #if !defined(_WIN32) && !defined(WIN32) && !defined(_WIN32_WCE) \\\par
18429      && !defined(__RTP__) && !defined(_WRS_KERNEL)\par
18430   \{\par
18431     struct passwd *pwent;\par
18432     uid_t uid = getuid();\par
18433     if( (pwent=getpwuid(uid)) != NULL) \{\par
18434       home_dir = pwent->pw_dir;\par
18435     \}\par
18436   \}\par
18437 #endif\par
18438 \par
18439 #if defined(_WIN32_WCE)\par
18440   /* Windows CE (arm-wince-mingw32ce-gcc) does not provide getenv()\par
18441    */\par
18442   home_dir = "/";\par
18443 #else\par
18444 \par
18445 #if defined(_WIN32) || defined(WIN32)\par
18446   if (!home_dir) \{\par
18447     home_dir = getenv("USERPROFILE");\par
18448   \}\par
18449 #endif\par
18450 \par
18451   if (!home_dir) \{\par
18452     home_dir = getenv("HOME");\par
18453   \}\par
18454 \par
18455 #if defined(_WIN32) || defined(WIN32)\par
18456   if (!home_dir) \{\par
18457     char *zDrive, *zPath;\par
18458     int n;\par
18459     zDrive = getenv("HOMEDRIVE");\par
18460     zPath = getenv("HOMEPATH");\par
18461     if( zDrive && zPath )\{\par
18462       n = strlen30(zDrive) + strlen30(zPath) + 1;\par
18463       home_dir = malloc( n );\par
18464       if( home_dir==0 ) return 0;\par
18465       sqlite3_snprintf(n, home_dir, "%s%s", zDrive, zPath);\par
18466       return home_dir;\par
18467     \}\par
18468     home_dir = "c:\\\\";\par
18469   \}\par
18470 #endif\par
18471 \par
18472 #endif /* !_WIN32_WCE */\par
18473 \par
18474   if( home_dir )\{\par
18475     int n = strlen30(home_dir) + 1;\par
18476     char *z = malloc( n );\par
18477     if( z ) memcpy(z, home_dir, n);\par
18478     home_dir = z;\par
18479   \}\par
18480 \par
18481   return home_dir;\par
18482 \}\par
}
}
{\xe \v freeColumnList\:shell.c}
{\xe \v shell.c\:freeColumnList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void freeColumnList (char **  {\i azCol}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11746 of file shell.c.}\par
{
References sqlite3_free.}\par
{
Referenced by dump_callback(), and tableColumnList().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11746                                         \{\par
11747   int i;\par
11748   for(i=1; azCol[i]; i++)\{\par
11749     sqlite3_free(azCol[i]);\par
11750   \}\par
11751   /* azCol[0] is a static string */\par
11752   sqlite3_free(azCol);\par
11753 \}\par
}
}
{\xe \v freeText\:shell.c}
{\xe \v shell.c\:freeText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void freeText ({\b ShellText} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 737 of file shell.c.}\par
{
References initText(), and ShellText::z.}\par
{
Referenced by do_meta_command(), dump_callback(), and shellFakeSchema().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   737                                   \{\par
  738   free(p->z);\par
  739   initText(p);\par
  740 \}\par
}
}
{\xe \v fsdirBestIndex\:shell.c}
{\xe \v shell.c\:fsdirBestIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fsdirBestIndex ({\b sqlite3_vtab} *  {\i tab}, {\b sqlite3_index_info} *  {\i pIdxInfo}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2902 of file shell.c.}\par
{
References sqlite3_index_info::aConstraint, sqlite3_index_info::aConstraintUsage, sqlite3_index_info::sqlite3_index_constraint_usage::argvIndex, sqlite3_index_info::estimatedCost, sqlite3_index_info::estimatedRows, FSDIR_COLUMN_DIR, FSDIR_COLUMN_PATH, sqlite3_index_info::idxNum, sqlite3_index_info::nConstraint, sqlite3_index_info::sqlite3_index_constraint_usage::omit, SQLITE_CONSTRAINT, SQLITE_INDEX_CONSTRAINT_EQ, and SQLITE_OK.}\par
{
Referenced by fsdirRegister().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2905  \{\par
 2906   int i;                 /* Loop over constraints */\par
 2907   int idxPath = -1;      /* Index in pIdxInfo->aConstraint of PATH= */\par
 2908   int idxDir = -1;       /* Index in pIdxInfo->aConstraint of DIR= */\par
 2909   int seenPath = 0;      /* True if an unusable PATH= constraint is seen */\par
 2910   int seenDir = 0;       /* True if an unusable DIR= constraint is seen */\par
 2911   const struct sqlite3_index_constraint *pConstraint;\par
 2912 \par
 2913   (void)tab;\par
 2914   pConstraint = pIdxInfo->aConstraint;\par
 2915   for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++)\{\par
 2916     if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;\par
 2917     switch( pConstraint->iColumn )\{\par
 2918       case FSDIR_COLUMN_PATH: \{\par
 2919         if( pConstraint->usable )\{\par
 2920           idxPath = i;\par
 2921           seenPath = 0;\par
 2922         \}else if( idxPath<0 )\{\par
 2923           seenPath = 1;\par
 2924         \}\par
 2925         break;\par
 2926       \}\par
 2927       case FSDIR_COLUMN_DIR: \{\par
 2928         if( pConstraint->usable )\{\par
 2929           idxDir = i;\par
 2930           seenDir = 0;\par
 2931         \}else if( idxDir<0 )\{\par
 2932           seenDir = 1;\par
 2933         \}\par
 2934         break;\par
 2935       \}\par
 2936     \} \par
 2937   \}\par
 2938   if( seenPath || seenDir )\{\par
 2939     /* If input parameters are unusable, disallow this plan */\par
 2940     return SQLITE_CONSTRAINT;\par
 2941   \}\par
 2942 \par
 2943   if( idxPath<0 )\{\par
 2944     pIdxInfo->idxNum = 0;\par
 2945     /* The pIdxInfo->estimatedCost should have been initialized to a huge\par
 2946     ** number.  Leave it unchanged. */\par
 2947     pIdxInfo->estimatedRows = 0x7fffffff;\par
 2948   \}else\{\par
 2949     pIdxInfo->aConstraintUsage[idxPath].omit = 1;\par
 2950     pIdxInfo->aConstraintUsage[idxPath].argvIndex = 1;\par
 2951     if( idxDir>=0 )\{\par
 2952       pIdxInfo->aConstraintUsage[idxDir].omit = 1;\par
 2953       pIdxInfo->aConstraintUsage[idxDir].argvIndex = 2;\par
 2954       pIdxInfo->idxNum = 2;\par
 2955       pIdxInfo->estimatedCost = 10.0;\par
 2956     \}else\{\par
 2957       pIdxInfo->idxNum = 1;\par
 2958       pIdxInfo->estimatedCost = 100.0;\par
 2959     \}\par
 2960   \}\par
 2961 \par
 2962   return SQLITE_OK;\par
 2963 \}\par
}
}
{\xe \v fsdirClose\:shell.c}
{\xe \v shell.c\:fsdirClose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fsdirClose ({\b sqlite3_vtab_cursor} *  {\i cur}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2673 of file shell.c.}\par
{
References fsdirResetCursor(), sqlite3_free, and SQLITE_OK.}\par
{
Referenced by fsdirRegister().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2673                                                \{\par
 2674   fsdir_cursor *pCur = (fsdir_cursor*)cur;\par
 2675 \par
 2676   fsdirResetCursor(pCur);\par
 2677   sqlite3_free(pCur);\par
 2678   return SQLITE_OK;\par
 2679 \}\par
}
}
{\xe \v fsdirColumn\:shell.c}
{\xe \v shell.c\:fsdirColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fsdirColumn ({\b sqlite3_vtab_cursor} *  {\i cur}, {\b sqlite3_context} *  {\i ctx}, int  {\i i}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2760 of file shell.c.}\par
{
References FSDIR_COLUMN_DATA, FSDIR_COLUMN_MODE, FSDIR_COLUMN_MTIME, FSDIR_COLUMN_NAME, FSDIR_COLUMN_PATH, fsdir_cursor::nBase, readFileContents(), sqlite3_free, sqlite3_malloc64, sqlite3_result_error_nomem, sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, SQLITE_NOMEM, SQLITE_OK, SQLITE_TRANSIENT, fsdir_cursor::sStat, and fsdir_cursor::zPath.}\par
{
Referenced by fsdirRegister().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2764  \{\par
 2765   fsdir_cursor *pCur = (fsdir_cursor*)cur;\par
 2766   switch( i )\{\par
 2767     case FSDIR_COLUMN_NAME: \{\par
 2768       sqlite3_result_text(ctx, &pCur->zPath[pCur->nBase], -1, SQLITE_TRANSIENT);\par
 2769       break;\par
 2770     \}\par
 2771 \par
 2772     case FSDIR_COLUMN_MODE:\par
 2773       sqlite3_result_int64(ctx, pCur->sStat.st_mode);\par
 2774       break;\par
 2775 \par
 2776     case FSDIR_COLUMN_MTIME:\par
 2777       sqlite3_result_int64(ctx, pCur->sStat.st_mtime);\par
 2778       break;\par
 2779 \par
 2780     case FSDIR_COLUMN_DATA: \{\par
 2781       mode_t m = pCur->sStat.st_mode;\par
 2782       if( S_ISDIR(m) )\{\par
 2783         sqlite3_result_null(ctx);\par
 2784 #if !defined(_WIN32) && !defined(WIN32)\par
 2785       \}else if( S_ISLNK(m) )\{\par
 2786         char aStatic[64];\par
 2787         char *aBuf = aStatic;\par
 2788         sqlite3_int64 nBuf = 64;\par
 2789         int n;\par
 2790 \par
 2791         while( 1 )\{\par
 2792           n = readlink(pCur->zPath, aBuf, nBuf);\par
 2793           if( n<nBuf ) break;\par
 2794           if( aBuf!=aStatic ) sqlite3_free(aBuf);\par
 2795           nBuf = nBuf*2;\par
 2796           aBuf = sqlite3_malloc64(nBuf);\par
 2797           if( aBuf==0 )\{\par
 2798             sqlite3_result_error_nomem(ctx);\par
 2799             return SQLITE_NOMEM;\par
 2800           \}\par
 2801         \}\par
 2802 \par
 2803         sqlite3_result_text(ctx, aBuf, n, SQLITE_TRANSIENT);\par
 2804         if( aBuf!=aStatic ) sqlite3_free(aBuf);\par
 2805 #endif\par
 2806       \}else\{\par
 2807         readFileContents(ctx, pCur->zPath);\par
 2808       \}\par
 2809     \}\par
 2810     case FSDIR_COLUMN_PATH:\par
 2811     default: \{\par
 2812       /* The FSDIR_COLUMN_PATH and FSDIR_COLUMN_DIR are input parameters.\par
 2813       ** always return their values as NULL */\par
 2814       break;\par
 2815     \}\par
 2816   \}\par
 2817   return SQLITE_OK;\par
 2818 \}\par
}
}
{\xe \v fsdirConnect\:shell.c}
{\xe \v shell.c\:fsdirConnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fsdirConnect ({\b sqlite3} *  {\i db}, void *  {\i pAux}, int  {\i argc}, const char *const *  {\i argv}, {\b sqlite3_vtab} **  {\i ppVtab}, char **  {\i pzErr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2602 of file shell.c.}\par
{
References FSDIR_SCHEMA, sqlite3_declare_vtab, sqlite3_malloc, sqlite3_vtab_config, SQLITE_NOMEM, SQLITE_OK, and SQLITE_VTAB_DIRECTONLY.}\par
{
Referenced by fsdirRegister().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2608  \{\par
 2609   fsdir_tab *pNew = 0;\par
 2610   int rc;\par
 2611   (void)pAux;\par
 2612   (void)argc;\par
 2613   (void)argv;\par
 2614   (void)pzErr;\par
 2615   rc = sqlite3_declare_vtab(db, "CREATE TABLE x" FSDIR_SCHEMA);\par
 2616   if( rc==SQLITE_OK )\{\par
 2617     pNew = (fsdir_tab*)sqlite3_malloc( sizeof(*pNew) );\par
 2618     if( pNew==0 ) return SQLITE_NOMEM;\par
 2619     memset(pNew, 0, sizeof(*pNew));\par
 2620     sqlite3_vtab_config(db, SQLITE_VTAB_DIRECTONLY);\par
 2621   \}\par
 2622   *ppVtab = (sqlite3_vtab*)pNew;\par
 2623   return rc;\par
 2624 \}\par
}
}
{\xe \v fsdirDisconnect\:shell.c}
{\xe \v shell.c\:fsdirDisconnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fsdirDisconnect ({\b sqlite3_vtab} *  {\i pVtab}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2629 of file shell.c.}\par
{
References sqlite3_free, and SQLITE_OK.}\par
{
Referenced by fsdirRegister().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2629                                                \{\par
 2630   sqlite3_free(pVtab);\par
 2631   return SQLITE_OK;\par
 2632 \}\par
}
}
{\xe \v fsdirEof\:shell.c}
{\xe \v shell.c\:fsdirEof}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fsdirEof ({\b sqlite3_vtab_cursor} *  {\i cur}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2835 of file shell.c.}\par
{
References fsdir_cursor::zPath.}\par
{
Referenced by fsdirRegister().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2835                                              \{\par
 2836   fsdir_cursor *pCur = (fsdir_cursor*)cur;\par
 2837   return (pCur->zPath==0);\par
 2838 \}\par
}
}
{\xe \v fsdirFilter\:shell.c}
{\xe \v shell.c\:fsdirFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fsdirFilter ({\b sqlite3_vtab_cursor} *  {\i cur}, int  {\i idxNum}, const char *  {\i idxStr}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2846 of file shell.c.}\par
{
References fileLinkStat(), fsdirResetCursor(), fsdirSetErrmsg(), fsdir_cursor::nBase, sqlite3_mprintf, sqlite3_value_text, SQLITE_ERROR, SQLITE_NOMEM, SQLITE_OK, fsdir_cursor::sStat, fsdir_cursor::zBase, and fsdir_cursor::zPath.}\par
{
Referenced by fsdirRegister().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2850  \{\par
 2851   const char *zDir = 0;\par
 2852   fsdir_cursor *pCur = (fsdir_cursor*)cur;\par
 2853   (void)idxStr;\par
 2854   fsdirResetCursor(pCur);\par
 2855 \par
 2856   if( idxNum==0 )\{\par
 2857     fsdirSetErrmsg(pCur, "table function fsdir requires an argument");\par
 2858     return SQLITE_ERROR;\par
 2859   \}\par
 2860 \par
 2861   assert( argc==idxNum && (argc==1 || argc==2) );\par
 2862   zDir = (const char*)sqlite3_value_text(argv[0]);\par
 2863   if( zDir==0 )\{\par
 2864     fsdirSetErrmsg(pCur, "table function fsdir requires a non-NULL argument");\par
 2865     return SQLITE_ERROR;\par
 2866   \}\par
 2867   if( argc==2 )\{\par
 2868     pCur->zBase = (const char*)sqlite3_value_text(argv[1]);\par
 2869   \}\par
 2870   if( pCur->zBase )\{\par
 2871     pCur->nBase = (int)strlen(pCur->zBase)+1;\par
 2872     pCur->zPath = sqlite3_mprintf("%s/%s", pCur->zBase, zDir);\par
 2873   \}else\{\par
 2874     pCur->zPath = sqlite3_mprintf("%s", zDir);\par
 2875   \}\par
 2876 \par
 2877   if( pCur->zPath==0 )\{\par
 2878     return SQLITE_NOMEM;\par
 2879   \}\par
 2880   if( fileLinkStat(pCur->zPath, &pCur->sStat) )\{\par
 2881     fsdirSetErrmsg(pCur, "cannot stat file: %s", pCur->zPath);\par
 2882     return SQLITE_ERROR;\par
 2883   \}\par
 2884 \par
 2885   return SQLITE_OK;\par
 2886 \}\par
}
}
{\xe \v fsdirNext\:shell.c}
{\xe \v shell.c\:fsdirNext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fsdirNext ({\b sqlite3_vtab_cursor} *  {\i cur}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2696 of file shell.c.}\par
{
References fsdir_cursor::aLvl, fileLinkStat(), fsdirSetErrmsg(), fsdir_cursor::iLvl, fsdir_cursor::iRowid, fsdir_cursor::nLvl, FsdirLevel::pDir, sqlite3_free, sqlite3_mprintf, sqlite3_realloc64, SQLITE_ERROR, SQLITE_NOMEM, SQLITE_OK, fsdir_cursor::sStat, FsdirLevel::zDir, and fsdir_cursor::zPath.}\par
{
Referenced by fsdirRegister().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2696                                               \{\par
 2697   fsdir_cursor *pCur = (fsdir_cursor*)cur;\par
 2698   mode_t m = pCur->sStat.st_mode;\par
 2699 \par
 2700   pCur->iRowid++;\par
 2701   if( S_ISDIR(m) )\{\par
 2702     /* Descend into this directory */\par
 2703     int iNew = pCur->iLvl + 1;\par
 2704     FsdirLevel *pLvl;\par
 2705     if( iNew>=pCur->nLvl )\{\par
 2706       int nNew = iNew+1;\par
 2707       sqlite3_int64 nByte = nNew*sizeof(FsdirLevel);\par
 2708       FsdirLevel *aNew = (FsdirLevel*)sqlite3_realloc64(pCur->aLvl, nByte);\par
 2709       if( aNew==0 ) return SQLITE_NOMEM;\par
 2710       memset(&aNew[pCur->nLvl], 0, sizeof(FsdirLevel)*(nNew-pCur->nLvl));\par
 2711       pCur->aLvl = aNew;\par
 2712       pCur->nLvl = nNew;\par
 2713     \}\par
 2714     pCur->iLvl = iNew;\par
 2715     pLvl = &pCur->aLvl[iNew];\par
 2716     \par
 2717     pLvl->zDir = pCur->zPath;\par
 2718     pCur->zPath = 0;\par
 2719     pLvl->pDir = opendir(pLvl->zDir);\par
 2720     if( pLvl->pDir==0 )\{\par
 2721       fsdirSetErrmsg(pCur, "cannot read directory: %s", pCur->zPath);\par
 2722       return SQLITE_ERROR;\par
 2723     \}\par
 2724   \}\par
 2725 \par
 2726   while( pCur->iLvl>=0 )\{\par
 2727     FsdirLevel *pLvl = &pCur->aLvl[pCur->iLvl];\par
 2728     struct dirent *pEntry = readdir(pLvl->pDir);\par
 2729     if( pEntry )\{\par
 2730       if( pEntry->d_name[0]=='.' )\{\par
 2731        if( pEntry->d_name[1]=='.' && pEntry->d_name[2]=='\\0' ) continue;\par
 2732        if( pEntry->d_name[1]=='\\0' ) continue;\par
 2733       \}\par
 2734       sqlite3_free(pCur->zPath);\par
 2735       pCur->zPath = sqlite3_mprintf("%s/%s", pLvl->zDir, pEntry->d_name);\par
 2736       if( pCur->zPath==0 ) return SQLITE_NOMEM;\par
 2737       if( fileLinkStat(pCur->zPath, &pCur->sStat) )\{\par
 2738         fsdirSetErrmsg(pCur, "cannot stat file: %s", pCur->zPath);\par
 2739         return SQLITE_ERROR;\par
 2740       \}\par
 2741       return SQLITE_OK;\par
 2742     \}\par
 2743     closedir(pLvl->pDir);\par
 2744     sqlite3_free(pLvl->zDir);\par
 2745     pLvl->pDir = 0;\par
 2746     pLvl->zDir = 0;\par
 2747     pCur->iLvl--;\par
 2748   \}\par
 2749 \par
 2750   /* EOF */\par
 2751   sqlite3_free(pCur->zPath);\par
 2752   pCur->zPath = 0;\par
 2753   return SQLITE_OK;\par
 2754 \}\par
}
}
{\xe \v fsdirOpen\:shell.c}
{\xe \v shell.c\:fsdirOpen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fsdirOpen ({\b sqlite3_vtab} *  {\i p}, {\b sqlite3_vtab_cursor} **  {\i ppCursor}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2637 of file shell.c.}\par
{
References fsdir_cursor::base, fsdir_cursor::iLvl, sqlite3_malloc, SQLITE_NOMEM, and SQLITE_OK.}\par
{
Referenced by fsdirRegister().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2637                                                                      \{\par
 2638   fsdir_cursor *pCur;\par
 2639   (void)p;\par
 2640   pCur = sqlite3_malloc( sizeof(*pCur) );\par
 2641   if( pCur==0 ) return SQLITE_NOMEM;\par
 2642   memset(pCur, 0, sizeof(*pCur));\par
 2643   pCur->iLvl = -1;\par
 2644   *ppCursor = &pCur->base;\par
 2645   return SQLITE_OK;\par
 2646 \}\par
}
}
{\xe \v fsdirRegister\:shell.c}
{\xe \v shell.c\:fsdirRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fsdirRegister ({\b sqlite3} *  {\i db}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2968 of file shell.c.}\par
{
References fsdirBestIndex(), fsdirClose(), fsdirColumn(), fsdirConnect(), fsdirDisconnect(), fsdirEof(), fsdirFilter(), fsdirNext(), fsdirOpen(), fsdirRowid(), and sqlite3_create_module.}\par
{
Referenced by sqlite3_fileio_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2968                                      \{\par
 2969   static sqlite3_module fsdirModule = \{\par
 2970     0,                         /* iVersion */\par
 2971     0,                         /* xCreate */\par
 2972     fsdirConnect,              /* xConnect */\par
 2973     fsdirBestIndex,            /* xBestIndex */\par
 2974     fsdirDisconnect,           /* xDisconnect */\par
 2975     0,                         /* xDestroy */\par
 2976     fsdirOpen,                 /* xOpen - open a cursor */\par
 2977     fsdirClose,                /* xClose - close a cursor */\par
 2978     fsdirFilter,               /* xFilter - configure scan constraints */\par
 2979     fsdirNext,                 /* xNext - advance a cursor */\par
 2980     fsdirEof,                  /* xEof - check for end of scan */\par
 2981     fsdirColumn,               /* xColumn - read data */\par
 2982     fsdirRowid,                /* xRowid - read data */\par
 2983     0,                         /* xUpdate */\par
 2984     0,                         /* xBegin */\par
 2985     0,                         /* xSync */\par
 2986     0,                         /* xCommit */\par
 2987     0,                         /* xRollback */\par
 2988     0,                         /* xFindMethod */\par
 2989     0,                         /* xRename */\par
 2990     0,                         /* xSavepoint */\par
 2991     0,                         /* xRelease */\par
 2992     0,                         /* xRollbackTo */\par
 2993     0,                         /* xShadowName */\par
 2994   \};\par
 2995 \par
 2996   int rc = sqlite3_create_module(db, "fsdir", &fsdirModule, 0);\par
 2997   return rc;\par
 2998 \}\par
}
}
{\xe \v fsdirResetCursor\:shell.c}
{\xe \v shell.c\:fsdirResetCursor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void fsdirResetCursor ({\b fsdir_cursor} *  {\i pCur}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2652 of file shell.c.}\par
{
References fsdir_cursor::aLvl, fsdir_cursor::iLvl, fsdir_cursor::iRowid, fsdir_cursor::nBase, fsdir_cursor::nLvl, FsdirLevel::pDir, sqlite3_free, fsdir_cursor::zBase, FsdirLevel::zDir, and fsdir_cursor::zPath.}\par
{
Referenced by fsdirClose(), and fsdirFilter().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2652                                                 \{\par
 2653   int i;\par
 2654   for(i=0; i<=pCur->iLvl; i++)\{\par
 2655     FsdirLevel *pLvl = &pCur->aLvl[i];\par
 2656     if( pLvl->pDir ) closedir(pLvl->pDir);\par
 2657     sqlite3_free(pLvl->zDir);\par
 2658   \}\par
 2659   sqlite3_free(pCur->zPath);\par
 2660   sqlite3_free(pCur->aLvl);\par
 2661   pCur->aLvl = 0;\par
 2662   pCur->zPath = 0;\par
 2663   pCur->zBase = 0;\par
 2664   pCur->nBase = 0;\par
 2665   pCur->nLvl = 0;\par
 2666   pCur->iLvl = -1;\par
 2667   pCur->iRowid = 1;\par
 2668 \}\par
}
}
{\xe \v fsdirRowid\:shell.c}
{\xe \v shell.c\:fsdirRowid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int fsdirRowid ({\b sqlite3_vtab_cursor} *  {\i cur}, {\b sqlite_int64} *  {\i pRowid}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2825 of file shell.c.}\par
{
References fsdir_cursor::iRowid, and SQLITE_OK.}\par
{
Referenced by fsdirRegister().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2825                                                                      \{\par
 2826   fsdir_cursor *pCur = (fsdir_cursor*)cur;\par
 2827   *pRowid = pCur->iRowid;\par
 2828   return SQLITE_OK;\par
 2829 \}\par
}
}
{\xe \v fsdirSetErrmsg\:shell.c}
{\xe \v shell.c\:fsdirSetErrmsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void fsdirSetErrmsg ({\b fsdir_cursor} *  {\i pCur}, const char *  {\i zFmt},   {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2685 of file shell.c.}\par
{
References fsdir_cursor::base, sqlite3_vtab_cursor::pVtab, sqlite3_vmprintf, and sqlite3_vtab::zErrMsg.}\par
{
Referenced by fsdirFilter(), and fsdirNext().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2685                                                                      \{\par
 2686   va_list ap;\par
 2687   va_start(ap, zFmt);\par
 2688   pCur->base.pVtab->zErrMsg = sqlite3_vmprintf(zFmt, ap);\par
 2689   va_end(ap);\par
 2690 \}\par
}
}
{\xe \v get2byteInt\:shell.c}
{\xe \v shell.c\:get2byteInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned int get2byteInt (unsigned char *  {\i a}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13486 of file shell.c.}\par
{
Referenced by shell_dbinfo_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13486                                                  \{\par
13487   return (a[0]<<8) + a[1];\par
13488 \}\par
}
}
{\xe \v get4byteInt\:shell.c}
{\xe \v shell.c\:get4byteInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned int get4byteInt (unsigned char *  {\i a}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13489 of file shell.c.}\par
{
Referenced by shell_dbinfo_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13489                                                  \{\par
13490   return (a[0]<<24) + (a[1]<<16) + (a[2]<<8) + a[3];\par
13491 \}\par
}
}
{\xe \v hash_step_vformat\:shell.c}
{\xe \v shell.c\:hash_step_vformat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void hash_step_vformat ({\b SHA3Context} *  {\i p}, const char *  {\i zFormat},   {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1841 of file shell.c.}\par
{
References SHA3Update(), and sqlite3_vsnprintf.}\par
{
Referenced by sha3QueryFunc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1845  \{\par
 1846   va_list ap;\par
 1847   int n;\par
 1848   char zBuf[50];\par
 1849   va_start(ap, zFormat);\par
 1850   sqlite3_vsnprintf(sizeof(zBuf),zBuf,zFormat,ap);\par
 1851   va_end(ap);\par
 1852   n = (int)strlen(zBuf);\par
 1853   SHA3Update(p, (unsigned char*)zBuf, n);\par
 1854 \}\par
}
}
{\xe \v hexDigitValue\:shell.c}
{\xe \v shell.c\:hexDigitValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int hexDigitValue (char  {\i c}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 668 of file shell.c.}\par
{
Referenced by booleanValue(), and integerValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   668                                 \{\par
  669   if( c>='0' && c<='9' ) return c - '0';\par
  670   if( c>='a' && c<='f' ) return c - 'a' + 10;\par
  671   if( c>='A' && c<='F' ) return c - 'A' + 10;\par
  672   return -1;\par
  673 \}\par
}
}
{\xe \v idxAppendColDefn\:shell.c}
{\xe \v shell.c\:idxAppendColDefn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* idxAppendColDefn (int *  {\i pRc}, char *  {\i zIn}, {\b IdxTable} *  {\i pTab}, {\b IdxConstraint} *  {\i pCons}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7512 of file shell.c.}\par
{
References IdxTable::aCol, IdxConstraint::bDesc, IdxConstraint::iCol, idxAppendText(), idxIdentifierRequiresQuotes(), sqlite3_stricmp, IdxConstraint::zColl, IdxColumn::zColl, and IdxColumn::zName.}\par
{
Referenced by idxCreateFromCons().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7517  \{\par
 7518   char *zRet = zIn;\par
 7519   IdxColumn *p = &pTab->aCol[pCons->iCol];\par
 7520   if( zRet ) zRet = idxAppendText(pRc, zRet, ", ");\par
 7521 \par
 7522   if( idxIdentifierRequiresQuotes(p->zName) )\{\par
 7523     zRet = idxAppendText(pRc, zRet, "%Q", p->zName);\par
 7524   \}else\{\par
 7525     zRet = idxAppendText(pRc, zRet, "%s", p->zName);\par
 7526   \}\par
 7527 \par
 7528   if( sqlite3_stricmp(p->zColl, pCons->zColl) )\{\par
 7529     if( idxIdentifierRequiresQuotes(pCons->zColl) )\{\par
 7530       zRet = idxAppendText(pRc, zRet, " COLLATE %Q", pCons->zColl);\par
 7531     \}else\{\par
 7532       zRet = idxAppendText(pRc, zRet, " COLLATE %s", pCons->zColl);\par
 7533     \}\par
 7534   \}\par
 7535 \par
 7536   if( pCons->bDesc )\{\par
 7537     zRet = idxAppendText(pRc, zRet, " DESC");\par
 7538   \}\par
 7539   return zRet;\par
 7540 \}\par
}
}
{\xe \v idxAppendText\:shell.c}
{\xe \v shell.c\:idxAppendText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* idxAppendText (int *  {\i pRc}, char *  {\i zIn}, const char *  {\i zFmt},   {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7462 of file shell.c.}\par
{
References sqlite3_free, sqlite3_malloc, sqlite3_vmprintf, SQLITE_NOMEM, SQLITE_OK, and STRLEN.}\par
{
Referenced by idxAppendColDefn(), idxCreateVtabSchema(), idxFindIndexes(), idxPopulateOneStat1(), idxProcessOneTrigger(), and sqlite3_expert_analyze().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7462                                                                       \{\par
 7463   va_list ap;\par
 7464   char *zAppend = 0;\par
 7465   char *zRet = 0;\par
 7466   int nIn = zIn ? STRLEN(zIn) : 0;\par
 7467   int nAppend = 0;\par
 7468   va_start(ap, zFmt);\par
 7469   if( *pRc==SQLITE_OK )\{\par
 7470     zAppend = sqlite3_vmprintf(zFmt, ap);\par
 7471     if( zAppend )\{\par
 7472       nAppend = STRLEN(zAppend);\par
 7473       zRet = (char*)sqlite3_malloc(nIn + nAppend + 1);\par
 7474     \}\par
 7475     if( zAppend && zRet )\{\par
 7476       if( nIn ) memcpy(zRet, zIn, nIn);\par
 7477       memcpy(&zRet[nIn], zAppend, nAppend+1);\par
 7478     \}else\{\par
 7479       sqlite3_free(zRet);\par
 7480       zRet = 0;\par
 7481       *pRc = SQLITE_NOMEM;\par
 7482     \}\par
 7483     sqlite3_free(zAppend);\par
 7484     sqlite3_free(zIn);\par
 7485   \}\par
 7486   va_end(ap);\par
 7487   return zRet;\par
 7488 \}\par
}
}
{\xe \v idxAuthCallback\:shell.c}
{\xe \v shell.c\:idxAuthCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxAuthCallback (void *  {\i pCtx}, int  {\i eOp}, const char *  {\i z3}, const char *  {\i z4}, const char *  {\i zDb}, const char *  {\i zTrigger}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7879 of file shell.c.}\par
{
References IdxWrite::eOp, idxMalloc(), IdxTable::pNext, IdxWrite::pNext, IdxWrite::pTab, sqlite3expert::pTable, sqlite3expert::pWrite, sqlite3_stricmp, SQLITE_DELETE, SQLITE_INSERT, SQLITE_OK, SQLITE_UPDATE, and IdxTable::zName.}\par
{
Referenced by sqlite3_expert_new().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7886  \{\par
 7887   int rc = SQLITE_OK;\par
 7888   (void)z4;\par
 7889   (void)zTrigger;\par
 7890   if( eOp==SQLITE_INSERT || eOp==SQLITE_UPDATE || eOp==SQLITE_DELETE )\{\par
 7891     if( sqlite3_stricmp(zDb, "main")==0 )\{\par
 7892       sqlite3expert *p = (sqlite3expert*)pCtx;\par
 7893       IdxTable *pTab;\par
 7894       for(pTab=p->pTable; pTab; pTab=pTab->pNext)\{\par
 7895         if( 0==sqlite3_stricmp(z3, pTab->zName) ) break;\par
 7896       \}\par
 7897       if( pTab )\{\par
 7898         IdxWrite *pWrite;\par
 7899         for(pWrite=p->pWrite; pWrite; pWrite=pWrite->pNext)\{\par
 7900           if( pWrite->pTab==pTab && pWrite->eOp==eOp ) break;\par
 7901         \}\par
 7902         if( pWrite==0 )\{\par
 7903           pWrite = idxMalloc(&rc, sizeof(IdxWrite));\par
 7904           if( rc==SQLITE_OK )\{\par
 7905             pWrite->pTab = pTab;\par
 7906             pWrite->eOp = eOp;\par
 7907             pWrite->pNext = p->pWrite;\par
 7908             p->pWrite = pWrite;\par
 7909           \}\par
 7910         \}\par
 7911       \}\par
 7912     \}\par
 7913   \}\par
 7914   return rc;\par
 7915 \}\par
}
}
{\xe \v idxBuildSampleTable\:shell.c}
{\xe \v shell.c\:idxBuildSampleTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxBuildSampleTable ({\b sqlite3expert} *  {\i p}, const char *  {\i zTab}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8318 of file shell.c.}\par
{
References sqlite3expert::dbv, sqlite3_exec, sqlite3_free, sqlite3_mprintf, SQLITE_NOMEM, SQLITE_OK, and UNIQUE_TABLE_NAME.}\par
{
Referenced by idxPopulateStat1().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8318                                                                   \{\par
 8319   int rc;\par
 8320   char *zSql;\par
 8321 \par
 8322   rc = sqlite3_exec(p->dbv,"DROP TABLE IF EXISTS temp."UNIQUE_TABLE_NAME,0,0,0);\par
 8323   if( rc!=SQLITE_OK ) return rc;\par
 8324 \par
 8325   zSql = sqlite3_mprintf(\par
 8326       "CREATE TABLE temp." UNIQUE_TABLE_NAME " AS SELECT * FROM %Q", zTab\par
 8327   );\par
 8328   if( zSql==0 ) return SQLITE_NOMEM;\par
 8329   rc = sqlite3_exec(p->dbv, zSql, 0, 0, 0);\par
 8330   sqlite3_free(zSql);\par
 8331 \par
 8332   return rc;\par
 8333 \}\par
}
}
{\xe \v idxConstraintFree\:shell.c}
{\xe \v shell.c\:idxConstraintFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void idxConstraintFree ({\b IdxConstraint} *  {\i pConstraint}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7742 of file shell.c.}\par
{
References IdxConstraint::pNext, and sqlite3_free.}\par
{
Referenced by idxScanFree().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7742                                                          \{\par
 7743   IdxConstraint *pNext;\par
 7744   IdxConstraint *p;\par
 7745 \par
 7746   for(p=pConstraint; p; p=pNext)\{\par
 7747     pNext = p->pNext;\par
 7748     sqlite3_free(p);\par
 7749   \}\par
 7750 \}\par
}
}
{\xe \v idxCreateCandidates\:shell.c}
{\xe \v shell.c\:idxCreateCandidates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxCreateCandidates ({\b sqlite3expert} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7725 of file shell.c.}\par
{
References idxCreateFromWhere(), IdxScan::pNextScan, IdxScan::pOrder, sqlite3expert::pScan, and SQLITE_OK.}\par
{
Referenced by sqlite3_expert_analyze().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7725                                                 \{\par
 7726   int rc = SQLITE_OK;\par
 7727   IdxScan *pIter;\par
 7728 \par
 7729   for(pIter=p->pScan; pIter && rc==SQLITE_OK; pIter=pIter->pNextScan)\{\par
 7730     rc = idxCreateFromWhere(p, pIter, 0);\par
 7731     if( rc==SQLITE_OK && pIter->pOrder )\{\par
 7732       rc = idxCreateFromWhere(p, pIter, pIter->pOrder);\par
 7733     \}\par
 7734   \}\par
 7735 \par
 7736   return rc;\par
 7737 \}\par
}
}
{\xe \v idxCreateFromCons\:shell.c}
{\xe \v shell.c\:idxCreateFromCons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxCreateFromCons ({\b sqlite3expert} *  {\i p}, {\b IdxScan} *  {\i pScan}, {\b IdxConstraint} *  {\i pEq}, {\b IdxConstraint} *  {\i pTail}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7617 of file shell.c.}\par
{
References sqlite3expert::dbm, sqlite3expert::hIdx, idxAppendColDefn(), idxFindCompatible(), idxHashAdd(), idxIdentifierRequiresQuotes(), IdxConstraint::pLink, IdxScan::pTab, sqlite3expert::pzErrmsg, sqlite3_exec, sqlite3_free, sqlite3_mprintf, SQLITE_NOMEM, SQLITE_OK, IdxTable::zName, and zName.}\par
{
Referenced by idxCreateFromWhere().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7622  \{\par
 7623   sqlite3 *dbm = p->dbm;\par
 7624   int rc = SQLITE_OK;\par
 7625   if( (pEq || pTail) && 0==idxFindCompatible(&rc, dbm, pScan, pEq, pTail) )\{\par
 7626     IdxTable *pTab = pScan->pTab;\par
 7627     char *zCols = 0;\par
 7628     char *zIdx = 0;\par
 7629     IdxConstraint *pCons;\par
 7630     unsigned int h = 0;\par
 7631     const char *zFmt;\par
 7632 \par
 7633     for(pCons=pEq; pCons; pCons=pCons->pLink)\{\par
 7634       zCols = idxAppendColDefn(&rc, zCols, pTab, pCons);\par
 7635     \}\par
 7636     for(pCons=pTail; pCons; pCons=pCons->pLink)\{\par
 7637       zCols = idxAppendColDefn(&rc, zCols, pTab, pCons);\par
 7638     \}\par
 7639 \par
 7640     if( rc==SQLITE_OK )\{\par
 7641       /* Hash the list of columns to come up with a name for the index */\par
 7642       const char *zTable = pScan->pTab->zName;\par
 7643       char *zName;                /* Index name */\par
 7644       int i;\par
 7645       for(i=0; zCols[i]; i++)\{\par
 7646         h += ((h<<3) + zCols[i]);\par
 7647       \}\par
 7648       zName = sqlite3_mprintf("%s_idx_%08x", zTable, h);\par
 7649       if( zName==0 )\{ \par
 7650         rc = SQLITE_NOMEM;\par
 7651       \}else\{\par
 7652         if( idxIdentifierRequiresQuotes(zTable) )\{\par
 7653           zFmt = "CREATE INDEX '%q' ON %Q(%s)";\par
 7654         \}else\{\par
 7655           zFmt = "CREATE INDEX %s ON %s(%s)";\par
 7656         \}\par
 7657         zIdx = sqlite3_mprintf(zFmt, zName, zTable, zCols);\par
 7658         if( !zIdx )\{\par
 7659           rc = SQLITE_NOMEM;\par
 7660         \}else\{\par
 7661           rc = sqlite3_exec(dbm, zIdx, 0, 0, p->pzErrmsg);\par
 7662           idxHashAdd(&rc, &p->hIdx, zName, zIdx);\par
 7663         \}\par
 7664         sqlite3_free(zName);\par
 7665         sqlite3_free(zIdx);\par
 7666       \}\par
 7667     \}\par
 7668 \par
 7669     sqlite3_free(zCols);\par
 7670   \}\par
 7671   return rc;\par
 7672 \}\par
}
}
{\xe \v idxCreateFromWhere\:shell.c}
{\xe \v shell.c\:idxCreateFromWhere}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxCreateFromWhere ({\b sqlite3expert} *  {\i p}, {\b IdxScan} *  {\i pScan}, {\b IdxConstraint} *  {\i pTail}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7686 of file shell.c.}\par
{
References idxCreateFromCons(), idxFindConstraint(), IdxScan::pEq, IdxConstraint::pLink, IdxConstraint::pNext, IdxScan::pRange, and SQLITE_OK.}\par
{
Referenced by idxCreateCandidates().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7690  \{\par
 7691   IdxConstraint *p1 = 0;\par
 7692   IdxConstraint *pCon;\par
 7693   int rc;\par
 7694 \par
 7695   /* Gather up all the == constraints. */\par
 7696   for(pCon=pScan->pEq; pCon; pCon=pCon->pNext)\{\par
 7697     if( !idxFindConstraint(p1, pCon) && !idxFindConstraint(pTail, pCon) )\{\par
 7698       pCon->pLink = p1;\par
 7699       p1 = pCon;\par
 7700     \}\par
 7701   \}\par
 7702 \par
 7703   /* Create an index using the == constraints collected above. And the\par
 7704   ** range constraint/ORDER BY terms passed in by the caller, if any. */\par
 7705   rc = idxCreateFromCons(p, pScan, p1, pTail);\par
 7706 \par
 7707   /* If no range/ORDER BY passed by the caller, create a version of the\par
 7708   ** index for each range constraint.  */\par
 7709   if( pTail==0 )\{\par
 7710     for(pCon=pScan->pRange; rc==SQLITE_OK && pCon; pCon=pCon->pNext)\{\par
 7711       assert( pCon->pLink==0 );\par
 7712       if( !idxFindConstraint(p1, pCon) && !idxFindConstraint(pTail, pCon) )\{\par
 7713         rc = idxCreateFromCons(p, pScan, p1, pCon);\par
 7714       \}\par
 7715     \}\par
 7716   \}\par
 7717 \par
 7718   return rc;\par
 7719 \}\par
}
}
{\xe \v idxCreateVtabSchema\:shell.c}
{\xe \v shell.c\:idxCreateVtabSchema}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxCreateVtabSchema ({\b sqlite3expert} *  {\i p}, char **  {\i pzErrmsg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8017 of file shell.c.}\par
{
References IdxTable::aCol, sqlite3expert::db, sqlite3expert::dbv, idxAppendText(), idxFinalize(), idxGetTableInfo(), idxPrepareStmt(), idxRegisterVtab(), IdxTable::nCol, IdxTable::pNext, sqlite3expert::pTable, sqlite3_column_text, sqlite3_exec, sqlite3_free, sqlite3_step, SQLITE_OK, SQLITE_ROW, IdxColumn::zColl, and IdxColumn::zName.}\par
{
Referenced by sqlite3_expert_new().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8017                                                                  \{\par
 8018   int rc = idxRegisterVtab(p);\par
 8019   sqlite3_stmt *pSchema = 0;\par
 8020 \par
 8021   /* For each table in the main db schema:\par
 8022   **\par
 8023   **   1) Add an entry to the p->pTable list, and\par
 8024   **   2) Create the equivalent virtual table in dbv.\par
 8025   */\par
 8026   rc = idxPrepareStmt(p->db, &pSchema, pzErrmsg,\par
 8027       "SELECT type, name, sql, 1 FROM sqlite_master "\par
 8028       "WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%' "\par
 8029       " UNION ALL "\par
 8030       "SELECT type, name, sql, 2 FROM sqlite_master "\par
 8031       "WHERE type = 'trigger'"\par
 8032       "  AND tbl_name IN(SELECT name FROM sqlite_master WHERE type = 'view') "\par
 8033       "ORDER BY 4, 1"\par
 8034   );\par
 8035   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSchema) )\{\par
 8036     const char *zType = (const char*)sqlite3_column_text(pSchema, 0);\par
 8037     const char *zName = (const char*)sqlite3_column_text(pSchema, 1);\par
 8038     const char *zSql = (const char*)sqlite3_column_text(pSchema, 2);\par
 8039 \par
 8040     if( zType[0]=='v' || zType[1]=='r' )\{\par
 8041       rc = sqlite3_exec(p->dbv, zSql, 0, 0, pzErrmsg);\par
 8042     \}else\{\par
 8043       IdxTable *pTab;\par
 8044       rc = idxGetTableInfo(p->db, zName, &pTab, pzErrmsg);\par
 8045       if( rc==SQLITE_OK )\{\par
 8046         int i;\par
 8047         char *zInner = 0;\par
 8048         char *zOuter = 0;\par
 8049         pTab->pNext = p->pTable;\par
 8050         p->pTable = pTab;\par
 8051 \par
 8052         /* The statement the vtab will pass to sqlite3_declare_vtab() */\par
 8053         zInner = idxAppendText(&rc, 0, "CREATE TABLE x(");\par
 8054         for(i=0; i<pTab->nCol; i++)\{\par
 8055           zInner = idxAppendText(&rc, zInner, "%s%Q COLLATE %s", \par
 8056               (i==0 ? "" : ", "), pTab->aCol[i].zName, pTab->aCol[i].zColl\par
 8057           );\par
 8058         \}\par
 8059         zInner = idxAppendText(&rc, zInner, ")");\par
 8060 \par
 8061         /* The CVT statement to create the vtab */\par
 8062         zOuter = idxAppendText(&rc, 0, \par
 8063             "CREATE VIRTUAL TABLE %Q USING expert(%Q)", zName, zInner\par
 8064         );\par
 8065         if( rc==SQLITE_OK )\{\par
 8066           rc = sqlite3_exec(p->dbv, zOuter, 0, 0, pzErrmsg);\par
 8067         \}\par
 8068         sqlite3_free(zInner);\par
 8069         sqlite3_free(zOuter);\par
 8070       \}\par
 8071     \}\par
 8072   \}\par
 8073   idxFinalize(&rc, pSchema);\par
 8074   return rc;\par
 8075 \}\par
}
}
{\xe \v idxDatabaseError\:shell.c}
{\xe \v shell.c\:idxDatabaseError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void idxDatabaseError ({\b sqlite3} *  {\i db}, char **  {\i pzErrmsg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7003 of file shell.c.}\par
{
References sqlite3_errmsg, and sqlite3_mprintf.}\par
{
Referenced by idxPrepareStmt(), idxProcessOneTrigger(), and sqlite3_expert_sql().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7006  \{\par
 7007   *pzErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(db));\par
 7008 \}\par
}
}
{\xe \v idxFinalize\:shell.c}
{\xe \v shell.c\:idxFinalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void idxFinalize (int *  {\i pRc}, {\b sqlite3_stmt} *  {\i pStmt}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7366 of file shell.c.}\par
{
References sqlite3_finalize, and SQLITE_OK.}\par
{
Referenced by idxCreateVtabSchema(), idxFindCompatible(), idxFindIndexes(), idxGetTableInfo(), idxLargestIndex(), idxPopulateOneStat1(), idxPopulateStat1(), idxProcessOneTrigger(), and sqlite3_expert_new().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7366                                                       \{\par
 7367   int rc = sqlite3_finalize(pStmt);\par
 7368   if( *pRc==SQLITE_OK ) *pRc = rc;\par
 7369 \}\par
}
}
{\xe \v idxFindCompatible\:shell.c}
{\xe \v shell.c\:idxFindCompatible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxFindCompatible (int *  {\i pRc}, {\b sqlite3} *  {\i dbm}, {\b IdxScan} *  {\i pScan}, {\b IdxConstraint} *  {\i pEq}, {\b IdxConstraint} *  {\i pTail}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7550 of file shell.c.}\par
{
References IdxConstraint::bFlag, IdxConstraint::iCol, idxFinalize(), idxPrintfPrepareStmt(), IdxConstraint::pLink, IdxScan::pTab, sqlite3_column_int, sqlite3_column_text, sqlite3_finalize, sqlite3_step, sqlite3_stricmp, SQLITE_OK, SQLITE_ROW, IdxConstraint::zColl, and IdxTable::zName.}\par
{
Referenced by idxCreateFromCons().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7556  \{\par
 7557   const char *zTbl = pScan->pTab->zName;\par
 7558   sqlite3_stmt *pIdxList = 0;\par
 7559   IdxConstraint *pIter;\par
 7560   int nEq = 0;                    /* Number of elements in pEq */\par
 7561   int rc;\par
 7562 \par
 7563   /* Count the elements in list pEq */\par
 7564   for(pIter=pEq; pIter; pIter=pIter->pLink) nEq++;\par
 7565 \par
 7566   rc = idxPrintfPrepareStmt(dbm, &pIdxList, 0, "PRAGMA index_list=%Q", zTbl);\par
 7567   while( rc==SQLITE_OK && sqlite3_step(pIdxList)==SQLITE_ROW )\{\par
 7568     int bMatch = 1;\par
 7569     IdxConstraint *pT = pTail;\par
 7570     sqlite3_stmt *pInfo = 0;\par
 7571     const char *zIdx = (const char*)sqlite3_column_text(pIdxList, 1);\par
 7572 \par
 7573     /* Zero the IdxConstraint.bFlag values in the pEq list */\par
 7574     for(pIter=pEq; pIter; pIter=pIter->pLink) pIter->bFlag = 0;\par
 7575 \par
 7576     rc = idxPrintfPrepareStmt(dbm, &pInfo, 0, "PRAGMA index_xInfo=%Q", zIdx);\par
 7577     while( rc==SQLITE_OK && sqlite3_step(pInfo)==SQLITE_ROW )\{\par
 7578       int iIdx = sqlite3_column_int(pInfo, 0);\par
 7579       int iCol = sqlite3_column_int(pInfo, 1);\par
 7580       const char *zColl = (const char*)sqlite3_column_text(pInfo, 4);\par
 7581 \par
 7582       if( iIdx<nEq )\{\par
 7583         for(pIter=pEq; pIter; pIter=pIter->pLink)\{\par
 7584           if( pIter->bFlag ) continue;\par
 7585           if( pIter->iCol!=iCol ) continue;\par
 7586           if( sqlite3_stricmp(pIter->zColl, zColl) ) continue;\par
 7587           pIter->bFlag = 1;\par
 7588           break;\par
 7589         \}\par
 7590         if( pIter==0 )\{\par
 7591           bMatch = 0;\par
 7592           break;\par
 7593         \}\par
 7594       \}else\{\par
 7595         if( pT )\{\par
 7596           if( pT->iCol!=iCol || sqlite3_stricmp(pT->zColl, zColl) )\{\par
 7597             bMatch = 0;\par
 7598             break;\par
 7599           \}\par
 7600           pT = pT->pLink;\par
 7601         \}\par
 7602       \}\par
 7603     \}\par
 7604     idxFinalize(&rc, pInfo);\par
 7605 \par
 7606     if( rc==SQLITE_OK && bMatch )\{\par
 7607       sqlite3_finalize(pIdxList);\par
 7608       return 1;\par
 7609     \}\par
 7610   \}\par
 7611   idxFinalize(&rc, pIdxList);\par
 7612 \par
 7613   *pRc = rc;\par
 7614   return 0;\par
 7615 \}\par
}
}
{\xe \v idxFindConstraint\:shell.c}
{\xe \v shell.c\:idxFindConstraint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxFindConstraint ({\b IdxConstraint} *  {\i pList}, {\b IdxConstraint} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7678 of file shell.c.}\par
{
References IdxConstraint::iCol, and IdxConstraint::pLink.}\par
{
Referenced by idxCreateFromWhere().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7678                                                                     \{\par
 7679   IdxConstraint *pCmp;\par
 7680   for(pCmp=pList; pCmp; pCmp=pCmp->pLink)\{\par
 7681     if( p->iCol==pCmp->iCol ) return 1;\par
 7682   \}\par
 7683   return 0;\par
 7684 \}\par
}
}
{\xe \v idxFindIndexes\:shell.c}
{\xe \v shell.c\:idxFindIndexes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int idxFindIndexes ({\b sqlite3expert} *  {\i p}, char **  {\i pzErr})}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7814 of file shell.c.}\par
{
References sqlite3expert::dbm, sqlite3expert::hIdx, idxAppendText(), idxFinalize(), idxHashAdd(), idxHashClear(), idxHashInit(), idxHashSearch(), idxPrintfPrepareStmt(), IdxHash::pFirst, IdxStatement::pNext, IdxHashEntry::pNext, sqlite3expert::pStatement, sqlite3_column_text, sqlite3_step, SQLITE_OK, SQLITE_ROW, STRLEN, IdxStatement::zEQP, IdxStatement::zIdx, IdxHashEntry::zKey, and IdxStatement::zSql.}\par
{
Referenced by sqlite3_expert_analyze().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7817  \{\par
 7818   IdxStatement *pStmt;\par
 7819   sqlite3 *dbm = p->dbm;\par
 7820   int rc = SQLITE_OK;\par
 7821 \par
 7822   IdxHash hIdx;\par
 7823   idxHashInit(&hIdx);\par
 7824 \par
 7825   for(pStmt=p->pStatement; rc==SQLITE_OK && pStmt; pStmt=pStmt->pNext)\{\par
 7826     IdxHashEntry *pEntry;\par
 7827     sqlite3_stmt *pExplain = 0;\par
 7828     idxHashClear(&hIdx);\par
 7829     rc = idxPrintfPrepareStmt(dbm, &pExplain, pzErr,\par
 7830         "EXPLAIN QUERY PLAN %s", pStmt->zSql\par
 7831     );\par
 7832     while( rc==SQLITE_OK && sqlite3_step(pExplain)==SQLITE_ROW )\{\par
 7833       /* int iId = sqlite3_column_int(pExplain, 0); */\par
 7834       /* int iParent = sqlite3_column_int(pExplain, 1); */\par
 7835       /* int iNotUsed = sqlite3_column_int(pExplain, 2); */\par
 7836       const char *zDetail = (const char*)sqlite3_column_text(pExplain, 3);\par
 7837       int nDetail = STRLEN(zDetail);\par
 7838       int i;\par
 7839 \par
 7840       for(i=0; i<nDetail; i++)\{\par
 7841         const char *zIdx = 0;\par
 7842         if( memcmp(&zDetail[i], " USING INDEX ", 13)==0 )\{\par
 7843           zIdx = &zDetail[i+13];\par
 7844         \}else if( memcmp(&zDetail[i], " USING COVERING INDEX ", 22)==0 )\{\par
 7845           zIdx = &zDetail[i+22];\par
 7846         \}\par
 7847         if( zIdx )\{\par
 7848           const char *zSql;\par
 7849           int nIdx = 0;\par
 7850           while( zIdx[nIdx]!='\\0' && (zIdx[nIdx]!=' ' || zIdx[nIdx+1]!='(') )\{\par
 7851             nIdx++;\par
 7852           \}\par
 7853           zSql = idxHashSearch(&p->hIdx, zIdx, nIdx);\par
 7854           if( zSql )\{\par
 7855             idxHashAdd(&rc, &hIdx, zSql, 0);\par
 7856             if( rc ) goto find_indexes_out;\par
 7857           \}\par
 7858           break;\par
 7859         \}\par
 7860       \}\par
 7861 \par
 7862       if( zDetail[0]!='-' )\{\par
 7863         pStmt->zEQP = idxAppendText(&rc, pStmt->zEQP, "%s\\n", zDetail);\par
 7864       \}\par
 7865     \}\par
 7866 \par
 7867     for(pEntry=hIdx.pFirst; pEntry; pEntry=pEntry->pNext)\{\par
 7868       pStmt->zIdx = idxAppendText(&rc, pStmt->zIdx, "%s;\\n", pEntry->zKey);\par
 7869     \}\par
 7870 \par
 7871     idxFinalize(&rc, pExplain);\par
 7872   \}\par
 7873 \par
 7874  find_indexes_out:\par
 7875   idxHashClear(&hIdx);\par
 7876   return rc;\par
 7877 \}\par
}
}
{\xe \v idxGetTableInfo\:shell.c}
{\xe \v shell.c\:idxGetTableInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxGetTableInfo ({\b sqlite3} *  {\i db}, const char *  {\i zTab}, {\b IdxTable} **  {\i ppOut}, char **  {\i pzErrmsg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7381 of file shell.c.}\par
{
References IdxTable::aCol, idxFinalize(), idxMalloc(), idxPrintfPrepareStmt(), IdxColumn::iPk, IdxTable::nCol, sqlite3_column_int, sqlite3_column_text, sqlite3_free, sqlite3_reset, sqlite3_step, sqlite3_table_column_metadata, SQLITE_OK, SQLITE_ROW, STRLEN, IdxColumn::zColl, IdxColumn::zName, and IdxTable::zName.}\par
{
Referenced by idxCreateVtabSchema().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7386  \{\par
 7387   sqlite3_stmt *p1 = 0;\par
 7388   int nCol = 0;\par
 7389   int nTab = STRLEN(zTab);\par
 7390   int nByte = sizeof(IdxTable) + nTab + 1;\par
 7391   IdxTable *pNew = 0;\par
 7392   int rc, rc2;\par
 7393   char *pCsr = 0;\par
 7394 \par
 7395   rc = idxPrintfPrepareStmt(db, &p1, pzErrmsg, "PRAGMA table_info=%Q", zTab);\par
 7396   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) )\{\par
 7397     const char *zCol = (const char*)sqlite3_column_text(p1, 1);\par
 7398     nByte += 1 + STRLEN(zCol);\par
 7399     rc = sqlite3_table_column_metadata(\par
 7400         db, "main", zTab, zCol, 0, &zCol, 0, 0, 0\par
 7401     );\par
 7402     nByte += 1 + STRLEN(zCol);\par
 7403     nCol++;\par
 7404   \}\par
 7405   rc2 = sqlite3_reset(p1);\par
 7406   if( rc==SQLITE_OK ) rc = rc2;\par
 7407 \par
 7408   nByte += sizeof(IdxColumn) * nCol;\par
 7409   if( rc==SQLITE_OK )\{\par
 7410     pNew = idxMalloc(&rc, nByte);\par
 7411   \}\par
 7412   if( rc==SQLITE_OK )\{\par
 7413     pNew->aCol = (IdxColumn*)&pNew[1];\par
 7414     pNew->nCol = nCol;\par
 7415     pCsr = (char*)&pNew->aCol[nCol];\par
 7416   \}\par
 7417 \par
 7418   nCol = 0;\par
 7419   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(p1) )\{\par
 7420     const char *zCol = (const char*)sqlite3_column_text(p1, 1);\par
 7421     int nCopy = STRLEN(zCol) + 1;\par
 7422     pNew->aCol[nCol].zName = pCsr;\par
 7423     pNew->aCol[nCol].iPk = sqlite3_column_int(p1, 5);\par
 7424     memcpy(pCsr, zCol, nCopy);\par
 7425     pCsr += nCopy;\par
 7426 \par
 7427     rc = sqlite3_table_column_metadata(\par
 7428         db, "main", zTab, zCol, 0, &zCol, 0, 0, 0\par
 7429     );\par
 7430     if( rc==SQLITE_OK )\{\par
 7431       nCopy = STRLEN(zCol) + 1;\par
 7432       pNew->aCol[nCol].zColl = pCsr;\par
 7433       memcpy(pCsr, zCol, nCopy);\par
 7434       pCsr += nCopy;\par
 7435     \}\par
 7436 \par
 7437     nCol++;\par
 7438   \}\par
 7439   idxFinalize(&rc, p1);\par
 7440 \par
 7441   if( rc!=SQLITE_OK )\{\par
 7442     sqlite3_free(pNew);\par
 7443     pNew = 0;\par
 7444   \}else\{\par
 7445     pNew->zName = pCsr;\par
 7446     memcpy(pNew->zName, zTab, nTab+1);\par
 7447   \}\par
 7448 \par
 7449   *ppOut = pNew;\par
 7450   return rc;\par
 7451 \}\par
}
}
{\xe \v idxHashAdd\:shell.c}
{\xe \v shell.c\:idxHashAdd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxHashAdd (int *  {\i pRc}, {\b IdxHash} *  {\i pHash}, const char *  {\i zKey}, const char *  {\i zVal}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6919 of file shell.c.}\par
{
References IdxHash::aHash, idxHashString(), idxMalloc(), IdxHash::pFirst, IdxHashEntry::pHashNext, IdxHashEntry::pNext, STRLEN, IdxHashEntry::zKey, and IdxHashEntry::zVal.}\par
{
Referenced by idxCreateFromCons(), and idxFindIndexes().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6924  \{\par
 6925   int nKey = STRLEN(zKey);\par
 6926   int iHash = idxHashString(zKey, nKey);\par
 6927   int nVal = (zVal ? STRLEN(zVal) : 0);\par
 6928   IdxHashEntry *pEntry;\par
 6929   assert( iHash>=0 );\par
 6930   for(pEntry=pHash->aHash[iHash]; pEntry; pEntry=pEntry->pHashNext)\{\par
 6931     if( STRLEN(pEntry->zKey)==nKey && 0==memcmp(pEntry->zKey, zKey, nKey) )\{\par
 6932       return 1;\par
 6933     \}\par
 6934   \}\par
 6935   pEntry = idxMalloc(pRc, sizeof(IdxHashEntry) + nKey+1 + nVal+1);\par
 6936   if( pEntry )\{\par
 6937     pEntry->zKey = (char*)&pEntry[1];\par
 6938     memcpy(pEntry->zKey, zKey, nKey);\par
 6939     if( zVal )\{\par
 6940       pEntry->zVal = &pEntry->zKey[nKey+1];\par
 6941       memcpy(pEntry->zVal, zVal, nVal);\par
 6942     \}\par
 6943     pEntry->pHashNext = pHash->aHash[iHash];\par
 6944     pHash->aHash[iHash] = pEntry;\par
 6945 \par
 6946     pEntry->pNext = pHash->pFirst;\par
 6947     pHash->pFirst = pEntry;\par
 6948   \}\par
 6949   return 0;\par
 6950 \}\par
}
}
{\xe \v idxHashClear\:shell.c}
{\xe \v shell.c\:idxHashClear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void idxHashClear ({\b IdxHash} *  {\i pHash}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6887 of file shell.c.}\par
{
References IdxHash::aHash, IDX_HASH_SIZE, IdxHashEntry::pHashNext, sqlite3_free, and IdxHashEntry::zVal2.}\par
{
Referenced by idxFindIndexes(), and sqlite3_expert_destroy().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6887                                         \{\par
 6888   int i;\par
 6889   for(i=0; i<IDX_HASH_SIZE; i++)\{\par
 6890     IdxHashEntry *pEntry;\par
 6891     IdxHashEntry *pNext;\par
 6892     for(pEntry=pHash->aHash[i]; pEntry; pEntry=pNext)\{\par
 6893       pNext = pEntry->pHashNext;\par
 6894       sqlite3_free(pEntry->zVal2);\par
 6895       sqlite3_free(pEntry);\par
 6896     \}\par
 6897   \}\par
 6898   memset(pHash, 0, sizeof(IdxHash));\par
 6899 \}\par
}
}
{\xe \v idxHashFind\:shell.c}
{\xe \v shell.c\:idxHashFind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b IdxHashEntry}* idxHashFind ({\b IdxHash} *  {\i pHash}, const char *  {\i zKey}, int  {\i nKey}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6956 of file shell.c.}\par
{
References IdxHash::aHash, idxHashString(), IdxHashEntry::pHashNext, STRLEN, and IdxHashEntry::zKey.}\par
{
Referenced by idxHashSearch(), and idxPopulateOneStat1().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6956                                                                             \{\par
 6957   int iHash;\par
 6958   IdxHashEntry *pEntry;\par
 6959   if( nKey<0 ) nKey = STRLEN(zKey);\par
 6960   iHash = idxHashString(zKey, nKey);\par
 6961   assert( iHash>=0 );\par
 6962   for(pEntry=pHash->aHash[iHash]; pEntry; pEntry=pEntry->pHashNext)\{\par
 6963     if( STRLEN(pEntry->zKey)==nKey && 0==memcmp(pEntry->zKey, zKey, nKey) )\{\par
 6964       return pEntry;\par
 6965     \}\par
 6966   \}\par
 6967   return 0;\par
 6968 \}\par
}
}
{\xe \v idxHashInit\:shell.c}
{\xe \v shell.c\:idxHashInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void idxHashInit ({\b IdxHash} *  {\i pHash}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6880 of file shell.c.}\par
{
Referenced by idxFindIndexes().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6880                                        \{\par
 6881   memset(pHash, 0, sizeof(IdxHash));\par
 6882 \}\par
}
}
{\xe \v idxHashSearch\:shell.c}
{\xe \v shell.c\:idxHashSearch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char* idxHashSearch ({\b IdxHash} *  {\i pHash}, const char *  {\i zKey}, int  {\i nKey}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6976 of file shell.c.}\par
{
References idxHashFind(), and IdxHashEntry::zVal.}\par
{
Referenced by idxFindIndexes().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6976                                                                             \{\par
 6977   IdxHashEntry *pEntry = idxHashFind(pHash, zKey, nKey);\par
 6978   if( pEntry ) return pEntry->zVal;\par
 6979   return 0;\par
 6980 \}\par
}
}
{\xe \v idxHashString\:shell.c}
{\xe \v shell.c\:idxHashString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxHashString (const char *  {\i z}, int  {\i n}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6905 of file shell.c.}\par
{
References IDX_HASH_SIZE.}\par
{
Referenced by idxHashAdd(), and idxHashFind().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6905                                               \{\par
 6906   unsigned int ret = 0;\par
 6907   int i;\par
 6908   for(i=0; i<n; i++)\{\par
 6909     ret += (ret<<3) + (unsigned char)(z[i]);\par
 6910   \}\par
 6911   return (int)(ret % IDX_HASH_SIZE);\par
 6912 \}\par
}
}
{\xe \v idxIdentifierRequiresQuotes\:shell.c}
{\xe \v shell.c\:idxIdentifierRequiresQuotes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxIdentifierRequiresQuotes (const char *  {\i zId}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7494 of file shell.c.}\par
{
Referenced by idxAppendColDefn(), and idxCreateFromCons().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7494                                                        \{\par
 7495   int i;\par
 7496   for(i=0; zId[i]; i++)\{\par
 7497     if( !(zId[i]=='_')\par
 7498      && !(zId[i]>='0' && zId[i]<='9')\par
 7499      && !(zId[i]>='a' && zId[i]<='z')\par
 7500      && !(zId[i]>='A' && zId[i]<='Z')\par
 7501     )\{\par
 7502       return 1;\par
 7503     \}\par
 7504   \}\par
 7505   return 0;\par
 7506 \}\par
}
}
{\xe \v idxLargestIndex\:shell.c}
{\xe \v shell.c\:idxLargestIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxLargestIndex ({\b sqlite3} *  {\i db}, int *  {\i pnMax}, char **  {\i pzErr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8198 of file shell.c.}\par
{
References idxFinalize(), idxPrepareStmt(), sqlite3_column_int, sqlite3_step, SQLITE_OK, and SQLITE_ROW.}\par
{
Referenced by idxPopulateStat1().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8198                                                                  \{\par
 8199   int rc = SQLITE_OK;\par
 8200   const char *zMax = \par
 8201     "SELECT max(i.seqno) FROM "\par
 8202     "  sqlite_master AS s, "\par
 8203     "  pragma_index_list(s.name) AS l, "\par
 8204     "  pragma_index_info(l.name) AS i "\par
 8205     "WHERE s.type = 'table'";\par
 8206   sqlite3_stmt *pMax = 0;\par
 8207 \par
 8208   *pnMax = 0;\par
 8209   rc = idxPrepareStmt(db, &pMax, pzErr, zMax);\par
 8210   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) )\{\par
 8211     *pnMax = sqlite3_column_int(pMax, 0) + 1;\par
 8212   \}\par
 8213   idxFinalize(&rc, pMax);\par
 8214 \par
 8215   return rc;\par
 8216 \}\par
}
}
{\xe \v idxMalloc\:shell.c}
{\xe \v shell.c\:idxMalloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void* idxMalloc (int *  {\i pRc}, int  {\i nByte}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6864 of file shell.c.}\par
{
References sqlite3_malloc, SQLITE_NOMEM, and SQLITE_OK.}\par
{
Referenced by expertBestIndex(), expertConnect(), expertOpen(), idxAuthCallback(), idxGetTableInfo(), idxHashAdd(), idxNewConstraint(), idxPopulateOneStat1(), idxPopulateStat1(), sqlite3_expert_new(), and sqlite3_expert_sql().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6864                                            \{\par
 6865   void *pRet;\par
 6866   assert( *pRc==SQLITE_OK );\par
 6867   assert( nByte>0 );\par
 6868   pRet = sqlite3_malloc(nByte);\par
 6869   if( pRet )\{\par
 6870     memset(pRet, 0, nByte);\par
 6871   \}else\{\par
 6872     *pRc = SQLITE_NOMEM;\par
 6873   \}\par
 6874   return pRet;\par
 6875 \}\par
}
}
{\xe \v idxNewConstraint\:shell.c}
{\xe \v shell.c\:idxNewConstraint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b IdxConstraint}* idxNewConstraint (int *  {\i pRc}, const char *  {\i zColl}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6986 of file shell.c.}\par
{
References idxMalloc(), SQLITE_OK, STRLEN, and IdxConstraint::zColl.}\par
{
Referenced by expertBestIndex().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  6986                                                                    \{\par
 6987   IdxConstraint *pNew;\par
 6988   int nColl = STRLEN(zColl);\par
 6989 \par
 6990   assert( *pRc==SQLITE_OK );\par
 6991   pNew = (IdxConstraint*)idxMalloc(pRc, sizeof(IdxConstraint) * nColl + 1);\par
 6992   if( pNew )\{\par
 6993     pNew->zColl = (char*)&pNew[1];\par
 6994     memcpy(pNew->zColl, zColl, nColl+1);\par
 6995   \}\par
 6996   return pNew;\par
 6997 \}\par
}
}
{\xe \v idxPopulateOneStat1\:shell.c}
{\xe \v shell.c\:idxPopulateOneStat1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxPopulateOneStat1 ({\b sqlite3expert} *  {\i p}, {\b sqlite3_stmt} *  {\i pIndexXInfo}, {\b sqlite3_stmt} *  {\i pWriteStat}, const char *  {\i zTab}, const char *  {\i zIdx}, char **  {\i pzErr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8218 of file shell.c.}\par
{
References sqlite3expert::db, sqlite3expert::dbv, sqlite3expert::hIdx, idxAppendText(), idxFinalize(), idxHashFind(), idxMalloc(), idxPrepareStmt(), sqlite3expert::iSample, sqlite3_bind_text, sqlite3_column_int, sqlite3_column_text, sqlite3_free, sqlite3_mprintf, sqlite3_reset, sqlite3_step, SQLITE_NOMEM, SQLITE_OK, SQLITE_ROW, SQLITE_STATIC, STRLEN, UNIQUE_TABLE_NAME, and IdxHashEntry::zVal2.}\par
{
Referenced by idxPopulateStat1().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8225  \{\par
 8226   char *zCols = 0;\par
 8227   char *zOrder = 0;\par
 8228   char *zQuery = 0;\par
 8229   int nCol = 0;\par
 8230   int i;\par
 8231   sqlite3_stmt *pQuery = 0;\par
 8232   int *aStat = 0;\par
 8233   int rc = SQLITE_OK;\par
 8234 \par
 8235   assert( p->iSample>0 );\par
 8236 \par
 8237   /* Formulate the query text */\par
 8238   sqlite3_bind_text(pIndexXInfo, 1, zIdx, -1, SQLITE_STATIC);\par
 8239   while( SQLITE_OK==rc && SQLITE_ROW==sqlite3_step(pIndexXInfo) )\{\par
 8240     const char *zComma = zCols==0 ? "" : ", ";\par
 8241     const char *zName = (const char*)sqlite3_column_text(pIndexXInfo, 0);\par
 8242     const char *zColl = (const char*)sqlite3_column_text(pIndexXInfo, 1);\par
 8243     zCols = idxAppendText(&rc, zCols, \par
 8244         "%sx.%Q IS rem(%d, x.%Q) COLLATE %s", zComma, zName, nCol, zName, zColl\par
 8245     );\par
 8246     zOrder = idxAppendText(&rc, zOrder, "%s%d", zComma, ++nCol);\par
 8247   \}\par
 8248   sqlite3_reset(pIndexXInfo);\par
 8249   if( rc==SQLITE_OK )\{\par
 8250     if( p->iSample==100 )\{\par
 8251       zQuery = sqlite3_mprintf(\par
 8252           "SELECT %s FROM %Q x ORDER BY %s", zCols, zTab, zOrder\par
 8253       );\par
 8254     \}else\{\par
 8255       zQuery = sqlite3_mprintf(\par
 8256           "SELECT %s FROM temp."UNIQUE_TABLE_NAME" x ORDER BY %s", zCols, zOrder\par
 8257       );\par
 8258     \}\par
 8259   \}\par
 8260   sqlite3_free(zCols);\par
 8261   sqlite3_free(zOrder);\par
 8262 \par
 8263   /* Formulate the query text */\par
 8264   if( rc==SQLITE_OK )\{\par
 8265     sqlite3 *dbrem = (p->iSample==100 ? p->db : p->dbv);\par
 8266     rc = idxPrepareStmt(dbrem, &pQuery, pzErr, zQuery);\par
 8267   \}\par
 8268   sqlite3_free(zQuery);\par
 8269 \par
 8270   if( rc==SQLITE_OK )\{\par
 8271     aStat = (int*)idxMalloc(&rc, sizeof(int)*(nCol+1));\par
 8272   \}\par
 8273   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pQuery) )\{\par
 8274     IdxHashEntry *pEntry;\par
 8275     char *zStat = 0;\par
 8276     for(i=0; i<=nCol; i++) aStat[i] = 1;\par
 8277     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pQuery) )\{\par
 8278       aStat[0]++;\par
 8279       for(i=0; i<nCol; i++)\{\par
 8280         if( sqlite3_column_int(pQuery, i)==0 ) break;\par
 8281       \}\par
 8282       for(/*no-op*/; i<nCol; i++)\{\par
 8283         aStat[i+1]++;\par
 8284       \}\par
 8285     \}\par
 8286 \par
 8287     if( rc==SQLITE_OK )\{\par
 8288       int s0 = aStat[0];\par
 8289       zStat = sqlite3_mprintf("%d", s0);\par
 8290       if( zStat==0 ) rc = SQLITE_NOMEM;\par
 8291       for(i=1; rc==SQLITE_OK && i<=nCol; i++)\{\par
 8292         zStat = idxAppendText(&rc, zStat, " %d", (s0+aStat[i]/2) / aStat[i]);\par
 8293       \}\par
 8294     \}\par
 8295 \par
 8296     if( rc==SQLITE_OK )\{\par
 8297       sqlite3_bind_text(pWriteStat, 1, zTab, -1, SQLITE_STATIC);\par
 8298       sqlite3_bind_text(pWriteStat, 2, zIdx, -1, SQLITE_STATIC);\par
 8299       sqlite3_bind_text(pWriteStat, 3, zStat, -1, SQLITE_STATIC);\par
 8300       sqlite3_step(pWriteStat);\par
 8301       rc = sqlite3_reset(pWriteStat);\par
 8302     \}\par
 8303 \par
 8304     pEntry = idxHashFind(&p->hIdx, zIdx, STRLEN(zIdx));\par
 8305     if( pEntry )\{\par
 8306       assert( pEntry->zVal2==0 );\par
 8307       pEntry->zVal2 = zStat;\par
 8308     \}else\{\par
 8309       sqlite3_free(zStat);\par
 8310     \}\par
 8311   \}\par
 8312   sqlite3_free(aStat);\par
 8313   idxFinalize(&rc, pQuery);\par
 8314 \par
 8315   return rc;\par
 8316 \}\par
}
}
{\xe \v idxPopulateStat1\:shell.c}
{\xe \v shell.c\:idxPopulateStat1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxPopulateStat1 ({\b sqlite3expert} *  {\i p}, char **  {\i pzErr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8342 of file shell.c.}\par
{
References IdxRemCtx::aSlot, sqlite3expert::db, sqlite3expert::dbm, sqlite3expert::dbv, idxBuildSampleTable(), idxFinalize(), idxLargestIndex(), idxMalloc(), idxPopulateOneStat1(), idxPrepareStmt(), idxRemFunc(), idxSampleFunc(), sqlite3expert::iSample, IdxSampleCtx::iTarget, IdxSampleCtx::nRet, IdxSampleCtx::nRow, IdxRemCtx::nSlot, sqlite3_column_int64, sqlite3_column_text, sqlite3_create_function, sqlite3_exec, sqlite3_free, sqlite3_step, SQLITE_OK, SQLITE_ROW, SQLITE_UTF8, IdxSampleCtx::target, UNIQUE_TABLE_NAME, and IdxRemCtx::IdxRemSlot::z.}\par
{
Referenced by sqlite3_expert_analyze().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8342                                                            \{\par
 8343   int rc = SQLITE_OK;\par
 8344   int nMax =0;\par
 8345   struct IdxRemCtx *pCtx = 0;\par
 8346   struct IdxSampleCtx samplectx; \par
 8347   int i;\par
 8348   i64 iPrev = -100000;\par
 8349   sqlite3_stmt *pAllIndex = 0;\par
 8350   sqlite3_stmt *pIndexXInfo = 0;\par
 8351   sqlite3_stmt *pWrite = 0;\par
 8352 \par
 8353   const char *zAllIndex =\par
 8354     "SELECT s.rowid, s.name, l.name FROM "\par
 8355     "  sqlite_master AS s, "\par
 8356     "  pragma_index_list(s.name) AS l "\par
 8357     "WHERE s.type = 'table'";\par
 8358   const char *zIndexXInfo = \par
 8359     "SELECT name, coll FROM pragma_index_xinfo(?) WHERE key";\par
 8360   const char *zWrite = "INSERT INTO sqlite_stat1 VALUES(?, ?, ?)";\par
 8361 \par
 8362   /* If iSample==0, no sqlite_stat1 data is required. */\par
 8363   if( p->iSample==0 ) return SQLITE_OK;\par
 8364 \par
 8365   rc = idxLargestIndex(p->dbm, &nMax, pzErr);\par
 8366   if( nMax<=0 || rc!=SQLITE_OK ) return rc;\par
 8367 \par
 8368   rc = sqlite3_exec(p->dbm, "ANALYZE; PRAGMA writable_schema=1", 0, 0, 0);\par
 8369 \par
 8370   if( rc==SQLITE_OK )\{\par
 8371     int nByte = sizeof(struct IdxRemCtx) + (sizeof(struct IdxRemSlot) * nMax);\par
 8372     pCtx = (struct IdxRemCtx*)idxMalloc(&rc, nByte);\par
 8373   \}\par
 8374 \par
 8375   if( rc==SQLITE_OK )\{\par
 8376     sqlite3 *dbrem = (p->iSample==100 ? p->db : p->dbv);\par
 8377     rc = sqlite3_create_function(\par
 8378         dbrem, "rem", 2, SQLITE_UTF8, (void*)pCtx, idxRemFunc, 0, 0\par
 8379     );\par
 8380   \}\par
 8381   if( rc==SQLITE_OK )\{\par
 8382     rc = sqlite3_create_function(\par
 8383         p->db, "sample", 0, SQLITE_UTF8, (void*)&samplectx, idxSampleFunc, 0, 0\par
 8384     );\par
 8385   \}\par
 8386 \par
 8387   if( rc==SQLITE_OK )\{\par
 8388     pCtx->nSlot = nMax+1;\par
 8389     rc = idxPrepareStmt(p->dbm, &pAllIndex, pzErr, zAllIndex);\par
 8390   \}\par
 8391   if( rc==SQLITE_OK )\{\par
 8392     rc = idxPrepareStmt(p->dbm, &pIndexXInfo, pzErr, zIndexXInfo);\par
 8393   \}\par
 8394   if( rc==SQLITE_OK )\{\par
 8395     rc = idxPrepareStmt(p->dbm, &pWrite, pzErr, zWrite);\par
 8396   \}\par
 8397 \par
 8398   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pAllIndex) )\{\par
 8399     i64 iRowid = sqlite3_column_int64(pAllIndex, 0);\par
 8400     const char *zTab = (const char*)sqlite3_column_text(pAllIndex, 1);\par
 8401     const char *zIdx = (const char*)sqlite3_column_text(pAllIndex, 2);\par
 8402     if( p->iSample<100 && iPrev!=iRowid )\{\par
 8403       samplectx.target = (double)p->iSample / 100.0;\par
 8404       samplectx.iTarget = p->iSample;\par
 8405       samplectx.nRow = 0.0;\par
 8406       samplectx.nRet = 0.0;\par
 8407       rc = idxBuildSampleTable(p, zTab);\par
 8408       if( rc!=SQLITE_OK ) break;\par
 8409     \}\par
 8410     rc = idxPopulateOneStat1(p, pIndexXInfo, pWrite, zTab, zIdx, pzErr);\par
 8411     iPrev = iRowid;\par
 8412   \}\par
 8413   if( rc==SQLITE_OK && p->iSample<100 )\{\par
 8414     rc = sqlite3_exec(p->dbv, \par
 8415         "DROP TABLE IF EXISTS temp." UNIQUE_TABLE_NAME, 0,0,0\par
 8416     );\par
 8417   \}\par
 8418 \par
 8419   idxFinalize(&rc, pAllIndex);\par
 8420   idxFinalize(&rc, pIndexXInfo);\par
 8421   idxFinalize(&rc, pWrite);\par
 8422 \par
 8423   for(i=0; i<pCtx->nSlot; i++)\{\par
 8424     sqlite3_free(pCtx->aSlot[i].z);\par
 8425   \}\par
 8426   sqlite3_free(pCtx);\par
 8427 \par
 8428   if( rc==SQLITE_OK )\{\par
 8429     rc = sqlite3_exec(p->dbm, "ANALYZE sqlite_master", 0, 0, 0);\par
 8430   \}\par
 8431 \par
 8432   sqlite3_exec(p->db, "DROP TABLE IF EXISTS temp."UNIQUE_TABLE_NAME,0,0,0);\par
 8433   return rc;\par
 8434 \}\par
}
}
{\xe \v idxPrepareStmt\:shell.c}
{\xe \v shell.c\:idxPrepareStmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxPrepareStmt ({\b sqlite3} *  {\i db}, {\b sqlite3_stmt} **  {\i ppStmt}, char **  {\i pzErrmsg}, const char *  {\i zSql}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7013 of file shell.c.}\par
{
References idxDatabaseError(), sqlite3_prepare_v2, and SQLITE_OK.}\par
{
Referenced by idxCreateVtabSchema(), idxLargestIndex(), idxPopulateOneStat1(), idxPopulateStat1(), and idxPrintfPrepareStmt().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7018  \{\par
 7019   int rc = sqlite3_prepare_v2(db, zSql, -1, ppStmt, 0);\par
 7020   if( rc!=SQLITE_OK )\{\par
 7021     *ppStmt = 0;\par
 7022     idxDatabaseError(db, pzErrmsg);\par
 7023   \}\par
 7024   return rc;\par
 7025 \}\par
}
}
{\xe \v idxPrintfPrepareStmt\:shell.c}
{\xe \v shell.c\:idxPrintfPrepareStmt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxPrintfPrepareStmt ({\b sqlite3} *  {\i db}, {\b sqlite3_stmt} **  {\i ppStmt}, char **  {\i pzErrmsg}, const char *  {\i zFmt},   {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7030 of file shell.c.}\par
{
References idxPrepareStmt(), sqlite3_free, sqlite3_vmprintf, and SQLITE_NOMEM.}\par
{
Referenced by expertFilter(), idxFindCompatible(), idxFindIndexes(), idxGetTableInfo(), idxProcessOneTrigger(), and sqlite3_expert_new().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7036  \{\par
 7037   va_list ap;\par
 7038   int rc;\par
 7039   char *zSql;\par
 7040   va_start(ap, zFmt);\par
 7041   zSql = sqlite3_vmprintf(zFmt, ap);\par
 7042   if( zSql==0 )\{\par
 7043     rc = SQLITE_NOMEM;\par
 7044   \}else\{\par
 7045     rc = idxPrepareStmt(db, ppStmt, pzErrmsg, zSql);\par
 7046     sqlite3_free(zSql);\par
 7047   \}\par
 7048   va_end(ap);\par
 7049   return rc;\par
 7050 \}\par
}
}
{\xe \v idxProcessOneTrigger\:shell.c}
{\xe \v shell.c\:idxProcessOneTrigger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxProcessOneTrigger ({\b sqlite3expert} *  {\i p}, {\b IdxWrite} *  {\i pWrite}, char **  {\i pzErr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7917 of file shell.c.}\par
{
References IdxTable::aCol, sqlite3expert::db, sqlite3expert::dbv, IdxWrite::eOp, idxAppendText(), idxDatabaseError(), idxFinalize(), idxPrintfPrepareStmt(), IdxTable::nCol, IdxWrite::pTab, sqlite3_column_text, sqlite3_exec, sqlite3_free, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_step, SQLITE_DELETE, SQLITE_INSERT, SQLITE_NOMEM, SQLITE_OK, SQLITE_ROW, SQLITE_UPDATE, UNIQUE_TABLE_NAME, IdxColumn::zName, and IdxTable::zName.}\par
{
Referenced by idxProcessTriggers().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7921  \{\par
 7922   static const char *zInt = UNIQUE_TABLE_NAME;\par
 7923   static const char *zDrop = "DROP TABLE " UNIQUE_TABLE_NAME;\par
 7924   IdxTable *pTab = pWrite->pTab;\par
 7925   const char *zTab = pTab->zName;\par
 7926   const char *zSql = \par
 7927     "SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_master "\par
 7928     "WHERE tbl_name = %Q AND type IN ('table', 'trigger') "\par
 7929     "ORDER BY type;";\par
 7930   sqlite3_stmt *pSelect = 0;\par
 7931   int rc = SQLITE_OK;\par
 7932   char *zWrite = 0;\par
 7933 \par
 7934   /* Create the table and its triggers in the temp schema */\par
 7935   rc = idxPrintfPrepareStmt(p->db, &pSelect, pzErr, zSql, zTab, zTab);\par
 7936   while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSelect) )\{\par
 7937     const char *zCreate = (const char*)sqlite3_column_text(pSelect, 0);\par
 7938     rc = sqlite3_exec(p->dbv, zCreate, 0, 0, pzErr);\par
 7939   \}\par
 7940   idxFinalize(&rc, pSelect);\par
 7941 \par
 7942   /* Rename the table in the temp schema to zInt */\par
 7943   if( rc==SQLITE_OK )\{\par
 7944     char *z = sqlite3_mprintf("ALTER TABLE temp.%Q RENAME TO %Q", zTab, zInt);\par
 7945     if( z==0 )\{\par
 7946       rc = SQLITE_NOMEM;\par
 7947     \}else\{\par
 7948       rc = sqlite3_exec(p->dbv, z, 0, 0, pzErr);\par
 7949       sqlite3_free(z);\par
 7950     \}\par
 7951   \}\par
 7952 \par
 7953   switch( pWrite->eOp )\{\par
 7954     case SQLITE_INSERT: \{\par
 7955       int i;\par
 7956       zWrite = idxAppendText(&rc, zWrite, "INSERT INTO %Q VALUES(", zInt);\par
 7957       for(i=0; i<pTab->nCol; i++)\{\par
 7958         zWrite = idxAppendText(&rc, zWrite, "%s?", i==0 ? "" : ", ");\par
 7959       \}\par
 7960       zWrite = idxAppendText(&rc, zWrite, ")");\par
 7961       break;\par
 7962     \}\par
 7963     case SQLITE_UPDATE: \{\par
 7964       int i;\par
 7965       zWrite = idxAppendText(&rc, zWrite, "UPDATE %Q SET ", zInt);\par
 7966       for(i=0; i<pTab->nCol; i++)\{\par
 7967         zWrite = idxAppendText(&rc, zWrite, "%s%Q=?", i==0 ? "" : ", ", \par
 7968             pTab->aCol[i].zName\par
 7969         );\par
 7970       \}\par
 7971       break;\par
 7972     \}\par
 7973     default: \{\par
 7974       assert( pWrite->eOp==SQLITE_DELETE );\par
 7975       if( rc==SQLITE_OK )\{\par
 7976         zWrite = sqlite3_mprintf("DELETE FROM %Q", zInt);\par
 7977         if( zWrite==0 ) rc = SQLITE_NOMEM;\par
 7978       \}\par
 7979     \}\par
 7980   \}\par
 7981 \par
 7982   if( rc==SQLITE_OK )\{\par
 7983     sqlite3_stmt *pX = 0;\par
 7984     rc = sqlite3_prepare_v2(p->dbv, zWrite, -1, &pX, 0);\par
 7985     idxFinalize(&rc, pX);\par
 7986     if( rc!=SQLITE_OK )\{\par
 7987       idxDatabaseError(p->dbv, pzErr);\par
 7988     \}\par
 7989   \}\par
 7990   sqlite3_free(zWrite);\par
 7991 \par
 7992   if( rc==SQLITE_OK )\{\par
 7993     rc = sqlite3_exec(p->dbv, zDrop, 0, 0, pzErr);\par
 7994   \}\par
 7995 \par
 7996   return rc;\par
 7997 \}\par
}
}
{\xe \v idxProcessTriggers\:shell.c}
{\xe \v shell.c\:idxProcessTriggers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxProcessTriggers ({\b sqlite3expert} *  {\i p}, char **  {\i pzErr}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7999 of file shell.c.}\par
{
References idxProcessOneTrigger(), IdxWrite::pNext, sqlite3expert::pWrite, and SQLITE_OK.}\par
{
Referenced by sqlite3_expert_analyze().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7999                                                              \{\par
 8000   int rc = SQLITE_OK;\par
 8001   IdxWrite *pEnd = 0;\par
 8002   IdxWrite *pFirst = p->pWrite;\par
 8003 \par
 8004   while( rc==SQLITE_OK && pFirst!=pEnd )\{\par
 8005     IdxWrite *pIter;\par
 8006     for(pIter=pFirst; rc==SQLITE_OK && pIter!=pEnd; pIter=pIter->pNext)\{\par
 8007       rc = idxProcessOneTrigger(p, pIter, pzErr);\par
 8008     \}\par
 8009     pEnd = pFirst;\par
 8010     pFirst = p->pWrite;\par
 8011   \}\par
 8012 \par
 8013   return rc;\par
 8014 \}\par
}
}
{\xe \v idxRegisterVtab\:shell.c}
{\xe \v shell.c\:idxRegisterVtab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int idxRegisterVtab ({\b sqlite3expert} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7328 of file shell.c.}\par
{
References sqlite3expert::dbv, expertBestIndex(), expertClose(), expertColumn(), expertConnect(), expertDisconnect(), expertEof(), expertFilter(), expertNext(), expertOpen(), expertRowid(), expertUpdate(), and sqlite3_create_module.}\par
{
Referenced by idxCreateVtabSchema().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7328                                             \{\par
 7329   static sqlite3_module expertModule = \{\par
 7330     2,                            /* iVersion */\par
 7331     expertConnect,                /* xCreate - create a table */\par
 7332     expertConnect,                /* xConnect - connect to an existing table */\par
 7333     expertBestIndex,              /* xBestIndex - Determine search strategy */\par
 7334     expertDisconnect,             /* xDisconnect - Disconnect from a table */\par
 7335     expertDisconnect,             /* xDestroy - Drop a table */\par
 7336     expertOpen,                   /* xOpen - open a cursor */\par
 7337     expertClose,                  /* xClose - close a cursor */\par
 7338     expertFilter,                 /* xFilter - configure scan constraints */\par
 7339     expertNext,                   /* xNext - advance a cursor */\par
 7340     expertEof,                    /* xEof */\par
 7341     expertColumn,                 /* xColumn - read data */\par
 7342     expertRowid,                  /* xRowid - read data */\par
 7343     expertUpdate,                 /* xUpdate - write data */\par
 7344     0,                            /* xBegin - begin transaction */\par
 7345     0,                            /* xSync - sync transaction */\par
 7346     0,                            /* xCommit - commit transaction */\par
 7347     0,                            /* xRollback - rollback transaction */\par
 7348     0,                            /* xFindFunction - function overloading */\par
 7349     0,                            /* xRename - rename the table */\par
 7350     0,                            /* xSavepoint */\par
 7351     0,                            /* xRelease */\par
 7352     0,                            /* xRollbackTo */\par
 7353     0,                            /* xShadowName */\par
 7354   \};\par
 7355 \par
 7356   return sqlite3_create_module(p->dbv, "expert", &expertModule, (void*)p);\par
 7357 \}\par
}
}
{\xe \v idxRemFunc\:shell.c}
{\xe \v shell.c\:idxRemFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void idxRemFunc ({\b sqlite3_context} *  {\i pCtx}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8125 of file shell.c.}\par
{
References IdxRemCtx::aSlot, sqlite3_realloc, sqlite3_result_blob, sqlite3_result_double, sqlite3_result_error_nomem, sqlite3_result_int64, sqlite3_result_text, sqlite3_user_data, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_double, sqlite3_value_int, sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type, SQLITE_BLOB, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL, SQLITE_TEXT, and SQLITE_TRANSIENT.}\par
{
Referenced by idxPopulateStat1().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8129  \{\par
 8130   struct IdxRemCtx *p = (struct IdxRemCtx*)sqlite3_user_data(pCtx);\par
 8131   struct IdxRemSlot *pSlot;\par
 8132   int iSlot;\par
 8133   assert( argc==2 );\par
 8134 \par
 8135   iSlot = sqlite3_value_int(argv[0]);\par
 8136   assert( iSlot<=p->nSlot );\par
 8137   pSlot = &p->aSlot[iSlot];\par
 8138 \par
 8139   switch( pSlot->eType )\{\par
 8140     case SQLITE_NULL:\par
 8141       /* no-op */\par
 8142       break;\par
 8143 \par
 8144     case SQLITE_INTEGER:\par
 8145       sqlite3_result_int64(pCtx, pSlot->iVal);\par
 8146       break;\par
 8147 \par
 8148     case SQLITE_FLOAT:\par
 8149       sqlite3_result_double(pCtx, pSlot->rVal);\par
 8150       break;\par
 8151 \par
 8152     case SQLITE_BLOB:\par
 8153       sqlite3_result_blob(pCtx, pSlot->z, pSlot->n, SQLITE_TRANSIENT);\par
 8154       break;\par
 8155 \par
 8156     case SQLITE_TEXT:\par
 8157       sqlite3_result_text(pCtx, pSlot->z, pSlot->n, SQLITE_TRANSIENT);\par
 8158       break;\par
 8159   \}\par
 8160 \par
 8161   pSlot->eType = sqlite3_value_type(argv[1]);\par
 8162   switch( pSlot->eType )\{\par
 8163     case SQLITE_NULL:\par
 8164       /* no-op */\par
 8165       break;\par
 8166 \par
 8167     case SQLITE_INTEGER:\par
 8168       pSlot->iVal = sqlite3_value_int64(argv[1]);\par
 8169       break;\par
 8170 \par
 8171     case SQLITE_FLOAT:\par
 8172       pSlot->rVal = sqlite3_value_double(argv[1]);\par
 8173       break;\par
 8174 \par
 8175     case SQLITE_BLOB:\par
 8176     case SQLITE_TEXT: \{\par
 8177       int nByte = sqlite3_value_bytes(argv[1]);\par
 8178       if( nByte>pSlot->nByte )\{\par
 8179         char *zNew = (char*)sqlite3_realloc(pSlot->z, nByte*2);\par
 8180         if( zNew==0 )\{\par
 8181           sqlite3_result_error_nomem(pCtx);\par
 8182           return;\par
 8183         \}\par
 8184         pSlot->nByte = nByte*2;\par
 8185         pSlot->z = zNew;\par
 8186       \}\par
 8187       pSlot->n = nByte;\par
 8188       if( pSlot->eType==SQLITE_BLOB )\{\par
 8189         memcpy(pSlot->z, sqlite3_value_blob(argv[1]), nByte);\par
 8190       \}else\{\par
 8191         memcpy(pSlot->z, sqlite3_value_text(argv[1]), nByte);\par
 8192       \}\par
 8193       break;\par
 8194     \}\par
 8195   \}\par
 8196 \}\par
}
}
{\xe \v idxSampleFunc\:shell.c}
{\xe \v shell.c\:idxSampleFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void idxSampleFunc ({\b sqlite3_context} *  {\i pCtx}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8084 of file shell.c.}\par
{
References IdxSampleCtx::iTarget, IdxSampleCtx::nRet, IdxSampleCtx::nRow, sqlite3_randomness, sqlite3_result_int, sqlite3_user_data, and IdxSampleCtx::target.}\par
{
Referenced by idxPopulateStat1().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8088  \{\par
 8089   struct IdxSampleCtx *p = (struct IdxSampleCtx*)sqlite3_user_data(pCtx);\par
 8090   int bRet;\par
 8091 \par
 8092   (void)argv;\par
 8093   assert( argc==0 );\par
 8094   if( p->nRow==0.0 )\{\par
 8095     bRet = 1;\par
 8096   \}else\{\par
 8097     bRet = (p->nRet / p->nRow) <= p->target;\par
 8098     if( bRet==0 )\{\par
 8099       unsigned short rnd;\par
 8100       sqlite3_randomness(2, (void*)&rnd);\par
 8101       bRet = ((int)rnd % 100) <= p->iTarget;\par
 8102     \}\par
 8103   \}\par
 8104 \par
 8105   sqlite3_result_int(pCtx, bRet);\par
 8106   p->nRow += 1.0;\par
 8107   p->nRet += (double)bRet;\par
 8108 \}\par
}
}
{\xe \v idxScanFree\:shell.c}
{\xe \v shell.c\:idxScanFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void idxScanFree ({\b IdxScan} *  {\i pScan}, {\b IdxScan} *  {\i pLast}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7756 of file shell.c.}\par
{
References idxConstraintFree(), IdxScan::pEq, IdxScan::pNextScan, IdxScan::pOrder, IdxScan::pRange, and sqlite3_free.}\par
{
Referenced by sqlite3_expert_destroy(), and sqlite3_expert_sql().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7756                                                        \{\par
 7757   IdxScan *p;\par
 7758   IdxScan *pNext;\par
 7759   for(p=pScan; p!=pLast; p=pNext)\{\par
 7760     pNext = p->pNextScan;\par
 7761     idxConstraintFree(p->pOrder);\par
 7762     idxConstraintFree(p->pEq);\par
 7763     idxConstraintFree(p->pRange);\par
 7764     sqlite3_free(p);\par
 7765   \}\par
 7766 \}\par
}
}
{\xe \v idxStatementFree\:shell.c}
{\xe \v shell.c\:idxStatementFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void idxStatementFree ({\b IdxStatement} *  {\i pStatement}, {\b IdxStatement} *  {\i pLast}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7772 of file shell.c.}\par
{
References IdxStatement::pNext, sqlite3_free, IdxStatement::zEQP, and IdxStatement::zIdx.}\par
{
Referenced by sqlite3_expert_destroy(), and sqlite3_expert_sql().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7772                                                                            \{\par
 7773   IdxStatement *p;\par
 7774   IdxStatement *pNext;\par
 7775   for(p=pStatement; p!=pLast; p=pNext)\{\par
 7776     pNext = p->pNext;\par
 7777     sqlite3_free(p->zEQP);\par
 7778     sqlite3_free(p->zIdx);\par
 7779     sqlite3_free(p);\par
 7780   \}\par
 7781 \}\par
}
}
{\xe \v idxTableFree\:shell.c}
{\xe \v shell.c\:idxTableFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void idxTableFree ({\b IdxTable} *  {\i pTab}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7786 of file shell.c.}\par
{
References IdxTable::pNext, and sqlite3_free.}\par
{
Referenced by sqlite3_expert_destroy().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7786                                         \{\par
 7787   IdxTable *pIter;\par
 7788   IdxTable *pNext;\par
 7789   for(pIter=pTab; pIter; pIter=pNext)\{\par
 7790     pNext = pIter->pNext;\par
 7791     sqlite3_free(pIter);\par
 7792   \}\par
 7793 \}\par
}
}
{\xe \v idxWriteFree\:shell.c}
{\xe \v shell.c\:idxWriteFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void idxWriteFree ({\b IdxWrite} *  {\i pTab}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7798 of file shell.c.}\par
{
References IdxWrite::pNext, and sqlite3_free.}\par
{
Referenced by sqlite3_expert_destroy().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  7798                                         \{\par
 7799   IdxWrite *pIter;\par
 7800   IdxWrite *pNext;\par
 7801   for(pIter=pTab; pIter; pIter=pNext)\{\par
 7802     pNext = pIter->pNext;\par
 7803     sqlite3_free(pIter);\par
 7804   \}\par
 7805 \}\par
}
}
{\xe \v import_append_char\:shell.c}
{\xe \v shell.c\:import_append_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void import_append_char ({\b ImportCtx} *  {\i p}, int  {\i c}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13083 of file shell.c.}\par
{
References ImportCtx::n, ImportCtx::nAlloc, shell_out_of_memory(), sqlite3_realloc64, and ImportCtx::z.}\par
{
Referenced by ascii_read_one_field(), csv_read_one_field(), and do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13083                                                    \{\par
13084   if( p->n+1>=p->nAlloc )\{\par
13085     p->nAlloc += p->nAlloc + 100;\par
13086     p->z = sqlite3_realloc64(p->z, p->nAlloc);\par
13087     if( p->z==0 ) shell_out_of_memory();\par
13088   \}\par
13089   p->z[p->n++] = (char)c;\par
13090 \}\par
}
}
{\xe \v initText\:shell.c}
{\xe \v shell.c\:initText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void initText ({\b ShellText} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 734 of file shell.c.}\par
{
Referenced by do_meta_command(), dump_callback(), freeText(), and shellFakeSchema().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   734                                   \{\par
  735   memset(p, 0, sizeof(*p));\par
  736 \}\par
}
}
{\xe \v integerValue\:shell.c}
{\xe \v shell.c\:integerValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b sqlite3_int64} integerValue (const char *  {\i zArg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 678 of file shell.c.}\par
{
References ArraySize, hexDigitValue(), IsDigit, sqlite3_stricmp, and time_test::x.}\par
{
Referenced by booleanValue(), do_meta_command(), expertDotCommand(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   678                                                    \{\par
  679   sqlite3_int64 v = 0;\par
  680   static const struct \{ char *zSuffix; int iMult; \} aMult[] = \{\par
  681     \{ "KiB", 1024 \},\par
  682     \{ "MiB", 1024*1024 \},\par
  683     \{ "GiB", 1024*1024*1024 \},\par
  684     \{ "KB",  1000 \},\par
  685     \{ "MB",  1000000 \},\par
  686     \{ "GB",  1000000000 \},\par
  687     \{ "K",   1000 \},\par
  688     \{ "M",   1000000 \},\par
  689     \{ "G",   1000000000 \},\par
  690   \};\par
  691   int i;\par
  692   int isNeg = 0;\par
  693   if( zArg[0]=='-' )\{\par
  694     isNeg = 1;\par
  695     zArg++;\par
  696   \}else if( zArg[0]=='+' )\{\par
  697     zArg++;\par
  698   \}\par
  699   if( zArg[0]=='0' && zArg[1]=='x' )\{\par
  700     int x;\par
  701     zArg += 2;\par
  702     while( (x = hexDigitValue(zArg[0]))>=0 )\{\par
  703       v = (v<<4) + x;\par
  704       zArg++;\par
  705     \}\par
  706   \}else\{\par
  707     while( IsDigit(zArg[0]) )\{\par
  708       v = v*10 + zArg[0] - '0';\par
  709       zArg++;\par
  710     \}\par
  711   \}\par
  712   for(i=0; i<ArraySize(aMult); i++)\{\par
  713     if( sqlite3_stricmp(aMult[i].zSuffix, zArg)==0 )\{\par
  714       v *= aMult[i].iMult;\par
  715       break;\par
  716     \}\par
  717   \}\par
  718   return isNeg? -v : v;\par
  719 \}\par
}
}
{\xe \v interrupt_handler\:shell.c}
{\xe \v shell.c\:interrupt_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void interrupt_handler (int  {\i NotUsed}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10174 of file shell.c.}\par
{
References sqlite3_interrupt, and UNUSED_PARAMETER.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10174                                           \{\par
10175   UNUSED_PARAMETER(NotUsed);\par
10176   seenInterrupt++;\par
10177   if( seenInterrupt>2 ) exit(1);\par
10178   if( globalDb ) sqlite3_interrupt(globalDb);\par
10179 \}\par
}
}
{\xe \v isatty\:shell.c}
{\xe \v shell.c\:isatty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int isatty (int )}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by main(), and Tclsqlite_Unload().}\par
}
{\xe \v isNumber\:shell.c}
{\xe \v shell.c\:isNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int isNumber (const char *  {\i z}, int *  {\i realnum}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 529 of file shell.c.}\par
{
References IsDigit.}\par
{
Referenced by shell_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   529                                                 \{\par
  530   if( *z=='-' || *z=='+' ) z++;\par
  531   if( !IsDigit(*z) )\{\par
  532     return 0;\par
  533   \}\par
  534   z++;\par
  535   if( realnum ) *realnum = 0;\par
  536   while( IsDigit(*z) )\{ z++; \}\par
  537   if( *z=='.' )\{\par
  538     z++;\par
  539     if( !IsDigit(*z) ) return 0;\par
  540     while( IsDigit(*z) )\{ z++; \}\par
  541     if( realnum ) *realnum = 1;\par
  542   \}\par
  543   if( *z=='e' || *z=='E' )\{\par
  544     z++;\par
  545     if( *z=='+' || *z=='-' ) z++;\par
  546     if( !IsDigit(*z) ) return 0;\par
  547     while( IsDigit(*z) )\{ z++; \}\par
  548     if( realnum ) *realnum = 1;\par
  549   \}\par
  550   return *z==0;\par
  551 \}\par
}
}
{\xe \v KeccakF1600Step\:shell.c}
{\xe \v shell.c\:KeccakF1600Step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void KeccakF1600Step ({\b SHA3Context} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1390 of file shell.c.}\par
{
References a00, a01, a02, a03, a04, a10, a11, a12, a13, a14, a20, a21, a22, a23, a24, a30, a31, a32, a33, a34, a40, a41, a42, a43, a44, and ROL64.}\par
{
Referenced by SHA3Update().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1390                                            \{\par
 1391   int i;\par
 1392   u64 b0, b1, b2, b3, b4;\par
 1393   u64 c0, c1, c2, c3, c4;\par
 1394   u64 d0, d1, d2, d3, d4;\par
 1395   static const u64 RC[] = \{\par
 1396     0x0000000000000001ULL,  0x0000000000008082ULL,\par
 1397     0x800000000000808aULL,  0x8000000080008000ULL,\par
 1398     0x000000000000808bULL,  0x0000000080000001ULL,\par
 1399     0x8000000080008081ULL,  0x8000000000008009ULL,\par
 1400     0x000000000000008aULL,  0x0000000000000088ULL,\par
 1401     0x0000000080008009ULL,  0x000000008000000aULL,\par
 1402     0x000000008000808bULL,  0x800000000000008bULL,\par
 1403     0x8000000000008089ULL,  0x8000000000008003ULL,\par
 1404     0x8000000000008002ULL,  0x8000000000000080ULL,\par
 1405     0x000000000000800aULL,  0x800000008000000aULL,\par
 1406     0x8000000080008081ULL,  0x8000000000008080ULL,\par
 1407     0x0000000080000001ULL,  0x8000000080008008ULL\par
 1408   \};\par
 1409 # define a00 (p->u.s[0])\par
 1410 # define a01 (p->u.s[1])\par
 1411 # define a02 (p->u.s[2])\par
 1412 # define a03 (p->u.s[3])\par
 1413 # define a04 (p->u.s[4])\par
 1414 # define a10 (p->u.s[5])\par
 1415 # define a11 (p->u.s[6])\par
 1416 # define a12 (p->u.s[7])\par
 1417 # define a13 (p->u.s[8])\par
 1418 # define a14 (p->u.s[9])\par
 1419 # define a20 (p->u.s[10])\par
 1420 # define a21 (p->u.s[11])\par
 1421 # define a22 (p->u.s[12])\par
 1422 # define a23 (p->u.s[13])\par
 1423 # define a24 (p->u.s[14])\par
 1424 # define a30 (p->u.s[15])\par
 1425 # define a31 (p->u.s[16])\par
 1426 # define a32 (p->u.s[17])\par
 1427 # define a33 (p->u.s[18])\par
 1428 # define a34 (p->u.s[19])\par
 1429 # define a40 (p->u.s[20])\par
 1430 # define a41 (p->u.s[21])\par
 1431 # define a42 (p->u.s[22])\par
 1432 # define a43 (p->u.s[23])\par
 1433 # define a44 (p->u.s[24])\par
 1434 # define ROL64(a,x) ((a<<x)|(a>>(64-x)))\par
 1435 \par
 1436   for(i=0; i<24; i+=4)\{\par
 1437     c0 = a00^a10^a20^a30^a40;\par
 1438     c1 = a01^a11^a21^a31^a41;\par
 1439     c2 = a02^a12^a22^a32^a42;\par
 1440     c3 = a03^a13^a23^a33^a43;\par
 1441     c4 = a04^a14^a24^a34^a44;\par
 1442     d0 = c4^ROL64(c1, 1);\par
 1443     d1 = c0^ROL64(c2, 1);\par
 1444     d2 = c1^ROL64(c3, 1);\par
 1445     d3 = c2^ROL64(c4, 1);\par
 1446     d4 = c3^ROL64(c0, 1);\par
 1447 \par
 1448     b0 = (a00^d0);\par
 1449     b1 = ROL64((a11^d1), 44);\par
 1450     b2 = ROL64((a22^d2), 43);\par
 1451     b3 = ROL64((a33^d3), 21);\par
 1452     b4 = ROL64((a44^d4), 14);\par
 1453     a00 =   b0 ^((~b1)&  b2 );\par
 1454     a00 ^= RC[i];\par
 1455     a11 =   b1 ^((~b2)&  b3 );\par
 1456     a22 =   b2 ^((~b3)&  b4 );\par
 1457     a33 =   b3 ^((~b4)&  b0 );\par
 1458     a44 =   b4 ^((~b0)&  b1 );\par
 1459 \par
 1460     b2 = ROL64((a20^d0), 3);\par
 1461     b3 = ROL64((a31^d1), 45);\par
 1462     b4 = ROL64((a42^d2), 61);\par
 1463     b0 = ROL64((a03^d3), 28);\par
 1464     b1 = ROL64((a14^d4), 20);\par
 1465     a20 =   b0 ^((~b1)&  b2 );\par
 1466     a31 =   b1 ^((~b2)&  b3 );\par
 1467     a42 =   b2 ^((~b3)&  b4 );\par
 1468     a03 =   b3 ^((~b4)&  b0 );\par
 1469     a14 =   b4 ^((~b0)&  b1 );\par
 1470 \par
 1471     b4 = ROL64((a40^d0), 18);\par
 1472     b0 = ROL64((a01^d1), 1);\par
 1473     b1 = ROL64((a12^d2), 6);\par
 1474     b2 = ROL64((a23^d3), 25);\par
 1475     b3 = ROL64((a34^d4), 8);\par
 1476     a40 =   b0 ^((~b1)&  b2 );\par
 1477     a01 =   b1 ^((~b2)&  b3 );\par
 1478     a12 =   b2 ^((~b3)&  b4 );\par
 1479     a23 =   b3 ^((~b4)&  b0 );\par
 1480     a34 =   b4 ^((~b0)&  b1 );\par
 1481 \par
 1482     b1 = ROL64((a10^d0), 36);\par
 1483     b2 = ROL64((a21^d1), 10);\par
 1484     b3 = ROL64((a32^d2), 15);\par
 1485     b4 = ROL64((a43^d3), 56);\par
 1486     b0 = ROL64((a04^d4), 27);\par
 1487     a10 =   b0 ^((~b1)&  b2 );\par
 1488     a21 =   b1 ^((~b2)&  b3 );\par
 1489     a32 =   b2 ^((~b3)&  b4 );\par
 1490     a43 =   b3 ^((~b4)&  b0 );\par
 1491     a04 =   b4 ^((~b0)&  b1 );\par
 1492 \par
 1493     b3 = ROL64((a30^d0), 41);\par
 1494     b4 = ROL64((a41^d1), 2);\par
 1495     b0 = ROL64((a02^d2), 62);\par
 1496     b1 = ROL64((a13^d3), 55);\par
 1497     b2 = ROL64((a24^d4), 39);\par
 1498     a30 =   b0 ^((~b1)&  b2 );\par
 1499     a41 =   b1 ^((~b2)&  b3 );\par
 1500     a02 =   b2 ^((~b3)&  b4 );\par
 1501     a13 =   b3 ^((~b4)&  b0 );\par
 1502     a24 =   b4 ^((~b0)&  b1 );\par
 1503 \par
 1504     c0 = a00^a20^a40^a10^a30;\par
 1505     c1 = a11^a31^a01^a21^a41;\par
 1506     c2 = a22^a42^a12^a32^a02;\par
 1507     c3 = a33^a03^a23^a43^a13;\par
 1508     c4 = a44^a14^a34^a04^a24;\par
 1509     d0 = c4^ROL64(c1, 1);\par
 1510     d1 = c0^ROL64(c2, 1);\par
 1511     d2 = c1^ROL64(c3, 1);\par
 1512     d3 = c2^ROL64(c4, 1);\par
 1513     d4 = c3^ROL64(c0, 1);\par
 1514 \par
 1515     b0 = (a00^d0);\par
 1516     b1 = ROL64((a31^d1), 44);\par
 1517     b2 = ROL64((a12^d2), 43);\par
 1518     b3 = ROL64((a43^d3), 21);\par
 1519     b4 = ROL64((a24^d4), 14);\par
 1520     a00 =   b0 ^((~b1)&  b2 );\par
 1521     a00 ^= RC[i+1];\par
 1522     a31 =   b1 ^((~b2)&  b3 );\par
 1523     a12 =   b2 ^((~b3)&  b4 );\par
 1524     a43 =   b3 ^((~b4)&  b0 );\par
 1525     a24 =   b4 ^((~b0)&  b1 );\par
 1526 \par
 1527     b2 = ROL64((a40^d0), 3);\par
 1528     b3 = ROL64((a21^d1), 45);\par
 1529     b4 = ROL64((a02^d2), 61);\par
 1530     b0 = ROL64((a33^d3), 28);\par
 1531     b1 = ROL64((a14^d4), 20);\par
 1532     a40 =   b0 ^((~b1)&  b2 );\par
 1533     a21 =   b1 ^((~b2)&  b3 );\par
 1534     a02 =   b2 ^((~b3)&  b4 );\par
 1535     a33 =   b3 ^((~b4)&  b0 );\par
 1536     a14 =   b4 ^((~b0)&  b1 );\par
 1537 \par
 1538     b4 = ROL64((a30^d0), 18);\par
 1539     b0 = ROL64((a11^d1), 1);\par
 1540     b1 = ROL64((a42^d2), 6);\par
 1541     b2 = ROL64((a23^d3), 25);\par
 1542     b3 = ROL64((a04^d4), 8);\par
 1543     a30 =   b0 ^((~b1)&  b2 );\par
 1544     a11 =   b1 ^((~b2)&  b3 );\par
 1545     a42 =   b2 ^((~b3)&  b4 );\par
 1546     a23 =   b3 ^((~b4)&  b0 );\par
 1547     a04 =   b4 ^((~b0)&  b1 );\par
 1548 \par
 1549     b1 = ROL64((a20^d0), 36);\par
 1550     b2 = ROL64((a01^d1), 10);\par
 1551     b3 = ROL64((a32^d2), 15);\par
 1552     b4 = ROL64((a13^d3), 56);\par
 1553     b0 = ROL64((a44^d4), 27);\par
 1554     a20 =   b0 ^((~b1)&  b2 );\par
 1555     a01 =   b1 ^((~b2)&  b3 );\par
 1556     a32 =   b2 ^((~b3)&  b4 );\par
 1557     a13 =   b3 ^((~b4)&  b0 );\par
 1558     a44 =   b4 ^((~b0)&  b1 );\par
 1559 \par
 1560     b3 = ROL64((a10^d0), 41);\par
 1561     b4 = ROL64((a41^d1), 2);\par
 1562     b0 = ROL64((a22^d2), 62);\par
 1563     b1 = ROL64((a03^d3), 55);\par
 1564     b2 = ROL64((a34^d4), 39);\par
 1565     a10 =   b0 ^((~b1)&  b2 );\par
 1566     a41 =   b1 ^((~b2)&  b3 );\par
 1567     a22 =   b2 ^((~b3)&  b4 );\par
 1568     a03 =   b3 ^((~b4)&  b0 );\par
 1569     a34 =   b4 ^((~b0)&  b1 );\par
 1570 \par
 1571     c0 = a00^a40^a30^a20^a10;\par
 1572     c1 = a31^a21^a11^a01^a41;\par
 1573     c2 = a12^a02^a42^a32^a22;\par
 1574     c3 = a43^a33^a23^a13^a03;\par
 1575     c4 = a24^a14^a04^a44^a34;\par
 1576     d0 = c4^ROL64(c1, 1);\par
 1577     d1 = c0^ROL64(c2, 1);\par
 1578     d2 = c1^ROL64(c3, 1);\par
 1579     d3 = c2^ROL64(c4, 1);\par
 1580     d4 = c3^ROL64(c0, 1);\par
 1581 \par
 1582     b0 = (a00^d0);\par
 1583     b1 = ROL64((a21^d1), 44);\par
 1584     b2 = ROL64((a42^d2), 43);\par
 1585     b3 = ROL64((a13^d3), 21);\par
 1586     b4 = ROL64((a34^d4), 14);\par
 1587     a00 =   b0 ^((~b1)&  b2 );\par
 1588     a00 ^= RC[i+2];\par
 1589     a21 =   b1 ^((~b2)&  b3 );\par
 1590     a42 =   b2 ^((~b3)&  b4 );\par
 1591     a13 =   b3 ^((~b4)&  b0 );\par
 1592     a34 =   b4 ^((~b0)&  b1 );\par
 1593 \par
 1594     b2 = ROL64((a30^d0), 3);\par
 1595     b3 = ROL64((a01^d1), 45);\par
 1596     b4 = ROL64((a22^d2), 61);\par
 1597     b0 = ROL64((a43^d3), 28);\par
 1598     b1 = ROL64((a14^d4), 20);\par
 1599     a30 =   b0 ^((~b1)&  b2 );\par
 1600     a01 =   b1 ^((~b2)&  b3 );\par
 1601     a22 =   b2 ^((~b3)&  b4 );\par
 1602     a43 =   b3 ^((~b4)&  b0 );\par
 1603     a14 =   b4 ^((~b0)&  b1 );\par
 1604 \par
 1605     b4 = ROL64((a10^d0), 18);\par
 1606     b0 = ROL64((a31^d1), 1);\par
 1607     b1 = ROL64((a02^d2), 6);\par
 1608     b2 = ROL64((a23^d3), 25);\par
 1609     b3 = ROL64((a44^d4), 8);\par
 1610     a10 =   b0 ^((~b1)&  b2 );\par
 1611     a31 =   b1 ^((~b2)&  b3 );\par
 1612     a02 =   b2 ^((~b3)&  b4 );\par
 1613     a23 =   b3 ^((~b4)&  b0 );\par
 1614     a44 =   b4 ^((~b0)&  b1 );\par
 1615 \par
 1616     b1 = ROL64((a40^d0), 36);\par
 1617     b2 = ROL64((a11^d1), 10);\par
 1618     b3 = ROL64((a32^d2), 15);\par
 1619     b4 = ROL64((a03^d3), 56);\par
 1620     b0 = ROL64((a24^d4), 27);\par
 1621     a40 =   b0 ^((~b1)&  b2 );\par
 1622     a11 =   b1 ^((~b2)&  b3 );\par
 1623     a32 =   b2 ^((~b3)&  b4 );\par
 1624     a03 =   b3 ^((~b4)&  b0 );\par
 1625     a24 =   b4 ^((~b0)&  b1 );\par
 1626 \par
 1627     b3 = ROL64((a20^d0), 41);\par
 1628     b4 = ROL64((a41^d1), 2);\par
 1629     b0 = ROL64((a12^d2), 62);\par
 1630     b1 = ROL64((a33^d3), 55);\par
 1631     b2 = ROL64((a04^d4), 39);\par
 1632     a20 =   b0 ^((~b1)&  b2 );\par
 1633     a41 =   b1 ^((~b2)&  b3 );\par
 1634     a12 =   b2 ^((~b3)&  b4 );\par
 1635     a33 =   b3 ^((~b4)&  b0 );\par
 1636     a04 =   b4 ^((~b0)&  b1 );\par
 1637 \par
 1638     c0 = a00^a30^a10^a40^a20;\par
 1639     c1 = a21^a01^a31^a11^a41;\par
 1640     c2 = a42^a22^a02^a32^a12;\par
 1641     c3 = a13^a43^a23^a03^a33;\par
 1642     c4 = a34^a14^a44^a24^a04;\par
 1643     d0 = c4^ROL64(c1, 1);\par
 1644     d1 = c0^ROL64(c2, 1);\par
 1645     d2 = c1^ROL64(c3, 1);\par
 1646     d3 = c2^ROL64(c4, 1);\par
 1647     d4 = c3^ROL64(c0, 1);\par
 1648 \par
 1649     b0 = (a00^d0);\par
 1650     b1 = ROL64((a01^d1), 44);\par
 1651     b2 = ROL64((a02^d2), 43);\par
 1652     b3 = ROL64((a03^d3), 21);\par
 1653     b4 = ROL64((a04^d4), 14);\par
 1654     a00 =   b0 ^((~b1)&  b2 );\par
 1655     a00 ^= RC[i+3];\par
 1656     a01 =   b1 ^((~b2)&  b3 );\par
 1657     a02 =   b2 ^((~b3)&  b4 );\par
 1658     a03 =   b3 ^((~b4)&  b0 );\par
 1659     a04 =   b4 ^((~b0)&  b1 );\par
 1660 \par
 1661     b2 = ROL64((a10^d0), 3);\par
 1662     b3 = ROL64((a11^d1), 45);\par
 1663     b4 = ROL64((a12^d2), 61);\par
 1664     b0 = ROL64((a13^d3), 28);\par
 1665     b1 = ROL64((a14^d4), 20);\par
 1666     a10 =   b0 ^((~b1)&  b2 );\par
 1667     a11 =   b1 ^((~b2)&  b3 );\par
 1668     a12 =   b2 ^((~b3)&  b4 );\par
 1669     a13 =   b3 ^((~b4)&  b0 );\par
 1670     a14 =   b4 ^((~b0)&  b1 );\par
 1671 \par
 1672     b4 = ROL64((a20^d0), 18);\par
 1673     b0 = ROL64((a21^d1), 1);\par
 1674     b1 = ROL64((a22^d2), 6);\par
 1675     b2 = ROL64((a23^d3), 25);\par
 1676     b3 = ROL64((a24^d4), 8);\par
 1677     a20 =   b0 ^((~b1)&  b2 );\par
 1678     a21 =   b1 ^((~b2)&  b3 );\par
 1679     a22 =   b2 ^((~b3)&  b4 );\par
 1680     a23 =   b3 ^((~b4)&  b0 );\par
 1681     a24 =   b4 ^((~b0)&  b1 );\par
 1682 \par
 1683     b1 = ROL64((a30^d0), 36);\par
 1684     b2 = ROL64((a31^d1), 10);\par
 1685     b3 = ROL64((a32^d2), 15);\par
 1686     b4 = ROL64((a33^d3), 56);\par
 1687     b0 = ROL64((a34^d4), 27);\par
 1688     a30 =   b0 ^((~b1)&  b2 );\par
 1689     a31 =   b1 ^((~b2)&  b3 );\par
 1690     a32 =   b2 ^((~b3)&  b4 );\par
 1691     a33 =   b3 ^((~b4)&  b0 );\par
 1692     a34 =   b4 ^((~b0)&  b1 );\par
 1693 \par
 1694     b3 = ROL64((a40^d0), 41);\par
 1695     b4 = ROL64((a41^d1), 2);\par
 1696     b0 = ROL64((a42^d2), 62);\par
 1697     b1 = ROL64((a43^d3), 55);\par
 1698     b2 = ROL64((a44^d4), 39);\par
 1699     a40 =   b0 ^((~b1)&  b2 );\par
 1700     a41 =   b1 ^((~b2)&  b3 );\par
 1701     a42 =   b2 ^((~b3)&  b4 );\par
 1702     a43 =   b3 ^((~b4)&  b0 );\par
 1703     a44 =   b4 ^((~b0)&  b1 );\par
 1704   \}\par
 1705 \}\par
}
}
{\xe \v line_contains_semicolon\:shell.c}
{\xe \v shell.c\:line_contains_semicolon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int line_contains_semicolon (const char *  {\i z}, int  {\i N}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18212 of file shell.c.}\par
{
Referenced by process_input().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18212                                                         \{\par
18213   int i;\par
18214   for(i=0; i<N; i++)\{  if( z[i]==';' ) return 1; \}\par
18215   return 0;\par
18216 \}\par
}
}
{\xe \v line_is_command_terminator\:shell.c}
{\xe \v shell.c\:line_is_command_terminator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int line_is_command_terminator (const char *  {\i zLine}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18247 of file shell.c.}\par
{
References _all_whitespace(), IsSpace, and ToLower.}\par
{
Referenced by process_input().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18247                                                         \{\par
18248   while( IsSpace(zLine[0]) )\{ zLine++; \};\par
18249   if( zLine[0]=='/' && _all_whitespace(&zLine[1]) )\{\par
18250     return 1;  /* Oracle */\par
18251   \}\par
18252   if( ToLower(zLine[0])=='g' && ToLower(zLine[1])=='o'\par
18253          && _all_whitespace(&zLine[2]) )\{\par
18254     return 1;  /* SQL Server */\par
18255   \}\par
18256   return 0;\par
18257 \}\par
}
}
{\xe \v line_is_complete\:shell.c}
{\xe \v shell.c\:line_is_complete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int line_is_complete (char *  {\i zSql}, int  {\i nSql}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18273 of file shell.c.}\par
{
References sqlite3_complete.}\par
{
Referenced by process_input().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18273                                                  \{\par
18274   int rc;\par
18275   if( zSql==0 ) return 1;\par
18276   zSql[nSql] = ';';\par
18277   zSql[nSql+1] = 0;\par
18278   rc = sqlite3_complete(zSql);\par
18279   zSql[nSql] = 0;\par
18280   return rc;\par
18281 \}\par
}
}
{\xe \v lintDotCommand\:shell.c}
{\xe \v shell.c\:lintDotCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lintDotCommand ({\b ShellState} *  {\i pState}, char **  {\i azArg}, int  {\i nArg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13996 of file shell.c.}\par
{
References lintFkeyIndexes(), raw_printf, sqlite3_strnicmp, SQLITE_ERROR, strlen30(), and usage().}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14000  \{\par
14001   int n;\par
14002   n = (nArg>=2 ? strlen30(azArg[1]) : 0);\par
14003   if( n<1 || sqlite3_strnicmp(azArg[1], "fkey-indexes", n) ) goto usage;\par
14004   return lintFkeyIndexes(pState, azArg, nArg);\par
14005 \par
14006  usage:\par
14007   raw_printf(stderr, "Usage %s sub-command ?switches...?\\n", azArg[0]);\par
14008   raw_printf(stderr, "Where sub-commands are:\\n");\par
14009   raw_printf(stderr, "    fkey-indexes\\n");\par
14010   return SQLITE_ERROR;\par
14011 \}\par
}
}
{\xe \v lintFkeyIndexes\:shell.c}
{\xe \v shell.c\:lintFkeyIndexes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int lintFkeyIndexes ({\b ShellState} *  {\i pState}, char **  {\i azArg}, int  {\i nArg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13820 of file shell.c.}\par
{
References ShellState::db, ShellState::out, raw_printf, shellFkeyCollateClause(), sqlite3_bind_int, sqlite3_column_text, sqlite3_create_function, sqlite3_errmsg, sqlite3_finalize, sqlite3_free, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_step, sqlite3_strglob, sqlite3_stricmp, sqlite3_strnicmp, SQLITE_ERROR, SQLITE_OK, SQLITE_ROW, SQLITE_UTF8, and strlen30().}\par
{
Referenced by lintDotCommand().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13824  \{\par
13825   sqlite3 *db = pState->db;       /* Database handle to query "main" db of */\par
13826   FILE *out = pState->out;        /* Stream to write non-error output to */\par
13827   int bVerbose = 0;               /* If -verbose is present */\par
13828   int bGroupByParent = 0;         /* If -groupbyparent is present */\par
13829   int i;                          /* To iterate through azArg[] */\par
13830   const char *zIndent = "";       /* How much to indent CREATE INDEX by */\par
13831   int rc;                         /* Return code */\par
13832   sqlite3_stmt *pSql = 0;         /* Compiled version of SQL statement below */\par
13833 \par
13834   /*\par
13835   ** This SELECT statement returns one row for each foreign key constraint\par
13836   ** in the schema of the main database. The column values are:\par
13837   **\par
13838   ** 0. The text of an SQL statement similar to:\par
13839   **\par
13840   **      "EXPLAIN QUERY PLAN SELECT 1 FROM child_table WHERE child_key=?"\par
13841   **\par
13842   **    This SELECT is similar to the one that the foreign keys implementation\par
13843   **    needs to run internally on child tables. If there is an index that can\par
13844   **    be used to optimize this query, then it can also be used by the FK\par
13845   **    implementation to optimize DELETE or UPDATE statements on the parent\par
13846   **    table.\par
13847   **\par
13848   ** 1. A GLOB pattern suitable for sqlite3_strglob(). If the plan output by\par
13849   **    the EXPLAIN QUERY PLAN command matches this pattern, then the schema\par
13850   **    contains an index that can be used to optimize the query.\par
13851   **\par
13852   ** 2. Human readable text that describes the child table and columns. e.g.\par
13853   **\par
13854   **       "child_table(child_key1, child_key2)"\par
13855   **\par
13856   ** 3. Human readable text that describes the parent table and columns. e.g.\par
13857   **\par
13858   **       "parent_table(parent_key1, parent_key2)"\par
13859   **\par
13860   ** 4. A full CREATE INDEX statement for an index that could be used to\par
13861   **    optimize DELETE or UPDATE statements on the parent table. e.g.\par
13862   **\par
13863   **       "CREATE INDEX child_table_child_key ON child_table(child_key)"\par
13864   **\par
13865   ** 5. The name of the parent table.\par
13866   **\par
13867   ** These six values are used by the C logic below to generate the report.\par
13868   */\par
13869   const char *zSql =\par
13870   "SELECT "\par
13871     "     'EXPLAIN QUERY PLAN SELECT 1 FROM ' || quote(s.name) || ' WHERE '"\par
13872     "  || group_concat(quote(s.name) || '.' || quote(f.[from]) || '=?' "\par
13873     "  || fkey_collate_clause("\par
13874     "       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),' AND ')"\par
13875     ", "\par
13876     "     'SEARCH TABLE ' || s.name || ' USING COVERING INDEX*('"\par
13877     "  || group_concat('*=?', ' AND ') || ')'"\par
13878     ", "\par
13879     "     s.name  || '(' || group_concat(f.[from],  ', ') || ')'"\par
13880     ", "\par
13881     "     f.[table] || '(' || group_concat(COALESCE(f.[to], p.[name])) || ')'"\par
13882     ", "\par
13883     "     'CREATE INDEX ' || quote(s.name ||'_'|| group_concat(f.[from], '_'))"\par
13884     "  || ' ON ' || quote(s.name) || '('"\par
13885     "  || group_concat(quote(f.[from]) ||"\par
13886     "        fkey_collate_clause("\par
13887     "          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), ', ')"\par
13888     "  || ');'"\par
13889     ", "\par
13890     "     f.[table] "\par
13891     "FROM sqlite_master AS s, pragma_foreign_key_list(s.name) AS f "\par
13892     "LEFT JOIN pragma_table_info AS p ON (pk-1=seq AND p.arg=f.[table]) "\par
13893     "GROUP BY s.name, f.id "\par
13894     "ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)"\par
13895   ;\par
13896   const char *zGlobIPK = "SEARCH TABLE * USING INTEGER PRIMARY KEY (rowid=?)";\par
13897 \par
13898   for(i=2; i<nArg; i++)\{\par
13899     int n = strlen30(azArg[i]);\par
13900     if( n>1 && sqlite3_strnicmp("-verbose", azArg[i], n)==0 )\{\par
13901       bVerbose = 1;\par
13902     \}\par
13903     else if( n>1 && sqlite3_strnicmp("-groupbyparent", azArg[i], n)==0 )\{\par
13904       bGroupByParent = 1;\par
13905       zIndent = "    ";\par
13906     \}\par
13907     else\{\par
13908       raw_printf(stderr, "Usage: %s %s ?-verbose? ?-groupbyparent?\\n",\par
13909           azArg[0], azArg[1]\par
13910       );\par
13911       return SQLITE_ERROR;\par
13912     \}\par
13913   \}\par
13914 \par
13915   /* Register the fkey_collate_clause() SQL function */\par
13916   rc = sqlite3_create_function(db, "fkey_collate_clause", 4, SQLITE_UTF8,\par
13917       0, shellFkeyCollateClause, 0, 0\par
13918   );\par
13919 \par
13920 \par
13921   if( rc==SQLITE_OK )\{\par
13922     rc = sqlite3_prepare_v2(db, zSql, -1, &pSql, 0);\par
13923   \}\par
13924   if( rc==SQLITE_OK )\{\par
13925     sqlite3_bind_int(pSql, 1, bGroupByParent);\par
13926   \}\par
13927 \par
13928   if( rc==SQLITE_OK )\{\par
13929     int rc2;\par
13930     char *zPrev = 0;\par
13931     while( SQLITE_ROW==sqlite3_step(pSql) )\{\par
13932       int res = -1;\par
13933       sqlite3_stmt *pExplain = 0;\par
13934       const char *zEQP = (const char*)sqlite3_column_text(pSql, 0);\par
13935       const char *zGlob = (const char*)sqlite3_column_text(pSql, 1);\par
13936       const char *zFrom = (const char*)sqlite3_column_text(pSql, 2);\par
13937       const char *zTarget = (const char*)sqlite3_column_text(pSql, 3);\par
13938       const char *zCI = (const char*)sqlite3_column_text(pSql, 4);\par
13939       const char *zParent = (const char*)sqlite3_column_text(pSql, 5);\par
13940 \par
13941       rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);\par
13942       if( rc!=SQLITE_OK ) break;\par
13943       if( SQLITE_ROW==sqlite3_step(pExplain) )\{\par
13944         const char *zPlan = (const char*)sqlite3_column_text(pExplain, 3);\par
13945         res = (\par
13946               0==sqlite3_strglob(zGlob, zPlan)\par
13947            || 0==sqlite3_strglob(zGlobIPK, zPlan)\par
13948         );\par
13949       \}\par
13950       rc = sqlite3_finalize(pExplain);\par
13951       if( rc!=SQLITE_OK ) break;\par
13952 \par
13953       if( res<0 )\{\par
13954         raw_printf(stderr, "Error: internal error");\par
13955         break;\par
13956       \}else\{\par
13957         if( bGroupByParent\par
13958         && (bVerbose || res==0)\par
13959         && (zPrev==0 || sqlite3_stricmp(zParent, zPrev))\par
13960         )\{\par
13961           raw_printf(out, "-- Parent table %s\\n", zParent);\par
13962           sqlite3_free(zPrev);\par
13963           zPrev = sqlite3_mprintf("%s", zParent);\par
13964         \}\par
13965 \par
13966         if( res==0 )\{\par
13967           raw_printf(out, "%s%s --> %s\\n", zIndent, zCI, zTarget);\par
13968         \}else if( bVerbose )\{\par
13969           raw_printf(out, "%s/* no extra indexes required for %s -> %s */\\n",\par
13970               zIndent, zFrom, zTarget\par
13971           );\par
13972         \}\par
13973       \}\par
13974     \}\par
13975     sqlite3_free(zPrev);\par
13976 \par
13977     if( rc!=SQLITE_OK )\{\par
13978       raw_printf(stderr, "%s\\n", sqlite3_errmsg(db));\par
13979     \}\par
13980 \par
13981     rc2 = sqlite3_finalize(pSql);\par
13982     if( rc==SQLITE_OK && rc2!=SQLITE_OK )\{\par
13983       rc = rc2;\par
13984       raw_printf(stderr, "%s\\n", sqlite3_errmsg(db));\par
13985     \}\par
13986   \}else\{\par
13987     raw_printf(stderr, "%s\\n", sqlite3_errmsg(db));\par
13988   \}\par
13989 \par
13990   return rc;\par
13991 \}\par
}
}
{\xe \v local_getline\:shell.c}
{\xe \v shell.c\:local_getline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* local_getline (char *  {\i zLine}, FILE *  {\i in}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 584 of file shell.c.}\par
{
References shell_out_of_memory(), sqlite3_free, and strlen30().}\par
{
Referenced by one_input_line().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   584                                                  \{\par
  585   int nLine = zLine==0 ? 0 : 100;\par
  586   int n = 0;\par
  587 \par
  588   while( 1 )\{\par
  589     if( n+100>nLine )\{\par
  590       nLine = nLine*2 + 100;\par
  591       zLine = realloc(zLine, nLine);\par
  592       if( zLine==0 ) shell_out_of_memory();\par
  593     \}\par
  594     if( fgets(&zLine[n], nLine - n, in)==0 )\{\par
  595       if( n==0 )\{\par
  596         free(zLine);\par
  597         return 0;\par
  598       \}\par
  599       zLine[n] = 0;\par
  600       break;\par
  601     \}\par
  602     while( zLine[n] ) n++;\par
  603     if( n>0 && zLine[n-1]=='\\n' )\{\par
  604       n--;\par
  605       if( n>0 && zLine[n-1]=='\\r' ) n--;\par
  606       zLine[n] = 0;\par
  607       break;\par
  608     \}\par
  609   \}\par
  610 #if defined(_WIN32) || defined(WIN32)\par
  611   /* For interactive input on Windows systems, translate the\par
  612   ** multi-byte characterset characters into UTF-8. */\par
  613   if( stdin_is_interactive && in==stdin )\{\par
  614     char *zTrans = sqlite3_win32_mbcs_to_utf8_v2(zLine, 0);\par
  615     if( zTrans )\{\par
  616       int nTrans = strlen30(zTrans)+1;\par
  617       if( nTrans>nLine )\{\par
  618         zLine = realloc(zLine, nTrans);\par
  619         if( zLine==0 ) shell_out_of_memory();\par
  620       \}\par
  621       memcpy(zLine, zTrans, nTrans);\par
  622       sqlite3_free(zTrans);\par
  623     \}\par
  624   \}\par
  625 #endif /* defined(_WIN32) || defined(WIN32) */\par
  626   return zLine;\par
  627 \}\par
}
}
{\xe \v lsModeFunc\:shell.c}
{\xe \v shell.c\:lsModeFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void lsModeFunc ({\b sqlite3_context} *  {\i context}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2537 of file shell.c.}\par
{
References sqlite3_result_text, sqlite3_value_int, and SQLITE_TRANSIENT.}\par
{
Referenced by sqlite3_fileio_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2541  \{\par
 2542   int i;\par
 2543   int iMode = sqlite3_value_int(argv[0]);\par
 2544   char z[16];\par
 2545   (void)argc;\par
 2546   if( S_ISLNK(iMode) )\{\par
 2547     z[0] = 'l';\par
 2548   \}else if( S_ISREG(iMode) )\{\par
 2549     z[0] = '-';\par
 2550   \}else if( S_ISDIR(iMode) )\{\par
 2551     z[0] = 'd';\par
 2552   \}else\{\par
 2553     z[0] = '?';\par
 2554   \}\par
 2555   for(i=0; i<3; i++)\{\par
 2556     int m = (iMode >> ((2-i)*3));\par
 2557     char *a = &z[1 + i*3];\par
 2558     a[0] = (m & 0x4) ? 'r' : '-';\par
 2559     a[1] = (m & 0x2) ? 'w' : '-';\par
 2560     a[2] = (m & 0x1) ? 'x' : '-';\par
 2561   \}\par
 2562   z[10] = '\\0';\par
 2563   sqlite3_result_text(context, z, -1, SQLITE_TRANSIENT);\par
 2564 \}\par
}
}
{\xe \v main\:shell.c}
{\xe \v shell.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int {\b SQLITE_CDECL} main (int  {\i argc}, char **  {\i argv})}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18665 of file shell.c.}\par
{
References ShellState::autoEQP, AUTOEQP_full, AUTOEQP_on, clearTempFile(), close_db(), cmdline_option_value(), ShellState::cMode, ShellState::colSeparator, main3::data, ShellState::db, do_meta_command(), ShellState::doXdgOpen, find_home_dir(), GETPID, ShellState::in, integerValue(), interrupt_handler(), isatty(), main_init(), ShellState::mode, MODE_Ascii, MODE_Column, MODE_Csv, MODE_Html, MODE_Line, MODE_List, MODE_Quote, ShellState::nullValue, open_db(), OPEN_DB_ZIPFILE, ShellState::openFlags, ShellState::openMode, ShellState::out, output_reset(), printBold(), process_input(), process_sqliterc(), raw_printf, ShellState::rowSeparator, ShellState::scanstatsOn, SEP_Record, SEP_Unit, session_close_all, set_table_name(), setBinaryMode, shell_exec(), SHELL_OPEN_APPENDVFS, SHELL_OPEN_DESERIALIZE, SHELL_OPEN_READONLY, SHELL_OPEN_ZIPFILE, shell_out_of_memory(), shell_read_history, shell_stifle_history, shell_write_history, ShellState::shellFlgs, ShellSetFlag, SHFLG_Backslash, SHFLG_Echo, SHFLG_Lookaside, SHFLG_Pagecache, ShellState::showHeader, sqlite3_appendvfs_init(), sqlite3_config(), sqlite3_free, sqlite3_initialize(), sqlite3_libversion, sqlite3_shutdown(), sqlite3_snprintf, sqlite3_sourceid, sqlite3_vfs_find, sqlite3_vfs_register, sqlite3MemTraceActivate(), SQLITE_CDECL, SQLITE_CONFIG_HEAP, SQLITE_CONFIG_LOOKASIDE, SQLITE_CONFIG_MMAP_SIZE, SQLITE_CONFIG_PAGECACHE, SQLITE_CONFIG_SORTERREF_SIZE, SQLITE_OPEN_NOFOLLOW, SQLITE_SOURCE_ID, ShellState::statsOn, strlen30(), ShellState::szMax, usage(), utf8_printf, verify_uninitialized(), ShellState::zDbFilename, and ShellState::zFreeOnClose.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18665                                             \{\par
18666 #else\par
18667 int SQLITE_CDECL wmain(int argc, wchar_t **wargv)\{\par
18668   char **argv;\par
18669 #endif\par
18670   char *zErrMsg = 0;\par
18671   ShellState data;\par
18672   const char *zInitFile = 0;\par
18673   int i;\par
18674   int rc = 0;\par
18675   int warnInmemoryDb = 0;\par
18676   int readStdin = 1;\par
18677   int nCmd = 0;\par
18678   char **azCmd = 0;\par
18679   const char *zVfs = 0;           /* Value of -vfs command-line option */\par
18680 #if !SQLITE_SHELL_IS_UTF8\par
18681   char **argvToFree = 0;\par
18682   int argcToFree = 0;\par
18683 #endif\par
18684 \par
18685   setBinaryMode(stdin, 0);\par
18686   setvbuf(stderr, 0, _IONBF, 0); /* Make sure stderr is unbuffered */\par
18687   stdin_is_interactive = isatty(0);\par
18688   stdout_is_console = isatty(1);\par
18689 \par
18690 #if !defined(_WIN32_WCE)\par
18691   if( getenv("SQLITE_DEBUG_BREAK") )\{\par
18692     if( isatty(0) && isatty(2) )\{\par
18693       fprintf(stderr,\par
18694           "attach debugger to process %d and press any key to continue.\\n",\par
18695           GETPID());\par
18696       fgetc(stdin);\par
18697     \}else\{\par
18698 #if defined(_WIN32) || defined(WIN32)\par
18699       DebugBreak();\par
18700 #elif defined(SIGTRAP)\par
18701       raise(SIGTRAP);\par
18702 #endif\par
18703     \}\par
18704   \}\par
18705 #endif\par
18706 \par
18707 #if USE_SYSTEM_SQLITE+0!=1\par
18708   if( strncmp(sqlite3_sourceid(),SQLITE_SOURCE_ID,60)!=0 )\{\par
18709     utf8_printf(stderr, "SQLite header and source version mismatch\\n%s\\n%s\\n",\par
18710             sqlite3_sourceid(), SQLITE_SOURCE_ID);\par
18711     exit(1);\par
18712   \}\par
18713 #endif\par
18714   main_init(&data);\par
18715 \par
18716   /* On Windows, we must translate command-line arguments into UTF-8.\par
18717   ** The SQLite memory allocator subsystem has to be enabled in order to\par
18718   ** do this.  But we want to run an sqlite3_shutdown() afterwards so that\par
18719   ** subsequent sqlite3_config() calls will work.  So copy all results into\par
18720   ** memory that does not come from the SQLite memory allocator.\par
18721   */\par
18722 #if !SQLITE_SHELL_IS_UTF8\par
18723   sqlite3_initialize();\par
18724   argvToFree = malloc(sizeof(argv[0])*argc*2);\par
18725   argcToFree = argc;\par
18726   argv = argvToFree + argc;\par
18727   if( argv==0 ) shell_out_of_memory();\par
18728   for(i=0; i<argc; i++)\{\par
18729     char *z = sqlite3_win32_unicode_to_utf8(wargv[i]);\par
18730     int n;\par
18731     if( z==0 ) shell_out_of_memory();\par
18732     n = (int)strlen(z);\par
18733     argv[i] = malloc( n+1 );\par
18734     if( argv[i]==0 ) shell_out_of_memory();\par
18735     memcpy(argv[i], z, n+1);\par
18736     argvToFree[i] = argv[i];\par
18737     sqlite3_free(z);\par
18738   \}\par
18739   sqlite3_shutdown();\par
18740 #endif\par
18741 \par
18742   assert( argc>=1 && argv && argv[0] );\par
18743   Argv0 = argv[0];\par
18744 \par
18745   /* Make sure we have a valid signal handler early, before anything\par
18746   ** else is done.\par
18747   */\par
18748 #ifdef SIGINT\par
18749   signal(SIGINT, interrupt_handler);\par
18750 #elif (defined(_WIN32) || defined(WIN32)) && !defined(_WIN32_WCE)\par
18751   SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);\par
18752 #endif\par
18753 \par
18754 #ifdef SQLITE_SHELL_DBNAME_PROC\par
18755   \{\par
18756     /* If the SQLITE_SHELL_DBNAME_PROC macro is defined, then it is the name\par
18757     ** of a C-function that will provide the name of the database file.  Use\par
18758     ** this compile-time option to embed this shell program in larger\par
18759     ** applications. */\par
18760     extern void SQLITE_SHELL_DBNAME_PROC(const char**);\par
18761     SQLITE_SHELL_DBNAME_PROC(&data.zDbFilename);\par
18762     warnInmemoryDb = 0;\par
18763   \}\par
18764 #endif\par
18765 \par
18766   /* Do an initial pass through the command-line argument to locate\par
18767   ** the name of the database file, the name of the initialization file,\par
18768   ** the size of the alternative malloc heap,\par
18769   ** and the first command to execute.\par
18770   */\par
18771   verify_uninitialized();\par
18772   for(i=1; i<argc; i++)\{\par
18773     char *z;\par
18774     z = argv[i];\par
18775     if( z[0]!='-' )\{\par
18776       if( data.zDbFilename==0 )\{\par
18777         data.zDbFilename = z;\par
18778       \}else\{\par
18779         /* Excesss arguments are interpreted as SQL (or dot-commands) and\par
18780         ** mean that nothing is read from stdin */\par
18781         readStdin = 0;\par
18782         nCmd++;\par
18783         azCmd = realloc(azCmd, sizeof(azCmd[0])*nCmd);\par
18784         if( azCmd==0 ) shell_out_of_memory();\par
18785         azCmd[nCmd-1] = z;\par
18786       \}\par
18787     \}\par
18788     if( z[1]=='-' ) z++;\par
18789     if( strcmp(z,"-separator")==0\par
18790      || strcmp(z,"-nullvalue")==0\par
18791      || strcmp(z,"-newline")==0\par
18792      || strcmp(z,"-cmd")==0\par
18793     )\{\par
18794       (void)cmdline_option_value(argc, argv, ++i);\par
18795     \}else if( strcmp(z,"-init")==0 )\{\par
18796       zInitFile = cmdline_option_value(argc, argv, ++i);\par
18797     \}else if( strcmp(z,"-batch")==0 )\{\par
18798       /* Need to check for batch mode here to so we can avoid printing\par
18799       ** informational messages (like from process_sqliterc) before\par
18800       ** we do the actual processing of arguments later in a second pass.\par
18801       */\par
18802       stdin_is_interactive = 0;\par
18803     \}else if( strcmp(z,"-heap")==0 )\{\par
18804 #if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5)\par
18805       const char *zSize;\par
18806       sqlite3_int64 szHeap;\par
18807 \par
18808       zSize = cmdline_option_value(argc, argv, ++i);\par
18809       szHeap = integerValue(zSize);\par
18810       if( szHeap>0x7fff0000 ) szHeap = 0x7fff0000;\par
18811       sqlite3_config(SQLITE_CONFIG_HEAP, malloc((int)szHeap), (int)szHeap, 64);\par
18812 #else\par
18813       (void)cmdline_option_value(argc, argv, ++i);\par
18814 #endif\par
18815     \}else if( strcmp(z,"-pagecache")==0 )\{\par
18816       int n, sz;\par
18817       sz = (int)integerValue(cmdline_option_value(argc,argv,++i));\par
18818       if( sz>70000 ) sz = 70000;\par
18819       if( sz<0 ) sz = 0;\par
18820       n = (int)integerValue(cmdline_option_value(argc,argv,++i));\par
18821       sqlite3_config(SQLITE_CONFIG_PAGECACHE,\par
18822                     (n>0 && sz>0) ? malloc(n*sz) : 0, sz, n);\par
18823       data.shellFlgs |= SHFLG_Pagecache;\par
18824     \}else if( strcmp(z,"-lookaside")==0 )\{\par
18825       int n, sz;\par
18826       sz = (int)integerValue(cmdline_option_value(argc,argv,++i));\par
18827       if( sz<0 ) sz = 0;\par
18828       n = (int)integerValue(cmdline_option_value(argc,argv,++i));\par
18829       if( n<0 ) n = 0;\par
18830       sqlite3_config(SQLITE_CONFIG_LOOKASIDE, sz, n);\par
18831       if( sz*n==0 ) data.shellFlgs &= ~SHFLG_Lookaside;\par
18832 #ifdef SQLITE_ENABLE_VFSTRACE\par
18833     \}else if( strcmp(z,"-vfstrace")==0 )\{\par
18834       extern int vfstrace_register(\par
18835          const char *zTraceName,\par
18836          const char *zOldVfsName,\par
18837          int (*xOut)(const char*,void*),\par
18838          void *pOutArg,\par
18839          int makeDefault\par
18840       );\par
18841       vfstrace_register("trace",0,(int(*)(const char*,void*))fputs,stderr,1);\par
18842 #endif\par
18843 #ifdef SQLITE_ENABLE_MULTIPLEX\par
18844     \}else if( strcmp(z,"-multiplex")==0 )\{\par
18845       extern int sqlite3_multiple_initialize(const char*,int);\par
18846       sqlite3_multiplex_initialize(0, 1);\par
18847 #endif\par
18848     \}else if( strcmp(z,"-mmap")==0 )\{\par
18849       sqlite3_int64 sz = integerValue(cmdline_option_value(argc,argv,++i));\par
18850       sqlite3_config(SQLITE_CONFIG_MMAP_SIZE, sz, sz);\par
18851 #ifdef SQLITE_ENABLE_SORTER_REFERENCES\par
18852     \}else if( strcmp(z,"-sorterref")==0 )\{\par
18853       sqlite3_int64 sz = integerValue(cmdline_option_value(argc,argv,++i));\par
18854       sqlite3_config(SQLITE_CONFIG_SORTERREF_SIZE, (int)sz);\par
18855 #endif\par
18856     \}else if( strcmp(z,"-vfs")==0 )\{\par
18857       zVfs = cmdline_option_value(argc, argv, ++i);\par
18858 #ifdef SQLITE_HAVE_ZLIB\par
18859     \}else if( strcmp(z,"-zip")==0 )\{\par
18860       data.openMode = SHELL_OPEN_ZIPFILE;\par
18861 #endif\par
18862     \}else if( strcmp(z,"-append")==0 )\{\par
18863       data.openMode = SHELL_OPEN_APPENDVFS;\par
18864 #ifdef SQLITE_ENABLE_DESERIALIZE\par
18865     \}else if( strcmp(z,"-deserialize")==0 )\{\par
18866       data.openMode = SHELL_OPEN_DESERIALIZE;\par
18867     \}else if( strcmp(z,"-maxsize")==0 && i+1<argc )\{\par
18868       data.szMax = integerValue(argv[++i]);\par
18869 #endif\par
18870     \}else if( strcmp(z,"-readonly")==0 )\{\par
18871       data.openMode = SHELL_OPEN_READONLY;\par
18872     \}else if( strcmp(z,"-nofollow")==0 )\{\par
18873       data.openFlags = SQLITE_OPEN_NOFOLLOW;\par
18874 #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)\par
18875     \}else if( strncmp(z, "-A",2)==0 )\{\par
18876       /* All remaining command-line arguments are passed to the ".archive"\par
18877       ** command, so ignore them */\par
18878       break;\par
18879 #endif\par
18880     \}else if( strcmp(z, "-memtrace")==0 )\{\par
18881       sqlite3MemTraceActivate(stderr);\par
18882     \}\par
18883   \}\par
18884   verify_uninitialized();\par
18885 \par
18886 \par
18887 #ifdef SQLITE_SHELL_INIT_PROC\par
18888   \{\par
18889     /* If the SQLITE_SHELL_INIT_PROC macro is defined, then it is the name\par
18890     ** of a C-function that will perform initialization actions on SQLite that\par
18891     ** occur just before or after sqlite3_initialize(). Use this compile-time\par
18892     ** option to embed this shell program in larger applications. */\par
18893     extern void SQLITE_SHELL_INIT_PROC(void);\par
18894     SQLITE_SHELL_INIT_PROC();\par
18895   \}\par
18896 #else\par
18897   /* All the sqlite3_config() calls have now been made. So it is safe\par
18898   ** to call sqlite3_initialize() and process any command line -vfs option. */\par
18899   sqlite3_initialize();\par
18900 #endif\par
18901 \par
18902   if( zVfs )\{\par
18903     sqlite3_vfs *pVfs = sqlite3_vfs_find(zVfs);\par
18904     if( pVfs )\{\par
18905       sqlite3_vfs_register(pVfs, 1);\par
18906     \}else\{\par
18907       utf8_printf(stderr, "no such VFS: \\"%s\\"\\n", argv[i]);\par
18908       exit(1);\par
18909     \}\par
18910   \}\par
18911 \par
18912   if( data.zDbFilename==0 )\{\par
18913 #ifndef SQLITE_OMIT_MEMORYDB\par
18914     data.zDbFilename = ":memory:";\par
18915     warnInmemoryDb = argc==1;\par
18916 #else\par
18917     utf8_printf(stderr,"%s: Error: no database filename specified\\n", Argv0);\par
18918     return 1;\par
18919 #endif\par
18920   \}\par
18921   data.out = stdout;\par
18922   sqlite3_appendvfs_init(0,0,0);\par
18923 \par
18924   /* Go ahead and open the database file if it already exists.  If the\par
18925   ** file does not exist, delay opening it.  This prevents empty database\par
18926   ** files from being created if a user mistypes the database name argument\par
18927   ** to the sqlite command-line tool.\par
18928   */\par
18929   if( access(data.zDbFilename, 0)==0 )\{\par
18930     open_db(&data, 0);\par
18931   \}\par
18932 \par
18933   /* Process the initialization file if there is one.  If no -init option\par
18934   ** is given on the command line, look for a file named ~/.sqliterc and\par
18935   ** try to process it.\par
18936   */\par
18937   process_sqliterc(&data,zInitFile);\par
18938 \par
18939   /* Make a second pass through the command-line argument and set\par
18940   ** options.  This second pass is delayed until after the initialization\par
18941   ** file is processed so that the command-line arguments will override\par
18942   ** settings in the initialization file.\par
18943   */\par
18944   for(i=1; i<argc; i++)\{\par
18945     char *z = argv[i];\par
18946     if( z[0]!='-' ) continue;\par
18947     if( z[1]=='-' )\{ z++; \}\par
18948     if( strcmp(z,"-init")==0 )\{\par
18949       i++;\par
18950     \}else if( strcmp(z,"-html")==0 )\{\par
18951       data.mode = MODE_Html;\par
18952     \}else if( strcmp(z,"-list")==0 )\{\par
18953       data.mode = MODE_List;\par
18954     \}else if( strcmp(z,"-quote")==0 )\{\par
18955       data.mode = MODE_Quote;\par
18956     \}else if( strcmp(z,"-line")==0 )\{\par
18957       data.mode = MODE_Line;\par
18958     \}else if( strcmp(z,"-column")==0 )\{\par
18959       data.mode = MODE_Column;\par
18960     \}else if( strcmp(z,"-csv")==0 )\{\par
18961       data.mode = MODE_Csv;\par
18962       memcpy(data.colSeparator,",",2);\par
18963 #ifdef SQLITE_HAVE_ZLIB\par
18964     \}else if( strcmp(z,"-zip")==0 )\{\par
18965       data.openMode = SHELL_OPEN_ZIPFILE;\par
18966 #endif\par
18967     \}else if( strcmp(z,"-append")==0 )\{\par
18968       data.openMode = SHELL_OPEN_APPENDVFS;\par
18969 #ifdef SQLITE_ENABLE_DESERIALIZE\par
18970     \}else if( strcmp(z,"-deserialize")==0 )\{\par
18971       data.openMode = SHELL_OPEN_DESERIALIZE;\par
18972     \}else if( strcmp(z,"-maxsize")==0 && i+1<argc )\{\par
18973       data.szMax = integerValue(argv[++i]);\par
18974 #endif\par
18975     \}else if( strcmp(z,"-readonly")==0 )\{\par
18976       data.openMode = SHELL_OPEN_READONLY;\par
18977     \}else if( strcmp(z,"-nofollow")==0 )\{\par
18978       data.openFlags |= SQLITE_OPEN_NOFOLLOW;\par
18979     \}else if( strcmp(z,"-ascii")==0 )\{\par
18980       data.mode = MODE_Ascii;\par
18981       sqlite3_snprintf(sizeof(data.colSeparator), data.colSeparator,\par
18982                        SEP_Unit);\par
18983       sqlite3_snprintf(sizeof(data.rowSeparator), data.rowSeparator,\par
18984                        SEP_Record);\par
18985     \}else if( strcmp(z,"-separator")==0 )\{\par
18986       sqlite3_snprintf(sizeof(data.colSeparator), data.colSeparator,\par
18987                        "%s",cmdline_option_value(argc,argv,++i));\par
18988     \}else if( strcmp(z,"-newline")==0 )\{\par
18989       sqlite3_snprintf(sizeof(data.rowSeparator), data.rowSeparator,\par
18990                        "%s",cmdline_option_value(argc,argv,++i));\par
18991     \}else if( strcmp(z,"-nullvalue")==0 )\{\par
18992       sqlite3_snprintf(sizeof(data.nullValue), data.nullValue,\par
18993                        "%s",cmdline_option_value(argc,argv,++i));\par
18994     \}else if( strcmp(z,"-header")==0 )\{\par
18995       data.showHeader = 1;\par
18996     \}else if( strcmp(z,"-noheader")==0 )\{\par
18997       data.showHeader = 0;\par
18998     \}else if( strcmp(z,"-echo")==0 )\{\par
18999       ShellSetFlag(&data, SHFLG_Echo);\par
19000     \}else if( strcmp(z,"-eqp")==0 )\{\par
19001       data.autoEQP = AUTOEQP_on;\par
19002     \}else if( strcmp(z,"-eqpfull")==0 )\{\par
19003       data.autoEQP = AUTOEQP_full;\par
19004     \}else if( strcmp(z,"-stats")==0 )\{\par
19005       data.statsOn = 1;\par
19006     \}else if( strcmp(z,"-scanstats")==0 )\{\par
19007       data.scanstatsOn = 1;\par
19008     \}else if( strcmp(z,"-backslash")==0 )\{\par
19009       /* Undocumented command-line option: -backslash\par
19010       ** Causes C-style backslash escapes to be evaluated in SQL statements\par
19011       ** prior to sending the SQL into SQLite.  Useful for injecting\par
19012       ** crazy bytes in the middle of SQL statements for testing and debugging.\par
19013       */\par
19014       ShellSetFlag(&data, SHFLG_Backslash);\par
19015     \}else if( strcmp(z,"-bail")==0 )\{\par
19016       bail_on_error = 1;\par
19017     \}else if( strcmp(z,"-version")==0 )\{\par
19018       printf("%s %s\\n", sqlite3_libversion(), sqlite3_sourceid());\par
19019       return 0;\par
19020     \}else if( strcmp(z,"-interactive")==0 )\{\par
19021       stdin_is_interactive = 1;\par
19022     \}else if( strcmp(z,"-batch")==0 )\{\par
19023       stdin_is_interactive = 0;\par
19024     \}else if( strcmp(z,"-heap")==0 )\{\par
19025       i++;\par
19026     \}else if( strcmp(z,"-pagecache")==0 )\{\par
19027       i+=2;\par
19028     \}else if( strcmp(z,"-lookaside")==0 )\{\par
19029       i+=2;\par
19030     \}else if( strcmp(z,"-mmap")==0 )\{\par
19031       i++;\par
19032     \}else if( strcmp(z,"-memtrace")==0 )\{\par
19033       i++;\par
19034 #ifdef SQLITE_ENABLE_SORTER_REFERENCES\par
19035     \}else if( strcmp(z,"-sorterref")==0 )\{\par
19036       i++;\par
19037 #endif\par
19038     \}else if( strcmp(z,"-vfs")==0 )\{\par
19039       i++;\par
19040 #ifdef SQLITE_ENABLE_VFSTRACE\par
19041     \}else if( strcmp(z,"-vfstrace")==0 )\{\par
19042       i++;\par
19043 #endif\par
19044 #ifdef SQLITE_ENABLE_MULTIPLEX\par
19045     \}else if( strcmp(z,"-multiplex")==0 )\{\par
19046       i++;\par
19047 #endif\par
19048     \}else if( strcmp(z,"-help")==0 )\{\par
19049       usage(1);\par
19050     \}else if( strcmp(z,"-cmd")==0 )\{\par
19051       /* Run commands that follow -cmd first and separately from commands\par
19052       ** that simply appear on the command-line.  This seems goofy.  It would\par
19053       ** be better if all commands ran in the order that they appear.  But\par
19054       ** we retain the goofy behavior for historical compatibility. */\par
19055       if( i==argc-1 ) break;\par
19056       z = cmdline_option_value(argc,argv,++i);\par
19057       if( z[0]=='.' )\{\par
19058         rc = do_meta_command(z, &data);\par
19059         if( rc && bail_on_error ) return rc==2 ? 0 : rc;\par
19060       \}else\{\par
19061         open_db(&data, 0);\par
19062         rc = shell_exec(&data, z, &zErrMsg);\par
19063         if( zErrMsg!=0 )\{\par
19064           utf8_printf(stderr,"Error: %s\\n", zErrMsg);\par
19065           if( bail_on_error ) return rc!=0 ? rc : 1;\par
19066         \}else if( rc!=0 )\{\par
19067           utf8_printf(stderr,"Error: unable to process SQL \\"%s\\"\\n", z);\par
19068           if( bail_on_error ) return rc;\par
19069         \}\par
19070       \}\par
19071 #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)\par
19072     \}else if( strncmp(z, "-A", 2)==0 )\{\par
19073       if( nCmd>0 )\{\par
19074         utf8_printf(stderr, "Error: cannot mix regular SQL or dot-commands"\par
19075                             " with \\"%s\\"\\n", z);\par
19076         return 1;\par
19077       \}\par
19078       open_db(&data, OPEN_DB_ZIPFILE);\par
19079       if( z[2] )\{\par
19080         argv[i] = &z[2];\par
19081         arDotCommand(&data, 1, argv+(i-1), argc-(i-1));\par
19082       \}else\{\par
19083         arDotCommand(&data, 1, argv+i, argc-i);\par
19084       \}\par
19085       readStdin = 0;\par
19086       break;\par
19087 #endif\par
19088     \}else\{\par
19089       utf8_printf(stderr,"%s: Error: unknown option: %s\\n", Argv0, z);\par
19090       raw_printf(stderr,"Use -help for a list of options.\\n");\par
19091       return 1;\par
19092     \}\par
19093     data.cMode = data.mode;\par
19094   \}\par
19095 \par
19096   if( !readStdin )\{\par
19097     /* Run all arguments that do not begin with '-' as if they were separate\par
19098     ** command-line inputs, except for the argToSkip argument which contains\par
19099     ** the database filename.\par
19100     */\par
19101     for(i=0; i<nCmd; i++)\{\par
19102       if( azCmd[i][0]=='.' )\{\par
19103         rc = do_meta_command(azCmd[i], &data);\par
19104         if( rc ) return rc==2 ? 0 : rc;\par
19105       \}else\{\par
19106         open_db(&data, 0);\par
19107         rc = shell_exec(&data, azCmd[i], &zErrMsg);\par
19108         if( zErrMsg!=0 )\{\par
19109           utf8_printf(stderr,"Error: %s\\n", zErrMsg);\par
19110           return rc!=0 ? rc : 1;\par
19111         \}else if( rc!=0 )\{\par
19112           utf8_printf(stderr,"Error: unable to process SQL: %s\\n", azCmd[i]);\par
19113           return rc;\par
19114         \}\par
19115       \}\par
19116     \}\par
19117     free(azCmd);\par
19118   \}else\{\par
19119     /* Run commands received from standard input\par
19120     */\par
19121     if( stdin_is_interactive )\{\par
19122       char *zHome;\par
19123       char *zHistory;\par
19124       int nHistory;\par
19125       printf(\par
19126         "SQLite version %s %.19s\\n" /*extra-version-info*/\par
19127         "Enter \\".help\\" for usage hints.\\n",\par
19128         sqlite3_libversion(), sqlite3_sourceid()\par
19129       );\par
19130       if( warnInmemoryDb )\{\par
19131         printf("Connected to a ");\par
19132         printBold("transient in-memory database");\par
19133         printf(".\\nUse \\".open FILENAME\\" to reopen on a "\par
19134                "persistent database.\\n");\par
19135       \}\par
19136       zHistory = getenv("SQLITE_HISTORY");\par
19137       if( zHistory )\{\par
19138         zHistory = strdup(zHistory);\par
19139       \}else if( (zHome = find_home_dir(0))!=0 )\{\par
19140         nHistory = strlen30(zHome) + 20;\par
19141         if( (zHistory = malloc(nHistory))!=0 )\{\par
19142           sqlite3_snprintf(nHistory, zHistory,"%s/.sqlite_history", zHome);\par
19143         \}\par
19144       \}\par
19145       if( zHistory )\{ shell_read_history(zHistory); \}\par
19146 #if HAVE_READLINE || HAVE_EDITLINE\par
19147       rl_attempted_completion_function = readline_completion;\par
19148 #elif HAVE_LINENOISE\par
19149       linenoiseSetCompletionCallback(linenoise_completion);\par
19150 #endif\par
19151       data.in = 0;\par
19152       rc = process_input(&data);\par
19153       if( zHistory )\{\par
19154         shell_stifle_history(2000);\par
19155         shell_write_history(zHistory);\par
19156         free(zHistory);\par
19157       \}\par
19158     \}else\{\par
19159       data.in = stdin;\par
19160       rc = process_input(&data);\par
19161     \}\par
19162   \}\par
19163   set_table_name(&data, 0);\par
19164   if( data.db )\{\par
19165     session_close_all(&data);\par
19166     close_db(data.db);\par
19167   \}\par
19168   sqlite3_free(data.zFreeOnClose);\par
19169   find_home_dir(1);\par
19170   output_reset(&data);\par
19171   data.doXdgOpen = 0;\par
19172   clearTempFile(&data);\par
19173 #if !SQLITE_SHELL_IS_UTF8\par
19174   for(i=0; i<argcToFree; i++) free(argvToFree[i]);\par
19175   free(argvToFree);\par
19176 #endif\par
19177   /* Clear the global data structure so that valgrind will detect memory\par
19178   ** leaks */\par
19179   memset(&data, 0, sizeof(data));\par
19180   return rc;\par
19181 \}\par
}
}
{\xe \v main_init\:shell.c}
{\xe \v shell.c\:main_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void main_init ({\b ShellState} *  {\i data}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18607 of file shell.c.}\par
{
References ShellState::autoExplain, ShellState::cMode, ShellState::colSeparator, ShellState::mode, MODE_List, ShellState::normalMode, printBold(), ShellState::rowSeparator, SEP_Column, SEP_Row, ShellState::shellFlgs, shellLog(), SHFLG_Lookaside, ShellState::showHeader, sqlite3_config(), sqlite3_snprintf, SQLITE_CONFIG_LOG, SQLITE_CONFIG_MULTITHREAD, SQLITE_CONFIG_URI, and verify_uninitialized().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18607                                         \{\par
18608   memset(data, 0, sizeof(*data));\par
18609   data->normalMode = data->cMode = data->mode = MODE_List;\par
18610   data->autoExplain = 1;\par
18611   memcpy(data->colSeparator,SEP_Column, 2);\par
18612   memcpy(data->rowSeparator,SEP_Row, 2);\par
18613   data->showHeader = 0;\par
18614   data->shellFlgs = SHFLG_Lookaside;\par
18615   verify_uninitialized();\par
18616   sqlite3_config(SQLITE_CONFIG_URI, 1);\par
18617   sqlite3_config(SQLITE_CONFIG_LOG, shellLog, data);\par
18618   sqlite3_config(SQLITE_CONFIG_MULTITHREAD);\par
18619   sqlite3_snprintf(sizeof(mainPrompt), mainPrompt,"sqlite> ");\par
18620   sqlite3_snprintf(sizeof(continuePrompt), continuePrompt,"   ...> ");\par
18621 \}\par
}
}
{\xe \v makeDirectory\:shell.c}
{\xe \v shell.c\:makeDirectory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int makeDirectory (const char *  {\i zFile}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2335 of file shell.c.}\par
{
References fileStat(), sqlite3_free, sqlite3_mprintf, SQLITE_ERROR, SQLITE_NOMEM, and SQLITE_OK.}\par
{
Referenced by writefileFunc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2337  \{\par
 2338   char *zCopy = sqlite3_mprintf("%s", zFile);\par
 2339   int rc = SQLITE_OK;\par
 2340 \par
 2341   if( zCopy==0 )\{\par
 2342     rc = SQLITE_NOMEM;\par
 2343   \}else\{\par
 2344     int nCopy = (int)strlen(zCopy);\par
 2345     int i = 1;\par
 2346 \par
 2347     while( rc==SQLITE_OK )\{\par
 2348       struct stat sStat;\par
 2349       int rc2;\par
 2350 \par
 2351       for(; zCopy[i]!='/' && i<nCopy; i++);\par
 2352       if( i==nCopy ) break;\par
 2353       zCopy[i] = '\\0';\par
 2354 \par
 2355       rc2 = fileStat(zCopy, &sStat);\par
 2356       if( rc2!=0 )\{\par
 2357         if( mkdir(zCopy, 0777) ) rc = SQLITE_ERROR;\par
 2358       \}else\{\par
 2359         if( !S_ISDIR(sStat.st_mode) ) rc = SQLITE_ERROR;\par
 2360       \}\par
 2361       zCopy[i] = '/';\par
 2362       i++;\par
 2363     \}\par
 2364 \par
 2365     sqlite3_free(zCopy);\par
 2366   \}\par
 2367 \par
 2368   return rc;\par
 2369 \}\par
}
}
{\xe \v memtraceFree\:shell.c}
{\xe \v shell.c\:memtraceFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void memtraceFree (void *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4145 of file shell.c.}\par
{
References sqlite3_mem_methods::xFree, and sqlite3_mem_methods::xSize.}\par
{
Referenced by memtraceRealloc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4145                                  \{\par
 4146   if( p==0 ) return;\par
 4147   if( memtraceOut )\{\par
 4148     fprintf(memtraceOut, "MEMTRACE: free %d bytes\\n", memtraceBase.xSize(p));\par
 4149   \}\par
 4150   memtraceBase.xFree(p);\par
 4151 \}\par
}
}
{\xe \v memtraceInit\:shell.c}
{\xe \v shell.c\:memtraceInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int memtraceInit (void *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4170 of file shell.c.}\par
{
References sqlite3_mem_methods::xInit.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4170                                 \{\par
 4171   return memtraceBase.xInit(p);\par
 4172 \}\par
}
}
{\xe \v memtraceMalloc\:shell.c}
{\xe \v shell.c\:memtraceMalloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void* memtraceMalloc (int  {\i n}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4138 of file shell.c.}\par
{
References sqlite3_mem_methods::xMalloc, and sqlite3_mem_methods::xRoundup.}\par
{
Referenced by memtraceRealloc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4138                                   \{\par
 4139   if( memtraceOut )\{\par
 4140     fprintf(memtraceOut, "MEMTRACE: allocate %d bytes\\n", \par
 4141             memtraceBase.xRoundup(n));\par
 4142   \}\par
 4143   return memtraceBase.xMalloc(n);\par
 4144 \}\par
}
}
{\xe \v memtraceRealloc\:shell.c}
{\xe \v shell.c\:memtraceRealloc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void* memtraceRealloc (void *  {\i p}, int  {\i n}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4152 of file shell.c.}\par
{
References memtraceFree(), memtraceMalloc(), sqlite3_mem_methods::xRealloc, sqlite3_mem_methods::xRoundup, and sqlite3_mem_methods::xSize.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4152                                             \{\par
 4153   if( p==0 ) return memtraceMalloc(n);\par
 4154   if( n==0 )\{\par
 4155     memtraceFree(p);\par
 4156     return 0;\par
 4157   \}\par
 4158   if( memtraceOut )\{\par
 4159     fprintf(memtraceOut, "MEMTRACE: resize %d -> %d bytes\\n",\par
 4160             memtraceBase.xSize(p), memtraceBase.xRoundup(n));\par
 4161   \}\par
 4162   return memtraceBase.xRealloc(p, n);\par
 4163 \}\par
}
}
{\xe \v memtraceRoundup\:shell.c}
{\xe \v shell.c\:memtraceRoundup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int memtraceRoundup (int  {\i n}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4167 of file shell.c.}\par
{
References sqlite3_mem_methods::xRoundup.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4167                                  \{\par
 4168   return memtraceBase.xRoundup(n);\par
 4169 \}\par
}
}
{\xe \v memtraceShutdown\:shell.c}
{\xe \v shell.c\:memtraceShutdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void memtraceShutdown (void *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4173 of file shell.c.}\par
{
References sqlite3_mem_methods::xShutdown.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4173                                      \{\par
 4174   memtraceBase.xShutdown(p);\par
 4175 \}\par
}
}
{\xe \v memtraceSize\:shell.c}
{\xe \v shell.c\:memtraceSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int memtraceSize (void *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4164 of file shell.c.}\par
{
References sqlite3_mem_methods::xSize.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4164                                 \{\par
 4165   return memtraceBase.xSize(p);\par
 4166 \}\par
}
}
{\xe \v newTempFile\:shell.c}
{\xe \v shell.c\:newTempFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void newTempFile ({\b ShellState} *  {\i p}, const char *  {\i zSuffix}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13743 of file shell.c.}\par
{
References clearTempFile(), ShellState::db, raw_printf, sqlite3_file_control, sqlite3_free, sqlite3_mprintf, sqlite3_randomness, SQLITE_FCNTL_TEMPFILENAME, and ShellState::zTempFile.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13743                                                            \{\par
13744   clearTempFile(p);\par
13745   sqlite3_free(p->zTempFile);\par
13746   p->zTempFile = 0;\par
13747   if( p->db )\{\par
13748     sqlite3_file_control(p->db, 0, SQLITE_FCNTL_TEMPFILENAME, &p->zTempFile);\par
13749   \}\par
13750   if( p->zTempFile==0 )\{\par
13751     sqlite3_uint64 r;\par
13752     sqlite3_randomness(sizeof(r), &r);\par
13753     p->zTempFile = sqlite3_mprintf("temp%llx.%s", r, zSuffix);\par
13754   \}else\{\par
13755     p->zTempFile = sqlite3_mprintf("%z.%s", p->zTempFile, zSuffix);\par
13756   \}\par
13757   if( p->zTempFile==0 )\{\par
13758     raw_printf(stderr, "out of memory\\n");\par
13759     exit(1);\par
13760   \}\par
13761 \}\par
}
}
{\xe \v one_input_line\:shell.c}
{\xe \v shell.c\:one_input_line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* one_input_line (FILE *  {\i in}, char *  {\i zPrior}, int  {\i isContinuation}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 643 of file shell.c.}\par
{
References continuePrompt, local_getline(), and mainPrompt.}\par
{
Referenced by process_input().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   643                                                                        \{\par
  644   char *zPrompt;\par
  645   char *zResult;\par
  646   if( in!=0 )\{\par
  647     zResult = local_getline(zPrior, in);\par
  648   \}else\{\par
  649     zPrompt = isContinuation ? continuePrompt : mainPrompt;\par
  650 #if SHELL_USE_LOCAL_GETLINE\par
  651     printf("%s", zPrompt);\par
  652     fflush(stdout);\par
  653     zResult = local_getline(zPrior, stdin);\par
  654 #else\par
  655     free(zPrior);\par
  656     zResult = shell_readline(zPrompt);\par
  657     if( zResult && *zResult ) shell_add_history(zResult);\par
  658 #endif\par
  659   \}\par
  660   return zResult;\par
  661 \}\par
}
}
{\xe \v open_db\:shell.c}
{\xe \v shell.c\:open_db}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void open_db ({\b ShellState} *  {\i p}, int  {\i openFlags}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12687 of file shell.c.}\par
{
References ShellState::db, deduceDatabaseType(), editFunc(), OPEN_DB_KEEPALIVE, OPEN_DB_ZIPFILE, ShellState::openFlags, ShellState::openMode, readFile(), SHELL_OPEN_APPENDVFS, SHELL_OPEN_DESERIALIZE, SHELL_OPEN_HEXDB, SHELL_OPEN_NORMAL, SHELL_OPEN_READONLY, SHELL_OPEN_UNSPEC, SHELL_OPEN_ZIPFILE, shellAddSchemaName(), shellEscapeCrnl(), shellIdQuote(), shellInt32(), shellModuleSchema(), shellPutsFunc(), sqlite3_completion_init(), sqlite3_create_function, sqlite3_deserialize(), sqlite3_enable_load_extension(), sqlite3_errcode, sqlite3_errmsg, sqlite3_exec, sqlite3_file_control, sqlite3_fileio_init(), sqlite3_free, sqlite3_mprintf, sqlite3_open, sqlite3_open_v2, sqlite3_shathree_init(), SQLITE_DESERIALIZE_FREEONCLOSE, SQLITE_DESERIALIZE_RESIZEABLE, SQLITE_FCNTL_SIZE_LIMIT, SQLITE_OK, SQLITE_OPEN_CREATE, SQLITE_OPEN_READONLY, SQLITE_OPEN_READWRITE, SQLITE_UTF8, ShellState::szMax, utf8_printf, and ShellState::zDbFilename.}\par
{
Referenced by do_meta_command(), main(), runOneSqlLine(), and shell_dbinfo_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12687                                                  \{\par
12688   if( p->db==0 )\{\par
12689     if( p->openMode==SHELL_OPEN_UNSPEC )\{\par
12690       if( p->zDbFilename==0 || p->zDbFilename[0]==0 )\{\par
12691         p->openMode = SHELL_OPEN_NORMAL;\par
12692       \}else\{\par
12693         p->openMode = (u8)deduceDatabaseType(p->zDbFilename, \par
12694                              (openFlags & OPEN_DB_ZIPFILE)!=0);\par
12695       \}\par
12696     \}\par
12697     switch( p->openMode )\{\par
12698       case SHELL_OPEN_APPENDVFS: \{\par
12699         sqlite3_open_v2(p->zDbFilename, &p->db, \par
12700            SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|p->openFlags, "apndvfs");\par
12701         break;\par
12702       \}\par
12703       case SHELL_OPEN_HEXDB:\par
12704       case SHELL_OPEN_DESERIALIZE: \{\par
12705         sqlite3_open(0, &p->db);\par
12706         break;\par
12707       \}\par
12708       case SHELL_OPEN_ZIPFILE: \{\par
12709         sqlite3_open(":memory:", &p->db);\par
12710         break;\par
12711       \}\par
12712       case SHELL_OPEN_READONLY: \{\par
12713         sqlite3_open_v2(p->zDbFilename, &p->db,\par
12714             SQLITE_OPEN_READONLY|p->openFlags, 0);\par
12715         break;\par
12716       \}\par
12717       case SHELL_OPEN_UNSPEC:\par
12718       case SHELL_OPEN_NORMAL: \{\par
12719         sqlite3_open_v2(p->zDbFilename, &p->db,\par
12720            SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|p->openFlags, 0);\par
12721         break;\par
12722       \}\par
12723     \}\par
12724     globalDb = p->db;\par
12725     if( p->db==0 || SQLITE_OK!=sqlite3_errcode(p->db) )\{\par
12726       utf8_printf(stderr,"Error: unable to open database \\"%s\\": %s\\n",\par
12727           p->zDbFilename, sqlite3_errmsg(p->db));\par
12728       if( openFlags & OPEN_DB_KEEPALIVE )\{\par
12729         sqlite3_open(":memory:", &p->db);\par
12730         return;\par
12731       \}\par
12732       exit(1);\par
12733     \}\par
12734 #ifndef SQLITE_OMIT_LOAD_EXTENSION\par
12735     sqlite3_enable_load_extension(p->db, 1);\par
12736 #endif\par
12737     sqlite3_fileio_init(p->db, 0, 0);\par
12738     sqlite3_shathree_init(p->db, 0, 0);\par
12739     sqlite3_completion_init(p->db, 0, 0);\par
12740 #if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB)\par
12741     sqlite3_dbdata_init(p->db, 0, 0);\par
12742 #endif\par
12743 #ifdef SQLITE_HAVE_ZLIB\par
12744     sqlite3_zipfile_init(p->db, 0, 0);\par
12745     sqlite3_sqlar_init(p->db, 0, 0);\par
12746 #endif\par
12747     sqlite3_create_function(p->db, "shell_add_schema", 3, SQLITE_UTF8, 0,\par
12748                             shellAddSchemaName, 0, 0);\par
12749     sqlite3_create_function(p->db, "shell_module_schema", 1, SQLITE_UTF8, 0,\par
12750                             shellModuleSchema, 0, 0);\par
12751     sqlite3_create_function(p->db, "shell_putsnl", 1, SQLITE_UTF8, p,\par
12752                             shellPutsFunc, 0, 0);\par
12753     sqlite3_create_function(p->db, "shell_escape_crnl", 1, SQLITE_UTF8, 0,\par
12754                             shellEscapeCrnl, 0, 0);\par
12755     sqlite3_create_function(p->db, "shell_int32", 2, SQLITE_UTF8, 0,\par
12756                             shellInt32, 0, 0);\par
12757     sqlite3_create_function(p->db, "shell_idquote", 1, SQLITE_UTF8, 0,\par
12758                             shellIdQuote, 0, 0);\par
12759 #ifndef SQLITE_NOHAVE_SYSTEM\par
12760     sqlite3_create_function(p->db, "edit", 1, SQLITE_UTF8, 0,\par
12761                             editFunc, 0, 0);\par
12762     sqlite3_create_function(p->db, "edit", 2, SQLITE_UTF8, 0,\par
12763                             editFunc, 0, 0);\par
12764 #endif\par
12765     if( p->openMode==SHELL_OPEN_ZIPFILE )\{\par
12766       char *zSql = sqlite3_mprintf(\par
12767          "CREATE VIRTUAL TABLE zip USING zipfile(%Q);", p->zDbFilename);\par
12768       sqlite3_exec(p->db, zSql, 0, 0, 0);\par
12769       sqlite3_free(zSql);\par
12770     \}\par
12771 #ifdef SQLITE_ENABLE_DESERIALIZE\par
12772     else\par
12773     if( p->openMode==SHELL_OPEN_DESERIALIZE || p->openMode==SHELL_OPEN_HEXDB )\{\par
12774       int rc;\par
12775       int nData = 0;\par
12776       unsigned char *aData;\par
12777       if( p->openMode==SHELL_OPEN_DESERIALIZE )\{\par
12778         aData = (unsigned char*)readFile(p->zDbFilename, &nData);\par
12779       \}else\{\par
12780         aData = readHexDb(p, &nData);\par
12781         if( aData==0 )\{\par
12782           return;\par
12783         \}\par
12784       \}\par
12785       rc = sqlite3_deserialize(p->db, "main", aData, nData, nData,\par
12786                    SQLITE_DESERIALIZE_RESIZEABLE |\par
12787                    SQLITE_DESERIALIZE_FREEONCLOSE);\par
12788       if( rc )\{\par
12789         utf8_printf(stderr, "Error: sqlite3_deserialize() returns %d\\n", rc);\par
12790       \}\par
12791       if( p->szMax>0 )\{\par
12792         sqlite3_file_control(p->db, "main", SQLITE_FCNTL_SIZE_LIMIT, &p->szMax);\par
12793       \}\par
12794     \}\par
12795 #endif\par
12796   \}\par
12797 \}\par
}
}
{\xe \v optionMatch\:shell.c}
{\xe \v shell.c\:optionMatch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int optionMatch (const char *  {\i zStr}, const char *  {\i zOpt}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13706 of file shell.c.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13706                                                           \{\par
13707   if( zStr[0]!='-' ) return 0;\par
13708   zStr++;\par
13709   if( zStr[0]=='-' ) zStr++;\par
13710   return strcmp(zStr, zOpt)==0;\par
13711 \}\par
}
}
{\xe \v output_c_string\:shell.c}
{\xe \v shell.c\:output_c_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void output_c_string (FILE *  {\i out}, const char *  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10051 of file shell.c.}\par
{
References raw_printf.}\par
{
Referenced by do_meta_command(), shell_callback(), and shellAuth().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10051                                                      \{\par
10052   unsigned int c;\par
10053   fputc('"', out);\par
10054   while( (c = *(z++))!=0 )\{\par
10055     if( c=='\\\\' )\{\par
10056       fputc(c, out);\par
10057       fputc(c, out);\par
10058     \}else if( c=='"' )\{\par
10059       fputc('\\\\', out);\par
10060       fputc('"', out);\par
10061     \}else if( c=='\\t' )\{\par
10062       fputc('\\\\', out);\par
10063       fputc('t', out);\par
10064     \}else if( c=='\\n' )\{\par
10065       fputc('\\\\', out);\par
10066       fputc('n', out);\par
10067     \}else if( c=='\\r' )\{\par
10068       fputc('\\\\', out);\par
10069       fputc('r', out);\par
10070     \}else if( !isprint(c&0xff) )\{\par
10071       raw_printf(out, "\\\\%03o", c&0xff);\par
10072     \}else\{\par
10073       fputc(c, out);\par
10074     \}\par
10075   \}\par
10076   fputc('"', out);\par
10077 \}\par
}
}
{\xe \v output_csv\:shell.c}
{\xe \v shell.c\:output_csv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void output_csv ({\b ShellState} *  {\i p}, const char *  {\i z}, int  {\i bSep}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10143 of file shell.c.}\par
{
References ShellState::colSeparator, ShellState::nullValue, ShellState::out, sqlite3_free, sqlite3_mprintf, strlen30(), and utf8_printf.}\par
{
Referenced by shell_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10143                                                               \{\par
10144   FILE *out = p->out;\par
10145   if( z==0 )\{\par
10146     utf8_printf(out,"%s",p->nullValue);\par
10147   \}else\{\par
10148     int i;\par
10149     int nSep = strlen30(p->colSeparator);\par
10150     for(i=0; z[i]; i++)\{\par
10151       if( needCsvQuote[((unsigned char*)z)[i]]\par
10152          || (z[i]==p->colSeparator[0] &&\par
10153              (nSep==1 || memcmp(z, p->colSeparator, nSep)==0)) )\{\par
10154         i = 0;\par
10155         break;\par
10156       \}\par
10157     \}\par
10158     if( i==0 )\{\par
10159       char *zQuoted = sqlite3_mprintf("\\"%w\\"", z);\par
10160       utf8_printf(out, "%s", zQuoted);\par
10161       sqlite3_free(zQuoted);\par
10162     \}else\{\par
10163       utf8_printf(out, "%s", z);\par
10164     \}\par
10165   \}\par
10166   if( bSep )\{\par
10167     utf8_printf(p->out, "%s", p->colSeparator);\par
10168   \}\par
10169 \}\par
}
}
{\xe \v output_file_close\:shell.c}
{\xe \v shell.c\:output_file_close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void output_file_close (FILE *  {\i f}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12971 of file shell.c.}\par
{
Referenced by do_meta_command(), and output_reset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12971                                       \{\par
12972   if( f && f!=stdout && f!=stderr ) fclose(f);\par
12973 \}\par
}
}
{\xe \v output_file_open\:shell.c}
{\xe \v shell.c\:output_file_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static FILE* output_file_open (const char *  {\i zFile}, int  {\i bTextMode}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12980 of file shell.c.}\par
{
References utf8_printf.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12980                                                                \{\par
12981   FILE *f;\par
12982   if( strcmp(zFile,"stdout")==0 )\{\par
12983     f = stdout;\par
12984   \}else if( strcmp(zFile, "stderr")==0 )\{\par
12985     f = stderr;\par
12986   \}else if( strcmp(zFile, "off")==0 )\{\par
12987     f = 0;\par
12988   \}else\{\par
12989     f = fopen(zFile, bTextMode ? "w" : "wb");\par
12990     if( f==0 )\{\par
12991       utf8_printf(stderr, "Error: cannot open \\"%s\\"\\n", zFile);\par
12992     \}\par
12993   \}\par
12994   return f;\par
12995 \}\par
}
}
{\xe \v output_hex_blob\:shell.c}
{\xe \v shell.c\:output_hex_blob}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void output_hex_blob (FILE *  {\i out}, const void *  {\i pBlob}, int  {\i nBlob}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9917 of file shell.c.}\par
{
References raw_printf.}\par
{
Referenced by shell_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9917                                                                     \{\par
 9918   int i;\par
 9919   char *zBlob = (char *)pBlob;\par
 9920   raw_printf(out,"X'");\par
 9921   for(i=0; i<nBlob; i++)\{ raw_printf(out,"%02x",zBlob[i]&0xff); \}\par
 9922   raw_printf(out,"'");\par
 9923 \}\par
}
}
{\xe \v output_html_string\:shell.c}
{\xe \v shell.c\:output_html_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void output_html_string (FILE *  {\i out}, const char *  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10083 of file shell.c.}\par
{
References raw_printf, and utf8_printf.}\par
{
Referenced by shell_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10083                                                         \{\par
10084   int i;\par
10085   if( z==0 ) z = "";\par
10086   while( *z )\{\par
10087     for(i=0;   z[i]\par
10088             && z[i]!='<'\par
10089             && z[i]!='&'\par
10090             && z[i]!='>'\par
10091             && z[i]!='\\"'\par
10092             && z[i]!='\\'';\par
10093         i++)\{\}\par
10094     if( i>0 )\{\par
10095       utf8_printf(out,"%.*s",i,z);\par
10096     \}\par
10097     if( z[i]=='<' )\{\par
10098       raw_printf(out,"&lt;");\par
10099     \}else if( z[i]=='&' )\{\par
10100       raw_printf(out,"&amp;");\par
10101     \}else if( z[i]=='>' )\{\par
10102       raw_printf(out,"&gt;");\par
10103     \}else if( z[i]=='\\"' )\{\par
10104       raw_printf(out,"&quot;");\par
10105     \}else if( z[i]=='\\'' )\{\par
10106       raw_printf(out,"&#39;");\par
10107     \}else\{\par
10108       break;\par
10109     \}\par
10110     z += i + 1;\par
10111   \}\par
10112 \}\par
}
}
{\xe \v output_quoted_escaped_string\:shell.c}
{\xe \v shell.c\:output_quoted_escaped_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void output_quoted_escaped_string (FILE *  {\i out}, const char *  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9990 of file shell.c.}\par
{
References raw_printf, setBinaryMode, setTextMode, unused_string(), and utf8_printf.}\par
{
Referenced by shell_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9990                                                                   \{\par
 9991   int i;\par
 9992   char c;\par
 9993   setBinaryMode(out, 1);\par
 9994   for(i=0; (c = z[i])!=0 && c!='\\'' && c!='\\n' && c!='\\r'; i++)\{\}\par
 9995   if( c==0 )\{\par
 9996     utf8_printf(out,"'%s'",z);\par
 9997   \}else\{\par
 9998     const char *zNL = 0;\par
 9999     const char *zCR = 0;\par
10000     int nNL = 0;\par
10001     int nCR = 0;\par
10002     char zBuf1[20], zBuf2[20];\par
10003     for(i=0; z[i]; i++)\{\par
10004       if( z[i]=='\\n' ) nNL++;\par
10005       if( z[i]=='\\r' ) nCR++;\par
10006     \}\par
10007     if( nNL )\{\par
10008       raw_printf(out, "replace(");\par
10009       zNL = unused_string(z, "\\\\n", "\\\\012", zBuf1);\par
10010     \}\par
10011     if( nCR )\{\par
10012       raw_printf(out, "replace(");\par
10013       zCR = unused_string(z, "\\\\r", "\\\\015", zBuf2);\par
10014     \}\par
10015     raw_printf(out, "'");\par
10016     while( *z )\{\par
10017       for(i=0; (c = z[i])!=0 && c!='\\n' && c!='\\r' && c!='\\''; i++)\{\}\par
10018       if( c=='\\'' ) i++;\par
10019       if( i )\{\par
10020         utf8_printf(out, "%.*s", i, z);\par
10021         z += i;\par
10022       \}\par
10023       if( c=='\\'' )\{\par
10024         raw_printf(out, "'");\par
10025         continue;\par
10026       \}\par
10027       if( c==0 )\{\par
10028         break;\par
10029       \}\par
10030       z++;\par
10031       if( c=='\\n' )\{\par
10032         raw_printf(out, "%s", zNL);\par
10033         continue;\par
10034       \}\par
10035       raw_printf(out, "%s", zCR);\par
10036     \}\par
10037     raw_printf(out, "'");\par
10038     if( nCR )\{\par
10039       raw_printf(out, ",'%s',char(13))", zCR);\par
10040     \}\par
10041     if( nNL )\{\par
10042       raw_printf(out, ",'%s',char(10))", zNL);\par
10043     \}\par
10044   \}\par
10045   setTextMode(out, 1);\par
10046 \}\par
}
}
{\xe \v output_quoted_string\:shell.c}
{\xe \v shell.c\:output_quoted_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void output_quoted_string (FILE *  {\i out}, const char *  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9951 of file shell.c.}\par
{
References raw_printf, setBinaryMode, setTextMode, and utf8_printf.}\par
{
Referenced by shell_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9951                                                           \{\par
 9952   int i;\par
 9953   char c;\par
 9954   setBinaryMode(out, 1);\par
 9955   for(i=0; (c = z[i])!=0 && c!='\\''; i++)\{\}\par
 9956   if( c==0 )\{\par
 9957     utf8_printf(out,"'%s'",z);\par
 9958   \}else\{\par
 9959     raw_printf(out, "'");\par
 9960     while( *z )\{\par
 9961       for(i=0; (c = z[i])!=0 && c!='\\''; i++)\{\}\par
 9962       if( c=='\\'' ) i++;\par
 9963       if( i )\{\par
 9964         utf8_printf(out, "%.*s", i, z);\par
 9965         z += i;\par
 9966       \}\par
 9967       if( c=='\\'' )\{\par
 9968         raw_printf(out, "'");\par
 9969         continue;\par
 9970       \}\par
 9971       if( c==0 )\{\par
 9972         break;\par
 9973       \}\par
 9974       z++;\par
 9975     \}\par
 9976     raw_printf(out, "'");\par
 9977   \}\par
 9978   setTextMode(out, 1);\par
 9979 \}\par
}
}
{\xe \v output_reset\:shell.c}
{\xe \v shell.c\:output_reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void output_reset ({\b ShellState} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13436 of file shell.c.}\par
{
References ShellState::doXdgOpen, ShellState::out, ShellState::outfile, output_file_close(), outputModePop(), pclose(), sqlite3_free, sqlite3_mprintf, sqlite3_sleep, utf8_printf, and ShellState::zTempFile.}\par
{
Referenced by do_meta_command(), main(), and process_input().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13436                                        \{\par
13437   if( p->outfile[0]=='|' )\{\par
13438 #ifndef SQLITE_OMIT_POPEN\par
13439     pclose(p->out);\par
13440 #endif\par
13441   \}else\{\par
13442     output_file_close(p->out);\par
13443 #ifndef SQLITE_NOHAVE_SYSTEM\par
13444     if( p->doXdgOpen )\{\par
13445       const char *zXdgOpenCmd =\par
13446 #if defined(_WIN32)\par
13447       "start";\par
13448 #elif defined(__APPLE__)\par
13449       "open";\par
13450 #else\par
13451       "xdg-open";\par
13452 #endif\par
13453       char *zCmd;\par
13454       zCmd = sqlite3_mprintf("%s %s", zXdgOpenCmd, p->zTempFile);\par
13455       if( system(zCmd) )\{\par
13456         utf8_printf(stderr, "Failed: [%s]\\n", zCmd);\par
13457       \}\par
13458       sqlite3_free(zCmd);\par
13459       outputModePop(p);\par
13460       p->doXdgOpen = 0;\par
13461       sqlite3_sleep(100);\par
13462     \}\par
13463 #endif /* !defined(SQLITE_NOHAVE_SYSTEM) */\par
13464   \}\par
13465   p->outfile[0] = 0;\par
13466   p->out = stdout;\par
13467 \}\par
}
}
{\xe \v outputModePop\:shell.c}
{\xe \v shell.c\:outputModePop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void outputModePop ({\b ShellState} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9908 of file shell.c.}\par
{
References ShellState::colSeparator, ShellState::colSepPrior, ShellState::mode, ShellState::modePrior, ShellState::rowSeparator, and ShellState::rowSepPrior.}\par
{
Referenced by output_reset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9908                                         \{\par
 9909   p->mode = p->modePrior;\par
 9910   memcpy(p->colSeparator, p->colSepPrior, sizeof(p->colSeparator));\par
 9911   memcpy(p->rowSeparator, p->rowSepPrior, sizeof(p->rowSeparator));\par
 9912 \}\par
}
}
{\xe \v outputModePush\:shell.c}
{\xe \v shell.c\:outputModePush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void outputModePush ({\b ShellState} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9903 of file shell.c.}\par
{
References ShellState::colSeparator, ShellState::colSepPrior, ShellState::mode, ShellState::modePrior, ShellState::rowSeparator, and ShellState::rowSepPrior.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9903                                          \{\par
 9904   p->modePrior = p->mode;\par
 9905   memcpy(p->colSepPrior, p->colSeparator, sizeof(p->colSeparator));\par
 9906   memcpy(p->rowSepPrior, p->rowSeparator, sizeof(p->rowSeparator));\par
 9907 \}\par
}
}
{\xe \v pclose\:shell.c}
{\xe \v shell.c\:pclose}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int pclose (FILE * )}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by do_meta_command(), and output_reset().}\par
}
{\xe \v popen\:shell.c}
{\xe \v shell.c\:popen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FILE* popen (const char * , const char * )}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by do_meta_command().}\par
}
{\xe \v printBold\:shell.c}
{\xe \v shell.c\:printBold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void printBold (const char *  {\i zText}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18638 of file shell.c.}\par
{
Referenced by main(), and main_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18638                                         \{\par
18639   printf("\\033[1m%s\\033[0m", zText);\par
18640 \}\par
}
}
{\xe \v printSchemaLine\:shell.c}
{\xe \v shell.c\:printSchemaLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void printSchemaLine (FILE *  {\i out}, const char *  {\i z}, const char *  {\i zTail}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10249 of file shell.c.}\par
{
References sqlite3_strglob, and utf8_printf.}\par
{
Referenced by dump_callback(), printSchemaLineN(), and shell_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10249                                                                         \{\par
10250   if( z==0 ) return;\par
10251   if( zTail==0 ) return;\par
10252   if( sqlite3_strglob("CREATE TABLE ['\\"]*", z)==0 )\{\par
10253     utf8_printf(out, "CREATE TABLE IF NOT EXISTS %s%s", z+13, zTail);\par
10254   \}else\{\par
10255     utf8_printf(out, "%s%s", z, zTail);\par
10256   \}\par
10257 \}\par
}
}
{\xe \v printSchemaLineN\:shell.c}
{\xe \v shell.c\:printSchemaLineN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void printSchemaLineN (FILE *  {\i out}, char *  {\i z}, int  {\i n}, const char *  {\i zTail}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10258 of file shell.c.}\par
{
References printSchemaLine().}\par
{
Referenced by shell_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10258                                                                           \{\par
10259   char c = z[n];\par
10260   z[n] = 0;\par
10261   printSchemaLine(out, z, zTail);\par
10262   z[n] = c;\par
10263 \}\par
}
}
{\xe \v process_input\:shell.c}
{\xe \v shell.c\:process_input}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int process_input ({\b ShellState} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18329 of file shell.c.}\par
{
References _all_whitespace(), clearTempFile(), do_meta_command(), ShellState::in, IsSpace, line_contains_semicolon(), line_is_command_terminator(), line_is_complete(), ShellState::lineno, one_input_line(), ShellState::out, ShellState::outCount, output_reset(), runOneSqlLine(), shell_out_of_memory(), ShellHasFlag, SHFLG_Echo, sqlite3_complete, and strlen30().}\par
{
Referenced by do_meta_command(), main(), process_sqliterc(), and showHelp().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18329                                        \{\par
18330   char *zLine = 0;          /* A single input line */\par
18331   char *zSql = 0;           /* Accumulated SQL text */\par
18332   int nLine;                /* Length of current line */\par
18333   int nSql = 0;             /* Bytes of zSql[] used */\par
18334   int nAlloc = 0;           /* Allocated zSql[] space */\par
18335   int nSqlPrior = 0;        /* Bytes of zSql[] used by prior line */\par
18336   int rc;                   /* Error code */\par
18337   int errCnt = 0;           /* Number of errors seen */\par
18338   int startline = 0;        /* Line number for start of current input */\par
18339 \par
18340   p->lineno = 0;\par
18341   while( errCnt==0 || !bail_on_error || (p->in==0 && stdin_is_interactive) )\{\par
18342     fflush(p->out);\par
18343     zLine = one_input_line(p->in, zLine, nSql>0);\par
18344     if( zLine==0 )\{\par
18345       /* End of input */\par
18346       if( p->in==0 && stdin_is_interactive ) printf("\\n");\par
18347       break;\par
18348     \}\par
18349     if( seenInterrupt )\{\par
18350       if( p->in!=0 ) break;\par
18351       seenInterrupt = 0;\par
18352     \}\par
18353     p->lineno++;\par
18354     if( nSql==0 && _all_whitespace(zLine) )\{\par
18355       if( ShellHasFlag(p, SHFLG_Echo) ) printf("%s\\n", zLine);\par
18356       continue;\par
18357     \}\par
18358     if( zLine && (zLine[0]=='.' || zLine[0]=='#') && nSql==0 )\{\par
18359       if( ShellHasFlag(p, SHFLG_Echo) ) printf("%s\\n", zLine);\par
18360       if( zLine[0]=='.' )\{\par
18361         rc = do_meta_command(zLine, p);\par
18362         if( rc==2 )\{ /* exit requested */\par
18363           break;\par
18364         \}else if( rc )\{\par
18365           errCnt++;\par
18366         \}\par
18367       \}\par
18368       continue;\par
18369     \}\par
18370     if( line_is_command_terminator(zLine) && line_is_complete(zSql, nSql) )\{\par
18371       memcpy(zLine,";",2);\par
18372     \}\par
18373     nLine = strlen30(zLine);\par
18374     if( nSql+nLine+2>=nAlloc )\{\par
18375       nAlloc = nSql+nLine+100;\par
18376       zSql = realloc(zSql, nAlloc);\par
18377       if( zSql==0 ) shell_out_of_memory();\par
18378     \}\par
18379     nSqlPrior = nSql;\par
18380     if( nSql==0 )\{\par
18381       int i;\par
18382       for(i=0; zLine[i] && IsSpace(zLine[i]); i++)\{\}\par
18383       assert( nAlloc>0 && zSql!=0 );\par
18384       memcpy(zSql, zLine+i, nLine+1-i);\par
18385       startline = p->lineno;\par
18386       nSql = nLine-i;\par
18387     \}else\{\par
18388       zSql[nSql++] = '\\n';\par
18389       memcpy(zSql+nSql, zLine, nLine+1);\par
18390       nSql += nLine;\par
18391     \}\par
18392     if( nSql && line_contains_semicolon(&zSql[nSqlPrior], nSql-nSqlPrior)\par
18393                 && sqlite3_complete(zSql) )\{\par
18394       errCnt += runOneSqlLine(p, zSql, p->in, startline);\par
18395       nSql = 0;\par
18396       if( p->outCount )\{\par
18397         output_reset(p);\par
18398         p->outCount = 0;\par
18399       \}else\{\par
18400         clearTempFile(p);\par
18401       \}\par
18402     \}else if( nSql && _all_whitespace(zSql) )\{\par
18403       if( ShellHasFlag(p, SHFLG_Echo) ) printf("%s\\n", zSql);\par
18404       nSql = 0;\par
18405     \}\par
18406   \}\par
18407   if( nSql && !_all_whitespace(zSql) )\{\par
18408     errCnt += runOneSqlLine(p, zSql, p->in, startline);\par
18409   \}\par
18410   free(zSql);\par
18411   free(zLine);\par
18412   return errCnt>0;\par
18413 \}\par
}
}
{\xe \v process_sqliterc\:shell.c}
{\xe \v shell.c\:process_sqliterc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void process_sqliterc ({\b ShellState} *  {\i p}, const char *  {\i sqliterc_override}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18490 of file shell.c.}\par
{
References find_home_dir(), ShellState::in, ShellState::lineno, process_input(), raw_printf, sqlite3_free, sqlite3_mprintf, and utf8_printf.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18493  \{\par
18494   char *home_dir = NULL;\par
18495   const char *sqliterc = sqliterc_override;\par
18496   char *zBuf = 0;\par
18497   FILE *inSaved = p->in;\par
18498   int savedLineno = p->lineno;\par
18499 \par
18500   if (sqliterc == NULL) \{\par
18501     home_dir = find_home_dir(0);\par
18502     if( home_dir==0 )\{\par
18503       raw_printf(stderr, "-- warning: cannot find home directory;"\par
18504                       " cannot read ~/.sqliterc\\n");\par
18505       return;\par
18506     \}\par
18507     zBuf = sqlite3_mprintf("%s/.sqliterc",home_dir);\par
18508     sqliterc = zBuf;\par
18509   \}\par
18510   p->in = fopen(sqliterc,"rb");\par
18511   if( p->in )\{\par
18512     if( stdin_is_interactive )\{\par
18513       utf8_printf(stderr,"-- Loading resources from %s\\n",sqliterc);\par
18514     \}\par
18515     process_input(p);\par
18516     fclose(p->in);\par
18517   \}\par
18518   p->in = inSaved;\par
18519   p->lineno = savedLineno;\par
18520   sqlite3_free(zBuf);\par
18521 \}\par
}
}
{\xe \v progress_handler\:shell.c}
{\xe \v shell.c\:progress_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int progress_handler (void *  {\i pClientData}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10372 of file shell.c.}\par
{
References ShellState::flgProgress, ShellState::mxProgress, ShellState::nProgress, ShellState::out, raw_printf, SHELL_PROGRESS_ONCE, SHELL_PROGRESS_QUIET, and SHELL_PROGRESS_RESET.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10372                                                \{\par
10373   ShellState *p = (ShellState*)pClientData;\par
10374   p->nProgress++;\par
10375   if( p->nProgress>=p->mxProgress && p->mxProgress>0 )\{\par
10376     raw_printf(p->out, "Progress limit reached (%u)\\n", p->nProgress);\par
10377     if( p->flgProgress & SHELL_PROGRESS_RESET ) p->nProgress = 0;\par
10378     if( p->flgProgress & SHELL_PROGRESS_ONCE ) p->mxProgress = 0;\par
10379     return 1;\par
10380   \}\par
10381   if( (p->flgProgress & SHELL_PROGRESS_QUIET)==0 )\{\par
10382     raw_printf(p->out, "Progress %u\\n", p->nProgress);\par
10383   \}\par
10384   return 0;\par
10385 \}\par
}
}
{\xe \v quoteChar\:shell.c}
{\xe \v shell.c\:quoteChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char quoteChar (const char *  {\i zName}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 794 of file shell.c.}\par
{
References sqlite3_keyword_check.}\par
{
Referenced by do_meta_command(), dump_callback(), set_table_name(), shell_callback(), shellAddSchemaName(), and shellFakeSchema().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   794                                         \{\par
  795   int i;\par
  796   if( !isalpha((unsigned char)zName[0]) && zName[0]!='_' ) return '"';\par
  797   for(i=0; zName[i]; i++)\{\par
  798     if( !isalnum((unsigned char)zName[i]) && zName[i]!='_' ) return '"';\par
  799   \}\par
  800   return sqlite3_keyword_check(zName, i) ? '"' : 0;\par
  801 \}\par
}
}
{\xe \v readFile\:shell.c}
{\xe \v shell.c\:readFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* readFile (const char *  {\i zName}, int *  {\i pnByte}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12328 of file shell.c.}\par
{
References session_close_all, sqlite3_free, and sqlite3_malloc64.}\par
{
Referenced by do_meta_command(), and open_db().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12328                                                      \{\par
12329   FILE *in = fopen(zName, "rb");\par
12330   long nIn;\par
12331   size_t nRead;\par
12332   char *pBuf;\par
12333   if( in==0 ) return 0;\par
12334   fseek(in, 0, SEEK_END);\par
12335   nIn = ftell(in);\par
12336   rewind(in);\par
12337   pBuf = sqlite3_malloc64( nIn+1 );\par
12338   if( pBuf==0 )\{ fclose(in); return 0; \}\par
12339   nRead = fread(pBuf, nIn, 1, in);\par
12340   fclose(in);\par
12341   if( nRead!=1 )\{\par
12342     sqlite3_free(pBuf);\par
12343     return 0;\par
12344   \}\par
12345   pBuf[nIn] = 0;\par
12346   if( pnByte ) *pnByte = nIn;\par
12347   return pBuf;\par
12348 \}\par
}
}
{\xe \v readFileContents\:shell.c}
{\xe \v shell.c\:readFileContents}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void readFileContents ({\b sqlite3_context} *  {\i ctx}, const char *  {\i zName}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2165 of file shell.c.}\par
{
References sqlite3_context_db_handle, sqlite3_free, sqlite3_limit, sqlite3_malloc64, sqlite3_result_blob64, sqlite3_result_error_code, sqlite3_result_error_nomem, SQLITE_IOERR, SQLITE_LIMIT_LENGTH, and SQLITE_TOOBIG.}\par
{
Referenced by fsdirColumn(), and readfileFunc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2165                                                                      \{\par
 2166   FILE *in;\par
 2167   sqlite3_int64 nIn;\par
 2168   void *pBuf;\par
 2169   sqlite3 *db;\par
 2170   int mxBlob;\par
 2171 \par
 2172   in = fopen(zName, "rb");\par
 2173   if( in==0 )\{\par
 2174     /* File does not exist or is unreadable. Leave the result set to NULL. */\par
 2175     return;\par
 2176   \}\par
 2177   fseek(in, 0, SEEK_END);\par
 2178   nIn = ftell(in);\par
 2179   rewind(in);\par
 2180   db = sqlite3_context_db_handle(ctx);\par
 2181   mxBlob = sqlite3_limit(db, SQLITE_LIMIT_LENGTH, -1);\par
 2182   if( nIn>mxBlob )\{\par
 2183     sqlite3_result_error_code(ctx, SQLITE_TOOBIG);\par
 2184     fclose(in);\par
 2185     return;\par
 2186   \}\par
 2187   pBuf = sqlite3_malloc64( nIn ? nIn : 1 );\par
 2188   if( pBuf==0 )\{\par
 2189     sqlite3_result_error_nomem(ctx);\par
 2190     fclose(in);\par
 2191     return;\par
 2192   \}\par
 2193   if( nIn==(sqlite3_int64)fread(pBuf, 1, (size_t)nIn, in) )\{\par
 2194     sqlite3_result_blob64(ctx, pBuf, nIn, sqlite3_free);\par
 2195   \}else\{\par
 2196     sqlite3_result_error_code(ctx, SQLITE_IOERR);\par
 2197     sqlite3_free(pBuf);\par
 2198   \}\par
 2199   fclose(in);\par
 2200 \}\par
}
}
{\xe \v readfileFunc\:shell.c}
{\xe \v shell.c\:readfileFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void readfileFunc ({\b sqlite3_context} *  {\i context}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2207 of file shell.c.}\par
{
References readFileContents(), sqlite3_value_text, and zName.}\par
{
Referenced by sqlite3_fileio_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2211  \{\par
 2212   const char *zName;\par
 2213   (void)(argc);  /* Unused parameter */\par
 2214   zName = (const char*)sqlite3_value_text(argv[0]);\par
 2215   if( zName==0 ) return;\par
 2216   readFileContents(context, zName);\par
 2217 \}\par
}
}
{\xe \v resolve_backslashes\:shell.c}
{\xe \v shell.c\:resolve_backslashes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void resolve_backslashes (char *  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12890 of file shell.c.}\par
{
Referenced by do_meta_command(), and runOneSqlLine().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12890                                         \{\par
12891   int i, j;\par
12892   char c;\par
12893   while( *z && *z!='\\\\' ) z++;\par
12894   for(i=j=0; (c = z[i])!=0; i++, j++)\{\par
12895     if( c=='\\\\' && z[i+1]!=0 )\{\par
12896       c = z[++i];\par
12897       if( c=='a' )\{\par
12898         c = '\\a';\par
12899       \}else if( c=='b' )\{\par
12900         c = '\\b';\par
12901       \}else if( c=='t' )\{\par
12902         c = '\\t';\par
12903       \}else if( c=='n' )\{\par
12904         c = '\\n';\par
12905       \}else if( c=='v' )\{\par
12906         c = '\\v';\par
12907       \}else if( c=='f' )\{\par
12908         c = '\\f';\par
12909       \}else if( c=='r' )\{\par
12910         c = '\\r';\par
12911       \}else if( c=='"' )\{\par
12912         c = '"';\par
12913       \}else if( c=='\\'' )\{\par
12914         c = '\\'';\par
12915       \}else if( c=='\\\\' )\{\par
12916         c = '\\\\';\par
12917       \}else if( c>='0' && c<='7' )\{\par
12918         c -= '0';\par
12919         if( z[i+1]>='0' && z[i+1]<='7' )\{\par
12920           i++;\par
12921           c = (c<<3) + z[i] - '0';\par
12922           if( z[i+1]>='0' && z[i+1]<='7' )\{\par
12923             i++;\par
12924             c = (c<<3) + z[i] - '0';\par
12925           \}\par
12926         \}\par
12927       \}\par
12928     \}\par
12929     z[j] = c;\par
12930   \}\par
12931   if( j<i ) z[j] = 0;\par
12932 \}\par
}
}
{\xe \v restore_debug_trace_modes\:shell.c}
{\xe \v shell.c\:restore_debug_trace_modes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void restore_debug_trace_modes (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11317 of file shell.c.}\par
{
Referenced by shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11317                                            \{\par
11318 #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_SELECTTRACE)\par
11319   sqlite3SelectTrace = savedSelectTrace;\par
11320 #endif\par
11321 #if defined(SQLITE_DEBUG) && defined(SQLITE_ENABLE_WHERETRACE)\par
11322   sqlite3WhereTrace = savedWhereTrace;\par
11323 #endif\par
11324 \}\par
}
}
{\xe \v run_schema_dump_query\:shell.c}
{\xe \v shell.c\:run_schema_dump_query}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int run_schema_dump_query ({\b ShellState} *  {\i p}, const char *  {\i zQuery}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11991 of file shell.c.}\par
{
References ShellState::db, dump_callback(), ShellState::out, raw_printf, sqlite3_exec, sqlite3_free, sqlite3_snprintf, SQLITE_CORRUPT, strlen30(), and utf8_printf.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11994  \{\par
11995   int rc;\par
11996   char *zErr = 0;\par
11997   rc = sqlite3_exec(p->db, zQuery, dump_callback, p, &zErr);\par
11998   if( rc==SQLITE_CORRUPT )\{\par
11999     char *zQ2;\par
12000     int len = strlen30(zQuery);\par
12001     raw_printf(p->out, "/****** CORRUPTION ERROR *******/\\n");\par
12002     if( zErr )\{\par
12003       utf8_printf(p->out, "/****** %s ******/\\n", zErr);\par
12004       sqlite3_free(zErr);\par
12005       zErr = 0;\par
12006     \}\par
12007     zQ2 = malloc( len+100 );\par
12008     if( zQ2==0 ) return rc;\par
12009     sqlite3_snprintf(len+100, zQ2, "%s ORDER BY rowid DESC", zQuery);\par
12010     rc = sqlite3_exec(p->db, zQ2, dump_callback, p, &zErr);\par
12011     if( rc )\{\par
12012       utf8_printf(p->out, "/****** ERROR: %s ******/\\n", zErr);\par
12013     \}else\{\par
12014       rc = SQLITE_CORRUPT;\par
12015     \}\par
12016     sqlite3_free(zErr);\par
12017     free(zQ2);\par
12018   \}\par
12019   return rc;\par
12020 \}\par
}
}
{\xe \v run_table_dump_query\:shell.c}
{\xe \v shell.c\:run_table_dump_query}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int run_table_dump_query ({\b ShellState} *  {\i p}, const char *  {\i zSelect}, const char *  {\i zFirstRow}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10872 of file shell.c.}\par
{
References ShellState::db, ShellState::nErr, ShellState::out, raw_printf, sqlite3_column_count, sqlite3_column_text, sqlite3_errmsg, sqlite3_finalize, sqlite3_prepare_v2, sqlite3_step, SQLITE_CORRUPT, SQLITE_OK, SQLITE_ROW, and utf8_printf.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10876  \{\par
10877   sqlite3_stmt *pSelect;\par
10878   int rc;\par
10879   int nResult;\par
10880   int i;\par
10881   const char *z;\par
10882   rc = sqlite3_prepare_v2(p->db, zSelect, -1, &pSelect, 0);\par
10883   if( rc!=SQLITE_OK || !pSelect )\{\par
10884     utf8_printf(p->out, "/**** ERROR: (%d) %s *****/\\n", rc,\par
10885                 sqlite3_errmsg(p->db));\par
10886     if( (rc&0xff)!=SQLITE_CORRUPT ) p->nErr++;\par
10887     return rc;\par
10888   \}\par
10889   rc = sqlite3_step(pSelect);\par
10890   nResult = sqlite3_column_count(pSelect);\par
10891   while( rc==SQLITE_ROW )\{\par
10892     if( zFirstRow )\{\par
10893       utf8_printf(p->out, "%s", zFirstRow);\par
10894       zFirstRow = 0;\par
10895     \}\par
10896     z = (const char*)sqlite3_column_text(pSelect, 0);\par
10897     utf8_printf(p->out, "%s", z);\par
10898     for(i=1; i<nResult; i++)\{\par
10899       utf8_printf(p->out, ",%s", sqlite3_column_text(pSelect, i));\par
10900     \}\par
10901     if( z==0 ) z = "";\par
10902     while( z[0] && (z[0]!='-' || z[1]!='-') ) z++;\par
10903     if( z[0] )\{\par
10904       raw_printf(p->out, "\\n;\\n");\par
10905     \}else\{\par
10906       raw_printf(p->out, ";\\n");\par
10907     \}\par
10908     rc = sqlite3_step(pSelect);\par
10909   \}\par
10910   rc = sqlite3_finalize(pSelect);\par
10911   if( rc!=SQLITE_OK )\{\par
10912     utf8_printf(p->out, "/**** ERROR: (%d) %s *****/\\n", rc,\par
10913                 sqlite3_errmsg(p->db));\par
10914     if( (rc&0xff)!=SQLITE_CORRUPT ) p->nErr++;\par
10915   \}\par
10916   return rc;\par
10917 \}\par
}
}
{\xe \v runOneSqlLine\:shell.c}
{\xe \v shell.c\:runOneSqlLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int runOneSqlLine ({\b ShellState} *  {\i p}, char *  {\i zSql}, FILE *  {\i in}, int  {\i startline}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18286 of file shell.c.}\par
{
References BEGIN_TIMER, ShellState::db, END_TIMER, ShellState::flgProgress, ShellState::nProgress, open_db(), ShellState::out, raw_printf, resolve_backslashes(), shell_exec(), SHELL_PROGRESS_RESET, ShellHasFlag, SHFLG_Backslash, SHFLG_CountChanges, sqlite3_changes, sqlite3_errmsg, sqlite3_free, sqlite3_snprintf, sqlite3_total_changes, and utf8_printf.}\par
{
Referenced by process_input().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18286                                                                             \{\par
18287   int rc;\par
18288   char *zErrMsg = 0;\par
18289 \par
18290   open_db(p, 0);\par
18291   if( ShellHasFlag(p,SHFLG_Backslash) ) resolve_backslashes(zSql);\par
18292   if( p->flgProgress & SHELL_PROGRESS_RESET ) p->nProgress = 0;\par
18293   BEGIN_TIMER;\par
18294   rc = shell_exec(p, zSql, &zErrMsg);\par
18295   END_TIMER;\par
18296   if( rc || zErrMsg )\{\par
18297     char zPrefix[100];\par
18298     if( in!=0 || !stdin_is_interactive )\{\par
18299       sqlite3_snprintf(sizeof(zPrefix), zPrefix,\par
18300                        "Error: near line %d:", startline);\par
18301     \}else\{\par
18302       sqlite3_snprintf(sizeof(zPrefix), zPrefix, "Error:");\par
18303     \}\par
18304     if( zErrMsg!=0 )\{\par
18305       utf8_printf(stderr, "%s %s\\n", zPrefix, zErrMsg);\par
18306       sqlite3_free(zErrMsg);\par
18307       zErrMsg = 0;\par
18308     \}else\{\par
18309       utf8_printf(stderr, "%s %s\\n", zPrefix, sqlite3_errmsg(p->db));\par
18310     \}\par
18311     return 1;\par
18312   \}else if( ShellHasFlag(p, SHFLG_CountChanges) )\{\par
18313     raw_printf(p->out, "changes: %3d   total_changes: %d\\n",\par
18314             sqlite3_changes(p->db), sqlite3_total_changes(p->db));\par
18315   \}\par
18316   return 0;\par
18317 \}\par
}
}
{\xe \v save_err_msg\:shell.c}
{\xe \v shell.c\:save_err_msg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* save_err_msg ({\b sqlite3} *  {\i db}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10922 of file shell.c.}\par
{
References ArraySize, sqlite3_errmsg, sqlite3_malloc64, sqlite3_snprintf, strlen30(), and utf8_printf.}\par
{
Referenced by shell_exec().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10924  \{\par
10925   int nErrMsg = 1+strlen30(sqlite3_errmsg(db));\par
10926   char *zErrMsg = sqlite3_malloc64(nErrMsg);\par
10927   if( zErrMsg )\{\par
10928     memcpy(zErrMsg, sqlite3_errmsg(db), nErrMsg);\par
10929   \}\par
10930   return zErrMsg;\par
10931 \}\par
}
}
{\xe \v set_table_name\:shell.c}
{\xe \v shell.c\:set_table_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void set_table_name ({\b ShellState} *  {\i p}, const char *  {\i zName}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10836 of file shell.c.}\par
{
References quoteChar(), shell_out_of_memory(), strlen30(), and ShellState::zDestTable.}\par
{
Referenced by do_meta_command(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10836                                                             \{\par
10837   int i, n;\par
10838   char cQuote;\par
10839   char *z;\par
10840 \par
10841   if( p->zDestTable )\{\par
10842     free(p->zDestTable);\par
10843     p->zDestTable = 0;\par
10844   \}\par
10845   if( zName==0 ) return;\par
10846   cQuote = quoteChar(zName);\par
10847   n = strlen30(zName);\par
10848   if( cQuote ) n += n+2;\par
10849   z = p->zDestTable = malloc( n+1 );\par
10850   if( z==0 ) shell_out_of_memory();\par
10851   n = 0;\par
10852   if( cQuote ) z[n++] = cQuote;\par
10853   for(i=0; zName[i]; i++)\{\par
10854     z[n++] = zName[i];\par
10855     if( zName[i]==cQuote ) z[n++] = cQuote;\par
10856   \}\par
10857   if( cQuote ) z[n++] = cQuote;\par
10858   z[n] = 0;\par
10859 \}\par
}
}
{\xe \v setOrClearFlag\:shell.c}
{\xe \v shell.c\:setOrClearFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void setOrClearFlag ({\b ShellState} *  {\i p}, unsigned  {\i mFlag}, const char *  {\i zArg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12960 of file shell.c.}\par
{
References booleanValue(), ShellClearFlag, and ShellSetFlag.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12960                                                                            \{\par
12961   if( booleanValue(zArg) )\{\par
12962     ShellSetFlag(p, mFlag);\par
12963   \}else\{\par
12964     ShellClearFlag(p, mFlag);\par
12965   \}\par
12966 \}\par
}
}
{\xe \v SHA3Final\:shell.c}
{\xe \v shell.c\:SHA3Final}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static unsigned char* SHA3Final ({\b SHA3Context} *  {\i p}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1780 of file shell.c.}\par
{
References SHA3Context::ixMask, SHA3Context::nLoaded, SHA3Context::nRate, SHA3Update(), SHA3Context::u, and SHA3Context::x.}\par
{
Referenced by sha3Func(), and sha3QueryFunc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1780                                                \{\par
 1781   unsigned int i;\par
 1782   if( p->nLoaded==p->nRate-1 )\{\par
 1783     const unsigned char c1 = 0x86;\par
 1784     SHA3Update(p, &c1, 1);\par
 1785   \}else\{\par
 1786     const unsigned char c2 = 0x06;\par
 1787     const unsigned char c3 = 0x80;\par
 1788     SHA3Update(p, &c2, 1);\par
 1789     p->nLoaded = p->nRate - 1;\par
 1790     SHA3Update(p, &c3, 1);\par
 1791   \}\par
 1792   for(i=0; i<p->nRate; i++)\{\par
 1793     p->u.x[i+p->nRate] = p->u.x[i^p->ixMask];\par
 1794   \}\par
 1795   return &p->u.x[p->nRate];\par
 1796 \}\par
}
}
{\xe \v sha3Func\:shell.c}
{\xe \v shell.c\:sha3Func}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void sha3Func ({\b sqlite3_context} *  {\i context}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1809 of file shell.c.}\par
{
References eType, SHA3Final(), SHA3Init(), SHA3Update(), sqlite3_result_blob, sqlite3_result_error, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_int, sqlite3_value_text, sqlite3_value_type, SQLITE_BLOB, SQLITE_NULL, and SQLITE_TRANSIENT.}\par
{
Referenced by sqlite3_shathree_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1813  \{\par
 1814   SHA3Context cx;\par
 1815   int eType = sqlite3_value_type(argv[0]);\par
 1816   int nByte = sqlite3_value_bytes(argv[0]);\par
 1817   int iSize;\par
 1818   if( argc==1 )\{\par
 1819     iSize = 256;\par
 1820   \}else\{\par
 1821     iSize = sqlite3_value_int(argv[1]);\par
 1822     if( iSize!=224 && iSize!=256 && iSize!=384 && iSize!=512 )\{\par
 1823       sqlite3_result_error(context, "SHA3 size should be one of: 224 256 "\par
 1824                                     "384 512", -1);\par
 1825       return;\par
 1826     \}\par
 1827   \}\par
 1828   if( eType==SQLITE_NULL ) return;\par
 1829   SHA3Init(&cx, iSize);\par
 1830   if( eType==SQLITE_BLOB )\{\par
 1831     SHA3Update(&cx, sqlite3_value_blob(argv[0]), nByte);\par
 1832   \}else\{\par
 1833     SHA3Update(&cx, sqlite3_value_text(argv[0]), nByte);\par
 1834   \}\par
 1835   sqlite3_result_blob(context, SHA3Final(&cx), iSize/8, SQLITE_TRANSIENT);\par
 1836 \}\par
}
}
{\xe \v SHA3Init\:shell.c}
{\xe \v shell.c\:SHA3Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void SHA3Init ({\b SHA3Context} *  {\i p}, int  {\i iSize}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1712 of file shell.c.}\par
{
References SHA3Context::ixMask, and SHA3Context::nRate.}\par
{
Referenced by sha3Func(), and sha3QueryFunc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1712                                                \{\par
 1713   memset(p, 0, sizeof(*p));\par
 1714   if( iSize>=128 && iSize<=512 )\{\par
 1715     p->nRate = (1600 - ((iSize + 31)&~31)*2)/8;\par
 1716   \}else\{\par
 1717     p->nRate = (1600 - 2*256)/8;\par
 1718   \}\par
 1719 #if SHA3_BYTEORDER==1234\par
 1720   /* Known to be little-endian at compile-time. No-op */\par
 1721 #elif SHA3_BYTEORDER==4321\par
 1722   p->ixMask = 7;  /* Big-endian */\par
 1723 #else\par
 1724   \{\par
 1725     static unsigned int one = 1;\par
 1726     if( 1==*(unsigned char*)&one )\{\par
 1727       /* Little endian.  No byte swapping. */\par
 1728       p->ixMask = 0;\par
 1729     \}else\{\par
 1730       /* Big endian.  Byte swap. */\par
 1731       p->ixMask = 7;\par
 1732     \}\par
 1733   \}\par
 1734 #endif\par
 1735 \}\par
}
}
{\xe \v sha3QueryFunc\:shell.c}
{\xe \v shell.c\:sha3QueryFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void sha3QueryFunc ({\b sqlite3_context} *  {\i context}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1888 of file shell.c.}\par
{
References hash_step_vformat(), SHA3Final(), SHA3Init(), SHA3Update(), sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_count, sqlite3_column_double, sqlite3_column_int64, sqlite3_column_text, sqlite3_column_type, sqlite3_context_db_handle, sqlite3_errmsg, sqlite3_finalize, sqlite3_free, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_result_blob, sqlite3_result_error, sqlite3_sql, sqlite3_step, sqlite3_stmt_readonly, sqlite3_value_int, sqlite3_value_text, SQLITE_BLOB, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL, SQLITE_ROW, SQLITE_TEXT, SQLITE_TRANSIENT, and time_test::x.}\par
{
Referenced by sqlite3_shathree_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1892  \{\par
 1893   sqlite3 *db = sqlite3_context_db_handle(context);\par
 1894   const char *zSql = (const char*)sqlite3_value_text(argv[0]);\par
 1895   sqlite3_stmt *pStmt = 0;\par
 1896   int nCol;                   /* Number of columns in the result set */\par
 1897   int i;                      /* Loop counter */\par
 1898   int rc;\par
 1899   int n;\par
 1900   const char *z;\par
 1901   SHA3Context cx;\par
 1902   int iSize;\par
 1903 \par
 1904   if( argc==1 )\{\par
 1905     iSize = 256;\par
 1906   \}else\{\par
 1907     iSize = sqlite3_value_int(argv[1]);\par
 1908     if( iSize!=224 && iSize!=256 && iSize!=384 && iSize!=512 )\{\par
 1909       sqlite3_result_error(context, "SHA3 size should be one of: 224 256 "\par
 1910                                     "384 512", -1);\par
 1911       return;\par
 1912     \}\par
 1913   \}\par
 1914   if( zSql==0 ) return;\par
 1915   SHA3Init(&cx, iSize);\par
 1916   while( zSql[0] )\{\par
 1917     rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zSql);\par
 1918     if( rc )\{\par
 1919       char *zMsg = sqlite3_mprintf("error SQL statement [%s]: %s",\par
 1920                                    zSql, sqlite3_errmsg(db));\par
 1921       sqlite3_finalize(pStmt);\par
 1922       sqlite3_result_error(context, zMsg, -1);\par
 1923       sqlite3_free(zMsg);\par
 1924       return;\par
 1925     \}\par
 1926     if( !sqlite3_stmt_readonly(pStmt) )\{\par
 1927       char *zMsg = sqlite3_mprintf("non-query: [%s]", sqlite3_sql(pStmt));\par
 1928       sqlite3_finalize(pStmt);\par
 1929       sqlite3_result_error(context, zMsg, -1);\par
 1930       sqlite3_free(zMsg);\par
 1931       return;\par
 1932     \}\par
 1933     nCol = sqlite3_column_count(pStmt);\par
 1934     z = sqlite3_sql(pStmt);\par
 1935     n = (int)strlen(z);\par
 1936     hash_step_vformat(&cx,"S%d:",n);\par
 1937     SHA3Update(&cx,(unsigned char*)z,n);\par
 1938 \par
 1939     /* Compute a hash over the result of the query */\par
 1940     while( SQLITE_ROW==sqlite3_step(pStmt) )\{\par
 1941       SHA3Update(&cx,(const unsigned char*)"R",1);\par
 1942       for(i=0; i<nCol; i++)\{\par
 1943         switch( sqlite3_column_type(pStmt,i) )\{\par
 1944           case SQLITE_NULL: \{\par
 1945             SHA3Update(&cx, (const unsigned char*)"N",1);\par
 1946             break;\par
 1947           \}\par
 1948           case SQLITE_INTEGER: \{\par
 1949             sqlite3_uint64 u;\par
 1950             int j;\par
 1951             unsigned char x[9];\par
 1952             sqlite3_int64 v = sqlite3_column_int64(pStmt,i);\par
 1953             memcpy(&u, &v, 8);\par
 1954             for(j=8; j>=1; j--)\{\par
 1955               x[j] = u & 0xff;\par
 1956               u >>= 8;\par
 1957             \}\par
 1958             x[0] = 'I';\par
 1959             SHA3Update(&cx, x, 9);\par
 1960             break;\par
 1961           \}\par
 1962           case SQLITE_FLOAT: \{\par
 1963             sqlite3_uint64 u;\par
 1964             int j;\par
 1965             unsigned char x[9];\par
 1966             double r = sqlite3_column_double(pStmt,i);\par
 1967             memcpy(&u, &r, 8);\par
 1968             for(j=8; j>=1; j--)\{\par
 1969               x[j] = u & 0xff;\par
 1970               u >>= 8;\par
 1971             \}\par
 1972             x[0] = 'F';\par
 1973             SHA3Update(&cx,x,9);\par
 1974             break;\par
 1975           \}\par
 1976           case SQLITE_TEXT: \{\par
 1977             int n2 = sqlite3_column_bytes(pStmt, i);\par
 1978             const unsigned char *z2 = sqlite3_column_text(pStmt, i);\par
 1979             hash_step_vformat(&cx,"T%d:",n2);\par
 1980             SHA3Update(&cx, z2, n2);\par
 1981             break;\par
 1982           \}\par
 1983           case SQLITE_BLOB: \{\par
 1984             int n2 = sqlite3_column_bytes(pStmt, i);\par
 1985             const unsigned char *z2 = sqlite3_column_blob(pStmt, i);\par
 1986             hash_step_vformat(&cx,"B%d:",n2);\par
 1987             SHA3Update(&cx, z2, n2);\par
 1988             break;\par
 1989           \}\par
 1990         \}\par
 1991       \}\par
 1992     \}\par
 1993     sqlite3_finalize(pStmt);\par
 1994   \}\par
 1995   sqlite3_result_blob(context, SHA3Final(&cx), iSize/8, SQLITE_TRANSIENT);\par
 1996 \}\par
}
}
{\xe \v SHA3Update\:shell.c}
{\xe \v shell.c\:SHA3Update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void SHA3Update ({\b SHA3Context} *  {\i p}, const unsigned char *  {\i aData}, unsigned int  {\i nData}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1741 of file shell.c.}\par
{
References SHA3Context::ixMask, KeccakF1600Step(), SHA3Context::nLoaded, SHA3Context::nRate, SHA3Context::s, SHA3Context::u, and SHA3Context::x.}\par
{
Referenced by hash_step_vformat(), SHA3Final(), sha3Func(), and sha3QueryFunc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1745  \{\par
 1746   unsigned int i = 0;\par
 1747 #if SHA3_BYTEORDER==1234\par
 1748   if( (p->nLoaded % 8)==0 && ((aData - (const unsigned char*)0)&7)==0 )\{\par
 1749     for(; i+7<nData; i+=8)\{\par
 1750       p->u.s[p->nLoaded/8] ^= *(u64*)&aData[i];\par
 1751       p->nLoaded += 8;\par
 1752       if( p->nLoaded>=p->nRate )\{\par
 1753         KeccakF1600Step(p);\par
 1754         p->nLoaded = 0;\par
 1755       \}\par
 1756     \}\par
 1757   \}\par
 1758 #endif\par
 1759   for(; i<nData; i++)\{\par
 1760 #if SHA3_BYTEORDER==1234\par
 1761     p->u.x[p->nLoaded] ^= aData[i];\par
 1762 #elif SHA3_BYTEORDER==4321\par
 1763     p->u.x[p->nLoaded^0x07] ^= aData[i];\par
 1764 #else\par
 1765     p->u.x[p->nLoaded^p->ixMask] ^= aData[i];\par
 1766 #endif\par
 1767     p->nLoaded++;\par
 1768     if( p->nLoaded==p->nRate )\{\par
 1769       KeccakF1600Step(p);\par
 1770       p->nLoaded = 0;\par
 1771     \}\par
 1772   \}\par
 1773 \}\par
}
}
{\xe \v shell_callback\:shell.c}
{\xe \v shell.c\:shell_callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int shell_callback (void *  {\i pArg}, int  {\i nArg}, char **  {\i azArg}, char **  {\i azCol}, int *  {\i aiType}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10392 of file shell.c.}\par
{
References ShellState::actualWidth, ShellState::aiIndent, ArraySize, ShellState::cMode, ShellState::cnt, ShellState::colSeparator, ShellState::colWidth, eqp_append(), ShellState::iIndent, isNumber(), IsSpace, MODE_Ascii, MODE_Column, MODE_Csv, MODE_EQP, MODE_Explain, MODE_Html, MODE_Insert, MODE_Line, MODE_List, MODE_Pretty, MODE_Quote, MODE_Semi, MODE_Tcl, ShellState::nIndent, ShellState::nullValue, ShellState::out, output_c_string(), output_csv(), output_hex_blob(), output_html_string(), output_quoted_escaped_string(), output_quoted_string(), printSchemaLine(), printSchemaLineN(), ShellState::pStmt, quoteChar(), raw_printf, ShellState::rowSeparator, SEP_Row, setBinaryMode, setTextMode, ShellHasFlag, SHFLG_Newlines, ShellState::showHeader, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_double, sqlite3_free, sqlite3_mprintf, sqlite3_snprintf, sqlite3_strlike, SQLITE_BLOB, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL, SQLITE_TEXT, strlen30(), strlenChar(), utf8_printf, utf8_width_print(), wsToEol(), and ShellState::zDestTable.}\par
{
Referenced by callback(), and exec_prepared_stmt().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10398  \{\par
10399   int i;\par
10400   ShellState *p = (ShellState*)pArg;\par
10401 \par
10402   if( azArg==0 ) return 0;\par
10403   switch( p->cMode )\{\par
10404     case MODE_Line: \{\par
10405       int w = 5;\par
10406       if( azArg==0 ) break;\par
10407       for(i=0; i<nArg; i++)\{\par
10408         int len = strlen30(azCol[i] ? azCol[i] : "");\par
10409         if( len>w ) w = len;\par
10410       \}\par
10411       if( p->cnt++>0 ) utf8_printf(p->out, "%s", p->rowSeparator);\par
10412       for(i=0; i<nArg; i++)\{\par
10413         utf8_printf(p->out,"%*s = %s%s", w, azCol[i],\par
10414                 azArg[i] ? azArg[i] : p->nullValue, p->rowSeparator);\par
10415       \}\par
10416       break;\par
10417     \}\par
10418     case MODE_Explain:\par
10419     case MODE_Column: \{\par
10420       static const int aExplainWidths[] = \{4, 13, 4, 4, 4, 13, 2, 13\};\par
10421       const int *colWidth;\par
10422       int showHdr;\par
10423       char *rowSep;\par
10424       int nWidth;\par
10425       if( p->cMode==MODE_Column )\{\par
10426         colWidth = p->colWidth;\par
10427         nWidth = ArraySize(p->colWidth);\par
10428         showHdr = p->showHeader;\par
10429         rowSep = p->rowSeparator;\par
10430       \}else\{\par
10431         colWidth = aExplainWidths;\par
10432         nWidth = ArraySize(aExplainWidths);\par
10433         showHdr = 1;\par
10434         rowSep = SEP_Row;\par
10435       \}\par
10436       if( p->cnt++==0 )\{\par
10437         for(i=0; i<nArg; i++)\{\par
10438           int w, n;\par
10439           if( i<nWidth )\{\par
10440             w = colWidth[i];\par
10441           \}else\{\par
10442             w = 0;\par
10443           \}\par
10444           if( w==0 )\{\par
10445             w = strlenChar(azCol[i] ? azCol[i] : "");\par
10446             if( w<10 ) w = 10;\par
10447             n = strlenChar(azArg && azArg[i] ? azArg[i] : p->nullValue);\par
10448             if( w<n ) w = n;\par
10449           \}\par
10450           if( i<ArraySize(p->actualWidth) )\{\par
10451             p->actualWidth[i] = w;\par
10452           \}\par
10453           if( showHdr )\{\par
10454             utf8_width_print(p->out, w, azCol[i]);\par
10455             utf8_printf(p->out, "%s", i==nArg-1 ? rowSep : "  ");\par
10456           \}\par
10457         \}\par
10458         if( showHdr )\{\par
10459           for(i=0; i<nArg; i++)\{\par
10460             int w;\par
10461             if( i<ArraySize(p->actualWidth) )\{\par
10462                w = p->actualWidth[i];\par
10463                if( w<0 ) w = -w;\par
10464             \}else\{\par
10465                w = 10;\par
10466             \}\par
10467             utf8_printf(p->out,"%-*.*s%s",w,w,\par
10468                    "----------------------------------------------------------"\par
10469                    "----------------------------------------------------------",\par
10470                     i==nArg-1 ? rowSep : "  ");\par
10471           \}\par
10472         \}\par
10473       \}\par
10474       if( azArg==0 ) break;\par
10475       for(i=0; i<nArg; i++)\{\par
10476         int w;\par
10477         if( i<ArraySize(p->actualWidth) )\{\par
10478            w = p->actualWidth[i];\par
10479         \}else\{\par
10480            w = 10;\par
10481         \}\par
10482         if( p->cMode==MODE_Explain && azArg[i] && strlenChar(azArg[i])>w )\{\par
10483           w = strlenChar(azArg[i]);\par
10484         \}\par
10485         if( i==1 && p->aiIndent && p->pStmt )\{\par
10486           if( p->iIndent<p->nIndent )\{\par
10487             utf8_printf(p->out, "%*.s", p->aiIndent[p->iIndent], "");\par
10488           \}\par
10489           p->iIndent++;\par
10490         \}\par
10491         utf8_width_print(p->out, w, azArg[i] ? azArg[i] : p->nullValue);\par
10492         utf8_printf(p->out, "%s", i==nArg-1 ? rowSep : "  ");\par
10493       \}\par
10494       break;\par
10495     \}\par
10496     case MODE_Semi: \{   /* .schema and .fullschema output */\par
10497       printSchemaLine(p->out, azArg[0], ";\\n");\par
10498       break;\par
10499     \}\par
10500     case MODE_Pretty: \{  /* .schema and .fullschema with --indent */\par
10501       char *z;\par
10502       int j;\par
10503       int nParen = 0;\par
10504       char cEnd = 0;\par
10505       char c;\par
10506       int nLine = 0;\par
10507       assert( nArg==1 );\par
10508       if( azArg[0]==0 ) break;\par
10509       if( sqlite3_strlike("CREATE VIEW%", azArg[0], 0)==0\par
10510        || sqlite3_strlike("CREATE TRIG%", azArg[0], 0)==0\par
10511       )\{\par
10512         utf8_printf(p->out, "%s;\\n", azArg[0]);\par
10513         break;\par
10514       \}\par
10515       z = sqlite3_mprintf("%s", azArg[0]);\par
10516       j = 0;\par
10517       for(i=0; IsSpace(z[i]); i++)\{\}\par
10518       for(; (c = z[i])!=0; i++)\{\par
10519         if( IsSpace(c) )\{\par
10520           if( z[j-1]=='\\r' ) z[j-1] = '\\n';\par
10521           if( IsSpace(z[j-1]) || z[j-1]=='(' ) continue;\par
10522         \}else if( (c=='(' || c==')') && j>0 && IsSpace(z[j-1]) )\{\par
10523           j--;\par
10524         \}\par
10525         z[j++] = c;\par
10526       \}\par
10527       while( j>0 && IsSpace(z[j-1]) )\{ j--; \}\par
10528       z[j] = 0;\par
10529       if( strlen30(z)>=79 )\{\par
10530         for(i=j=0; (c = z[i])!=0; i++)\{ /* Copy from z[i] back to z[j] */\par
10531           if( c==cEnd )\{\par
10532             cEnd = 0;\par
10533           \}else if( c=='"' || c=='\\'' || c=='`' )\{\par
10534             cEnd = c;\par
10535           \}else if( c=='[' )\{\par
10536             cEnd = ']';\par
10537           \}else if( c=='-' && z[i+1]=='-' )\{\par
10538             cEnd = '\\n';\par
10539           \}else if( c=='(' )\{\par
10540             nParen++;\par
10541           \}else if( c==')' )\{\par
10542             nParen--;\par
10543             if( nLine>0 && nParen==0 && j>0 )\{\par
10544               printSchemaLineN(p->out, z, j, "\\n");\par
10545               j = 0;\par
10546             \}\par
10547           \}\par
10548           z[j++] = c;\par
10549           if( nParen==1 && cEnd==0\par
10550            && (c=='(' || c=='\\n' || (c==',' && !wsToEol(z+i+1)))\par
10551           )\{\par
10552             if( c=='\\n' ) j--;\par
10553             printSchemaLineN(p->out, z, j, "\\n  ");\par
10554             j = 0;\par
10555             nLine++;\par
10556             while( IsSpace(z[i+1]) )\{ i++; \}\par
10557           \}\par
10558         \}\par
10559         z[j] = 0;\par
10560       \}\par
10561       printSchemaLine(p->out, z, ";\\n");\par
10562       sqlite3_free(z);\par
10563       break;\par
10564     \}\par
10565     case MODE_List: \{\par
10566       if( p->cnt++==0 && p->showHeader )\{\par
10567         for(i=0; i<nArg; i++)\{\par
10568           utf8_printf(p->out,"%s%s",azCol[i],\par
10569                   i==nArg-1 ? p->rowSeparator : p->colSeparator);\par
10570         \}\par
10571       \}\par
10572       if( azArg==0 ) break;\par
10573       for(i=0; i<nArg; i++)\{\par
10574         char *z = azArg[i];\par
10575         if( z==0 ) z = p->nullValue;\par
10576         utf8_printf(p->out, "%s", z);\par
10577         if( i<nArg-1 )\{\par
10578           utf8_printf(p->out, "%s", p->colSeparator);\par
10579         \}else\{\par
10580           utf8_printf(p->out, "%s", p->rowSeparator);\par
10581         \}\par
10582       \}\par
10583       break;\par
10584     \}\par
10585     case MODE_Html: \{\par
10586       if( p->cnt++==0 && p->showHeader )\{\par
10587         raw_printf(p->out,"<TR>");\par
10588         for(i=0; i<nArg; i++)\{\par
10589           raw_printf(p->out,"<TH>");\par
10590           output_html_string(p->out, azCol[i]);\par
10591           raw_printf(p->out,"</TH>\\n");\par
10592         \}\par
10593         raw_printf(p->out,"</TR>\\n");\par
10594       \}\par
10595       if( azArg==0 ) break;\par
10596       raw_printf(p->out,"<TR>");\par
10597       for(i=0; i<nArg; i++)\{\par
10598         raw_printf(p->out,"<TD>");\par
10599         output_html_string(p->out, azArg[i] ? azArg[i] : p->nullValue);\par
10600         raw_printf(p->out,"</TD>\\n");\par
10601       \}\par
10602       raw_printf(p->out,"</TR>\\n");\par
10603       break;\par
10604     \}\par
10605     case MODE_Tcl: \{\par
10606       if( p->cnt++==0 && p->showHeader )\{\par
10607         for(i=0; i<nArg; i++)\{\par
10608           output_c_string(p->out,azCol[i] ? azCol[i] : "");\par
10609           if(i<nArg-1) utf8_printf(p->out, "%s", p->colSeparator);\par
10610         \}\par
10611         utf8_printf(p->out, "%s", p->rowSeparator);\par
10612       \}\par
10613       if( azArg==0 ) break;\par
10614       for(i=0; i<nArg; i++)\{\par
10615         output_c_string(p->out, azArg[i] ? azArg[i] : p->nullValue);\par
10616         if(i<nArg-1) utf8_printf(p->out, "%s", p->colSeparator);\par
10617       \}\par
10618       utf8_printf(p->out, "%s", p->rowSeparator);\par
10619       break;\par
10620     \}\par
10621     case MODE_Csv: \{\par
10622       setBinaryMode(p->out, 1);\par
10623       if( p->cnt++==0 && p->showHeader )\{\par
10624         for(i=0; i<nArg; i++)\{\par
10625           output_csv(p, azCol[i] ? azCol[i] : "", i<nArg-1);\par
10626         \}\par
10627         utf8_printf(p->out, "%s", p->rowSeparator);\par
10628       \}\par
10629       if( nArg>0 )\{\par
10630         for(i=0; i<nArg; i++)\{\par
10631           output_csv(p, azArg[i], i<nArg-1);\par
10632         \}\par
10633         utf8_printf(p->out, "%s", p->rowSeparator);\par
10634       \}\par
10635       setTextMode(p->out, 1);\par
10636       break;\par
10637     \}\par
10638     case MODE_Insert: \{\par
10639       if( azArg==0 ) break;\par
10640       utf8_printf(p->out,"INSERT INTO %s",p->zDestTable);\par
10641       if( p->showHeader )\{\par
10642         raw_printf(p->out,"(");\par
10643         for(i=0; i<nArg; i++)\{\par
10644           if( i>0 ) raw_printf(p->out, ",");\par
10645           if( quoteChar(azCol[i]) )\{\par
10646             char *z = sqlite3_mprintf("\\"%w\\"", azCol[i]);\par
10647             utf8_printf(p->out, "%s", z);\par
10648             sqlite3_free(z);\par
10649           \}else\{\par
10650             raw_printf(p->out, "%s", azCol[i]);\par
10651           \}\par
10652         \}\par
10653         raw_printf(p->out,")");\par
10654       \}\par
10655       p->cnt++;\par
10656       for(i=0; i<nArg; i++)\{\par
10657         raw_printf(p->out, i>0 ? "," : " VALUES(");\par
10658         if( (azArg[i]==0) || (aiType && aiType[i]==SQLITE_NULL) )\{\par
10659           utf8_printf(p->out,"NULL");\par
10660         \}else if( aiType && aiType[i]==SQLITE_TEXT )\{\par
10661           if( ShellHasFlag(p, SHFLG_Newlines) )\{\par
10662             output_quoted_string(p->out, azArg[i]);\par
10663           \}else\{\par
10664             output_quoted_escaped_string(p->out, azArg[i]);\par
10665           \}\par
10666         \}else if( aiType && aiType[i]==SQLITE_INTEGER )\{\par
10667           utf8_printf(p->out,"%s", azArg[i]);\par
10668         \}else if( aiType && aiType[i]==SQLITE_FLOAT )\{\par
10669           char z[50];\par
10670           double r = sqlite3_column_double(p->pStmt, i);\par
10671           sqlite3_uint64 ur;\par
10672           memcpy(&ur,&r,sizeof(r));\par
10673           if( ur==0x7ff0000000000000LL )\{\par
10674             raw_printf(p->out, "1e999");\par
10675           \}else if( ur==0xfff0000000000000LL )\{\par
10676             raw_printf(p->out, "-1e999");\par
10677           \}else\{\par
10678             sqlite3_snprintf(50,z,"%!.20g", r);\par
10679             raw_printf(p->out, "%s", z);\par
10680           \}\par
10681         \}else if( aiType && aiType[i]==SQLITE_BLOB && p->pStmt )\{\par
10682           const void *pBlob = sqlite3_column_blob(p->pStmt, i);\par
10683           int nBlob = sqlite3_column_bytes(p->pStmt, i);\par
10684           output_hex_blob(p->out, pBlob, nBlob);\par
10685         \}else if( isNumber(azArg[i], 0) )\{\par
10686           utf8_printf(p->out,"%s", azArg[i]);\par
10687         \}else if( ShellHasFlag(p, SHFLG_Newlines) )\{\par
10688           output_quoted_string(p->out, azArg[i]);\par
10689         \}else\{\par
10690           output_quoted_escaped_string(p->out, azArg[i]);\par
10691         \}\par
10692       \}\par
10693       raw_printf(p->out,");\\n");\par
10694       break;\par
10695     \}\par
10696     case MODE_Quote: \{\par
10697       if( azArg==0 ) break;\par
10698       if( p->cnt==0 && p->showHeader )\{\par
10699         for(i=0; i<nArg; i++)\{\par
10700           if( i>0 ) raw_printf(p->out, ",");\par
10701           output_quoted_string(p->out, azCol[i]);\par
10702         \}\par
10703         raw_printf(p->out,"\\n");\par
10704       \}\par
10705       p->cnt++;\par
10706       for(i=0; i<nArg; i++)\{\par
10707         if( i>0 ) raw_printf(p->out, ",");\par
10708         if( (azArg[i]==0) || (aiType && aiType[i]==SQLITE_NULL) )\{\par
10709           utf8_printf(p->out,"NULL");\par
10710         \}else if( aiType && aiType[i]==SQLITE_TEXT )\{\par
10711           output_quoted_string(p->out, azArg[i]);\par
10712         \}else if( aiType && aiType[i]==SQLITE_INTEGER )\{\par
10713           utf8_printf(p->out,"%s", azArg[i]);\par
10714         \}else if( aiType && aiType[i]==SQLITE_FLOAT )\{\par
10715           char z[50];\par
10716           double r = sqlite3_column_double(p->pStmt, i);\par
10717           sqlite3_snprintf(50,z,"%!.20g", r);\par
10718           raw_printf(p->out, "%s", z);\par
10719         \}else if( aiType && aiType[i]==SQLITE_BLOB && p->pStmt )\{\par
10720           const void *pBlob = sqlite3_column_blob(p->pStmt, i);\par
10721           int nBlob = sqlite3_column_bytes(p->pStmt, i);\par
10722           output_hex_blob(p->out, pBlob, nBlob);\par
10723         \}else if( isNumber(azArg[i], 0) )\{\par
10724           utf8_printf(p->out,"%s", azArg[i]);\par
10725         \}else\{\par
10726           output_quoted_string(p->out, azArg[i]);\par
10727         \}\par
10728       \}\par
10729       raw_printf(p->out,"\\n");\par
10730       break;\par
10731     \}\par
10732     case MODE_Ascii: \{\par
10733       if( p->cnt++==0 && p->showHeader )\{\par
10734         for(i=0; i<nArg; i++)\{\par
10735           if( i>0 ) utf8_printf(p->out, "%s", p->colSeparator);\par
10736           utf8_printf(p->out,"%s",azCol[i] ? azCol[i] : "");\par
10737         \}\par
10738         utf8_printf(p->out, "%s", p->rowSeparator);\par
10739       \}\par
10740       if( azArg==0 ) break;\par
10741       for(i=0; i<nArg; i++)\{\par
10742         if( i>0 ) utf8_printf(p->out, "%s", p->colSeparator);\par
10743         utf8_printf(p->out,"%s",azArg[i] ? azArg[i] : p->nullValue);\par
10744       \}\par
10745       utf8_printf(p->out, "%s", p->rowSeparator);\par
10746       break;\par
10747     \}\par
10748     case MODE_EQP: \{\par
10749       eqp_append(p, atoi(azArg[0]), atoi(azArg[1]), azArg[3]);\par
10750       break;\par
10751     \}\par
10752   \}\par
10753   return 0;\par
10754 \}\par
}
}
{\xe \v shell_dbinfo_command\:shell.c}
{\xe \v shell.c\:shell_dbinfo_command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int shell_dbinfo_command ({\b ShellState} *  {\i p}, int  {\i nArg}, char **  {\i azArg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13498 of file shell.c.}\par
{
References ArraySize, ShellState::db, db_int(), get2byteInt(), get4byteInt(), open_db(), ShellState::out, raw_printf, sqlite3_bind_text, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_compileoption_used, sqlite3_errmsg, sqlite3_file_control, sqlite3_finalize, sqlite3_free, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_step, SQLITE_FCNTL_DATA_VERSION, SQLITE_ROW, SQLITE_STATIC, utf8_printf, and zName.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13498                                                                       \{\par
13499   static const struct \{ const char *zName; int ofst; \} aField[] = \{\par
13500      \{ "file change counter:",  24  \},\par
13501      \{ "database page count:",  28  \},\par
13502      \{ "freelist page count:",  36  \},\par
13503      \{ "schema cookie:",        40  \},\par
13504      \{ "schema format:",        44  \},\par
13505      \{ "default cache size:",   48  \},\par
13506      \{ "autovacuum top root:",  52  \},\par
13507      \{ "incremental vacuum:",   64  \},\par
13508      \{ "text encoding:",        56  \},\par
13509      \{ "user version:",         60  \},\par
13510      \{ "application id:",       68  \},\par
13511      \{ "software version:",     96  \},\par
13512   \};\par
13513   static const struct \{ const char *zName; const char *zSql; \} aQuery[] = \{\par
13514      \{ "number of tables:",\par
13515        "SELECT count(*) FROM %s WHERE type='table'" \},\par
13516      \{ "number of indexes:",\par
13517        "SELECT count(*) FROM %s WHERE type='index'" \},\par
13518      \{ "number of triggers:",\par
13519        "SELECT count(*) FROM %s WHERE type='trigger'" \},\par
13520      \{ "number of views:",\par
13521        "SELECT count(*) FROM %s WHERE type='view'" \},\par
13522      \{ "schema size:",\par
13523        "SELECT total(length(sql)) FROM %s" \},\par
13524   \};\par
13525   int i, rc;\par
13526   unsigned iDataVersion;\par
13527   char *zSchemaTab;\par
13528   char *zDb = nArg>=2 ? azArg[1] : "main";\par
13529   sqlite3_stmt *pStmt = 0;\par
13530   unsigned char aHdr[100];\par
13531   open_db(p, 0);\par
13532   if( p->db==0 ) return 1;\par
13533   rc = sqlite3_prepare_v2(p->db,\par
13534              "SELECT data FROM sqlite_dbpage(?1) WHERE pgno=1",\par
13535              -1, &pStmt, 0);\par
13536   if( rc )\{\par
13537     if( !sqlite3_compileoption_used("ENABLE_DBPAGE_VTAB") )\{\par
13538       utf8_printf(stderr, "the \\".dbinfo\\" command requires the "\par
13539                           "-DSQLITE_ENABLE_DBPAGE_VTAB compile-time options\\n");\par
13540     \}else\{\par
13541       utf8_printf(stderr, "error: %s\\n", sqlite3_errmsg(p->db));\par
13542     \}\par
13543     sqlite3_finalize(pStmt);\par
13544     return 1;\par
13545   \}\par
13546   sqlite3_bind_text(pStmt, 1, zDb, -1, SQLITE_STATIC);\par
13547   if( sqlite3_step(pStmt)==SQLITE_ROW\par
13548    && sqlite3_column_bytes(pStmt,0)>100\par
13549   )\{\par
13550     memcpy(aHdr, sqlite3_column_blob(pStmt,0), 100);\par
13551     sqlite3_finalize(pStmt);\par
13552   \}else\{\par
13553     raw_printf(stderr, "unable to read database header\\n");\par
13554     sqlite3_finalize(pStmt);\par
13555     return 1;\par
13556   \}\par
13557   i = get2byteInt(aHdr+16);\par
13558   if( i==1 ) i = 65536;\par
13559   utf8_printf(p->out, "%-20s %d\\n", "database page size:", i);\par
13560   utf8_printf(p->out, "%-20s %d\\n", "write format:", aHdr[18]);\par
13561   utf8_printf(p->out, "%-20s %d\\n", "read format:", aHdr[19]);\par
13562   utf8_printf(p->out, "%-20s %d\\n", "reserved bytes:", aHdr[20]);\par
13563   for(i=0; i<ArraySize(aField); i++)\{\par
13564     int ofst = aField[i].ofst;\par
13565     unsigned int val = get4byteInt(aHdr + ofst);\par
13566     utf8_printf(p->out, "%-20s %u", aField[i].zName, val);\par
13567     switch( ofst )\{\par
13568       case 56: \{\par
13569         if( val==1 ) raw_printf(p->out, " (utf8)");\par
13570         if( val==2 ) raw_printf(p->out, " (utf16le)");\par
13571         if( val==3 ) raw_printf(p->out, " (utf16be)");\par
13572       \}\par
13573     \}\par
13574     raw_printf(p->out, "\\n");\par
13575   \}\par
13576   if( zDb==0 )\{\par
13577     zSchemaTab = sqlite3_mprintf("main.sqlite_master");\par
13578   \}else if( strcmp(zDb,"temp")==0 )\{\par
13579     zSchemaTab = sqlite3_mprintf("%s", "sqlite_temp_master");\par
13580   \}else\{\par
13581     zSchemaTab = sqlite3_mprintf("\\"%w\\".sqlite_master", zDb);\par
13582   \}\par
13583   for(i=0; i<ArraySize(aQuery); i++)\{\par
13584     char *zSql = sqlite3_mprintf(aQuery[i].zSql, zSchemaTab);\par
13585     int val = db_int(p, zSql);\par
13586     sqlite3_free(zSql);\par
13587     utf8_printf(p->out, "%-20s %d\\n", aQuery[i].zName, val);\par
13588   \}\par
13589   sqlite3_free(zSchemaTab);\par
13590   sqlite3_file_control(p->db, zDb, SQLITE_FCNTL_DATA_VERSION, &iDataVersion);\par
13591   utf8_printf(p->out, "%-20s %u\\n", "data version", iDataVersion);\par
13592   return 0;\par
13593 \}\par
}
}
{\xe \v shell_exec\:shell.c}
{\xe \v shell.c\:shell_exec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int shell_exec ({\b ShellState} *  {\i pArg}, const char *  {\i zSql}, char **  {\i pzErrMsg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11590 of file shell.c.}\par
{
References ShellState::autoEQP, AUTOEQP_full, AUTOEQP_trigger, ShellState::autoExplain, bind_prepared_stmt(), ShellState::cMode, ShellState::cnt, ShellState::db, disable_debug_trace_modes(), display_scanstats(), display_stats(), eqp_append(), eqp_render(), exec_prepared_stmt(), ShellState::expert, expertFinish(), expertHandleSQL(), explain_data_delete(), explain_data_prepare(), IsSpace, ShellState::mode, MODE_EQP, MODE_Explain, ShellState::out, ExpertInfo::pExpert, ShellState::pStmt, restore_debug_trace_modes(), save_err_msg(), ShellState::scanstatsOn, ShellHasFlag, SHFLG_Echo, sqlite3_column_int, sqlite3_column_text, sqlite3_db_config, sqlite3_finalize, sqlite3_free, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_sql, sqlite3_step, sqlite3_stmt_isexplain, SQLITE_DBCONFIG_TRIGGER_EQP, SQLITE_NOMEM, SQLITE_OK, SQLITE_ROW, ShellState::statsOn, and utf8_printf.}\par
{
Referenced by do_meta_command(), dump_callback(), main(), and runOneSqlLine().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11594  \{\par
11595   sqlite3_stmt *pStmt = NULL;     /* Statement to execute. */\par
11596   int rc = SQLITE_OK;             /* Return Code */\par
11597   int rc2;\par
11598   const char *zLeftover;          /* Tail of unprocessed SQL */\par
11599   sqlite3 *db = pArg->db;\par
11600 \par
11601   if( pzErrMsg )\{\par
11602     *pzErrMsg = NULL;\par
11603   \}\par
11604 \par
11605 #ifndef SQLITE_OMIT_VIRTUALTABLE\par
11606   if( pArg->expert.pExpert )\{\par
11607     rc = expertHandleSQL(pArg, zSql, pzErrMsg);\par
11608     return expertFinish(pArg, (rc!=SQLITE_OK), pzErrMsg);\par
11609   \}\par
11610 #endif\par
11611 \par
11612   while( zSql[0] && (SQLITE_OK == rc) )\{\par
11613     static const char *zStmtSql;\par
11614     rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);\par
11615     if( SQLITE_OK != rc )\{\par
11616       if( pzErrMsg )\{\par
11617         *pzErrMsg = save_err_msg(db);\par
11618       \}\par
11619     \}else\{\par
11620       if( !pStmt )\{\par
11621         /* this happens for a comment or white-space */\par
11622         zSql = zLeftover;\par
11623         while( IsSpace(zSql[0]) ) zSql++;\par
11624         continue;\par
11625       \}\par
11626       zStmtSql = sqlite3_sql(pStmt);\par
11627       if( zStmtSql==0 ) zStmtSql = "";\par
11628       while( IsSpace(zStmtSql[0]) ) zStmtSql++;\par
11629 \par
11630       /* save off the prepared statment handle and reset row count */\par
11631       if( pArg )\{\par
11632         pArg->pStmt = pStmt;\par
11633         pArg->cnt = 0;\par
11634       \}\par
11635 \par
11636       /* echo the sql statement if echo on */\par
11637       if( pArg && ShellHasFlag(pArg, SHFLG_Echo) )\{\par
11638         utf8_printf(pArg->out, "%s\\n", zStmtSql ? zStmtSql : zSql);\par
11639       \}\par
11640 \par
11641       /* Show the EXPLAIN QUERY PLAN if .eqp is on */\par
11642       if( pArg && pArg->autoEQP && sqlite3_stmt_isexplain(pStmt)==0 )\{\par
11643         sqlite3_stmt *pExplain;\par
11644         char *zEQP;\par
11645         int triggerEQP = 0;\par
11646         disable_debug_trace_modes();\par
11647         sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, -1, &triggerEQP);\par
11648         if( pArg->autoEQP>=AUTOEQP_trigger )\{\par
11649           sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, 1, 0);\par
11650         \}\par
11651         zEQP = sqlite3_mprintf("EXPLAIN QUERY PLAN %s", zStmtSql);\par
11652         rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);\par
11653         if( rc==SQLITE_OK )\{\par
11654           while( sqlite3_step(pExplain)==SQLITE_ROW )\{\par
11655             const char *zEQPLine = (const char*)sqlite3_column_text(pExplain,3);\par
11656             int iEqpId = sqlite3_column_int(pExplain, 0);\par
11657             int iParentId = sqlite3_column_int(pExplain, 1);\par
11658             if( zEQPLine[0]=='-' ) eqp_render(pArg);\par
11659             eqp_append(pArg, iEqpId, iParentId, zEQPLine);\par
11660           \}\par
11661           eqp_render(pArg);\par
11662         \}\par
11663         sqlite3_finalize(pExplain);\par
11664         sqlite3_free(zEQP);\par
11665         if( pArg->autoEQP>=AUTOEQP_full )\{\par
11666           /* Also do an EXPLAIN for ".eqp full" mode */\par
11667           zEQP = sqlite3_mprintf("EXPLAIN %s", zStmtSql);\par
11668           rc = sqlite3_prepare_v2(db, zEQP, -1, &pExplain, 0);\par
11669           if( rc==SQLITE_OK )\{\par
11670             pArg->cMode = MODE_Explain;\par
11671             explain_data_prepare(pArg, pExplain);\par
11672             exec_prepared_stmt(pArg, pExplain);\par
11673             explain_data_delete(pArg);\par
11674           \}\par
11675           sqlite3_finalize(pExplain);\par
11676           sqlite3_free(zEQP);\par
11677         \}\par
11678         if( pArg->autoEQP>=AUTOEQP_trigger && triggerEQP==0 )\{\par
11679           sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, 0, 0);\par
11680           /* Reprepare pStmt before reactiving trace modes */\par
11681           sqlite3_finalize(pStmt);\par
11682           sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\par
11683           if( pArg ) pArg->pStmt = pStmt;\par
11684         \}\par
11685         restore_debug_trace_modes();\par
11686       \}\par
11687 \par
11688       if( pArg )\{\par
11689         pArg->cMode = pArg->mode;\par
11690         if( pArg->autoExplain )\{\par
11691           if( sqlite3_stmt_isexplain(pStmt)==1 )\{\par
11692             pArg->cMode = MODE_Explain;\par
11693           \}\par
11694           if( sqlite3_stmt_isexplain(pStmt)==2 )\{\par
11695             pArg->cMode = MODE_EQP;\par
11696           \}\par
11697         \}\par
11698 \par
11699         /* If the shell is currently in ".explain" mode, gather the extra\par
11700         ** data required to add indents to the output.*/\par
11701         if( pArg->cMode==MODE_Explain )\{\par
11702           explain_data_prepare(pArg, pStmt);\par
11703         \}\par
11704       \}\par
11705 \par
11706       bind_prepared_stmt(pArg, pStmt);\par
11707       exec_prepared_stmt(pArg, pStmt);\par
11708       explain_data_delete(pArg);\par
11709       eqp_render(pArg);\par
11710 \par
11711       /* print usage stats if stats on */\par
11712       if( pArg && pArg->statsOn )\{\par
11713         display_stats(db, pArg, 0);\par
11714       \}\par
11715 \par
11716       /* print loop-counters if required */\par
11717       if( pArg && pArg->scanstatsOn )\{\par
11718         display_scanstats(db, pArg);\par
11719       \}\par
11720 \par
11721       /* Finalize the statement just executed. If this fails, save a\par
11722       ** copy of the error message. Otherwise, set zSql to point to the\par
11723       ** next statement to execute. */\par
11724       rc2 = sqlite3_finalize(pStmt);\par
11725       if( rc!=SQLITE_NOMEM ) rc = rc2;\par
11726       if( rc==SQLITE_OK )\{\par
11727         zSql = zLeftover;\par
11728         while( IsSpace(zSql[0]) ) zSql++;\par
11729       \}else if( pzErrMsg )\{\par
11730         *pzErrMsg = save_err_msg(db);\par
11731       \}\par
11732 \par
11733       /* clear saved stmt handle */\par
11734       if( pArg )\{\par
11735         pArg->pStmt = NULL;\par
11736       \}\par
11737     \}\par
11738   \} /* end while */\par
11739 \par
11740   return rc;\par
11741 \}\par
}
}
{\xe \v shell_out_of_memory\:shell.c}
{\xe \v shell.c\:shell_out_of_memory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void shell_out_of_memory (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 464 of file shell.c.}\par
{
References raw_printf, sqlite3_free, sqlite3_vmprintf, SQLITE_CDECL, and utf8_printf.}\par
{
Referenced by appendText(), do_meta_command(), eqp_append(), explain_data_prepare(), import_append_char(), local_getline(), main(), process_input(), set_table_name(), tableColumnList(), and tryToCloneData().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   464                                      \{\par
  465   raw_printf(stderr,"Error: out of memory\\n");\par
  466   exit(1);\par
  467 \}\par
}
}
{\xe \v shellAddSchemaName\:shell.c}
{\xe \v shell.c\:shellAddSchemaName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void shellAddSchemaName ({\b sqlite3_context} *  {\i pCtx}, int  {\i nVal}, {\b sqlite3_value} **  {\i apVal}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 889 of file shell.c.}\par
{
References aPrefix, quoteChar(), shellFakeSchema(), sqlite3_context_db_handle, sqlite3_free, sqlite3_mprintf, sqlite3_result_text, sqlite3_result_value, sqlite3_stricmp, sqlite3_value_text, strlen30(), UNUSED_PARAMETER, and zName.}\par
{
Referenced by open_db().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   893  \{\par
  894   static const char *aPrefix[] = \{\par
  895      "TABLE",\par
  896      "INDEX",\par
  897      "UNIQUE INDEX",\par
  898      "VIEW",\par
  899      "TRIGGER",\par
  900      "VIRTUAL TABLE"\par
  901   \};\par
  902   int i = 0;\par
  903   const char *zIn = (const char*)sqlite3_value_text(apVal[0]);\par
  904   const char *zSchema = (const char*)sqlite3_value_text(apVal[1]);\par
  905   const char *zName = (const char*)sqlite3_value_text(apVal[2]);\par
  906   sqlite3 *db = sqlite3_context_db_handle(pCtx);\par
  907   UNUSED_PARAMETER(nVal);\par
  908   if( zIn!=0 && strncmp(zIn, "CREATE ", 7)==0 )\{\par
  909     for(i=0; i<(int)(sizeof(aPrefix)/sizeof(aPrefix[0])); i++)\{\par
  910       int n = strlen30(aPrefix[i]);\par
  911       if( strncmp(zIn+7, aPrefix[i], n)==0 && zIn[n+7]==' ' )\{\par
  912         char *z = 0;\par
  913         char *zFake = 0;\par
  914         if( zSchema )\{\par
  915           char cQuote = quoteChar(zSchema);\par
  916           if( cQuote && sqlite3_stricmp(zSchema,"temp")!=0 )\{\par
  917             z = sqlite3_mprintf("%.*s \\"%w\\".%s", n+7, zIn, zSchema, zIn+n+8);\par
  918           \}else\{\par
  919             z = sqlite3_mprintf("%.*s %s.%s", n+7, zIn, zSchema, zIn+n+8);\par
  920           \}\par
  921         \}\par
  922         if( zName\par
  923          && aPrefix[i][0]=='V'\par
  924          && (zFake = shellFakeSchema(db, zSchema, zName))!=0\par
  925         )\{\par
  926           if( z==0 )\{\par
  927             z = sqlite3_mprintf("%s\\n/* %s */", zIn, zFake);\par
  928           \}else\{\par
  929             z = sqlite3_mprintf("%z\\n/* %s */", z, zFake);\par
  930           \}\par
  931           free(zFake);\par
  932         \}\par
  933         if( z )\{\par
  934           sqlite3_result_text(pCtx, z, -1, sqlite3_free);\par
  935           return;\par
  936         \}\par
  937       \}\par
  938     \}\par
  939   \}\par
  940   sqlite3_result_value(pCtx, apVal[0]);\par
  941 \}\par
}
}
{\xe \v shellAuth\:shell.c}
{\xe \v shell.c\:shellAuth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int shellAuth (void *  {\i pClientData}, int  {\i op}, const char *  {\i zA1}, const char *  {\i zA2}, const char *  {\i zA3}, const char *  {\i zA4}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10201 of file shell.c.}\par
{
References ShellState::out, output_c_string(), raw_printf, SQLITE_OK, and utf8_printf.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10208  \{\par
10209   ShellState *p = (ShellState*)pClientData;\par
10210   static const char *azAction[] = \{ 0,\par
10211      "CREATE_INDEX",         "CREATE_TABLE",         "CREATE_TEMP_INDEX",\par
10212      "CREATE_TEMP_TABLE",    "CREATE_TEMP_TRIGGER",  "CREATE_TEMP_VIEW",\par
10213      "CREATE_TRIGGER",       "CREATE_VIEW",          "DELETE",\par
10214      "DROP_INDEX",           "DROP_TABLE",           "DROP_TEMP_INDEX",\par
10215      "DROP_TEMP_TABLE",      "DROP_TEMP_TRIGGER",    "DROP_TEMP_VIEW",\par
10216      "DROP_TRIGGER",         "DROP_VIEW",            "INSERT",\par
10217      "PRAGMA",               "READ",                 "SELECT",\par
10218      "TRANSACTION",          "UPDATE",               "ATTACH",\par
10219      "DETACH",               "ALTER_TABLE",          "REINDEX",\par
10220      "ANALYZE",              "CREATE_VTABLE",        "DROP_VTABLE",\par
10221      "FUNCTION",             "SAVEPOINT",            "RECURSIVE"\par
10222   \};\par
10223   int i;\par
10224   const char *az[4];\par
10225   az[0] = zA1;\par
10226   az[1] = zA2;\par
10227   az[2] = zA3;\par
10228   az[3] = zA4;\par
10229   utf8_printf(p->out, "authorizer: %s", azAction[op]);\par
10230   for(i=0; i<4; i++)\{\par
10231     raw_printf(p->out, " ");\par
10232     if( az[i] )\{\par
10233       output_c_string(p->out, az[i]);\par
10234     \}else\{\par
10235       raw_printf(p->out, "NULL");\par
10236     \}\par
10237   \}\par
10238   raw_printf(p->out, "\\n");\par
10239   return SQLITE_OK;\par
10240 \}\par
}
}
{\xe \v shellDatabaseError\:shell.c}
{\xe \v shell.c\:shellDatabaseError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int shellDatabaseError ({\b sqlite3} *  {\i db}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13598 of file shell.c.}\par
{
References sqlite3_errmsg, and utf8_printf.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13598                                           \{\par
13599   const char *zErr = sqlite3_errmsg(db);\par
13600   utf8_printf(stderr, "Error: %s\\n", zErr);\par
13601   return 1;\par
13602 \}\par
}
}
{\xe \v shellDeleteFile\:shell.c}
{\xe \v shell.c\:shellDeleteFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int shellDeleteFile (const char *  {\i zFilename})}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13716 of file shell.c.}\par
{
References sqlite3_free.}\par
{
Referenced by clearTempFile(), and do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13716                                           \{\par
13717   int rc;\par
13718 #ifdef _WIN32\par
13719   wchar_t *z = sqlite3_win32_utf8_to_unicode(zFilename);\par
13720   rc = _wunlink(z);\par
13721   sqlite3_free(z);\par
13722 #else\par
13723   rc = unlink(zFilename);\par
13724 #endif\par
13725   return rc;\par
13726 \}\par
}
}
{\xe \v shellEscapeCrnl\:shell.c}
{\xe \v shell.c\:shellEscapeCrnl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void shellEscapeCrnl ({\b sqlite3_context} *  {\i context}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12592 of file shell.c.}\par
{
References sqlite3_free, sqlite3_malloc64, sqlite3_result_error_nomem, sqlite3_result_text, sqlite3_result_value, sqlite3_value_bytes, sqlite3_value_text, SQLITE_TRANSIENT, UNUSED_PARAMETER, and unused_string().}\par
{
Referenced by open_db().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12596  \{\par
12597   const char *zText = (const char*)sqlite3_value_text(argv[0]);\par
12598   UNUSED_PARAMETER(argc);\par
12599   if( zText[0]=='\\'' )\{\par
12600     int nText = sqlite3_value_bytes(argv[0]);\par
12601     int i;\par
12602     char zBuf1[20];\par
12603     char zBuf2[20];\par
12604     const char *zNL = 0;\par
12605     const char *zCR = 0;\par
12606     int nCR = 0;\par
12607     int nNL = 0;\par
12608 \par
12609     for(i=0; zText[i]; i++)\{\par
12610       if( zNL==0 && zText[i]=='\\n' )\{\par
12611         zNL = unused_string(zText, "\\\\n", "\\\\012", zBuf1);\par
12612         nNL = (int)strlen(zNL);\par
12613       \}\par
12614       if( zCR==0 && zText[i]=='\\r' )\{\par
12615         zCR = unused_string(zText, "\\\\r", "\\\\015", zBuf2);\par
12616         nCR = (int)strlen(zCR);\par
12617       \}\par
12618     \}\par
12619 \par
12620     if( zNL || zCR )\{\par
12621       int iOut = 0;\par
12622       i64 nMax = (nNL > nCR) ? nNL : nCR;\par
12623       i64 nAlloc = nMax * nText + (nMax+64)*2;\par
12624       char *zOut = (char*)sqlite3_malloc64(nAlloc);\par
12625       if( zOut==0 )\{\par
12626         sqlite3_result_error_nomem(context);\par
12627         return;\par
12628       \}\par
12629 \par
12630       if( zNL && zCR )\{\par
12631         memcpy(&zOut[iOut], "replace(replace(", 16);\par
12632         iOut += 16;\par
12633       \}else\{\par
12634         memcpy(&zOut[iOut], "replace(", 8);\par
12635         iOut += 8;\par
12636       \}\par
12637       for(i=0; zText[i]; i++)\{\par
12638         if( zText[i]=='\\n' )\{\par
12639           memcpy(&zOut[iOut], zNL, nNL);\par
12640           iOut += nNL;\par
12641         \}else if( zText[i]=='\\r' )\{\par
12642           memcpy(&zOut[iOut], zCR, nCR);\par
12643           iOut += nCR;\par
12644         \}else\{\par
12645           zOut[iOut] = zText[i];\par
12646           iOut++;\par
12647         \}\par
12648       \}\par
12649 \par
12650       if( zNL )\{\par
12651         memcpy(&zOut[iOut], ",'", 2); iOut += 2;\par
12652         memcpy(&zOut[iOut], zNL, nNL); iOut += nNL;\par
12653         memcpy(&zOut[iOut], "', char(10))", 12); iOut += 12;\par
12654       \}\par
12655       if( zCR )\{\par
12656         memcpy(&zOut[iOut], ",'", 2); iOut += 2;\par
12657         memcpy(&zOut[iOut], zCR, nCR); iOut += nCR;\par
12658         memcpy(&zOut[iOut], "', char(13))", 12); iOut += 12;\par
12659       \}\par
12660 \par
12661       sqlite3_result_text(context, zOut, iOut, SQLITE_TRANSIENT);\par
12662       sqlite3_free(zOut);\par
12663       return;\par
12664     \}\par
12665   \}\par
12666 \par
12667   sqlite3_result_value(context, argv[0]);\par
12668 \}\par
}
}
{\xe \v shellFakeSchema\:shell.c}
{\xe \v shell.c\:shellFakeSchema}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char* shellFakeSchema ({\b sqlite3} *  {\i db}, const char *  {\i zSchema}, const char *  {\i zName}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 807 of file shell.c.}\par
{
References appendText(), freeText(), initText(), quoteChar(), sqlite3_column_text, sqlite3_finalize, sqlite3_free, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_step, sqlite3_stricmp, SQLITE_ROW, and ShellText::z.}\par
{
Referenced by shellAddSchemaName(), and shellModuleSchema().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   811  \{\par
  812   sqlite3_stmt *pStmt = 0;\par
  813   char *zSql;\par
  814   ShellText s;\par
  815   char cQuote;\par
  816   char *zDiv = "(";\par
  817   int nRow = 0;\par
  818 \par
  819   zSql = sqlite3_mprintf("PRAGMA \\"%w\\".table_info=%Q;",\par
  820                          zSchema ? zSchema : "main", zName);\par
  821   sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\par
  822   sqlite3_free(zSql);\par
  823   initText(&s);\par
  824   if( zSchema )\{\par
  825     cQuote = quoteChar(zSchema);\par
  826     if( cQuote && sqlite3_stricmp(zSchema,"temp")==0 ) cQuote = 0;\par
  827     appendText(&s, zSchema, cQuote);\par
  828     appendText(&s, ".", 0);\par
  829   \}\par
  830   cQuote = quoteChar(zName);\par
  831   appendText(&s, zName, cQuote);\par
  832   while( sqlite3_step(pStmt)==SQLITE_ROW )\{\par
  833     const char *zCol = (const char*)sqlite3_column_text(pStmt, 1);\par
  834     nRow++;\par
  835     appendText(&s, zDiv, 0);\par
  836     zDiv = ",";\par
  837     cQuote = quoteChar(zCol);\par
  838     appendText(&s, zCol, cQuote);\par
  839   \}\par
  840   appendText(&s, ")", 0);\par
  841   sqlite3_finalize(pStmt);\par
  842   if( nRow==0 )\{\par
  843     freeText(&s);\par
  844     s.z = 0;\par
  845   \}\par
  846   return s.z;\par
  847 \}\par
}
}
{\xe \v shellFinalize\:shell.c}
{\xe \v shell.c\:shellFinalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void shellFinalize (int *  {\i pRc}, {\b sqlite3_stmt} *  {\i pStmt})}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14068 of file shell.c.}\par
{
References raw_printf, sqlite3_db_handle, sqlite3_errmsg, sqlite3_finalize, and SQLITE_OK.}\par
{
Referenced by shellReset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14071  \{\par
14072   if( pStmt )\{\par
14073     sqlite3 *db = sqlite3_db_handle(pStmt);\par
14074     int rc = sqlite3_finalize(pStmt);\par
14075     if( *pRc==SQLITE_OK )\{\par
14076       if( rc!=SQLITE_OK )\{\par
14077         raw_printf(stderr, "SQL error: %s\\n", sqlite3_errmsg(db));\par
14078       \}\par
14079       *pRc = rc;\par
14080     \}\par
14081   \}\par
14082 \}\par
}
}
{\xe \v shellFkeyCollateClause\:shell.c}
{\xe \v shell.c\:shellFkeyCollateClause}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void shellFkeyCollateClause ({\b sqlite3_context} *  {\i pCtx}, int  {\i nVal}, {\b sqlite3_value} **  {\i apVal}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13779 of file shell.c.}\par
{
References sqlite3_context_db_handle, sqlite3_free, sqlite3_mprintf, sqlite3_result_text, sqlite3_stricmp, sqlite3_table_column_metadata, sqlite3_value_text, SQLITE_OK, SQLITE_STATIC, and SQLITE_TRANSIENT.}\par
{
Referenced by lintFkeyIndexes().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13783  \{\par
13784   sqlite3 *db = sqlite3_context_db_handle(pCtx);\par
13785   const char *zParent;\par
13786   const char *zParentCol;\par
13787   const char *zParentSeq;\par
13788   const char *zChild;\par
13789   const char *zChildCol;\par
13790   const char *zChildSeq = 0;  /* Initialize to avoid false-positive warning */\par
13791   int rc;\par
13792 \par
13793   assert( nVal==4 );\par
13794   zParent = (const char*)sqlite3_value_text(apVal[0]);\par
13795   zParentCol = (const char*)sqlite3_value_text(apVal[1]);\par
13796   zChild = (const char*)sqlite3_value_text(apVal[2]);\par
13797   zChildCol = (const char*)sqlite3_value_text(apVal[3]);\par
13798 \par
13799   sqlite3_result_text(pCtx, "", -1, SQLITE_STATIC);\par
13800   rc = sqlite3_table_column_metadata(\par
13801       db, "main", zParent, zParentCol, 0, &zParentSeq, 0, 0, 0\par
13802   );\par
13803   if( rc==SQLITE_OK )\{\par
13804     rc = sqlite3_table_column_metadata(\par
13805         db, "main", zChild, zChildCol, 0, &zChildSeq, 0, 0, 0\par
13806     );\par
13807   \}\par
13808 \par
13809   if( rc==SQLITE_OK && sqlite3_stricmp(zParentSeq, zChildSeq) )\{\par
13810     char *z = sqlite3_mprintf(" COLLATE %s", zParentSeq);\par
13811     sqlite3_result_text(pCtx, z, -1, SQLITE_TRANSIENT);\par
13812     sqlite3_free(z);\par
13813   \}\par
13814 \}\par
}
}
{\xe \v shellIdQuote\:shell.c}
{\xe \v shell.c\:shellIdQuote}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void shellIdQuote ({\b sqlite3_context} *  {\i context}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12566 of file shell.c.}\par
{
References sqlite3_free, sqlite3_mprintf, sqlite3_result_text, sqlite3_value_text, and UNUSED_PARAMETER.}\par
{
Referenced by open_db(), and shellReset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12570  \{\par
12571   const char *zName = (const char*)sqlite3_value_text(argv[0]);\par
12572   UNUSED_PARAMETER(argc);\par
12573   if( zName )\{\par
12574     char *z = sqlite3_mprintf("\\"%w\\"", zName);\par
12575     sqlite3_result_text(context, z, -1, sqlite3_free);\par
12576   \}\par
12577 \}\par
}
}
{\xe \v shellInt32\:shell.c}
{\xe \v shell.c\:shellInt32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void shellInt32 ({\b sqlite3_context} *  {\i context}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12538 of file shell.c.}\par
{
References sqlite3_result_int64, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_int, and UNUSED_PARAMETER.}\par
{
Referenced by open_db().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12542  \{\par
12543   const unsigned char *pBlob;\par
12544   int nBlob;\par
12545   int iInt;\par
12546 \par
12547   UNUSED_PARAMETER(argc);\par
12548   nBlob = sqlite3_value_bytes(argv[0]);\par
12549   pBlob = (const unsigned char*)sqlite3_value_blob(argv[0]);\par
12550   iInt = sqlite3_value_int(argv[1]);\par
12551 \par
12552   if( iInt>=0 && (iInt+1)*4<=nBlob )\{\par
12553     const unsigned char *a = &pBlob[iInt*4];\par
12554     sqlite3_int64 iVal = ((sqlite3_int64)a[0]<<24)\par
12555                        + ((sqlite3_int64)a[1]<<16)\par
12556                        + ((sqlite3_int64)a[2]<< 8)\par
12557                        + ((sqlite3_int64)a[3]<< 0);\par
12558     sqlite3_result_int64(context, iVal);\par
12559   \}\par
12560 \}\par
}
}
{\xe \v shellLog\:shell.c}
{\xe \v shell.c\:shellLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void shellLog (void *  {\i pArg}, int  {\i iErrCode}, const char *  {\i zMsg}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9732 of file shell.c.}\par
{
References ShellState::pLog, and utf8_printf.}\par
{
Referenced by main_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9732                                                                 \{\par
 9733   ShellState *p = (ShellState*)pArg;\par
 9734   if( p->pLog==0 ) return;\par
 9735   utf8_printf(p->pLog, "(%d) %s\\n", iErrCode, zMsg);\par
 9736   fflush(p->pLog);\par
 9737 \}\par
}
}
{\xe \v shellModuleSchema\:shell.c}
{\xe \v shell.c\:shellModuleSchema}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void shellModuleSchema ({\b sqlite3_context} *  {\i pCtx}, int  {\i nVal}, {\b sqlite3_value} **  {\i apVal}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 855 of file shell.c.}\par
{
References shellFakeSchema(), sqlite3_context_db_handle, sqlite3_free, sqlite3_mprintf, sqlite3_result_text, sqlite3_value_text, UNUSED_PARAMETER, and zName.}\par
{
Referenced by open_db().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   859  \{\par
  860   const char *zName = (const char*)sqlite3_value_text(apVal[0]);\par
  861   char *zFake = shellFakeSchema(sqlite3_context_db_handle(pCtx), 0, zName);\par
  862   UNUSED_PARAMETER(nVal);\par
  863   if( zFake )\{\par
  864     sqlite3_result_text(pCtx, sqlite3_mprintf("/* %s */", zFake),\par
  865                         -1, sqlite3_free);\par
  866     free(zFake);\par
  867   \}\par
  868 \}\par
}
}
{\xe \v shellPrepare\:shell.c}
{\xe \v shell.c\:shellPrepare}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void shellPrepare ({\b sqlite3} *  {\i db}, int *  {\i pRc}, const char *  {\i zSql}, {\b sqlite3_stmt} **  {\i ppStmt}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14014 of file shell.c.}\par
{
References raw_printf, sqlite3_errcode, sqlite3_errmsg, sqlite3_prepare_v2, and SQLITE_OK.}\par
{
Referenced by shellPreparePrintf(), and shellReset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14019  \{\par
14020   *ppStmt = 0;\par
14021   if( *pRc==SQLITE_OK )\{\par
14022     int rc = sqlite3_prepare_v2(db, zSql, -1, ppStmt, 0);\par
14023     if( rc!=SQLITE_OK )\{\par
14024       raw_printf(stderr, "sql error: %s (%d)\\n", \par
14025           sqlite3_errmsg(db), sqlite3_errcode(db)\par
14026       );\par
14027       *pRc = rc;\par
14028     \}\par
14029   \}\par
14030 \}\par
}
}
{\xe \v shellPreparePrintf\:shell.c}
{\xe \v shell.c\:shellPreparePrintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void shellPreparePrintf ({\b sqlite3} *  {\i db}, int *  {\i pRc}, {\b sqlite3_stmt} **  {\i ppStmt}, const char *  {\i zFmt},   {\i ...})}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14039 of file shell.c.}\par
{
References shellPrepare(), sqlite3_free, sqlite3_vmprintf, SQLITE_NOMEM, and SQLITE_OK.}\par
{
Referenced by shellReset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14045  \{\par
14046   *ppStmt = 0;\par
14047   if( *pRc==SQLITE_OK )\{\par
14048     va_list ap;\par
14049     char *z;\par
14050     va_start(ap, zFmt);\par
14051     z = sqlite3_vmprintf(zFmt, ap);\par
14052     va_end(ap);\par
14053     if( z==0 )\{\par
14054       *pRc = SQLITE_NOMEM;\par
14055     \}else\{\par
14056       shellPrepare(db, pRc, z, ppStmt);\par
14057       sqlite3_free(z);\par
14058     \}\par
14059   \}\par
14060 \}\par
}
}
{\xe \v shellPutsFunc\:shell.c}
{\xe \v shell.c\:shellPutsFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void shellPutsFunc ({\b sqlite3_context} *  {\i pCtx}, int  {\i nVal}, {\b sqlite3_value} **  {\i apVal}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9745 of file shell.c.}\par
{
References ShellState::out, sqlite3_result_value, sqlite3_user_data, sqlite3_value_text, and utf8_printf.}\par
{
Referenced by open_db(), and shellReset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9749  \{\par
 9750   ShellState *p = (ShellState*)sqlite3_user_data(pCtx);\par
 9751   (void)nVal;\par
 9752   utf8_printf(p->out, "%s\\n", sqlite3_value_text(apVal[0]));\par
 9753   sqlite3_result_value(pCtx, apVal[0]);\par
 9754 \}\par
}
}
{\xe \v shellReset\:shell.c}
{\xe \v shell.c\:shellReset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void shellReset (int *  {\i pRc}, {\b sqlite3_stmt} *  {\i pStmt})}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14090 of file shell.c.}\par
{
References close_db(), ShellState::db, deduceDatabaseType(), ShellState::openMode, ShellState::out, raw_printf, SHELL_OPEN_APPENDVFS, SHELL_OPEN_UNSPEC, SHELL_OPEN_ZIPFILE, shellFinalize(), shellIdQuote(), shellPrepare(), shellPreparePrintf(), shellPutsFunc(), showHelp(), sqlite3_bind_int, sqlite3_bind_parameter_index, sqlite3_bind_text, sqlite3_close, sqlite3_column_int, sqlite3_column_text, sqlite3_create_function, sqlite3_db_handle, sqlite3_errmsg, sqlite3_exec, sqlite3_fileio_init(), sqlite3_free, sqlite3_malloc64, sqlite3_mprintf, sqlite3_open, sqlite3_open_v2, sqlite3_randomness, sqlite3_reset, sqlite3_snprintf, sqlite3_sql, sqlite3_step, sqlite3_stricmp, sqlite3_strnicmp, sqlite3_table_column_metadata, sqlite3_vmprintf, SQLITE_ERROR, SQLITE_NOMEM, SQLITE_OK, SQLITE_OPEN_CREATE, SQLITE_OPEN_READONLY, SQLITE_OPEN_READWRITE, SQLITE_ROW, SQLITE_STATIC, SQLITE_TRANSIENT, SQLITE_UTF8, strlen30(), and utf8_printf.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 14093  \{\par
14094   int rc = sqlite3_reset(pStmt);\par
14095   if( *pRc==SQLITE_OK )\{\par
14096     if( rc!=SQLITE_OK )\{\par
14097       sqlite3 *db = sqlite3_db_handle(pStmt);\par
14098       raw_printf(stderr, "SQL error: %s\\n", sqlite3_errmsg(db));\par
14099     \}\par
14100     *pRc = rc;\par
14101   \}\par
14102 \}\par
}
}
{\xe \v showHelp\:shell.c}
{\xe \v shell.c\:showHelp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int showHelp (FILE *  {\i out}, const char *  {\i zPattern}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12250 of file shell.c.}\par
{
References ArraySize, azHelp, process_input(), sqlite3_free, sqlite3_mprintf, sqlite3_strglob, sqlite3_strlike, and utf8_printf.}\par
{
Referenced by do_meta_command(), and shellReset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 12250                                                     \{\par
12251   int i = 0;\par
12252   int j = 0;\par
12253   int n = 0;\par
12254   char *zPat;\par
12255   if( zPattern==0\par
12256    || zPattern[0]=='0'\par
12257    || strcmp(zPattern,"-a")==0\par
12258    || strcmp(zPattern,"-all")==0\par
12259   )\{\par
12260     /* Show all commands, but only one line per command */\par
12261     if( zPattern==0 ) zPattern = "";\par
12262     for(i=0; i<ArraySize(azHelp); i++)\{\par
12263       if( azHelp[i][0]=='.' || zPattern[0] )\{\par
12264         utf8_printf(out, "%s\\n", azHelp[i]);\par
12265         n++;\par
12266       \}\par
12267     \}\par
12268   \}else\{\par
12269     /* Look for commands that for which zPattern is an exact prefix */\par
12270     zPat = sqlite3_mprintf(".%s*", zPattern);\par
12271     for(i=0; i<ArraySize(azHelp); i++)\{\par
12272       if( sqlite3_strglob(zPat, azHelp[i])==0 )\{\par
12273         utf8_printf(out, "%s\\n", azHelp[i]);\par
12274         j = i+1;\par
12275         n++;\par
12276       \}\par
12277     \}\par
12278     sqlite3_free(zPat);\par
12279     if( n )\{\par
12280       if( n==1 )\{\par
12281         /* when zPattern is a prefix of exactly one command, then include the\par
12282         ** details of that command, which should begin at offset j */\par
12283         while( j<ArraySize(azHelp)-1 && azHelp[j][0]!='.' )\{\par
12284           utf8_printf(out, "%s\\n", azHelp[j]);\par
12285           j++;\par
12286         \}\par
12287       \}\par
12288       return n;\par
12289     \}\par
12290     /* Look for commands that contain zPattern anywhere.  Show the complete\par
12291     ** text of all commands that match. */\par
12292     zPat = sqlite3_mprintf("%%%s%%", zPattern);\par
12293     for(i=0; i<ArraySize(azHelp); i++)\{\par
12294       if( azHelp[i][0]=='.' ) j = i;\par
12295       if( sqlite3_strlike(zPat, azHelp[i], 0)==0 )\{\par
12296         utf8_printf(out, "%s\\n", azHelp[j]);\par
12297         while( j<ArraySize(azHelp)-1 && azHelp[j+1][0]!='.' )\{\par
12298           j++;\par
12299           utf8_printf(out, "%s\\n", azHelp[j]);\par
12300         \}\par
12301         i = j;\par
12302         n++;\par
12303       \}\par
12304     \}\par
12305     sqlite3_free(zPat);\par
12306   \}\par
12307   return n;\par
12308 \}\par
}
}
{\xe \v sql_trace_callback\:shell.c}
{\xe \v shell.c\:sql_trace_callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int sql_trace_callback (unsigned  {\i mType}, void *  {\i pArg}, void *  {\i pP}, void *  {\i pX}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13001 of file shell.c.}\par
{
References ShellState::eTraceType, SHELL_TRACE_EXPANDED, SHELL_TRACE_NORMALIZED, sqlite3_expanded_sql, sqlite3_normalized_sql, sqlite3_sql, SQLITE_TRACE_CLOSE, SQLITE_TRACE_PROFILE, SQLITE_TRACE_ROW, SQLITE_TRACE_STMT, strlen30(), ShellState::traceOut, and utf8_printf.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13006  \{\par
13007   ShellState *p = (ShellState*)pArg;\par
13008   sqlite3_stmt *pStmt;\par
13009   const char *zSql;\par
13010   int nSql;\par
13011   if( p->traceOut==0 ) return 0;\par
13012   if( mType==SQLITE_TRACE_CLOSE )\{\par
13013     utf8_printf(p->traceOut, "-- closing database connection\\n");\par
13014     return 0;\par
13015   \}\par
13016   if( mType!=SQLITE_TRACE_ROW && ((const char*)pX)[0]=='-' )\{\par
13017     zSql = (const char*)pX;\par
13018   \}else\{\par
13019     pStmt = (sqlite3_stmt*)pP;\par
13020     switch( p->eTraceType )\{\par
13021       case SHELL_TRACE_EXPANDED: \{\par
13022         zSql = sqlite3_expanded_sql(pStmt);\par
13023         break;\par
13024       \}\par
13025 #ifdef SQLITE_ENABLE_NORMALIZE\par
13026       case SHELL_TRACE_NORMALIZED: \{\par
13027         zSql = sqlite3_normalized_sql(pStmt);\par
13028         break;\par
13029       \}\par
13030 #endif\par
13031       default: \{\par
13032         zSql = sqlite3_sql(pStmt);\par
13033         break;\par
13034       \}\par
13035     \}\par
13036   \}\par
13037   if( zSql==0 ) return 0;\par
13038   nSql = strlen30(zSql);\par
13039   while( nSql>0 && zSql[nSql-1]==';' )\{ nSql--; \}\par
13040   switch( mType )\{\par
13041     case SQLITE_TRACE_ROW:\par
13042     case SQLITE_TRACE_STMT: \{\par
13043       utf8_printf(p->traceOut, "%.*s;\\n", nSql, zSql);\par
13044       break;\par
13045     \}\par
13046     case SQLITE_TRACE_PROFILE: \{\par
13047       sqlite3_int64 nNanosec = *(sqlite3_int64*)pX;\par
13048       utf8_printf(p->traceOut, "%.*s; -- %lld ns\\n", nSql, zSql, nNanosec);\par
13049       break;\par
13050     \}\par
13051   \}\par
13052   return 0;\par
13053 \}\par
}
}
{\xe \v sqlite3_appendvfs_init\:shell.c}
{\xe \v shell.c\:sqlite3_appendvfs_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sqlite3_appendvfs_init ({\b sqlite3} *  {\i db}, char **  {\i pzErrMsg}, const {\b sqlite3_api_routines} *  {\i pApi})}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4080 of file shell.c.}\par
{
References sqlite3_vfs::iVersion, sqlite3_vfs::pAppData, sqlite3_auto_extension, sqlite3_vfs_find, sqlite3_vfs_register, SQLITE_EXTENSION_INIT2, SQLITE_OK, SQLITE_OK_LOAD_PERMANENTLY, and sqlite3_vfs::szOsFile.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4084  \{\par
 4085   int rc = SQLITE_OK;\par
 4086   sqlite3_vfs *pOrig;\par
 4087   SQLITE_EXTENSION_INIT2(pApi);\par
 4088   (void)pzErrMsg;\par
 4089   (void)db;\par
 4090   pOrig = sqlite3_vfs_find(0);\par
 4091   apnd_vfs.iVersion = pOrig->iVersion;\par
 4092   apnd_vfs.pAppData = pOrig;\par
 4093   apnd_vfs.szOsFile = pOrig->szOsFile + sizeof(ApndFile);\par
 4094   rc = sqlite3_vfs_register(&apnd_vfs, 0);\par
 4095 #ifdef APPENDVFS_TEST\par
 4096   if( rc==SQLITE_OK )\{\par
 4097     rc = sqlite3_auto_extension((void(*)(void))apndvfsRegister);\par
 4098   \}\par
 4099 #endif\par
 4100   if( rc==SQLITE_OK ) rc = SQLITE_OK_LOAD_PERMANENTLY;\par
 4101   return rc;\par
 4102 \}\par
}
}
{\xe \v sqlite3_completion_init\:shell.c}
{\xe \v shell.c\:sqlite3_completion_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sqlite3_completion_init ({\b sqlite3} *  {\i db}, char **  {\i pzErrMsg}, const {\b sqlite3_api_routines} *  {\i pApi})}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3522 of file shell.c.}\par
{
References sqlite3CompletionVtabInit(), SQLITE_EXTENSION_INIT1, SQLITE_EXTENSION_INIT2, and SQLITE_OK.}\par
{
Referenced by open_db().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3526  \{\par
 3527   int rc = SQLITE_OK;\par
 3528   SQLITE_EXTENSION_INIT2(pApi);\par
 3529   (void)(pzErrMsg);  /* Unused parameter */\par
 3530 #ifndef SQLITE_OMIT_VIRTUALTABLE\par
 3531   rc = sqlite3CompletionVtabInit(db);\par
 3532 #endif\par
 3533   return rc;\par
 3534 \}\par
}
}
{\xe \v sqlite3_expert_analyze\:shell.c}
{\xe \v shell.c\:sqlite3_expert_analyze}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sqlite3_expert_analyze ({\b sqlite3expert} *  {\i p}, char **  {\i pzErr})}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8569 of file shell.c.}\par
{
References sqlite3expert::bRun, sqlite3expert::hIdx, idxAppendText(), idxCreateCandidates(), idxFindIndexes(), idxPopulateStat1(), idxProcessTriggers(), IdxHash::pFirst, IdxHashEntry::pNext, SQLITE_OK, sqlite3expert::zCandidates, IdxHashEntry::zVal, and IdxHashEntry::zVal2.}\par
{
Referenced by expertFinish().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8569                                                           \{\par
 8570   int rc;\par
 8571   IdxHashEntry *pEntry;\par
 8572 \par
 8573   /* Do trigger processing to collect any extra IdxScan structures */\par
 8574   rc = idxProcessTriggers(p, pzErr);\par
 8575 \par
 8576   /* Create candidate indexes within the in-memory database file */\par
 8577   if( rc==SQLITE_OK )\{\par
 8578     rc = idxCreateCandidates(p);\par
 8579   \}\par
 8580 \par
 8581   /* Generate the stat1 data */\par
 8582   if( rc==SQLITE_OK )\{\par
 8583     rc = idxPopulateStat1(p, pzErr);\par
 8584   \}\par
 8585 \par
 8586   /* Formulate the EXPERT_REPORT_CANDIDATES text */\par
 8587   for(pEntry=p->hIdx.pFirst; pEntry; pEntry=pEntry->pNext)\{\par
 8588     p->zCandidates = idxAppendText(&rc, p->zCandidates, \par
 8589         "%s;%s%s\\n", pEntry->zVal, \par
 8590         pEntry->zVal2 ? " -- stat1: " : "", pEntry->zVal2\par
 8591     );\par
 8592   \}\par
 8593 \par
 8594   /* Figure out which of the candidate indexes are preferred by the query\par
 8595   ** planner and report the results to the user.  */\par
 8596   if( rc==SQLITE_OK )\{\par
 8597     rc = idxFindIndexes(p, pzErr);\par
 8598   \}\par
 8599 \par
 8600   if( rc==SQLITE_OK )\{\par
 8601     p->bRun = 1;\par
 8602   \}\par
 8603   return rc;\par
 8604 \}\par
}
}
{\xe \v sqlite3_expert_config\:shell.c}
{\xe \v shell.c\:sqlite3_expert_config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sqlite3_expert_config ({\b sqlite3expert} *  {\i p}, int  {\i op},   {\i ...})}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8500 of file shell.c.}\par
{
References EXPERT_CONFIG_SAMPLE, sqlite3expert::iSample, SQLITE_NOTFOUND, and SQLITE_OK.}\par
{
Referenced by expertDotCommand().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8500                                                         \{\par
 8501   int rc = SQLITE_OK;\par
 8502   va_list ap;\par
 8503   va_start(ap, op);\par
 8504   switch( op )\{\par
 8505     case EXPERT_CONFIG_SAMPLE: \{\par
 8506       int iVal = va_arg(ap, int);\par
 8507       if( iVal<0 ) iVal = 0;\par
 8508       if( iVal>100 ) iVal = 100;\par
 8509       p->iSample = iVal;\par
 8510       break;\par
 8511     \}\par
 8512     default:\par
 8513       rc = SQLITE_NOTFOUND;\par
 8514       break;\par
 8515   \}\par
 8516 \par
 8517   va_end(ap);\par
 8518   return rc;\par
 8519 \}\par
}
}
{\xe \v sqlite3_expert_count\:shell.c}
{\xe \v shell.c\:sqlite3_expert_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sqlite3_expert_count ({\b sqlite3expert} *  {\i p})}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8610 of file shell.c.}\par
{
References IdxStatement::iId, and sqlite3expert::pStatement.}\par
{
Referenced by expertFinish().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8610                                           \{\par
 8611   int nRet = 0;\par
 8612   if( p->pStatement ) nRet = p->pStatement->iId+1;\par
 8613   return nRet;\par
 8614 \}\par
}
}
{\xe \v sqlite3_expert_destroy\:shell.c}
{\xe \v shell.c\:sqlite3_expert_destroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void sqlite3_expert_destroy ({\b sqlite3expert} *  {\i p})}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8645 of file shell.c.}\par
{
References sqlite3_index_info::aConstraint, sqlite3_index_info::aConstraintUsage, sqlite3_index_info::aOrderBy, sqlite3_index_info::sqlite3_index_constraint_usage::argvIndex, sqlite3expert::dbm, sqlite3expert::dbv, sqlite3_index_info::sqlite3_index_orderby::desc, sqlite3_index_info::estimatedCost, sqlite3_index_info::estimatedRows, eType, sqlite3expert::hIdx, sqlite3_index_info::sqlite3_index_orderby::iColumn, idxHashClear(), sqlite3_index_info::idxNum, idxScanFree(), idxStatementFree(), idxTableFree(), idxWriteFree(), sqlite3_index_info::nConstraint, sqlite3_index_info::nOrderBy, sqlite3_index_info::sqlite3_index_constraint_usage::omit, sqlite3_index_info::orderByConsumed, sqlite3expert::pScan, sqlite3expert::pStatement, sqlite3expert::pTable, sqlite3_vtab_cursor::pVtab, sqlite3expert::pWrite, sqlite3_bind_int64, sqlite3_bind_text, sqlite3_close, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_int, sqlite3_create_module, sqlite3_declare_vtab, sqlite3_errmsg, sqlite3_finalize, sqlite3_free, sqlite3_malloc64, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_reset, sqlite3_result_blob, sqlite3_result_double, sqlite3_result_int, sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_step, sqlite3_value_int, sqlite3_value_text, SQLITE_CONSTRAINT, SQLITE_EXTENSION_INIT1, SQLITE_EXTENSION_INIT2, SQLITE_INDEX_CONSTRAINT_EQ, SQLITE_NOMEM, SQLITE_OK, SQLITE_ROW, SQLITE_TRANSIENT, X, sqlite3expert::zCandidates, and zName.}\par
{
Referenced by expertFinish(), and sqlite3_expert_new().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8645                                              \{\par
 8646   if( p )\{\par
 8647     sqlite3_close(p->dbm);\par
 8648     sqlite3_close(p->dbv);\par
 8649     idxScanFree(p->pScan, 0);\par
 8650     idxStatementFree(p->pStatement, 0);\par
 8651     idxTableFree(p->pTable);\par
 8652     idxWriteFree(p->pWrite);\par
 8653     idxHashClear(&p->hIdx);\par
 8654     sqlite3_free(p->zCandidates);\par
 8655     sqlite3_free(p);\par
 8656   \}\par
 8657 \}\par
}
}
{\xe \v sqlite3_expert_new\:shell.c}
{\xe \v shell.c\:sqlite3_expert_new}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sqlite3expert} * sqlite3_expert_new ({\b sqlite3} *  {\i db}, char **  {\i pzErr})}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8439 of file shell.c.}\par
{
References sqlite3expert::db, sqlite3expert::dbm, sqlite3expert::dbv, idxAuthCallback(), idxCreateVtabSchema(), idxFinalize(), idxMalloc(), idxPrintfPrepareStmt(), sqlite3expert::iSample, sqlite3_column_text, sqlite3_db_config, sqlite3_exec, sqlite3_expert_destroy(), sqlite3_open, sqlite3_set_authorizer, sqlite3_step, SQLITE_DBCONFIG_TRIGGER_EQP, SQLITE_OK, and SQLITE_ROW.}\par
{
Referenced by expertDotCommand().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8439                                                                \{\par
 8440   int rc = SQLITE_OK;\par
 8441   sqlite3expert *pNew;\par
 8442 \par
 8443   pNew = (sqlite3expert*)idxMalloc(&rc, sizeof(sqlite3expert));\par
 8444 \par
 8445   /* Open two in-memory databases to work with. The "vtab database" (dbv)\par
 8446   ** will contain a virtual table corresponding to each real table in\par
 8447   ** the user database schema, and a copy of each view. It is used to\par
 8448   ** collect information regarding the WHERE, ORDER BY and other clauses\par
 8449   ** of the user's query.\par
 8450   */\par
 8451   if( rc==SQLITE_OK )\{\par
 8452     pNew->db = db;\par
 8453     pNew->iSample = 100;\par
 8454     rc = sqlite3_open(":memory:", &pNew->dbv);\par
 8455   \}\par
 8456   if( rc==SQLITE_OK )\{\par
 8457     rc = sqlite3_open(":memory:", &pNew->dbm);\par
 8458     if( rc==SQLITE_OK )\{\par
 8459       sqlite3_db_config(pNew->dbm, SQLITE_DBCONFIG_TRIGGER_EQP, 1, (int*)0);\par
 8460     \}\par
 8461   \}\par
 8462   \par
 8463 \par
 8464   /* Copy the entire schema of database [db] into [dbm]. */\par
 8465   if( rc==SQLITE_OK )\{\par
 8466     sqlite3_stmt *pSql;\par
 8467     rc = idxPrintfPrepareStmt(pNew->db, &pSql, pzErrmsg, \par
 8468         "SELECT sql FROM sqlite_master WHERE name NOT LIKE 'sqlite_%%'"\par
 8469         " AND sql NOT LIKE 'CREATE VIRTUAL %%'"\par
 8470     );\par
 8471     while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSql) )\{\par
 8472       const char *zSql = (const char*)sqlite3_column_text(pSql, 0);\par
 8473       rc = sqlite3_exec(pNew->dbm, zSql, 0, 0, pzErrmsg);\par
 8474     \}\par
 8475     idxFinalize(&rc, pSql);\par
 8476   \}\par
 8477 \par
 8478   /* Create the vtab schema */\par
 8479   if( rc==SQLITE_OK )\{\par
 8480     rc = idxCreateVtabSchema(pNew, pzErrmsg);\par
 8481   \}\par
 8482 \par
 8483   /* Register the auth callback with dbv */\par
 8484   if( rc==SQLITE_OK )\{\par
 8485     sqlite3_set_authorizer(pNew->dbv, idxAuthCallback, (void*)pNew);\par
 8486   \}\par
 8487 \par
 8488   /* If an error has occurred, free the new object and reutrn NULL. Otherwise,\par
 8489   ** return the new sqlite3expert handle.  */\par
 8490   if( rc!=SQLITE_OK )\{\par
 8491     sqlite3_expert_destroy(pNew);\par
 8492     pNew = 0;\par
 8493   \}\par
 8494   return pNew;\par
 8495 \}\par
}
}
{\xe \v sqlite3_expert_report\:shell.c}
{\xe \v shell.c\:sqlite3_expert_report}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * sqlite3_expert_report ({\b sqlite3expert} *  {\i p}, int  {\i iStmt}, int  {\i eReport})}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8619 of file shell.c.}\par
{
References sqlite3expert::bRun, EXPERT_REPORT_CANDIDATES, EXPERT_REPORT_INDEXES, EXPERT_REPORT_PLAN, EXPERT_REPORT_SQL, IdxStatement::iId, IdxStatement::pNext, sqlite3expert::pStatement, sqlite3expert::zCandidates, IdxStatement::zEQP, IdxStatement::zIdx, and IdxStatement::zSql.}\par
{
Referenced by expertFinish().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8619                                                                            \{\par
 8620   const char *zRet = 0;\par
 8621   IdxStatement *pStmt;\par
 8622 \par
 8623   if( p->bRun==0 ) return 0;\par
 8624   for(pStmt=p->pStatement; pStmt && pStmt->iId!=iStmt; pStmt=pStmt->pNext);\par
 8625   switch( eReport )\{\par
 8626     case EXPERT_REPORT_SQL:\par
 8627       if( pStmt ) zRet = pStmt->zSql;\par
 8628       break;\par
 8629     case EXPERT_REPORT_INDEXES:\par
 8630       if( pStmt ) zRet = pStmt->zIdx;\par
 8631       break;\par
 8632     case EXPERT_REPORT_PLAN:\par
 8633       if( pStmt ) zRet = pStmt->zEQP;\par
 8634       break;\par
 8635     case EXPERT_REPORT_CANDIDATES:\par
 8636       zRet = p->zCandidates;\par
 8637       break;\par
 8638   \}\par
 8639   return zRet;\par
 8640 \}\par
}
}
{\xe \v sqlite3_expert_sql\:shell.c}
{\xe \v shell.c\:sqlite3_expert_sql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sqlite3_expert_sql ({\b sqlite3expert} *  {\i p}, const char *  {\i zSql}, char **  {\i pzErr})}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8524 of file shell.c.}\par
{
References sqlite3expert::bRun, sqlite3expert::dbv, idxDatabaseError(), idxMalloc(), idxScanFree(), idxStatementFree(), IdxStatement::iId, IdxStatement::pNext, sqlite3expert::pScan, sqlite3expert::pStatement, sqlite3_finalize, sqlite3_prepare_v2, sqlite3_sql, SQLITE_MISUSE, SQLITE_OK, STRLEN, and IdxStatement::zSql.}\par
{
Referenced by expertHandleSQL().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  8528  \{\par
 8529   IdxScan *pScanOrig = p->pScan;\par
 8530   IdxStatement *pStmtOrig = p->pStatement;\par
 8531   int rc = SQLITE_OK;\par
 8532   const char *zStmt = zSql;\par
 8533 \par
 8534   if( p->bRun ) return SQLITE_MISUSE;\par
 8535 \par
 8536   while( rc==SQLITE_OK && zStmt && zStmt[0] )\{\par
 8537     sqlite3_stmt *pStmt = 0;\par
 8538     rc = sqlite3_prepare_v2(p->dbv, zStmt, -1, &pStmt, &zStmt);\par
 8539     if( rc==SQLITE_OK )\{\par
 8540       if( pStmt )\{\par
 8541         IdxStatement *pNew;\par
 8542         const char *z = sqlite3_sql(pStmt);\par
 8543         int n = STRLEN(z);\par
 8544         pNew = (IdxStatement*)idxMalloc(&rc, sizeof(IdxStatement) + n+1);\par
 8545         if( rc==SQLITE_OK )\{\par
 8546           pNew->zSql = (char*)&pNew[1];\par
 8547           memcpy(pNew->zSql, z, n+1);\par
 8548           pNew->pNext = p->pStatement;\par
 8549           if( p->pStatement ) pNew->iId = p->pStatement->iId+1;\par
 8550           p->pStatement = pNew;\par
 8551         \}\par
 8552         sqlite3_finalize(pStmt);\par
 8553       \}\par
 8554     \}else\{\par
 8555       idxDatabaseError(p->dbv, pzErr);\par
 8556     \}\par
 8557   \}\par
 8558 \par
 8559   if( rc!=SQLITE_OK )\{\par
 8560     idxScanFree(p->pScan, pScanOrig);\par
 8561     idxStatementFree(p->pStatement, pStmtOrig);\par
 8562     p->pScan = pScanOrig;\par
 8563     p->pStatement = pStmtOrig;\par
 8564   \}\par
 8565 \par
 8566   return rc;\par
 8567 \}\par
}
}
{\xe \v sqlite3_fileio_init\:shell.c}
{\xe \v shell.c\:sqlite3_fileio_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sqlite3_fileio_init ({\b sqlite3} *  {\i db}, char **  {\i pzErrMsg}, const {\b sqlite3_api_routines} *  {\i pApi})}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3006 of file shell.c.}\par
{
References fsdirRegister(), lsModeFunc(), readfileFunc(), sqlite3_create_function, SQLITE_DIRECTONLY, SQLITE_EXTENSION_INIT1, SQLITE_EXTENSION_INIT2, SQLITE_OK, SQLITE_UTF8, and writefileFunc().}\par
{
Referenced by open_db(), and shellReset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3010  \{\par
 3011   int rc = SQLITE_OK;\par
 3012   SQLITE_EXTENSION_INIT2(pApi);\par
 3013   (void)pzErrMsg;  /* Unused parameter */\par
 3014   rc = sqlite3_create_function(db, "readfile", 1, \par
 3015                                SQLITE_UTF8|SQLITE_DIRECTONLY, 0,\par
 3016                                readfileFunc, 0, 0);\par
 3017   if( rc==SQLITE_OK )\{\par
 3018     rc = sqlite3_create_function(db, "writefile", -1,\par
 3019                                  SQLITE_UTF8|SQLITE_DIRECTONLY, 0,\par
 3020                                  writefileFunc, 0, 0);\par
 3021   \}\par
 3022   if( rc==SQLITE_OK )\{\par
 3023     rc = sqlite3_create_function(db, "lsmode", 1, SQLITE_UTF8, 0,\par
 3024                                  lsModeFunc, 0, 0);\par
 3025   \}\par
 3026   if( rc==SQLITE_OK )\{\par
 3027     rc = fsdirRegister(db);\par
 3028   \}\par
 3029   return rc;\par
 3030 \}\par
}
}
{\xe \v sqlite3_shathree_init\:shell.c}
{\xe \v shell.c\:sqlite3_shathree_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sqlite3_shathree_init ({\b sqlite3} *  {\i db}, char **  {\i pzErrMsg}, const {\b sqlite3_api_routines} *  {\i pApi})}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2002 of file shell.c.}\par
{
References sha3Func(), sha3QueryFunc(), sqlite3_create_function, SQLITE_DETERMINISTIC, SQLITE_DIRECTONLY, SQLITE_EXTENSION_INIT1, SQLITE_EXTENSION_INIT2, SQLITE_INNOCUOUS, SQLITE_OK, and SQLITE_UTF8.}\par
{
Referenced by open_db().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2006  \{\par
 2007   int rc = SQLITE_OK;\par
 2008   SQLITE_EXTENSION_INIT2(pApi);\par
 2009   (void)pzErrMsg;  /* Unused parameter */\par
 2010   rc = sqlite3_create_function(db, "sha3", 1,\par
 2011                       SQLITE_UTF8 | SQLITE_INNOCUOUS | SQLITE_DETERMINISTIC,\par
 2012                       0, sha3Func, 0, 0);\par
 2013   if( rc==SQLITE_OK )\{\par
 2014     rc = sqlite3_create_function(db, "sha3", 2,\par
 2015                       SQLITE_UTF8 | SQLITE_INNOCUOUS | SQLITE_DETERMINISTIC,\par
 2016                       0, sha3Func, 0, 0);\par
 2017   \}\par
 2018   if( rc==SQLITE_OK )\{\par
 2019     rc = sqlite3_create_function(db, "sha3_query", 1,\par
 2020                       SQLITE_UTF8 | SQLITE_DIRECTONLY,\par
 2021                       0, sha3QueryFunc, 0, 0);\par
 2022   \}\par
 2023   if( rc==SQLITE_OK )\{\par
 2024     rc = sqlite3_create_function(db, "sha3_query", 2,\par
 2025                       SQLITE_UTF8 | SQLITE_DIRECTONLY,\par
 2026                       0, sha3QueryFunc, 0, 0);\par
 2027   \}\par
 2028   return rc;\par
 2029 \}\par
}
}
{\xe \v sqlite3CompletionVtabInit\:shell.c}
{\xe \v shell.c\:sqlite3CompletionVtabInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sqlite3CompletionVtabInit ({\b sqlite3} *  {\i db})}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3511 of file shell.c.}\par
{
References sqlite3_create_module, and SQLITE_OK.}\par
{
Referenced by sqlite3_completion_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  3511                                           \{\par
 3512   int rc = SQLITE_OK;\par
 3513 #ifndef SQLITE_OMIT_VIRTUALTABLE\par
 3514   rc = sqlite3_create_module(db, "completion", &completionModule, 0);\par
 3515 #endif\par
 3516   return rc;\par
 3517 \}\par
}
}
{\xe \v sqlite3MemTraceActivate\:shell.c}
{\xe \v shell.c\:sqlite3MemTraceActivate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sqlite3MemTraceActivate (FILE *  {\i out})}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4190 of file shell.c.}\par
{
References sqlite3_config(), SQLITE_CONFIG_GETMALLOC, SQLITE_CONFIG_MALLOC, SQLITE_OK, and sqlite3_mem_methods::xMalloc.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4190                                       \{\par
 4191   int rc = SQLITE_OK;\par
 4192   if( memtraceBase.xMalloc==0 )\{\par
 4193     rc = sqlite3_config(SQLITE_CONFIG_GETMALLOC, &memtraceBase);\par
 4194     if( rc==SQLITE_OK )\{\par
 4195       rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &ersaztMethods);\par
 4196     \}\par
 4197   \}\par
 4198   memtraceOut = out;\par
 4199   return rc;\par
 4200 \}\par
}
}
{\xe \v sqlite3MemTraceDeactivate\:shell.c}
{\xe \v shell.c\:sqlite3MemTraceDeactivate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int sqlite3MemTraceDeactivate (void )}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4203 of file shell.c.}\par
{
References sqlite3_index_info::aConstraint, sqlite3_index_info::aConstraintUsage, ALWAYS, sqlite3_index_info::sqlite3_index_constraint_usage::argvIndex, main3::cur, list_test::E, sqlite3_index_info::estimatedCost, sqlite3_index_info::idxNum, sqlite3_vfs::iVersion, MIN, sqlite3_index_info::nConstraint, nName, sqlite3_index_info::sqlite3_index_constraint_usage::omit, sqlite3_vtab_cursor::pVtab, sqlite3_aggregate_context, sqlite3_config(), sqlite3_create_function, sqlite3_create_module, sqlite3_declare_vtab, sqlite3_free, sqlite3_malloc, sqlite3_malloc64, sqlite3_mprintf, sqlite3_overload_function, sqlite3_realloc64, sqlite3_result_blob, sqlite3_result_error, sqlite3_result_error_code, sqlite3_result_error_nomem, sqlite3_result_int, sqlite3_result_int64, sqlite3_result_text, sqlite3_result_value, sqlite3_stricmp, sqlite3_user_data, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_int, sqlite3_value_int64, sqlite3_value_text, sqlite3_value_type, sqlite3_vfs_find, sqlite3_vmprintf, sqlite3_vtab_config, sqlite3_vtab_nochange, sqlite3_vtab_on_conflict, SQLITE_BLOB, SQLITE_CONFIG_MALLOC, SQLITE_CONSTRAINT, SQLITE_ERROR, SQLITE_EXTENSION_INIT1, SQLITE_EXTENSION_INIT2, SQLITE_IGNORE, SQLITE_INDEX_CONSTRAINT_EQ, SQLITE_INNOCUOUS, SQLITE_NOMEM, SQLITE_NULL, SQLITE_OK, SQLITE_REPLACE, SQLITE_STATIC, SQLITE_TRANSIENT, SQLITE_UTF8, SQLITE_VTAB_DIRECTONLY, sqlite3_vfs::xCurrentTime, sqlite3_vfs::xCurrentTimeInt64, sqlite3_mem_methods::xMalloc, and zName.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  4203                                    \{\par
 4204   int rc = SQLITE_OK;\par
 4205   if( memtraceBase.xMalloc!=0 )\{\par
 4206     rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &memtraceBase);\par
 4207     if( rc==SQLITE_OK )\{\par
 4208       memset(&memtraceBase, 0, sizeof(memtraceBase));\par
 4209     \}\par
 4210   \}\par
 4211   memtraceOut = 0;\par
 4212   return rc;\par
 4213 \}\par
}
}
{\xe \v str_in_array\:shell.c}
{\xe \v shell.c\:str_in_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int str_in_array (const char *  {\i zStr}, const char **  {\i azArray}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11180 of file shell.c.}\par
{
Referenced by explain_data_prepare().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11180                                                                \{\par
11181   int i;\par
11182   for(i=0; azArray[i]; i++)\{\par
11183     if( 0==strcmp(zStr, azArray[i]) ) return 1;\par
11184   \}\par
11185   return 0;\par
11186 \}\par
}
}
{\xe \v strlen30\:shell.c}
{\xe \v shell.c\:strlen30}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int strlen30 (const char *  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 557 of file shell.c.}\par
{
Referenced by appendText(), close_db(), do_meta_command(), eqp_append(), eqp_render_level(), expertDotCommand(), find_home_dir(), lintDotCommand(), lintFkeyIndexes(), local_getline(), main(), output_csv(), process_input(), run_schema_dump_query(), save_err_msg(), set_table_name(), shell_callback(), shellAddSchemaName(), shellReset(), sql_trace_callback(), and tryToCloneData().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   557                                   \{\par
  558   const char *z2 = z;\par
  559   while( *z2 )\{ z2++; \}\par
  560   return 0x3fffffff & (int)(z2 - z);\par
  561 \}\par
}
}
{\xe \v strlenChar\:shell.c}
{\xe \v shell.c\:strlenChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int strlenChar (const char *  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 567 of file shell.c.}\par
{
Referenced by shell_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   567                                     \{\par
  568   int n = 0;\par
  569   while( *z )\{\par
  570     if( (0xc0&*(z++))!=0x80 ) n++;\par
  571   \}\par
  572   return n;\par
  573 \}\par
}
}
{\xe \v tableColumnList\:shell.c}
{\xe \v shell.c\:tableColumnList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static char** tableColumnList ({\b ShellState} *  {\i p}, const char *  {\i zTab}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11768 of file shell.c.}\par
{
References ShellState::db, freeColumnList(), shell_out_of_memory(), ShellHasFlag, SHFLG_PreserveRowid, sqlite3_column_int, sqlite3_column_text, sqlite3_finalize, sqlite3_free, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_realloc, sqlite3_step, sqlite3_stricmp, sqlite3_table_column_metadata, SQLITE_OK, and SQLITE_ROW.}\par
{
Referenced by dump_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11768                                                               \{\par
11769   char **azCol = 0;\par
11770   sqlite3_stmt *pStmt;\par
11771   char *zSql;\par
11772   int nCol = 0;\par
11773   int nAlloc = 0;\par
11774   int nPK = 0;       /* Number of PRIMARY KEY columns seen */\par
11775   int isIPK = 0;     /* True if one PRIMARY KEY column of type INTEGER */\par
11776   int preserveRowid = ShellHasFlag(p, SHFLG_PreserveRowid);\par
11777   int rc;\par
11778 \par
11779   zSql = sqlite3_mprintf("PRAGMA table_info=%Q", zTab);\par
11780   rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\par
11781   sqlite3_free(zSql);\par
11782   if( rc ) return 0;\par
11783   while( sqlite3_step(pStmt)==SQLITE_ROW )\{\par
11784     if( nCol>=nAlloc-2 )\{\par
11785       nAlloc = nAlloc*2 + nCol + 10;\par
11786       azCol = sqlite3_realloc(azCol, nAlloc*sizeof(azCol[0]));\par
11787       if( azCol==0 ) shell_out_of_memory();\par
11788     \}\par
11789     azCol[++nCol] = sqlite3_mprintf("%s", sqlite3_column_text(pStmt, 1));\par
11790     if( sqlite3_column_int(pStmt, 5) )\{\par
11791       nPK++;\par
11792       if( nPK==1\par
11793        && sqlite3_stricmp((const char*)sqlite3_column_text(pStmt,2),\par
11794                           "INTEGER")==0\par
11795       )\{\par
11796         isIPK = 1;\par
11797       \}else\{\par
11798         isIPK = 0;\par
11799       \}\par
11800     \}\par
11801   \}\par
11802   sqlite3_finalize(pStmt);\par
11803   if( azCol==0 ) return 0;\par
11804   azCol[0] = 0;\par
11805   azCol[nCol+1] = 0;\par
11806 \par
11807   /* The decision of whether or not a rowid really needs to be preserved\par
11808   ** is tricky.  We never need to preserve a rowid for a WITHOUT ROWID table\par
11809   ** or a table with an INTEGER PRIMARY KEY.  We are unable to preserve\par
11810   ** rowids on tables where the rowid is inaccessible because there are other\par
11811   ** columns in the table named "rowid", "_rowid_", and "oid".\par
11812   */\par
11813   if( preserveRowid && isIPK )\{\par
11814     /* If a single PRIMARY KEY column with type INTEGER was seen, then it\par
11815     ** might be an alise for the ROWID.  But it might also be a WITHOUT ROWID\par
11816     ** table or a INTEGER PRIMARY KEY DESC column, neither of which are\par
11817     ** ROWID aliases.  To distinguish these cases, check to see if\par
11818     ** there is a "pk" entry in "PRAGMA index_list".  There will be\par
11819     ** no "pk" index if the PRIMARY KEY really is an alias for the ROWID.\par
11820     */\par
11821     zSql = sqlite3_mprintf("SELECT 1 FROM pragma_index_list(%Q)"\par
11822                            " WHERE origin='pk'", zTab);\par
11823     rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);\par
11824     sqlite3_free(zSql);\par
11825     if( rc )\{\par
11826       freeColumnList(azCol);\par
11827       return 0;\par
11828     \}\par
11829     rc = sqlite3_step(pStmt);\par
11830     sqlite3_finalize(pStmt);\par
11831     preserveRowid = rc==SQLITE_ROW;\par
11832   \}\par
11833   if( preserveRowid )\{\par
11834     /* Only preserve the rowid if we can find a name to use for the\par
11835     ** rowid */\par
11836     static char *azRowid[] = \{ "rowid", "_rowid_", "oid" \};\par
11837     int i, j;\par
11838     for(j=0; j<3; j++)\{\par
11839       for(i=1; i<=nCol; i++)\{\par
11840         if( sqlite3_stricmp(azRowid[j],azCol[i])==0 ) break;\par
11841       \}\par
11842       if( i>nCol )\{\par
11843         /* At this point, we know that azRowid[j] is not the name of any\par
11844         ** ordinary column in the table.  Verify that azRowid[j] is a valid\par
11845         ** name for the rowid before adding it to azCol[0].  WITHOUT ROWID\par
11846         ** tables will fail this last check */\par
11847         rc = sqlite3_table_column_metadata(p->db,0,zTab,azRowid[j],0,0,0,0,0);\par
11848         if( rc==SQLITE_OK ) azCol[0] = azRowid[j];\par
11849         break;\par
11850       \}\par
11851     \}\par
11852   \}\par
11853   return azCol;\par
11854 \}\par
}
}
{\xe \v test_breakpoint\:shell.c}
{\xe \v shell.c\:test_breakpoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void test_breakpoint (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13060 of file shell.c.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13060                                  \{\par
13061   static int nCall = 0;\par
13062   nCall++;\par
13063 \}\par
}
}
{\xe \v testcase_glob\:shell.c}
{\xe \v shell.c\:testcase_glob}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int testcase_glob (const char *  {\i zGlob}, const char *  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13627 of file shell.c.}\par
{
References IsDigit, and IsSpace.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13627                                                           \{\par
13628   int c, c2;\par
13629   int invert;\par
13630   int seen;\par
13631 \par
13632   while( (c = (*(zGlob++)))!=0 )\{\par
13633     if( IsSpace(c) )\{\par
13634       if( !IsSpace(*z) ) return 0;\par
13635       while( IsSpace(*zGlob) ) zGlob++;\par
13636       while( IsSpace(*z) ) z++;\par
13637     \}else if( c=='*' )\{\par
13638       while( (c=(*(zGlob++))) == '*' || c=='?' )\{\par
13639         if( c=='?' && (*(z++))==0 ) return 0;\par
13640       \}\par
13641       if( c==0 )\{\par
13642         return 1;\par
13643       \}else if( c=='[' )\{\par
13644         while( *z && testcase_glob(zGlob-1,z)==0 )\{\par
13645           z++;\par
13646         \}\par
13647         return (*z)!=0;\par
13648       \}\par
13649       while( (c2 = (*(z++)))!=0 )\{\par
13650         while( c2!=c )\{\par
13651           c2 = *(z++);\par
13652           if( c2==0 ) return 0;\par
13653         \}\par
13654         if( testcase_glob(zGlob,z) ) return 1;\par
13655       \}\par
13656       return 0;\par
13657     \}else if( c=='?' )\{\par
13658       if( (*(z++))==0 ) return 0;\par
13659     \}else if( c=='[' )\{\par
13660       int prior_c = 0;\par
13661       seen = 0;\par
13662       invert = 0;\par
13663       c = *(z++);\par
13664       if( c==0 ) return 0;\par
13665       c2 = *(zGlob++);\par
13666       if( c2=='^' )\{\par
13667         invert = 1;\par
13668         c2 = *(zGlob++);\par
13669       \}\par
13670       if( c2==']' )\{\par
13671         if( c==']' ) seen = 1;\par
13672         c2 = *(zGlob++);\par
13673       \}\par
13674       while( c2 && c2!=']' )\{\par
13675         if( c2=='-' && zGlob[0]!=']' && zGlob[0]!=0 && prior_c>0 )\{\par
13676           c2 = *(zGlob++);\par
13677           if( c>=prior_c && c<=c2 ) seen = 1;\par
13678           prior_c = 0;\par
13679         \}else\{\par
13680           if( c==c2 )\{\par
13681             seen = 1;\par
13682           \}\par
13683           prior_c = c2;\par
13684         \}\par
13685         c2 = *(zGlob++);\par
13686       \}\par
13687       if( c2==0 || (seen ^ invert)==0 ) return 0;\par
13688     \}else if( c=='#' )\{\par
13689       if( (z[0]=='-' || z[0]=='+') && IsDigit(z[1]) ) z++;\par
13690       if( !IsDigit(z[0]) ) return 0;\par
13691       z++;\par
13692       while( IsDigit(z[0]) )\{ z++; \}\par
13693     \}else\{\par
13694       if( c!=(*(z++)) ) return 0;\par
13695     \}\par
13696   \}\par
13697   while( IsSpace(*z) )\{ z++; \}\par
13698   return *z==0;\par
13699 \}\par
}
}
{\xe \v timeDiff\:shell.c}
{\xe \v shell.c\:timeDiff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static double timeDiff (struct timeval *  {\i pStart}, struct timeval *  {\i pEnd}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 270 of file shell.c.}\par
{
Referenced by endTimer().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   270                                                                     \{\par
  271   return (pEnd->tv_usec - pStart->tv_usec)*0.000001 +\par
  272          (double)(pEnd->tv_sec - pStart->tv_sec);\par
  273 \}\par
}
}
{\xe \v timeOfDay\:shell.c}
{\xe \v shell.c\:timeOfDay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b sqlite3_int64} timeOfDay (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 228 of file shell.c.}\par
{
References sqlite3_vfs::iVersion, sqlite3_vfs_find, sqlite3_vfs::xCurrentTime, and sqlite3_vfs::xCurrentTimeInt64.}\par
{
Referenced by beginTimer(), and endTimer().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   228                                     \{\par
  229   static sqlite3_vfs *clockVfs = 0;\par
  230   sqlite3_int64 t;\par
  231   if( clockVfs==0 ) clockVfs = sqlite3_vfs_find(0);\par
  232   if( clockVfs->iVersion>=2 && clockVfs->xCurrentTimeInt64!=0 )\{\par
  233     clockVfs->xCurrentTimeInt64(clockVfs, &t);\par
  234   \}else\{\par
  235     double r;\par
  236     clockVfs->xCurrentTime(clockVfs, &r);\par
  237     t = (sqlite3_int64)(r*86400000.0);\par
  238   \}\par
  239   return t;\par
  240 \}\par
}
}
{\xe \v toggleSelectOrder\:shell.c}
{\xe \v shell.c\:toggleSelectOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void toggleSelectOrder ({\b sqlite3} *  {\i db}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11859 of file shell.c.}\par
{
References sqlite3_column_int, sqlite3_exec, sqlite3_finalize, sqlite3_prepare_v2, sqlite3_snprintf, sqlite3_step, and SQLITE_ROW.}\par
{
Referenced by dump_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 11859                                           \{\par
11860   sqlite3_stmt *pStmt = 0;\par
11861   int iSetting = 0;\par
11862   char zStmt[100];\par
11863   sqlite3_prepare_v2(db, "PRAGMA reverse_unordered_selects", -1, &pStmt, 0);\par
11864   if( sqlite3_step(pStmt)==SQLITE_ROW )\{\par
11865     iSetting = sqlite3_column_int(pStmt, 0);\par
11866   \}\par
11867   sqlite3_finalize(pStmt);\par
11868   sqlite3_snprintf(sizeof(zStmt), zStmt,\par
11869        "PRAGMA reverse_unordered_selects(%d)", !iSetting);\par
11870   sqlite3_exec(db, zStmt, 0, 0, 0);\par
11871 \}\par
}
}
{\xe \v tryToClone\:shell.c}
{\xe \v shell.c\:tryToClone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void tryToClone ({\b ShellState} *  {\i p}, const char *  {\i zNewDb}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13407 of file shell.c.}\par
{
References close_db(), ShellState::db, sqlite3_errmsg, sqlite3_exec, sqlite3_open, tryToCloneData(), tryToCloneSchema(), and utf8_printf.}\par
{
Referenced by do_meta_command().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13407                                                          \{\par
13408   int rc;\par
13409   sqlite3 *newDb = 0;\par
13410   if( access(zNewDb,0)==0 )\{\par
13411     utf8_printf(stderr, "File \\"%s\\" already exists.\\n", zNewDb);\par
13412     return;\par
13413   \}\par
13414   rc = sqlite3_open(zNewDb, &newDb);\par
13415   if( rc )\{\par
13416     utf8_printf(stderr, "Cannot create output database: %s\\n",\par
13417             sqlite3_errmsg(newDb));\par
13418   \}else\{\par
13419     sqlite3_exec(p->db, "PRAGMA writable_schema=ON;", 0, 0, 0);\par
13420     sqlite3_exec(newDb, "BEGIN EXCLUSIVE;", 0, 0, 0);\par
13421     tryToCloneSchema(p, newDb, "type='table'", tryToCloneData);\par
13422     tryToCloneSchema(p, newDb, "type!='table'", 0);\par
13423     sqlite3_exec(newDb, "COMMIT;", 0, 0, 0);\par
13424     sqlite3_exec(p->db, "PRAGMA writable_schema=OFF;", 0, 0, 0);\par
13425   \}\par
13426   close_db(newDb);\par
13427 \}\par
}
}
{\xe \v tryToCloneData\:shell.c}
{\xe \v shell.c\:tryToCloneData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void tryToCloneData ({\b ShellState} *  {\i p}, {\b sqlite3} *  {\i newDb}, const char *  {\i zTable}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13222 of file shell.c.}\par
{
References ShellState::db, shell_out_of_memory(), sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_int64, sqlite3_bind_null, sqlite3_bind_text, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_count, sqlite3_column_double, sqlite3_column_int64, sqlite3_column_text, sqlite3_column_type, sqlite3_errmsg, sqlite3_extended_errcode, sqlite3_finalize, sqlite3_free, sqlite3_malloc64, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_reset, sqlite3_snprintf, sqlite3_step, SQLITE_BLOB, SQLITE_DONE, SQLITE_FLOAT, SQLITE_INTEGER, SQLITE_NULL, SQLITE_OK, SQLITE_ROW, SQLITE_STATIC, SQLITE_TEXT, strlen30(), and utf8_printf.}\par
{
Referenced by tryToClone().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13226  \{\par
13227   sqlite3_stmt *pQuery = 0;\par
13228   sqlite3_stmt *pInsert = 0;\par
13229   char *zQuery = 0;\par
13230   char *zInsert = 0;\par
13231   int rc;\par
13232   int i, j, n;\par
13233   int nTable = strlen30(zTable);\par
13234   int k = 0;\par
13235   int cnt = 0;\par
13236   const int spinRate = 10000;\par
13237 \par
13238   zQuery = sqlite3_mprintf("SELECT * FROM \\"%w\\"", zTable);\par
13239   rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\par
13240   if( rc )\{\par
13241     utf8_printf(stderr, "Error %d: %s on [%s]\\n",\par
13242             sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),\par
13243             zQuery);\par
13244     goto end_data_xfer;\par
13245   \}\par
13246   n = sqlite3_column_count(pQuery);\par
13247   zInsert = sqlite3_malloc64(200 + nTable + n*3);\par
13248   if( zInsert==0 ) shell_out_of_memory();\par
13249   sqlite3_snprintf(200+nTable,zInsert,\par
13250                    "INSERT OR IGNORE INTO \\"%s\\" VALUES(?", zTable);\par
13251   i = strlen30(zInsert);\par
13252   for(j=1; j<n; j++)\{\par
13253     memcpy(zInsert+i, ",?", 2);\par
13254     i += 2;\par
13255   \}\par
13256   memcpy(zInsert+i, ");", 3);\par
13257   rc = sqlite3_prepare_v2(newDb, zInsert, -1, &pInsert, 0);\par
13258   if( rc )\{\par
13259     utf8_printf(stderr, "Error %d: %s on [%s]\\n",\par
13260             sqlite3_extended_errcode(newDb), sqlite3_errmsg(newDb),\par
13261             zQuery);\par
13262     goto end_data_xfer;\par
13263   \}\par
13264   for(k=0; k<2; k++)\{\par
13265     while( (rc = sqlite3_step(pQuery))==SQLITE_ROW )\{\par
13266       for(i=0; i<n; i++)\{\par
13267         switch( sqlite3_column_type(pQuery, i) )\{\par
13268           case SQLITE_NULL: \{\par
13269             sqlite3_bind_null(pInsert, i+1);\par
13270             break;\par
13271           \}\par
13272           case SQLITE_INTEGER: \{\par
13273             sqlite3_bind_int64(pInsert, i+1, sqlite3_column_int64(pQuery,i));\par
13274             break;\par
13275           \}\par
13276           case SQLITE_FLOAT: \{\par
13277             sqlite3_bind_double(pInsert, i+1, sqlite3_column_double(pQuery,i));\par
13278             break;\par
13279           \}\par
13280           case SQLITE_TEXT: \{\par
13281             sqlite3_bind_text(pInsert, i+1,\par
13282                              (const char*)sqlite3_column_text(pQuery,i),\par
13283                              -1, SQLITE_STATIC);\par
13284             break;\par
13285           \}\par
13286           case SQLITE_BLOB: \{\par
13287             sqlite3_bind_blob(pInsert, i+1, sqlite3_column_blob(pQuery,i),\par
13288                                             sqlite3_column_bytes(pQuery,i),\par
13289                                             SQLITE_STATIC);\par
13290             break;\par
13291           \}\par
13292         \}\par
13293       \} /* End for */\par
13294       rc = sqlite3_step(pInsert);\par
13295       if( rc!=SQLITE_OK && rc!=SQLITE_ROW && rc!=SQLITE_DONE )\{\par
13296         utf8_printf(stderr, "Error %d: %s\\n", sqlite3_extended_errcode(newDb),\par
13297                         sqlite3_errmsg(newDb));\par
13298       \}\par
13299       sqlite3_reset(pInsert);\par
13300       cnt++;\par
13301       if( (cnt%spinRate)==0 )\{\par
13302         printf("%c\\b", "|/-\\\\"[(cnt/spinRate)%4]);\par
13303         fflush(stdout);\par
13304       \}\par
13305     \} /* End while */\par
13306     if( rc==SQLITE_DONE ) break;\par
13307     sqlite3_finalize(pQuery);\par
13308     sqlite3_free(zQuery);\par
13309     zQuery = sqlite3_mprintf("SELECT * FROM \\"%w\\" ORDER BY rowid DESC;",\par
13310                              zTable);\par
13311     rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\par
13312     if( rc )\{\par
13313       utf8_printf(stderr, "Warning: cannot step \\"%s\\" backwards", zTable);\par
13314       break;\par
13315     \}\par
13316   \} /* End for(k=0...) */\par
13317 \par
13318 end_data_xfer:\par
13319   sqlite3_finalize(pQuery);\par
13320   sqlite3_finalize(pInsert);\par
13321   sqlite3_free(zQuery);\par
13322   sqlite3_free(zInsert);\par
13323 \}\par
}
}
{\xe \v tryToCloneSchema\:shell.c}
{\xe \v shell.c\:tryToCloneSchema}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void tryToCloneSchema ({\b ShellState} *  {\i p}, {\b sqlite3} *  {\i newDb}, const char *  {\i zWhere}, void(*)({\b ShellState} *, {\b sqlite3} *, const char *)  {\i xForEach}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13332 of file shell.c.}\par
{
References ShellState::db, sqlite3_column_text, sqlite3_errmsg, sqlite3_exec, sqlite3_extended_errcode, sqlite3_finalize, sqlite3_free, sqlite3_mprintf, sqlite3_prepare_v2, sqlite3_step, SQLITE_DONE, SQLITE_ROW, utf8_printf, and zName.}\par
{
Referenced by tryToClone().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 13337  \{\par
13338   sqlite3_stmt *pQuery = 0;\par
13339   char *zQuery = 0;\par
13340   int rc;\par
13341   const unsigned char *zName;\par
13342   const unsigned char *zSql;\par
13343   char *zErrMsg = 0;\par
13344 \par
13345   zQuery = sqlite3_mprintf("SELECT name, sql FROM sqlite_master"\par
13346                            " WHERE %s", zWhere);\par
13347   rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\par
13348   if( rc )\{\par
13349     utf8_printf(stderr, "Error: (%d) %s on [%s]\\n",\par
13350                     sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),\par
13351                     zQuery);\par
13352     goto end_schema_xfer;\par
13353   \}\par
13354   while( (rc = sqlite3_step(pQuery))==SQLITE_ROW )\{\par
13355     zName = sqlite3_column_text(pQuery, 0);\par
13356     zSql = sqlite3_column_text(pQuery, 1);\par
13357     printf("%s... ", zName); fflush(stdout);\par
13358     sqlite3_exec(newDb, (const char*)zSql, 0, 0, &zErrMsg);\par
13359     if( zErrMsg )\{\par
13360       utf8_printf(stderr, "Error: %s\\nSQL: [%s]\\n", zErrMsg, zSql);\par
13361       sqlite3_free(zErrMsg);\par
13362       zErrMsg = 0;\par
13363     \}\par
13364     if( xForEach )\{\par
13365       xForEach(p, newDb, (const char*)zName);\par
13366     \}\par
13367     printf("done\\n");\par
13368   \}\par
13369   if( rc!=SQLITE_DONE )\{\par
13370     sqlite3_finalize(pQuery);\par
13371     sqlite3_free(zQuery);\par
13372     zQuery = sqlite3_mprintf("SELECT name, sql FROM sqlite_master"\par
13373                              " WHERE %s ORDER BY rowid DESC", zWhere);\par
13374     rc = sqlite3_prepare_v2(p->db, zQuery, -1, &pQuery, 0);\par
13375     if( rc )\{\par
13376       utf8_printf(stderr, "Error: (%d) %s on [%s]\\n",\par
13377                       sqlite3_extended_errcode(p->db), sqlite3_errmsg(p->db),\par
13378                       zQuery);\par
13379       goto end_schema_xfer;\par
13380     \}\par
13381     while( (rc = sqlite3_step(pQuery))==SQLITE_ROW )\{\par
13382       zName = sqlite3_column_text(pQuery, 0);\par
13383       zSql = sqlite3_column_text(pQuery, 1);\par
13384       printf("%s... ", zName); fflush(stdout);\par
13385       sqlite3_exec(newDb, (const char*)zSql, 0, 0, &zErrMsg);\par
13386       if( zErrMsg )\{\par
13387         utf8_printf(stderr, "Error: %s\\nSQL: [%s]\\n", zErrMsg, zSql);\par
13388         sqlite3_free(zErrMsg);\par
13389         zErrMsg = 0;\par
13390       \}\par
13391       if( xForEach )\{\par
13392         xForEach(p, newDb, (const char*)zName);\par
13393       \}\par
13394       printf("done\\n");\par
13395     \}\par
13396   \}\par
13397 end_schema_xfer:\par
13398   sqlite3_finalize(pQuery);\par
13399   sqlite3_free(zQuery);\par
13400 \}\par
}
}
{\xe \v unused_string\:shell.c}
{\xe \v shell.c\:unused_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static const char* unused_string (const char *  {\i z}, const char *  {\i zA}, const char *  {\i zB}, char *  {\i zBuf}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9932 of file shell.c.}\par
{
References sqlite3_snprintf.}\par
{
Referenced by output_quoted_escaped_string(), and shellEscapeCrnl().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  9936  \{\par
 9937   unsigned i = 0;\par
 9938   if( strstr(z, zA)==0 ) return zA;\par
 9939   if( strstr(z, zB)==0 ) return zB;\par
 9940   do\{\par
 9941     sqlite3_snprintf(20,zBuf,"(%s%u)", zA, i++);\par
 9942   \}while( strstr(z,zBuf)!=0 );\par
 9943   return zBuf;\par
 9944 \}\par
}
}
{\xe \v usage\:shell.c}
{\xe \v shell.c\:usage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void usage (int  {\i showDetail}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18580 of file shell.c.}\par
{
References raw_printf, and utf8_printf.}\par
{
Referenced by lintDotCommand(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18580                                  \{\par
18581   utf8_printf(stderr,\par
18582       "Usage: %s [OPTIONS] FILENAME [SQL]\\n"\par
18583       "FILENAME is the name of an SQLite database. A new database is created\\n"\par
18584       "if the file does not previously exist.\\n", Argv0);\par
18585   if( showDetail )\{\par
18586     utf8_printf(stderr, "OPTIONS include:\\n%s", zOptions);\par
18587   \}else\{\par
18588     raw_printf(stderr, "Use the -help option for additional information\\n");\par
18589   \}\par
18590   exit(1);\par
18591 \}\par
}
}
{\xe \v utf8_width_print\:shell.c}
{\xe \v shell.c\:utf8_width_print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void utf8_width_print (FILE *  {\i pOut}, int  {\i w}, const char *  {\i zUtf}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 501 of file shell.c.}\par
{
References utf8_printf.}\par
{
Referenced by shell_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   501                                                                  \{\par
  502   int i;\par
  503   int n;\par
  504   int aw = w<0 ? -w : w;\par
  505   char zBuf[1000];\par
  506   if( aw>(int)sizeof(zBuf)/3 ) aw = (int)sizeof(zBuf)/3;\par
  507   for(i=n=0; zUtf[i]; i++)\{\par
  508     if( (zUtf[i]&0xc0)!=0x80 )\{\par
  509       n++;\par
  510       if( n==aw )\{\par
  511         do\{ i++; \}while( (zUtf[i]&0xc0)==0x80 );\par
  512         break;\par
  513       \}\par
  514     \}\par
  515   \}\par
  516   if( n>=aw )\{\par
  517     utf8_printf(pOut, "%.*s", i, zUtf);\par
  518   \}else if( w<0 )\{\par
  519     utf8_printf(pOut, "%*s%s", aw-n, "", zUtf);\par
  520   \}else\{\par
  521     utf8_printf(pOut, "%s%*s", zUtf, aw-n, "");\par
  522   \}\par
  523 \}\par
}
}
{\xe \v verify_uninitialized\:shell.c}
{\xe \v shell.c\:verify_uninitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void verify_uninitialized (void ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18597 of file shell.c.}\par
{
References sqlite3_config(), SQLITE_MISUSE, and utf8_printf.}\par
{
Referenced by main(), and main_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 18597                                       \{\par
18598   if( sqlite3_config(-1)==SQLITE_MISUSE )\{\par
18599     utf8_printf(stdout, "WARNING: attempt to configure SQLite after"\par
18600                         " initialization.\\n");\par
18601   \}\par
18602 \}\par
}
}
{\xe \v writeFile\:shell.c}
{\xe \v shell.c\:writeFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int writeFile ({\b sqlite3_context} *  {\i pCtx}, const char *  {\i zFile}, {\b sqlite3_value} *  {\i pData}, mode_t  {\i mode}, {\b sqlite3_int64}  {\i mtime}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2375 of file shell.c.}\par
{
References fileStat(), sqlite3_free, sqlite3_result_int64, sqlite3_value_blob, sqlite3_value_bytes, and sqlite3_value_text.}\par
{
Referenced by writefileFunc().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2381  \{\par
 2382 #if !defined(_WIN32) && !defined(WIN32)\par
 2383   if( S_ISLNK(mode) )\{\par
 2384     const char *zTo = (const char*)sqlite3_value_text(pData);\par
 2385     if( symlink(zTo, zFile)<0 ) return 1;\par
 2386   \}else\par
 2387 #endif\par
 2388   \{\par
 2389     if( S_ISDIR(mode) )\{\par
 2390       if( mkdir(zFile, mode) )\{\par
 2391         /* The mkdir() call to create the directory failed. This might not\par
 2392         ** be an error though - if there is already a directory at the same\par
 2393         ** path and either the permissions already match or can be changed\par
 2394         ** to do so using chmod(), it is not an error.  */\par
 2395         struct stat sStat;\par
 2396         if( errno!=EEXIST\par
 2397          || 0!=fileStat(zFile, &sStat)\par
 2398          || !S_ISDIR(sStat.st_mode)\par
 2399          || ((sStat.st_mode&0777)!=(mode&0777) && 0!=chmod(zFile, mode&0777))\par
 2400         )\{\par
 2401           return 1;\par
 2402         \}\par
 2403       \}\par
 2404     \}else\{\par
 2405       sqlite3_int64 nWrite = 0;\par
 2406       const char *z;\par
 2407       int rc = 0;\par
 2408       FILE *out = fopen(zFile, "wb");\par
 2409       if( out==0 ) return 1;\par
 2410       z = (const char*)sqlite3_value_blob(pData);\par
 2411       if( z )\{\par
 2412         sqlite3_int64 n = fwrite(z, 1, sqlite3_value_bytes(pData), out);\par
 2413         nWrite = sqlite3_value_bytes(pData);\par
 2414         if( nWrite!=n )\{\par
 2415           rc = 1;\par
 2416         \}\par
 2417       \}\par
 2418       fclose(out);\par
 2419       if( rc==0 && mode && chmod(zFile, mode & 0777) )\{\par
 2420         rc = 1;\par
 2421       \}\par
 2422       if( rc ) return 2;\par
 2423       sqlite3_result_int64(pCtx, nWrite);\par
 2424     \}\par
 2425   \}\par
 2426 \par
 2427   if( mtime>=0 )\{\par
 2428 #if defined(_WIN32)\par
 2429     /* Windows */\par
 2430     FILETIME lastAccess;\par
 2431     FILETIME lastWrite;\par
 2432     SYSTEMTIME currentTime;\par
 2433     LONGLONG intervals;\par
 2434     HANDLE hFile;\par
 2435     LPWSTR zUnicodeName;\par
 2436     extern LPWSTR sqlite3_win32_utf8_to_unicode(const char*);\par
 2437 \par
 2438     GetSystemTime(&currentTime);\par
 2439     SystemTimeToFileTime(&currentTime, &lastAccess);\par
 2440     intervals = Int32x32To64(mtime, 10000000) + 116444736000000000;\par
 2441     lastWrite.dwLowDateTime = (DWORD)intervals;\par
 2442     lastWrite.dwHighDateTime = intervals >> 32;\par
 2443     zUnicodeName = sqlite3_win32_utf8_to_unicode(zFile);\par
 2444     if( zUnicodeName==0 )\{\par
 2445       return 1;\par
 2446     \}\par
 2447     hFile = CreateFileW(\par
 2448       zUnicodeName, FILE_WRITE_ATTRIBUTES, 0, NULL, OPEN_EXISTING,\par
 2449       FILE_FLAG_BACKUP_SEMANTICS, NULL\par
 2450     );\par
 2451     sqlite3_free(zUnicodeName);\par
 2452     if( hFile!=INVALID_HANDLE_VALUE )\{\par
 2453       BOOL bResult = SetFileTime(hFile, NULL, &lastAccess, &lastWrite);\par
 2454       CloseHandle(hFile);\par
 2455       return !bResult;\par
 2456     \}else\{\par
 2457       return 1;\par
 2458     \}\par
 2459 #elif defined(AT_FDCWD) && 0 /* utimensat() is not universally available */\par
 2460     /* Recent unix */\par
 2461     struct timespec times[2];\par
 2462     times[0].tv_nsec = times[1].tv_nsec = 0;\par
 2463     times[0].tv_sec = time(0);\par
 2464     times[1].tv_sec = mtime;\par
 2465     if( utimensat(AT_FDCWD, zFile, times, AT_SYMLINK_NOFOLLOW) )\{\par
 2466       return 1;\par
 2467     \}\par
 2468 #else\par
 2469     /* Legacy unix */\par
 2470     struct timeval times[2];\par
 2471     times[0].tv_usec = times[1].tv_usec = 0;\par
 2472     times[0].tv_sec = time(0);\par
 2473     times[1].tv_sec = mtime;\par
 2474     if( utimes(zFile, times) )\{\par
 2475       return 1;\par
 2476     \}\par
 2477 #endif\par
 2478   \}\par
 2479 \par
 2480   return 0;\par
 2481 \}\par
}
}
{\xe \v writefileFunc\:shell.c}
{\xe \v shell.c\:writefileFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void writefileFunc ({\b sqlite3_context} *  {\i context}, int  {\i argc}, {\b sqlite3_value} **  {\i argv}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 2487 of file shell.c.}\par
{
References ctxErrorMsg(), makeDirectory(), sqlite3_result_error, sqlite3_value_int, sqlite3_value_int64, sqlite3_value_text, SQLITE_OK, and writeFile().}\par
{
Referenced by sqlite3_fileio_init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  2491  \{\par
 2492   const char *zFile;\par
 2493   mode_t mode = 0;\par
 2494   int res;\par
 2495   sqlite3_int64 mtime = -1;\par
 2496 \par
 2497   if( argc<2 || argc>4 )\{\par
 2498     sqlite3_result_error(context, \par
 2499         "wrong number of arguments to function writefile()", -1\par
 2500     );\par
 2501     return;\par
 2502   \}\par
 2503 \par
 2504   zFile = (const char*)sqlite3_value_text(argv[0]);\par
 2505   if( zFile==0 ) return;\par
 2506   if( argc>=3 )\{\par
 2507     mode = (mode_t)sqlite3_value_int(argv[2]);\par
 2508   \}\par
 2509   if( argc==4 )\{\par
 2510     mtime = sqlite3_value_int64(argv[3]);\par
 2511   \}\par
 2512 \par
 2513   res = writeFile(context, zFile, argv[1], mode, mtime);\par
 2514   if( res==1 && errno==ENOENT )\{\par
 2515     if( makeDirectory(zFile)==SQLITE_OK )\{\par
 2516       res = writeFile(context, zFile, argv[1], mode, mtime);\par
 2517     \}\par
 2518   \}\par
 2519 \par
 2520   if( argc>2 && res!=0 )\{\par
 2521     if( S_ISLNK(mode) )\{\par
 2522       ctxErrorMsg(context, "failed to create symlink: %s", zFile);\par
 2523     \}else if( S_ISDIR(mode) )\{\par
 2524       ctxErrorMsg(context, "failed to create directory: %s", zFile);\par
 2525     \}else\{\par
 2526       ctxErrorMsg(context, "failed to write file: %s", zFile);\par
 2527     \}\par
 2528   \}\par
 2529 \}\par
}
}
{\xe \v wsToEol\:shell.c}
{\xe \v shell.c\:wsToEol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int wsToEol (const char *  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10269 of file shell.c.}\par
{
References IsSpace.}\par
{
Referenced by shell_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 10269                                  \{\par
10270   int i;\par
10271   for(i=0; z[i]; i++)\{\par
10272     if( z[i]=='\\n' ) return 1;\par
10273     if( IsSpace(z[i]) ) continue;\par
10274     if( z[i]=='-' && z[i+1]=='-' ) return 1;\par
10275     return 0;\par
10276   \}\par
10277   return 1;\par
10278 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v apnd_io_methods\:shell.c}
{\xe \v shell.c\:apnd_io_methods}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b sqlite3_io_methods} apnd_io_methods{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
  3,                              \par
  apndClose,                      \par
  apndRead,                       \par
  apndWrite,                      \par
  apndTruncate,                   \par
  apndSync,                       \par
  apndFileSize,                   \par
  apndLock,                       \par
  apndUnlock,                     \par
  apndCheckReservedLock,          \par
  apndFileControl,                \par
  apndSectorSize,                 \par
  apndDeviceCharacteristics,      \par
  apndShmMap,                     \par
  apndShmLock,                    \par
  apndShmBarrier,                 \par
  apndShmUnmap,                   \par
  apndFetch,                      \par
  apndUnfetch                     \par
\}\par
}
{
Definition at line 3696 of file shell.c.}\par
{
Referenced by apndOpen().}\par
}
{\xe \v apnd_vfs\:shell.c}
{\xe \v shell.c\:apnd_vfs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sqlite3_vfs} apnd_vfs{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
  3,                            \par
  0,                            \par
  1024,                         \par
  0,                            \par
  "apndvfs",                    \par
  0,                             \par
  apndOpen,                     \par
  apndDelete,                   \par
  apndAccess,                   \par
  apndFullPathname,             \par
  apndDlOpen,                   \par
  apndDlError,                  \par
  apndDlSym,                    \par
  apndDlClose,                  \par
  apndRandomness,               \par
  apndSleep,                    \par
  apndCurrentTime,              \par
  apndGetLastError,             \par
  apndCurrentTimeInt64,         \par
  apndSetSystemCall,            \par
  apndGetSystemCall,            \par
  apndNextSystemCall            \par
\}\par
}
{
Definition at line 3671 of file shell.c.}\par
}
{\xe \v apndDlSym\:shell.c}
{\xe \v shell.c\:apndDlSym}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(*)(void) apndDlSym({\b sqlite3_vfs} *pVfs, void *p, const char *zSym){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3660 of file shell.c.}\par
{
Referenced by apndDlError().}\par
}
{\xe \v Argv0\:shell.c}
{\xe \v shell.c\:Argv0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* Argv0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 422 of file shell.c.}\par
}
{\xe \v azHelp\:shell.c}
{\xe \v shell.c\:azHelp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* azHelp[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12031 of file shell.c.}\par
{
Referenced by showHelp().}\par
}
{\xe \v bail_on_error\:shell.c}
{\xe \v shell.c\:bail_on_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bail_on_error = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 391 of file shell.c.}\par
}
{\xe \v completionModule\:shell.c}
{\xe \v shell.c\:completionModule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sqlite3_module} completionModule{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
  0,                         \par
  0,                         \par
  completionConnect,         \par
  completionBestIndex,       \par
  completionDisconnect,      \par
  0,                         \par
  completionOpen,            \par
  completionClose,           \par
  completionFilter,          \par
  completionNext,            \par
  completionEof,             \par
  completionColumn,          \par
  completionRowid,           \par
  0,                         \par
  0,                         \par
  0,                         \par
  0,                         \par
  0,                         \par
  0,                         \par
  0,                         \par
  0,                         \par
  0,                         \par
  0,                         \par
  0                          \par
\}\par
}
{
Definition at line 3482 of file shell.c.}\par
}
{\xe \v continuePrompt\:shell.c}
{\xe \v shell.c\:continuePrompt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char continuePrompt[20]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 429 of file shell.c.}\par
{
Referenced by one_input_line().}\par
}
{\xe \v enableTimer\:shell.c}
{\xe \v shell.c\:enableTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int enableTimer = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 225 of file shell.c.}\par
}
{\xe \v ersaztMethods\:shell.c}
{\xe \v shell.c\:ersaztMethods}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sqlite3_mem_methods} ersaztMethods{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
  memtraceMalloc,\par
  memtraceFree,\par
  memtraceRealloc,\par
  memtraceSize,\par
  memtraceRoundup,\par
  memtraceInit,\par
  memtraceShutdown,\par
  0\par
\}\par
}
{
Definition at line 4178 of file shell.c.}\par
}
{\xe \v globalDb\:shell.c}
{\xe \v shell.c\:globalDb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sqlite3}* globalDb = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 411 of file shell.c.}\par
}
{\xe \v iBegin\:shell.c}
{\xe \v shell.c\:iBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sqlite3_int64} iBegin{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 257 of file shell.c.}\par
}
{\xe \v mainPrompt\:shell.c}
{\xe \v shell.c\:mainPrompt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char mainPrompt[20]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 428 of file shell.c.}\par
{
Referenced by one_input_line().}\par
}
{\xe \v memtraceBase\:shell.c}
{\xe \v shell.c\:memtraceBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sqlite3_mem_methods} memtraceBase{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4134 of file shell.c.}\par
}
{\xe \v memtraceOut\:shell.c}
{\xe \v shell.c\:memtraceOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FILE* memtraceOut{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4135 of file shell.c.}\par
}
{\xe \v modeDescr\:shell.c}
{\xe \v shell.c\:modeDescr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* modeDescr[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
  "line",\par
  "column",\par
  "list",\par
  "semi",\par
  "html",\par
  "insert",\par
  "quote",\par
  "tcl",\par
  "csv",\par
  "explain",\par
  "ascii",\par
  "prettyprint",\par
  "eqp"\par
\}\par
}
{
Definition at line 9700 of file shell.c.}\par
}
{\xe \v needCsvQuote\:shell.c}
{\xe \v shell.c\:needCsvQuote}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char needCsvQuote[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,\par
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,\par
  1, 0, 1, 0, 0, 0, 0, 1,   0, 0, 0, 0, 0, 0, 0, 0,\par
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\par
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\par
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\par
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\par
  0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 1,\par
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,\par
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,\par
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,\par
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,\par
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,\par
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,\par
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,\par
  1, 1, 1, 1, 1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,\par
\}\par
}
{
Definition at line 10118 of file shell.c.}\par
}
{\xe \v sBegin\:shell.c}
{\xe \v shell.c\:sBegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct rusage sBegin{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 256 of file shell.c.}\par
{
Referenced by beginTimer(), and endTimer().}\par
}
{\xe \v seenInterrupt\:shell.c}
{\xe \v shell.c\:seenInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile int seenInterrupt = 0{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 416 of file shell.c.}\par
}
{\xe \v stdin_is_interactive\:shell.c}
{\xe \v shell.c\:stdin_is_interactive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int stdin_is_interactive = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 397 of file shell.c.}\par
}
{\xe \v stdout_is_console\:shell.c}
{\xe \v shell.c\:stdout_is_console}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int stdout_is_console = 1{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 404 of file shell.c.}\par
}
{\xe \v zOptions\:shell.c}
{\xe \v shell.c\:zOptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char zOptions[]{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18526 of file shell.c.}\par
}
}